{
    "uid": "CE4F231B812401459218A74604DDF88C533C",
    "isLoaded": true,
    "lastModificationTime": 0,
    "items": {
        "name": "Component_DataGridBehavior",
        "type": "game_script",
        "order": 20,
        "parentId": "01A95DA3K01E8A4CB4SBE17E790BCE1FC035",
        "folder": false,
        "content": "# ===================================================================\n#\n#   Script: Component_DataGridBehavior\n#\n#   $$COPYRIGHT$$\n#\n# ===================================================================\nclass Component_DataGridBehavior extends gs.Component_Visual\n    class DataWrapper\n        constructor: (data) ->\n            @data = data\n            @viewData = [yes, no, no, yes, no]\n    \n    class DataSource\n        constructor: (source) ->\n            @source = source || []\n            @length = @source.length\n            @wrappedSource = new Array(@source.length)\n            @wrappedSource[i] = null for i in [0..@wrappedSource.length]\n                \n        set: (source) ->\n            @source = source || []\n            @length = @source.length\n            @wrappedSource = new Array(@source.length)\n            @wrappedSource[i] = null for i in [0..@wrappedSource.length]\n            \n        itemAt: (index) ->\n            item = @wrappedSource[index]\n            if !item\n                item = new DataWrapper(@source[index])\n                @wrappedSource[index] = item\n                \n            return item\n    \n        setItemAt:(index, data) ->\n            if @wrappedSource[index]\n                @wrappedSource[index].data = data\n            @source[index] = data\n            \n    @accessors \"dataSource\", \n        set: (v) ->\n            if v != @dataSource_.source\n                @dataSource_.set(v)\n                @resize()\n        get: -> @dataSource_\n        \n    ###*\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    * \n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n    ###\n    onDataBundleRestore: (data, context) ->\n        @setupEventHandlers()\n        \n    ###*\n    * The data-grid behavior component defines the logic for a data-grid. A data-grid\n    * allows to display items from a associated data-source using a specified\n    * item-template. Unlike a stack-layout, a data-grid is optimized to display even high amounts of items but they all\n    * need to use the same item-template with same size.\n    *\n    * @module ui\n    * @class Component_DataGridBehavior\n    * @extends gs.Component_Visual\n    * @memberof ui\n    * @constructor\n    * @params {Object} params - The params-object containing the data-grid settings.\n    ###\n    constructor: (params) ->\n        super()\n        @params = params || {}\n        ###*\n        * The item-template descriptor used for each item of the data-grid.\n        * @property template\n        * @type Object\n        ###\n        @template = @params.template\n        \n        ###*\n        * The data-source used for the data-grid. Can be an array or a formula.\n        * @property dataSource\n        * @type Object[]|string\n        ###\n        @dataSource_ = null\n        \n        ###*\n        * Stores the item-objects needed for rendering. They are created from the item-template.\n        * @property items\n        * @protected\n        * @type gs.Object_Base[]\n        ###\n        @items = @params.items || []\n        \n        ###*\n        * Numbers of columns.\n        * @property columns\n        * @type number\n        ###\n        @columns = @params.columns || 1\n        \n        ###*\n        * Indicates if the data-grid is initialized and ready for rendering.\n        * @property initialized\n        * @protected\n        * @type boolean\n        ###\n        @initialized = no\n        \n        ###*\n        * Defines a horizontal and vertical spacing between items.\n        * @property spacing\n        * @default [0, 10]        \n        * @type number[]\n        ###\n        @spacing = @params.spacing || [0, 0]\n     \n    ###*\n    * Adds event-handlers for mouse/touch events\n    *\n    * @method setupEventHandlers\n    ### \n    setupEventHandlers: ->\n        gs.GlobalEventManager.on \"mouseWheel\", =>\n            r = @object.dstRect\n            \n            if Rect.contains(r.x, r.y, r.width, r.height, Input.Mouse.x - @object.origin.x, Input.Mouse.y - @object.origin.y)\n                @updateScroll()\n    \n    ###*\n    * Sets up the data-grid.\n    *\n    * @method setup\n    ###   \n    setup: ->\n        if @object.dstRect.width == 1 then return\n        @initialized = yes\n\n        if !@template.size\n            item = ui.UIManager.createControlFromDescriptor(@template.descriptor, @object)\n            item.index = 0\n            item.update()\n            @template.size = [item.dstRect.width, item.dstRect.height]\n            item.dispose()\n            \n        if @params.dataSource.exec\n            @dataSource_ = new DataSource(ui.Component_FormulaHandler.fieldValue(@object, @params.dataSource) || [])\n        else\n            @dataSource_ = new DataSource(@params.dataSource || [])\n        \n        @resize()\n        \n        @setupEventHandlers()\n                \n        super()\n    \n        @object.scrollableHeight = Math.max(0, @object.contentHeight - @object.dstRect.height)\n     \n    \n    ###*\n    * Scrolls to the end.\n    *\n    * @method scrollToEnd\n    ###    \n    scrollToEnd: ->\n        @object.scrollOffsetY = @object.scrollableHeight\n        \n    ###*\n    * Updates scrolling.\n    *\n    * @method updateScroll\n    ###\n    updateScroll: ->\n        @object.scrollableHeight = Math.max(0, @object.contentHeight - @object.dstRect.height)\n        if Input.Mouse.wheel <= -1\n            @object.scrollOffsetY = Math.max(@object.scrollOffsetY - Input.Mouse.wheelSpeed * 0.1, 0)\n           \n        if Input.Mouse.wheel >= 1\n            @object.scrollOffsetY = Math.min(@object.scrollOffsetY - Input.Mouse.wheelSpeed * 0.1, @object.scrollableHeight)\n            \n    \n        @object.scrollOffsetY = Math.max(Math.min(@object.scrollOffsetY, @object.scrollableHeight), 0)\n         \n    ###*\n    * Resizes the data-grid and creates the necessary display objects from the data-grid template.\n    *\n    * @method resize\n    ###     \n    resize: ->\n        width = @object.dstRect.width\n        height = @object.dstRect.height\n        \n        itemsX = @columns || 1\n        itemsY = Math.ceil((height-@spacing[1]) / (@template.size[1]+@spacing[1])) + @columns+1\n        totalItemsY = Math.ceil(@dataSource.length / @columns)\n        \n        item?.dispose() for item in @items\n        @items = [] #new Array(itemsX * itemsY)\n        \n        for y in [0...itemsY]\n            for x in [0...itemsX]\n                index  = y * itemsX + x\n                if index < @dataSource.length\n                    item = ui.UIManager.createControlFromDescriptor(@template.descriptor, @object)\n\n                    item.data[0] = @dataSource.itemAt(index).data                    \n                    item.dstRect.x = @spacing[0] + x * (@template.size[0]+@spacing[0])\n                    item.dstRect.y = @spacing[1] + y * (@template.size[1]+@spacing[1])\n                    item.dstRect.width = @template.size[0]\n                    item.dstRect.height = @template.size[1]\n                    item.index = index\n                    item.ui.viewData = @dataSource.itemAt(index).viewData\n                    \n                    @items[item.index] = item\n                    @object.addObject(item)\n                \n        @object.scrollableHeight = @spacing[1] + totalItemsY * (@template.size[1]+@spacing[1]) - height\n        @object.scrollOffsetY = 0\n        @object.contentHeight = @spacing[1] + totalItemsY * (@template.size[1]+@spacing[1])\n\n    itemAtIndex: (index) ->\n        @items.first (item) -> item.index == index\n        \n    indexForItem: (item) -> item.index\n        \n    ###*\n    * Updates the data-grid.\n    *\n    * @method update\n    ###  \n    update: ->\n        super()\n        \n        if not @initialized\n            @setup()\n        \n        scrollOffset = @object.scrollOffsetY\n        offset = Math.floor((scrollOffset) / (@template.size[1]+@spacing[1])) * @columns\n        i = offset\n        itemIndex = 0\n        itemsY = Math.ceil((@object.dstRect.height-@spacing[1]) /  (@template.size[1]+@spacing[1])) * @columns + @columns+1\n        \n        while i < Math.min(offset+itemsY, @dataSource.length)\n            row = Math.floor(i / @columns)\n            column = i % @columns\n            item = @items[itemIndex]\n            if item\n                item.data[0] = @dataSource.itemAt(i).data\n                if @object.clipRect\n                    item.clipRect = @object.clipRect\n                item.index = i\n                item.ui.viewData = @dataSource.itemAt(i).viewData\n                item.dstRect.x = @spacing[0] + column * (@template.size[0]+@spacing[0])\n                item.dstRect.y = @spacing[1] + (row-(offset/@columns)) * (@template.size[1]+@spacing[1]) + (-scrollOffset % (@template.size[1]+@spacing[1]))\n                item.visible = yes\n                item.update()\n                item.update()\n                itemIndex++\n              \n            i++\n        \n        for j in [itemIndex...@items.length]\n            if @items[j]\n                @items[j].visible = no\n                @items[j].update()\n        \n        \n        \nui.Component_DataGridBehavior = Component_DataGridBehavior",
        "compiledContent": "// Generated by CoffeeScript 1.12.7\n(function() {\n  var Component_DataGridBehavior,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  Component_DataGridBehavior = (function(superClass) {\n    var DataSource, DataWrapper;\n\n    extend(Component_DataGridBehavior, superClass);\n\n    DataWrapper = (function() {\n      function DataWrapper(data) {\n        this.data = data;\n        this.viewData = [true, false, false, true, false];\n      }\n\n      return DataWrapper;\n\n    })();\n\n    DataSource = (function() {\n      function DataSource(source) {\n        var i, k, ref;\n        this.source = source || [];\n        this.length = this.source.length;\n        this.wrappedSource = new Array(this.source.length);\n        for (i = k = 0, ref = this.wrappedSource.length; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {\n          this.wrappedSource[i] = null;\n        }\n      }\n\n      DataSource.prototype.set = function(source) {\n        var i, k, ref, results;\n        this.source = source || [];\n        this.length = this.source.length;\n        this.wrappedSource = new Array(this.source.length);\n        results = [];\n        for (i = k = 0, ref = this.wrappedSource.length; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {\n          results.push(this.wrappedSource[i] = null);\n        }\n        return results;\n      };\n\n      DataSource.prototype.itemAt = function(index) {\n        var item;\n        item = this.wrappedSource[index];\n        if (!item) {\n          item = new DataWrapper(this.source[index]);\n          this.wrappedSource[index] = item;\n        }\n        return item;\n      };\n\n      DataSource.prototype.setItemAt = function(index, data) {\n        if (this.wrappedSource[index]) {\n          this.wrappedSource[index].data = data;\n        }\n        return this.source[index] = data;\n      };\n\n      return DataSource;\n\n    })();\n\n    Component_DataGridBehavior.accessors(\"dataSource\", {\n      set: function(v) {\n        if (v !== this.dataSource_.source) {\n          this.dataSource_.set(v);\n          return this.resize();\n        }\n      },\n      get: function() {\n        return this.dataSource_;\n      }\n    });\n\n\n    /**\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    * \n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n     */\n\n    Component_DataGridBehavior.prototype.onDataBundleRestore = function(data, context) {\n      return this.setupEventHandlers();\n    };\n\n\n    /**\n    * The data-grid behavior component defines the logic for a data-grid. A data-grid\n    * allows to display items from a associated data-source using a specified\n    * item-template. Unlike a stack-layout, a data-grid is optimized to display even high amounts of items but they all\n    * need to use the same item-template with same size.\n    *\n    * @module ui\n    * @class Component_DataGridBehavior\n    * @extends gs.Component_Visual\n    * @memberof ui\n    * @constructor\n    * @params {Object} params - The params-object containing the data-grid settings.\n     */\n\n    function Component_DataGridBehavior(params) {\n      Component_DataGridBehavior.__super__.constructor.call(this);\n      this.params = params || {};\n\n      /**\n      * The item-template descriptor used for each item of the data-grid.\n      * @property template\n      * @type Object\n       */\n      this.template = this.params.template;\n\n      /**\n      * The data-source used for the data-grid. Can be an array or a formula.\n      * @property dataSource\n      * @type Object[]|string\n       */\n      this.dataSource_ = null;\n\n      /**\n      * Stores the item-objects needed for rendering. They are created from the item-template.\n      * @property items\n      * @protected\n      * @type gs.Object_Base[]\n       */\n      this.items = this.params.items || [];\n\n      /**\n      * Numbers of columns.\n      * @property columns\n      * @type number\n       */\n      this.columns = this.params.columns || 1;\n\n      /**\n      * Indicates if the data-grid is initialized and ready for rendering.\n      * @property initialized\n      * @protected\n      * @type boolean\n       */\n      this.initialized = false;\n\n      /**\n      * Defines a horizontal and vertical spacing between items.\n      * @property spacing\n      * @default [0, 10]        \n      * @type number[]\n       */\n      this.spacing = this.params.spacing || [0, 0];\n    }\n\n\n    /**\n    * Adds event-handlers for mouse/touch events\n    *\n    * @method setupEventHandlers\n     */\n\n    Component_DataGridBehavior.prototype.setupEventHandlers = function() {\n      return gs.GlobalEventManager.on(\"mouseWheel\", (function(_this) {\n        return function() {\n          var r;\n          r = _this.object.dstRect;\n          if (Rect.contains(r.x, r.y, r.width, r.height, Input.Mouse.x - _this.object.origin.x, Input.Mouse.y - _this.object.origin.y)) {\n            return _this.updateScroll();\n          }\n        };\n      })(this));\n    };\n\n\n    /**\n    * Sets up the data-grid.\n    *\n    * @method setup\n     */\n\n    Component_DataGridBehavior.prototype.setup = function() {\n      var item;\n      if (this.object.dstRect.width === 1) {\n        return;\n      }\n      this.initialized = true;\n      if (!this.template.size) {\n        item = ui.UIManager.createControlFromDescriptor(this.template.descriptor, this.object);\n        item.index = 0;\n        item.update();\n        this.template.size = [item.dstRect.width, item.dstRect.height];\n        item.dispose();\n      }\n      if (this.params.dataSource.exec) {\n        this.dataSource_ = new DataSource(ui.Component_FormulaHandler.fieldValue(this.object, this.params.dataSource) || []);\n      } else {\n        this.dataSource_ = new DataSource(this.params.dataSource || []);\n      }\n      this.resize();\n      this.setupEventHandlers();\n      Component_DataGridBehavior.__super__.setup.call(this);\n      return this.object.scrollableHeight = Math.max(0, this.object.contentHeight - this.object.dstRect.height);\n    };\n\n\n    /**\n    * Scrolls to the end.\n    *\n    * @method scrollToEnd\n     */\n\n    Component_DataGridBehavior.prototype.scrollToEnd = function() {\n      return this.object.scrollOffsetY = this.object.scrollableHeight;\n    };\n\n\n    /**\n    * Updates scrolling.\n    *\n    * @method updateScroll\n     */\n\n    Component_DataGridBehavior.prototype.updateScroll = function() {\n      this.object.scrollableHeight = Math.max(0, this.object.contentHeight - this.object.dstRect.height);\n      if (Input.Mouse.wheel <= -1) {\n        this.object.scrollOffsetY = Math.max(this.object.scrollOffsetY - Input.Mouse.wheelSpeed * 0.1, 0);\n      }\n      if (Input.Mouse.wheel >= 1) {\n        this.object.scrollOffsetY = Math.min(this.object.scrollOffsetY - Input.Mouse.wheelSpeed * 0.1, this.object.scrollableHeight);\n      }\n      return this.object.scrollOffsetY = Math.max(Math.min(this.object.scrollOffsetY, this.object.scrollableHeight), 0);\n    };\n\n\n    /**\n    * Resizes the data-grid and creates the necessary display objects from the data-grid template.\n    *\n    * @method resize\n     */\n\n    Component_DataGridBehavior.prototype.resize = function() {\n      var height, index, item, itemsX, itemsY, k, l, len, m, ref, ref1, ref2, totalItemsY, width, x, y;\n      width = this.object.dstRect.width;\n      height = this.object.dstRect.height;\n      itemsX = this.columns || 1;\n      itemsY = Math.ceil((height - this.spacing[1]) / (this.template.size[1] + this.spacing[1])) + this.columns + 1;\n      totalItemsY = Math.ceil(this.dataSource.length / this.columns);\n      ref = this.items;\n      for (k = 0, len = ref.length; k < len; k++) {\n        item = ref[k];\n        if (item != null) {\n          item.dispose();\n        }\n      }\n      this.items = [];\n      for (y = l = 0, ref1 = itemsY; 0 <= ref1 ? l < ref1 : l > ref1; y = 0 <= ref1 ? ++l : --l) {\n        for (x = m = 0, ref2 = itemsX; 0 <= ref2 ? m < ref2 : m > ref2; x = 0 <= ref2 ? ++m : --m) {\n          index = y * itemsX + x;\n          if (index < this.dataSource.length) {\n            item = ui.UIManager.createControlFromDescriptor(this.template.descriptor, this.object);\n            item.data[0] = this.dataSource.itemAt(index).data;\n            item.dstRect.x = this.spacing[0] + x * (this.template.size[0] + this.spacing[0]);\n            item.dstRect.y = this.spacing[1] + y * (this.template.size[1] + this.spacing[1]);\n            item.dstRect.width = this.template.size[0];\n            item.dstRect.height = this.template.size[1];\n            item.index = index;\n            item.ui.viewData = this.dataSource.itemAt(index).viewData;\n            this.items[item.index] = item;\n            this.object.addObject(item);\n          }\n        }\n      }\n      this.object.scrollableHeight = this.spacing[1] + totalItemsY * (this.template.size[1] + this.spacing[1]) - height;\n      this.object.scrollOffsetY = 0;\n      return this.object.contentHeight = this.spacing[1] + totalItemsY * (this.template.size[1] + this.spacing[1]);\n    };\n\n    Component_DataGridBehavior.prototype.itemAtIndex = function(index) {\n      return this.items.first(function(item) {\n        return item.index === index;\n      });\n    };\n\n    Component_DataGridBehavior.prototype.indexForItem = function(item) {\n      return item.index;\n    };\n\n\n    /**\n    * Updates the data-grid.\n    *\n    * @method update\n     */\n\n    Component_DataGridBehavior.prototype.update = function() {\n      var column, i, item, itemIndex, itemsY, j, k, offset, ref, ref1, results, row, scrollOffset;\n      Component_DataGridBehavior.__super__.update.call(this);\n      if (!this.initialized) {\n        this.setup();\n      }\n      scrollOffset = this.object.scrollOffsetY;\n      offset = Math.floor(scrollOffset / (this.template.size[1] + this.spacing[1])) * this.columns;\n      i = offset;\n      itemIndex = 0;\n      itemsY = Math.ceil((this.object.dstRect.height - this.spacing[1]) / (this.template.size[1] + this.spacing[1])) * this.columns + this.columns + 1;\n      while (i < Math.min(offset + itemsY, this.dataSource.length)) {\n        row = Math.floor(i / this.columns);\n        column = i % this.columns;\n        item = this.items[itemIndex];\n        if (item) {\n          item.data[0] = this.dataSource.itemAt(i).data;\n          if (this.object.clipRect) {\n            item.clipRect = this.object.clipRect;\n          }\n          item.index = i;\n          item.ui.viewData = this.dataSource.itemAt(i).viewData;\n          item.dstRect.x = this.spacing[0] + column * (this.template.size[0] + this.spacing[0]);\n          item.dstRect.y = this.spacing[1] + (row - (offset / this.columns)) * (this.template.size[1] + this.spacing[1]) + (-scrollOffset % (this.template.size[1] + this.spacing[1]));\n          item.visible = true;\n          item.update();\n          item.update();\n          itemIndex++;\n        }\n        i++;\n      }\n      results = [];\n      for (j = k = ref = itemIndex, ref1 = this.items.length; ref <= ref1 ? k < ref1 : k > ref1; j = ref <= ref1 ? ++k : --k) {\n        if (this.items[j]) {\n          this.items[j].visible = false;\n          results.push(this.items[j].update());\n        } else {\n          results.push(void 0);\n        }\n      }\n      return results;\n    };\n\n    return Component_DataGridBehavior;\n\n  })(gs.Component_Visual);\n\n  ui.Component_DataGridBehavior = Component_DataGridBehavior;\n\n}).call(this);\n"
    },
    "summary": [
        "name",
        "type"
    ],
    "externalItems": []
}