{
    "uid": "9D2D1D14K49FAA43CBS8582E7937AF84F3A2",
    "isLoaded": true,
    "lastModificationTime": 1422817393812,
    "items": {
        "name": "GameManager",
        "type": "game_script",
        "order": 1,
        "parentId": "C0268943K60B3A42B7SA6F1EDDCF2F642FD7",
        "content": "# ===================================================================\n#\n#   Script: GameManager\n#\n#   $$COPYRIGHT$$\n#\n# ===================================================================\nclass GameManager\n    ###*\n    * Manages all general things around the game like holding the game settings,\n    * manages the save/load of a game, etc.\n    *\n    * @module gs\n    * @class GameManager\n    * @memberof gs\n    * @constructor\n    ###\n    constructor: ->\n        ###*\n        * The current scene data.\n        * @property sceneData\n        * @type Object\n        ###\n        @sceneData = {}\n\n        ###*\n        * The scene viewport containing all visual objects which are part of the scene and influenced\n        * by the in-game camera.\n        * @property sceneViewport\n        * @type gs.Object_Viewport\n        ###\n        @sceneViewport = null\n\n        ###*\n        * The list of common events.\n        * @property commonEvents\n        * @type gs.Object_CommonEvent[]\n        ###\n        @commonEvents = []\n\n        ###*\n        * Indicates if the GameManager is initialized.\n        * @property commonEvents\n        * @type gs.Object_CommonEvent[]\n        ###\n        @initialized = no\n\n        ###*\n        * Temporary game settings.\n        * @property tempSettings\n        * @type Object\n        ###\n        @tempSettings = skip: false, skipTime: 5, loadMenuAccess: true, menuAccess: true, backlogAccess: true, saveMenuAccess: true, messageFading: { animation: { type: 1 }, duration: 15, easing: null }\n\n        ###*\n        * Temporary game fields.\n        * @property tempFields\n        * @type Object\n        ###\n        @tempFields = null\n\n        ###*\n        * Stores default values for backgrounds, pictures, etc.\n        * @property defaults\n        * @type Object\n        ###\n        @defaults = {\n            background: { \"duration\": 30, \"origin\": 0, \"zOrder\": 0, \"loopVertical\": 0, \"loopHorizontal\": 0, \"easing\": { \"type\": 0, \"inOut\": 1 }, \"animation\": { \"type\": 1, \"movement\": 0, \"mask\": { \"graphic\": null, \"vague\": 30 } }, \"motionBlur\": { \"enabled\": 0, \"delay\": 2, \"opacity\": 100, \"dissolveSpeed\": 3 } },\n            picture: { \"appearDuration\": 30, \"disappearDuration\": 30, \"origin\": 1, \"zOrder\": 0, \"appearEasing\": { \"type\": 0, \"inOut\": 1 }, \"disappearEasing\": { \"type\": 0, \"inOut\": 1 }, \"appearAnimation\": { \"type\": 1, \"movement\": 0, \"mask\": { \"graphic\": null, \"vague\": 30 } }, \"disappearAnimation\": { \"type\": 1, \"movement\": 0, \"mask\": { \"graphic\": null, \"vague\": 30 } }, \"motionBlur\": { \"enabled\": 0, \"delay\": 2, \"opacity\": 100, \"dissolveSpeed\": 3 } },\n            character: { \"expressionDuration\": 0, \"appearDuration\": 40, \"disappearDuration\": 40, \"origin\": 1, \"zOrder\": 0, \"appearEasing\": { \"type\": 2, \"inOut\": 2 }, \"disappearEasing\": { \"type\": 1, \"inOut\": 1 }, \"appearAnimation\": { \"type\": 1, \"movement\": 0, \"mask\": { \"graphic\": null, \"vague\": 30 } }, \"disappearAnimation\": { \"type\": 1, \"movement\": 0, \"mask\": { \"graphic\": null, \"vague\": 30 } }, \"motionBlur\": { \"enabled\": 0, \"delay\": 2, \"opacity\": 100, \"dissolveSpeed\": 3 }, \"changeAnimation\": { \"type\": 1, \"movement\": 0, \"fading\": 0, \"mask\": { \"graphic\": null, \"vague\": 30 } }, \"changeEasing\": { \"type\": 2, \"inOut\": 2 } },\n            text: { \"appearDuration\": 30, \"disappearDuration\": 30, \"positionOrigin\": 0, \"origin\": 0, \"zOrder\": 0, \"appearEasing\": { \"type\": 0, \"inOut\": 1 }, \"disappearEasing\": { \"type\": 0, \"inOut\": 1 }, \"appearAnimation\": { \"type\": 1, \"movement\": 0, \"mask\": { \"graphic\": null, \"vague\": 30 } }, \"disappearAnimation\": { \"type\": 1, \"movement\": 0, \"mask\": { \"graphic\": null, \"vague\": 30 } }, \"motionBlur\": { \"enabled\": 0, \"delay\": 2, \"opacity\": 100, \"dissolveSpeed\": 3 } },\n            video: { \"appearDuration\": 30, \"disappearDuration\": 30, \"origin\": 0, \"zOrder\": 0, \"appearEasing\": { \"type\": 0, \"inOut\": 1 }, \"disappearEasing\": { \"type\": 0, \"inOut\": 1 }, \"appearAnimation\": { \"type\": 1, \"movement\": 0, \"mask\": { \"graphic\": null, \"vague\": 30 } }, \"disappearAnimation\": { \"type\": 1, \"movement\": 0, \"mask\": { \"graphic\": null, \"vague\": 30 } }, \"motionBlur\": { \"enabled\": 0, \"delay\": 2, \"opacity\": 100, \"dissolveSpeed\": 3 } },\n            live2d: { \"motionFadeInTime\": 1000, \"appearDuration\": 30, \"disappearDuration\": 30, \"zOrder\": 0, \"appearEasing\": { \"type\": 0, \"inOut\": 1 }, \"disappearEasing\": { \"type\": 0, \"inOut\": 1 }, \"appearAnimation\": { \"type\": 1, \"movement\": 0, \"mask\": { \"graphic\": null, \"vague\": 30 } }, \"disappearAnimation\": { \"type\": 1, \"movement\": 0, \"mask\": { \"graphic\": null, \"vague\": 30 } } },\n            messageBox: { \"appearDuration\": 30, \"disappearDuration\": 30, \"zOrder\": 0, \"appearEasing\": { \"type\": 0, \"inOut\": 1 }, \"disappearEasing\": { \"type\": 0, \"inOut\": 1 }, \"appearAnimation\": { \"type\": 0, \"movement\": 3, \"mask\": { \"graphic\": null, \"vague\": 30 } }, \"disappearAnimation\": { \"type\": 0, \"movement\": 3, \"mask\": { \"graphic\": null, \"vague\": 30 } } },\n            audio: { \"musicFadeInDuration\": 0, \"musicFadeOutDuration\": 0, \"musicVolume\": 100, \"musicPlaybackRate\": 100, \"soundVolume\": 100, \"soundPlaybackRate\": 100, \"voiceVolume\": 100, \"voicePlaybackRate\": 100 }\n        }\n\n        ###*\n        * The game's backlog.\n        * @property backlog\n        * @type Object[]\n        ###\n        @backlog = []\n\n        ###*\n        * Character parameters by character ID.\n        * @property characterParams\n        * @type Object[]\n        ###\n        @characterParams = []\n\n        ###*\n        * The game's chapter\n        * @property chapters\n        * @type gs.Document[]\n        ###\n        @chapters = []\n\n        ###*\n        * The game's current displayed messages. Especially in NVL mode the messages\n        * of the current page are stored here.\n        * @property messages\n        * @type Object[]\n        ###\n        @messages = []\n\n        ###*\n        * Count of save slots. Default is 100.\n        * @property saveSlotCount\n        * @type number\n        ###\n        @saveSlotCount = 100\n\n        ###*\n        * The index of save games. Contains the header-info for each save game slot.\n        * @property saveGameSlots\n        * @type Object[]\n        ###\n        @saveGameSlots = []\n\n        ###*\n        * Stores global data like the state of persistent game variables.\n        * @property globalData\n        * @type Object\n        ###\n        @globalData = null\n\n        ###*\n        * Indicates if the game runs in editor's live-preview.\n        * @property inLivePreview\n        * @type Object\n        ###\n        @inLivePreview = no\n\n\n    ###*\n    * Initializes the GameManager, should be called before the actual game starts.\n    *\n    * @method initialize\n    ###\n    initialize: ->\n        @initialized = yes\n        @inLivePreview = $PARAMS.preview?\n        @saveSlotCount = RecordManager.system.saveSlotCount || 100\n        @tempFields = new gs.GameTemp()\n        window.$tempFields = @tempFields\n\n        @createSaveGameIndex()\n        @variableStore = new gs.VariableStore()\n        DataManager.getDocumentsByType(\"persistent_variables\")\n        @variableStore.setupDomains(DataManager.getDocumentsByType(\"global_variables\").select (v) -> v.items.domain||\"\")\n        @variableStore.persistentNumbersByDomain = @globalData.persistentNumbers ? @variableStore.persistentNumbersByDomain\n        @variableStore.persistentBooleansByDomain = @globalData.persistentBooleans ? @variableStore.persistentBooleansByDomain\n        @variableStore.persistentStringsByDomain = @globalData.persistentStrings ? @variableStore.persistentStringsByDomain\n        @variableStore.persistentListsByDomain = @globalData.persistentLists ? @variableStore.persistentListsByDomain\n\n        @sceneViewport = new gs.Object_Viewport(new Viewport(0, 0, Graphics.width, Graphics.height, Graphics.viewport))\n        for character in RecordManager.charactersArray\n            if character?\n                @characterParams[character.index] = {}\n                if character.params?\n                    for param in character.params\n                        @characterParams[character.index][param.name] = param.value\n\n\n        @setupCommonEvents()\n\n        for i in [0...RecordManager.characters]\n            @settings.voicesPerCharacter[i] = 100\n\n        @chapters = DataManager.getDocumentsByType(\"vn.chapter\")\n        @chapters.sort (a, b) ->\n            if a.items.order > b.items.order\n                return 1\n            else if a.items.order < b.items.order\n                return -1\n            else\n                return 0\n\n    ###*\n    * Sets up common events.\n    *\n    * @method setupCommonEvents\n    ###\n    setupCommonEvents: ->\n        for event in @commonEvents\n            event?.dispose()\n\n        @commonEvents = []\n        for event in RecordManager.commonEvents\n            object = new gs.Object_CommonEvent()\n            object.record = event\n            object.rid = event.index\n            @commonEvents[event.index] = object\n            @commonEvents.push(object)\n\n    ###*\n    * Preloads resources for common events with auto-preload option enabled.\n    *\n    * @method preloadCommonEvents\n    ###\n    preloadCommonEvents: ->\n        for event in RecordManager.commonEvents\n            continue if not event\n            if event.startCondition == 1 and event.autoPreload\n                gs.ResourceLoader.loadEventCommandsGraphics(event.commands)\n\n    ###*\n    * Sets up cursor depending on system settings.\n    *\n    * @method setupCursor\n    ###\n    setupCursor: ->\n        if RecordManager.system.cursor?.name\n            bitmap = ResourceManager.getBitmap(\"Graphics/Pictures/#{RecordManager.system.cursor.name}\")\n            Graphics.setCursorBitmap(bitmap, RecordManager.system.cursor.hx, RecordManager.system.cursor.hy)\n        else\n            Graphics.setCursorBitmap(null)\n\n    ###*\n    * Disposes the GameManager. Should be called before quit the game.\n    *\n    * @method dispose\n    ###\n    dispose: ->\n\n    ###*\n    * Quits the game. The implementation depends on the platform. So for example on mobile\n    * devices this method has no effect.\n    *\n    * @method exit\n    ###\n    exit: -> Application.exit()\n\n    ###*\n    * Resets the GameManager by disposing and re-initializing it.\n    *\n    * @method reset\n    ###\n    reset: ->\n        @initialized = no\n        @interpreter = null\n        @dispose()\n        @initialize()\n\n    ###*\n    * Starts a new game.\n    *\n    * @method newGame\n    ###\n    newGame: ->\n        @messages = []\n        @variableStore.clearAllGlobalVariables()\n        @variableStore.clearAllLocalVariables()\n        @tempSettings.skip = no\n        @tempFields.clear()\n        @tempFields.inGame = yes\n        @setupCommonEvents()\n        @tempSettings.menuAccess = yes\n        @tempSettings.saveMenuAccess = yes\n        @tempSettings.loadMenuAccess = yes\n        @tempSettings.backlogAccess = yes\n\n\n    ###*\n    * Exists the game and resets the GameManager which is important before going back to\n    * the main menu or title screen.\n    *\n    * @method exitGame\n    ###\n    exitGame: ->\n        @tempFields.inGame = no\n        @tempFields.isExitingGame = yes\n\n    ###*\n    * Updates the GameManager. Should be called once per frame.\n    *\n    * @method update\n    ###\n    update: ->\n\n    ###*\n    * Creates the index of all save-games. Should be called whenever a new save game\n    * is created.\n    *\n    * @method createSaveGameIndex\n    * @protected\n    ###\n    createSaveGameIndex: ->\n        @saveGameSlots = []\n        for i in [0...@saveSlotCount]\n            if GameStorage.exists(\"SaveGame_#{i}_Header\")\n                header = GameStorage.getObject(\"SaveGame_#{i}_Header\")\n                chapter = DataManager.getDocument(header.chapterUid)\n                scene = DataManager.getDocumentSummary(header.sceneUid)\n                image = header.image\n            else\n                header = null\n                chaper = null\n                scene = null\n\n            if chapter? and scene? and !@inLivePreview\n                @saveGameSlots.push({\n                    date: header.date,\n                    chapter: chapter.items.name || \"DELETED\"\n                    scene: scene.items.name || \"DELETED\",\n                    image: image #chapter.items.commands[0].params.saveGameGraphic?.name\n                })\n            else\n                @saveGameSlots.push({ \"date\": \"\", \"chapter\": \"\", \"scene\": \"\", \"image\": null })\n\n        return @saveGameSlots\n\n    ###*\n    * Resets the game's settings to its default values.\n    *\n    * @method resetSettings\n    ###\n    resetSettings: ->\n        @settings = { version: 342, renderer: 0, filter: 1, confirmation: yes, adjustAspectRatio: no, allowSkip: yes, allowSkipUnreadMessages: yes,  allowVideoSkip: yes, skipVoiceOnAction: yes, allowChoiceSkip: no, voicesByCharacter: [], timeMessageToVoice: true,  \"autoMessage\": { enabled: false, time: 0, waitForVoice: yes, stopOnAction: no },  \"voiceEnabled\": true, \"bgmEnabled\": true, \"soundEnabled\": true, \"voiceVolume\": 100, \"bgmVolume\": 100, \"seVolume\": 100, \"messageSpeed\": 4, \"fullScreen\": no, \"aspectRatio\": 0 }\n        @saveGameSlots = []\n        for i in [0...@saveSlotCount]\n            GameStorage.remove(\"SaveGame_#{i}_Header\")\n            GameStorage.remove(\"SaveGame_#{i}\")\n\n            @saveGameSlots.push({ \"date\": \"\", \"chapter\": \"\", \"scene\": \"\", \"thumb\": \"\" })\n\n        GameStorage.setObject(\"settings\", @settings)\n\n\n\n    ###*\n    * Saves current game settings.\n    *\n    * @method saveSettings\n    ###\n    saveSettings: ->\n        GameStorage.setObject(\"settings\", @settings)\n\n    ###*\n    * Saves current global data.\n    *\n    * @method saveGlobalData\n    ###\n    saveGlobalData: ->\n        @globalData.persistentNumbers = @variableStore.persistentNumbersByDomain\n        @globalData.persistentLists = @variableStore.persistentListsByDomain\n        @globalData.persistentBooleans = @variableStore.persistentBooleansByDomain\n        @globalData.persistentStrings = @variableStore.persistentStringsByDomain\n        GameStorage.setObject(\"globalData\", @globalData)\n\n    ###*\n    * Resets current global data. All stored data about read messages, persistent variables and\n    * CG gallery will be deleted.\n    *\n    * @method resetGlobalData\n    ###\n    resetGlobalData: ->\n        version = @globalData?.version\n        data = @globalData\n\n        @globalData = {\n            messages: {}, cgGallery: {}, version: 342,\n            persistentNumbers: { \"0\": [], \"com.degica.vnm.default\": [] },\n            persistentStrings: { \"0\": [], \"com.degica.vnm.default\": [] },\n            persistentBooleans: { \"0\": [], \"com.degica.vnm.default\": [] },\n            persistentLists: { \"0\": [], \"com.degica.vnm.default\": [] }\n        }\n\n        for cg, i in RecordManager.cgGalleryArray\n            if cg?\n                @globalData.cgGallery[cg.index] = { unlocked: no }\n\n        GameStorage.setObject(\"globalData\", @globalData)\n\n        @migrateGlobalData(data, version+1, @globalData.version)\n\n    migrateGlobalData: (data, from, to) ->\n        for i in [from..to]\n            if this[\"migrateGlobalData#{i}\"]?\n                this[\"migrateGlobalData#{i}\"](data)\n\n    migrateGlobalData342: (data) ->\n        if data?\n            @globalData.persistentNumbers[0] = data.persistentNumbers[0] || []\n            @globalData.persistentStrings[0] = data.persistentStrings[0] || []\n            @globalData.persistentBooleans[0] = data.persistentBooleans[0] || []\n            @globalData.persistentLists[0] = data.persistentLists[0] || []\n            @globalData.persistentNumbers[\"com.degica.vnm.default\"] = data.persistentNumbers[0] || []\n            @globalData.persistentStrings[\"com.degica.vnm.default\"] = data.persistentStrings[0] || []\n            @globalData.persistentBooleans[\"com.degica.vnm.default\"] = data.persistentBooleans[0] || []\n            @globalData.persistentLists[\"com.degica.vnm.default\"] = data.persistentLists[0] || []\n\n    readSaveGame: (saveGame) ->\n    writeSaveGame: (saveGame) ->\n\n    prepareSaveGame: (snapshot) ->\n        if snapshot\n            snapshot = ResourceManager.getCustomBitmap(\"$snapshot\")\n            snapshot?.dispose()\n            ResourceManager.setCustomBitmap(\"$snapshot\", Graphics.snapshot())\n\n        context = new gs.ObjectCodecContext()\n        context.decodedObjectStore.push(Graphics.viewport)\n        context.decodedObjectStore.push(@scene)\n        context.decodedObjectStore.push(@scene.behavior)\n\n        messageBoxIds = [\"messageBox\", \"nvlMessageBox\", \"messageMenu\"];\n        messageIds = [\"gameMessage_message\", \"nvlGameMessage_message\"];\n        messageBoxes = messageBoxIds.select (id) => @scene.behavior.objectManager.objectById(id)\n        messages = messageIds.select (id) => @scene.behavior.objectManager.objectById(id)\n\n        sceneData = {}\n        saveGame = {}\n        saveGame.encodedObjectStore = null\n        saveGame.sceneUid = @scene.sceneDocument.uid\n        saveGame.data = {\n            resourceContext: @scene.behavior.resourceContext.toDataBundle(),\n            currentCharacter: @scene.currentCharacter,\n            characterParams: @characterParams,\n            frameCount: Graphics.frameCount,\n            tempFields: @tempFields,\n            viewport: @scene.viewport,\n            characters: @scene.characters,\n            characterNames: RecordManager.charactersArray.select((c) -> { name: c.name, index: c.index }),\n            backgrounds: @scene.backgrounds,\n            pictures: @scene.pictureContainer.subObjectsByDomain,\n            texts: @scene.textContainer.subObjectsByDomain,\n            videos: @scene.videoContainer.subObjectsByDomain,\n            viewports: @scene.viewportContainer.subObjects,\n            commonEvents: @scene.commonEventContainer.subObjects,\n            hotspots: @scene.hotspotContainer.subObjectsByDomain,\n            interpreter: @scene.interpreter,\n            choices: @scene.choices,\n            messageBoxes: messageBoxes.select((mb, i) => { visible: mb.visible, id: mb.id, message: messages[i] }),\n            backlog: @backlog,\n            variableStore: @variableStore,\n            defaults: @defaults,\n            transitionData: SceneManager.transitionData,\n            audio: { audioBuffers: AudioManager.audioBuffers, audioBuffersByLayer: AudioManager.audioBuffersByLayer, audioLayers: AudioManager.audioLayers, soundReferences: AudioManager.soundReferences },\n            messageAreas: @scene.messageAreaContainer.subObjectsByDomain\n        }\n\n        saveGame.data = gs.ObjectCodec.encode(saveGame.data, context)\n        saveGame.encodedObjectStore = context.encodedObjectStore\n\n        @saveGame = saveGame\n\n    createSaveGameSlot: (header) ->\n        slot = {\n            \"date\": new Date().toDateString(),\n            \"chapter\": @scene.chapter.items.name,\n            \"scene\": @scene.sceneDocument.items.name,\n            \"image\": header.image\n        }\n\n        return slot;\n\n    createSaveGameHeader: (thumbWidth, thumbHeight) ->\n        thumbImage = @createSaveGameThumbImage(thumbWidth, thumbHeight)\n\n        header = {\n            \"date\": new Date().toDateString(),\n            \"chapterUid\": @scene.chapter.uid,\n            \"sceneUid\": @scene.sceneDocument.uid,\n            \"image\": thumbImage?.image.toDataURL()\n        }\n\n        thumbImage?.dispose()\n\n        return header\n\n    createSaveGameThumbImage: (width, height) ->\n        snapshot = ResourceManager.getBitmap(\"$snapshot\")\n        thumbImage = null\n\n        if snapshot and snapshot.loaded\n            if width and height\n                thumbImage = new Bitmap(width, height)\n            else\n                thumbImage = new Bitmap(Graphics.width / 8, Graphics.height / 8)\n            thumbImage.stretchBlt(new Rect(0, 0, thumbImage.width, thumbImage.height), snapshot, new Rect(0, 0, snapshot.width, snapshot.height))\n\n        return thumbImage\n\n    storeSaveGame: (name, saveGame, header) ->\n        if header\n            GameStorage.setData(\"#{name}_Header\", JSON.stringify(header))\n\n        GameStorage.setData(name, JSON.stringify(saveGame))\n\n    ###*\n    * Saves the current game at the specified slot.\n    *\n    * @method save\n    * @param {number} slot - The slot where the game should be saved at.\n    * @param {number} thumbWidth - The width for the snapshot-thumb. You can specify <b>null</b> or 0 to use an auto calculated width.\n    * @param {number} thumbHeight - The height for the snapshot-thumb. You can specify <b>null</b> or 0 to use an auto calculated height.\n    ###\n    save: (slot, thumbWidth, thumbHeight) ->\n        if @saveGame\n            header = @createSaveGameHeader(thumbWidth, thumbHeight)\n            @saveGameSlots[slot] = @createSaveGameSlot(header)\n            @storeSaveGame(\"SaveGame_#{slot}\", @saveGame, header)\n            @sceneData = {}\n\n            return @saveGame\n\n    restore: (saveGame) ->\n        @backlog = saveGame.data.backlog\n        @defaults = saveGame.data.defaults\n        @variableStore.restore(saveGame.data.variableStore)\n        @sceneData = saveGame.data\n        @saveGame = null\n        @loadedSaveGame = null\n        @tempFields = saveGame.data.tempFields\n        @characterParams = saveGame.data.characterParams\n        window.$tempFields = @tempFields\n        window.$dataFields.backlog = @backlog\n\n\n    prepareLoadGame: ->\n        AudioManager.stopAllMusic(30)\n\n    ###*\n    * Loads the game from the specified save game slot. This method triggers\n    * a automatic scene change.\n    *\n    * @method load\n    * @param {number} slot - The slot where the game should be loaded from.\n    ###\n    load: (slot) ->\n        return if !@saveGameSlots[slot] or @saveGameSlots[slot].date.trim().length == 0\n\n        @prepareLoadGame()\n        @loadedSaveGame = @loadSaveGame(\"SaveGame_#{slot}\")\n\n\n        gs.Audio.reset()\n        gs.GlobalEventManager.clear()\n        SceneManager.switchTo(new vn.Object_Scene())\n        SceneManager.clear()\n\n\n    loadSaveGame: (name) -> JSON.parse(GameStorage.getData(name))\n\n\n    ###*\n    * Gets the save game data for a specified slot.\n    *\n    * @method getSaveGame\n    * @param {number} slot - The slot to get the save data from.\n    * @return {Object} The save game data.\n    ###\n    getSaveGame: (slot) -> JSON.parse(GameStorage.getData(\"SaveGame_#{slot}\"))\n\nwindow.GameManager = new GameManager()\ngs.GameManager = window.GameManager",
        "compiledContent": "// Generated by CoffeeScript 1.12.7\n(function() {\n  var GameManager;\n\n  GameManager = (function() {\n\n    /**\n    * Manages all general things around the game like holding the game settings,\n    * manages the save/load of a game, etc.\n    *\n    * @module gs\n    * @class GameManager\n    * @memberof gs\n    * @constructor\n     */\n    function GameManager() {\n\n      /**\n      * The current scene data.\n      * @property sceneData\n      * @type Object\n       */\n      this.sceneData = {};\n\n      /**\n      * The scene viewport containing all visual objects which are part of the scene and influenced\n      * by the in-game camera.\n      * @property sceneViewport\n      * @type gs.Object_Viewport\n       */\n      this.sceneViewport = null;\n\n      /**\n      * The list of common events.\n      * @property commonEvents\n      * @type gs.Object_CommonEvent[]\n       */\n      this.commonEvents = [];\n\n      /**\n      * Indicates if the GameManager is initialized.\n      * @property commonEvents\n      * @type gs.Object_CommonEvent[]\n       */\n      this.initialized = false;\n\n      /**\n      * Temporary game settings.\n      * @property tempSettings\n      * @type Object\n       */\n      this.tempSettings = {\n        skip: false,\n        skipTime: 5,\n        loadMenuAccess: true,\n        menuAccess: true,\n        backlogAccess: true,\n        saveMenuAccess: true,\n        messageFading: {\n          animation: {\n            type: 1\n          },\n          duration: 15,\n          easing: null\n        }\n\n        /**\n        * Temporary game fields.\n        * @property tempFields\n        * @type Object\n         */\n      };\n      this.tempFields = null;\n\n      /**\n      * Stores default values for backgrounds, pictures, etc.\n      * @property defaults\n      * @type Object\n       */\n      this.defaults = {\n        background: {\n          \"duration\": 30,\n          \"origin\": 0,\n          \"zOrder\": 0,\n          \"loopVertical\": 0,\n          \"loopHorizontal\": 0,\n          \"easing\": {\n            \"type\": 0,\n            \"inOut\": 1\n          },\n          \"animation\": {\n            \"type\": 1,\n            \"movement\": 0,\n            \"mask\": {\n              \"graphic\": null,\n              \"vague\": 30\n            }\n          },\n          \"motionBlur\": {\n            \"enabled\": 0,\n            \"delay\": 2,\n            \"opacity\": 100,\n            \"dissolveSpeed\": 3\n          }\n        },\n        picture: {\n          \"appearDuration\": 30,\n          \"disappearDuration\": 30,\n          \"origin\": 1,\n          \"zOrder\": 0,\n          \"appearEasing\": {\n            \"type\": 0,\n            \"inOut\": 1\n          },\n          \"disappearEasing\": {\n            \"type\": 0,\n            \"inOut\": 1\n          },\n          \"appearAnimation\": {\n            \"type\": 1,\n            \"movement\": 0,\n            \"mask\": {\n              \"graphic\": null,\n              \"vague\": 30\n            }\n          },\n          \"disappearAnimation\": {\n            \"type\": 1,\n            \"movement\": 0,\n            \"mask\": {\n              \"graphic\": null,\n              \"vague\": 30\n            }\n          },\n          \"motionBlur\": {\n            \"enabled\": 0,\n            \"delay\": 2,\n            \"opacity\": 100,\n            \"dissolveSpeed\": 3\n          }\n        },\n        character: {\n          \"expressionDuration\": 0,\n          \"appearDuration\": 40,\n          \"disappearDuration\": 40,\n          \"origin\": 1,\n          \"zOrder\": 0,\n          \"appearEasing\": {\n            \"type\": 2,\n            \"inOut\": 2\n          },\n          \"disappearEasing\": {\n            \"type\": 1,\n            \"inOut\": 1\n          },\n          \"appearAnimation\": {\n            \"type\": 1,\n            \"movement\": 0,\n            \"mask\": {\n              \"graphic\": null,\n              \"vague\": 30\n            }\n          },\n          \"disappearAnimation\": {\n            \"type\": 1,\n            \"movement\": 0,\n            \"mask\": {\n              \"graphic\": null,\n              \"vague\": 30\n            }\n          },\n          \"motionBlur\": {\n            \"enabled\": 0,\n            \"delay\": 2,\n            \"opacity\": 100,\n            \"dissolveSpeed\": 3\n          },\n          \"changeAnimation\": {\n            \"type\": 1,\n            \"movement\": 0,\n            \"fading\": 0,\n            \"mask\": {\n              \"graphic\": null,\n              \"vague\": 30\n            }\n          },\n          \"changeEasing\": {\n            \"type\": 2,\n            \"inOut\": 2\n          }\n        },\n        text: {\n          \"appearDuration\": 30,\n          \"disappearDuration\": 30,\n          \"positionOrigin\": 0,\n          \"origin\": 0,\n          \"zOrder\": 0,\n          \"appearEasing\": {\n            \"type\": 0,\n            \"inOut\": 1\n          },\n          \"disappearEasing\": {\n            \"type\": 0,\n            \"inOut\": 1\n          },\n          \"appearAnimation\": {\n            \"type\": 1,\n            \"movement\": 0,\n            \"mask\": {\n              \"graphic\": null,\n              \"vague\": 30\n            }\n          },\n          \"disappearAnimation\": {\n            \"type\": 1,\n            \"movement\": 0,\n            \"mask\": {\n              \"graphic\": null,\n              \"vague\": 30\n            }\n          },\n          \"motionBlur\": {\n            \"enabled\": 0,\n            \"delay\": 2,\n            \"opacity\": 100,\n            \"dissolveSpeed\": 3\n          }\n        },\n        video: {\n          \"appearDuration\": 30,\n          \"disappearDuration\": 30,\n          \"origin\": 0,\n          \"zOrder\": 0,\n          \"appearEasing\": {\n            \"type\": 0,\n            \"inOut\": 1\n          },\n          \"disappearEasing\": {\n            \"type\": 0,\n            \"inOut\": 1\n          },\n          \"appearAnimation\": {\n            \"type\": 1,\n            \"movement\": 0,\n            \"mask\": {\n              \"graphic\": null,\n              \"vague\": 30\n            }\n          },\n          \"disappearAnimation\": {\n            \"type\": 1,\n            \"movement\": 0,\n            \"mask\": {\n              \"graphic\": null,\n              \"vague\": 30\n            }\n          },\n          \"motionBlur\": {\n            \"enabled\": 0,\n            \"delay\": 2,\n            \"opacity\": 100,\n            \"dissolveSpeed\": 3\n          }\n        },\n        live2d: {\n          \"motionFadeInTime\": 1000,\n          \"appearDuration\": 30,\n          \"disappearDuration\": 30,\n          \"zOrder\": 0,\n          \"appearEasing\": {\n            \"type\": 0,\n            \"inOut\": 1\n          },\n          \"disappearEasing\": {\n            \"type\": 0,\n            \"inOut\": 1\n          },\n          \"appearAnimation\": {\n            \"type\": 1,\n            \"movement\": 0,\n            \"mask\": {\n              \"graphic\": null,\n              \"vague\": 30\n            }\n          },\n          \"disappearAnimation\": {\n            \"type\": 1,\n            \"movement\": 0,\n            \"mask\": {\n              \"graphic\": null,\n              \"vague\": 30\n            }\n          }\n        },\n        messageBox: {\n          \"appearDuration\": 30,\n          \"disappearDuration\": 30,\n          \"zOrder\": 0,\n          \"appearEasing\": {\n            \"type\": 0,\n            \"inOut\": 1\n          },\n          \"disappearEasing\": {\n            \"type\": 0,\n            \"inOut\": 1\n          },\n          \"appearAnimation\": {\n            \"type\": 0,\n            \"movement\": 3,\n            \"mask\": {\n              \"graphic\": null,\n              \"vague\": 30\n            }\n          },\n          \"disappearAnimation\": {\n            \"type\": 0,\n            \"movement\": 3,\n            \"mask\": {\n              \"graphic\": null,\n              \"vague\": 30\n            }\n          }\n        },\n        audio: {\n          \"musicFadeInDuration\": 0,\n          \"musicFadeOutDuration\": 0,\n          \"musicVolume\": 100,\n          \"musicPlaybackRate\": 100,\n          \"soundVolume\": 100,\n          \"soundPlaybackRate\": 100,\n          \"voiceVolume\": 100,\n          \"voicePlaybackRate\": 100\n        }\n      };\n\n      /**\n      * The game's backlog.\n      * @property backlog\n      * @type Object[]\n       */\n      this.backlog = [];\n\n      /**\n      * Character parameters by character ID.\n      * @property characterParams\n      * @type Object[]\n       */\n      this.characterParams = [];\n\n      /**\n      * The game's chapter\n      * @property chapters\n      * @type gs.Document[]\n       */\n      this.chapters = [];\n\n      /**\n      * The game's current displayed messages. Especially in NVL mode the messages\n      * of the current page are stored here.\n      * @property messages\n      * @type Object[]\n       */\n      this.messages = [];\n\n      /**\n      * Count of save slots. Default is 100.\n      * @property saveSlotCount\n      * @type number\n       */\n      this.saveSlotCount = 100;\n\n      /**\n      * The index of save games. Contains the header-info for each save game slot.\n      * @property saveGameSlots\n      * @type Object[]\n       */\n      this.saveGameSlots = [];\n\n      /**\n      * Stores global data like the state of persistent game variables.\n      * @property globalData\n      * @type Object\n       */\n      this.globalData = null;\n\n      /**\n      * Indicates if the game runs in editor's live-preview.\n      * @property inLivePreview\n      * @type Object\n       */\n      this.inLivePreview = false;\n    }\n\n\n    /**\n    * Initializes the GameManager, should be called before the actual game starts.\n    *\n    * @method initialize\n     */\n\n    GameManager.prototype.initialize = function() {\n      var character, i, j, k, l, len, len1, param, ref, ref1, ref2, ref3, ref4, ref5, ref6;\n      this.initialized = true;\n      this.inLivePreview = $PARAMS.preview != null;\n      this.saveSlotCount = RecordManager.system.saveSlotCount || 100;\n      this.tempFields = new gs.GameTemp();\n      window.$tempFields = this.tempFields;\n      this.createSaveGameIndex();\n      this.variableStore = new gs.VariableStore();\n      DataManager.getDocumentsByType(\"persistent_variables\");\n      this.variableStore.setupDomains(DataManager.getDocumentsByType(\"global_variables\").select(function(v) {\n        return v.items.domain || \"\";\n      }));\n      this.variableStore.persistentNumbersByDomain = (ref = this.globalData.persistentNumbers) != null ? ref : this.variableStore.persistentNumbersByDomain;\n      this.variableStore.persistentBooleansByDomain = (ref1 = this.globalData.persistentBooleans) != null ? ref1 : this.variableStore.persistentBooleansByDomain;\n      this.variableStore.persistentStringsByDomain = (ref2 = this.globalData.persistentStrings) != null ? ref2 : this.variableStore.persistentStringsByDomain;\n      this.variableStore.persistentListsByDomain = (ref3 = this.globalData.persistentLists) != null ? ref3 : this.variableStore.persistentListsByDomain;\n      this.sceneViewport = new gs.Object_Viewport(new Viewport(0, 0, Graphics.width, Graphics.height, Graphics.viewport));\n      ref4 = RecordManager.charactersArray;\n      for (j = 0, len = ref4.length; j < len; j++) {\n        character = ref4[j];\n        if (character != null) {\n          this.characterParams[character.index] = {};\n          if (character.params != null) {\n            ref5 = character.params;\n            for (k = 0, len1 = ref5.length; k < len1; k++) {\n              param = ref5[k];\n              this.characterParams[character.index][param.name] = param.value;\n            }\n          }\n        }\n      }\n      this.setupCommonEvents();\n      for (i = l = 0, ref6 = RecordManager.characters; 0 <= ref6 ? l < ref6 : l > ref6; i = 0 <= ref6 ? ++l : --l) {\n        this.settings.voicesPerCharacter[i] = 100;\n      }\n      this.chapters = DataManager.getDocumentsByType(\"vn.chapter\");\n      return this.chapters.sort(function(a, b) {\n        if (a.items.order > b.items.order) {\n          return 1;\n        } else if (a.items.order < b.items.order) {\n          return -1;\n        } else {\n          return 0;\n        }\n      });\n    };\n\n\n    /**\n    * Sets up common events.\n    *\n    * @method setupCommonEvents\n     */\n\n    GameManager.prototype.setupCommonEvents = function() {\n      var event, j, k, len, len1, object, ref, ref1, results;\n      ref = this.commonEvents;\n      for (j = 0, len = ref.length; j < len; j++) {\n        event = ref[j];\n        if (event != null) {\n          event.dispose();\n        }\n      }\n      this.commonEvents = [];\n      ref1 = RecordManager.commonEvents;\n      results = [];\n      for (k = 0, len1 = ref1.length; k < len1; k++) {\n        event = ref1[k];\n        object = new gs.Object_CommonEvent();\n        object.record = event;\n        object.rid = event.index;\n        this.commonEvents[event.index] = object;\n        results.push(this.commonEvents.push(object));\n      }\n      return results;\n    };\n\n\n    /**\n    * Preloads resources for common events with auto-preload option enabled.\n    *\n    * @method preloadCommonEvents\n     */\n\n    GameManager.prototype.preloadCommonEvents = function() {\n      var event, j, len, ref, results;\n      ref = RecordManager.commonEvents;\n      results = [];\n      for (j = 0, len = ref.length; j < len; j++) {\n        event = ref[j];\n        if (!event) {\n          continue;\n        }\n        if (event.startCondition === 1 && event.autoPreload) {\n          results.push(gs.ResourceLoader.loadEventCommandsGraphics(event.commands));\n        } else {\n          results.push(void 0);\n        }\n      }\n      return results;\n    };\n\n\n    /**\n    * Sets up cursor depending on system settings.\n    *\n    * @method setupCursor\n     */\n\n    GameManager.prototype.setupCursor = function() {\n      var bitmap, ref;\n      if ((ref = RecordManager.system.cursor) != null ? ref.name : void 0) {\n        bitmap = ResourceManager.getBitmap(\"Graphics/Pictures/\" + RecordManager.system.cursor.name);\n        return Graphics.setCursorBitmap(bitmap, RecordManager.system.cursor.hx, RecordManager.system.cursor.hy);\n      } else {\n        return Graphics.setCursorBitmap(null);\n      }\n    };\n\n\n    /**\n    * Disposes the GameManager. Should be called before quit the game.\n    *\n    * @method dispose\n     */\n\n    GameManager.prototype.dispose = function() {};\n\n\n    /**\n    * Quits the game. The implementation depends on the platform. So for example on mobile\n    * devices this method has no effect.\n    *\n    * @method exit\n     */\n\n    GameManager.prototype.exit = function() {\n      return Application.exit();\n    };\n\n\n    /**\n    * Resets the GameManager by disposing and re-initializing it.\n    *\n    * @method reset\n     */\n\n    GameManager.prototype.reset = function() {\n      this.initialized = false;\n      this.interpreter = null;\n      this.dispose();\n      return this.initialize();\n    };\n\n\n    /**\n    * Starts a new game.\n    *\n    * @method newGame\n     */\n\n    GameManager.prototype.newGame = function() {\n      this.messages = [];\n      this.variableStore.clearAllGlobalVariables();\n      this.variableStore.clearAllLocalVariables();\n      this.tempSettings.skip = false;\n      this.tempFields.clear();\n      this.tempFields.inGame = true;\n      this.setupCommonEvents();\n      this.tempSettings.menuAccess = true;\n      this.tempSettings.saveMenuAccess = true;\n      this.tempSettings.loadMenuAccess = true;\n      return this.tempSettings.backlogAccess = true;\n    };\n\n\n    /**\n    * Exists the game and resets the GameManager which is important before going back to\n    * the main menu or title screen.\n    *\n    * @method exitGame\n     */\n\n    GameManager.prototype.exitGame = function() {\n      this.tempFields.inGame = false;\n      return this.tempFields.isExitingGame = true;\n    };\n\n\n    /**\n    * Updates the GameManager. Should be called once per frame.\n    *\n    * @method update\n     */\n\n    GameManager.prototype.update = function() {};\n\n\n    /**\n    * Creates the index of all save-games. Should be called whenever a new save game\n    * is created.\n    *\n    * @method createSaveGameIndex\n    * @protected\n     */\n\n    GameManager.prototype.createSaveGameIndex = function() {\n      var chaper, chapter, header, i, image, j, ref, scene;\n      this.saveGameSlots = [];\n      for (i = j = 0, ref = this.saveSlotCount; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n        if (GameStorage.exists(\"SaveGame_\" + i + \"_Header\")) {\n          header = GameStorage.getObject(\"SaveGame_\" + i + \"_Header\");\n          chapter = DataManager.getDocument(header.chapterUid);\n          scene = DataManager.getDocumentSummary(header.sceneUid);\n          image = header.image;\n        } else {\n          header = null;\n          chaper = null;\n          scene = null;\n        }\n        if ((chapter != null) && (scene != null) && !this.inLivePreview) {\n          this.saveGameSlots.push({\n            date: header.date,\n            chapter: chapter.items.name || \"DELETED\",\n            scene: scene.items.name || \"DELETED\",\n            image: image\n          });\n        } else {\n          this.saveGameSlots.push({\n            \"date\": \"\",\n            \"chapter\": \"\",\n            \"scene\": \"\",\n            \"image\": null\n          });\n        }\n      }\n      return this.saveGameSlots;\n    };\n\n\n    /**\n    * Resets the game's settings to its default values.\n    *\n    * @method resetSettings\n     */\n\n    GameManager.prototype.resetSettings = function() {\n      var i, j, ref;\n      this.settings = {\n        version: 342,\n        renderer: 0,\n        filter: 1,\n        confirmation: true,\n        adjustAspectRatio: false,\n        allowSkip: true,\n        allowSkipUnreadMessages: true,\n        allowVideoSkip: true,\n        skipVoiceOnAction: true,\n        allowChoiceSkip: false,\n        voicesByCharacter: [],\n        timeMessageToVoice: true,\n        \"autoMessage\": {\n          enabled: false,\n          time: 0,\n          waitForVoice: true,\n          stopOnAction: false\n        },\n        \"voiceEnabled\": true,\n        \"bgmEnabled\": true,\n        \"soundEnabled\": true,\n        \"voiceVolume\": 100,\n        \"bgmVolume\": 100,\n        \"seVolume\": 100,\n        \"messageSpeed\": 4,\n        \"fullScreen\": false,\n        \"aspectRatio\": 0\n      };\n      this.saveGameSlots = [];\n      for (i = j = 0, ref = this.saveSlotCount; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n        GameStorage.remove(\"SaveGame_\" + i + \"_Header\");\n        GameStorage.remove(\"SaveGame_\" + i);\n        this.saveGameSlots.push({\n          \"date\": \"\",\n          \"chapter\": \"\",\n          \"scene\": \"\",\n          \"thumb\": \"\"\n        });\n      }\n      return GameStorage.setObject(\"settings\", this.settings);\n    };\n\n\n    /**\n    * Saves current game settings.\n    *\n    * @method saveSettings\n     */\n\n    GameManager.prototype.saveSettings = function() {\n      return GameStorage.setObject(\"settings\", this.settings);\n    };\n\n\n    /**\n    * Saves current global data.\n    *\n    * @method saveGlobalData\n     */\n\n    GameManager.prototype.saveGlobalData = function() {\n      this.globalData.persistentNumbers = this.variableStore.persistentNumbersByDomain;\n      this.globalData.persistentLists = this.variableStore.persistentListsByDomain;\n      this.globalData.persistentBooleans = this.variableStore.persistentBooleansByDomain;\n      this.globalData.persistentStrings = this.variableStore.persistentStringsByDomain;\n      return GameStorage.setObject(\"globalData\", this.globalData);\n    };\n\n\n    /**\n    * Resets current global data. All stored data about read messages, persistent variables and\n    * CG gallery will be deleted.\n    *\n    * @method resetGlobalData\n     */\n\n    GameManager.prototype.resetGlobalData = function() {\n      var cg, data, i, j, len, ref, ref1, version;\n      version = (ref = this.globalData) != null ? ref.version : void 0;\n      data = this.globalData;\n      this.globalData = {\n        messages: {},\n        cgGallery: {},\n        version: 342,\n        persistentNumbers: {\n          \"0\": [],\n          \"com.degica.vnm.default\": []\n        },\n        persistentStrings: {\n          \"0\": [],\n          \"com.degica.vnm.default\": []\n        },\n        persistentBooleans: {\n          \"0\": [],\n          \"com.degica.vnm.default\": []\n        },\n        persistentLists: {\n          \"0\": [],\n          \"com.degica.vnm.default\": []\n        }\n      };\n      ref1 = RecordManager.cgGalleryArray;\n      for (i = j = 0, len = ref1.length; j < len; i = ++j) {\n        cg = ref1[i];\n        if (cg != null) {\n          this.globalData.cgGallery[cg.index] = {\n            unlocked: false\n          };\n        }\n      }\n      GameStorage.setObject(\"globalData\", this.globalData);\n      return this.migrateGlobalData(data, version + 1, this.globalData.version);\n    };\n\n    GameManager.prototype.migrateGlobalData = function(data, from, to) {\n      var i, j, ref, ref1, results;\n      results = [];\n      for (i = j = ref = from, ref1 = to; ref <= ref1 ? j <= ref1 : j >= ref1; i = ref <= ref1 ? ++j : --j) {\n        if (this[\"migrateGlobalData\" + i] != null) {\n          results.push(this[\"migrateGlobalData\" + i](data));\n        } else {\n          results.push(void 0);\n        }\n      }\n      return results;\n    };\n\n    GameManager.prototype.migrateGlobalData342 = function(data) {\n      if (data != null) {\n        this.globalData.persistentNumbers[0] = data.persistentNumbers[0] || [];\n        this.globalData.persistentStrings[0] = data.persistentStrings[0] || [];\n        this.globalData.persistentBooleans[0] = data.persistentBooleans[0] || [];\n        this.globalData.persistentLists[0] = data.persistentLists[0] || [];\n        this.globalData.persistentNumbers[\"com.degica.vnm.default\"] = data.persistentNumbers[0] || [];\n        this.globalData.persistentStrings[\"com.degica.vnm.default\"] = data.persistentStrings[0] || [];\n        this.globalData.persistentBooleans[\"com.degica.vnm.default\"] = data.persistentBooleans[0] || [];\n        return this.globalData.persistentLists[\"com.degica.vnm.default\"] = data.persistentLists[0] || [];\n      }\n    };\n\n    GameManager.prototype.readSaveGame = function(saveGame) {};\n\n    GameManager.prototype.writeSaveGame = function(saveGame) {};\n\n    GameManager.prototype.prepareSaveGame = function(snapshot) {\n      var context, messageBoxIds, messageBoxes, messageIds, messages, saveGame, sceneData;\n      if (snapshot) {\n        snapshot = ResourceManager.getCustomBitmap(\"$snapshot\");\n        if (snapshot != null) {\n          snapshot.dispose();\n        }\n        ResourceManager.setCustomBitmap(\"$snapshot\", Graphics.snapshot());\n      }\n      context = new gs.ObjectCodecContext();\n      context.decodedObjectStore.push(Graphics.viewport);\n      context.decodedObjectStore.push(this.scene);\n      context.decodedObjectStore.push(this.scene.behavior);\n      messageBoxIds = [\"messageBox\", \"nvlMessageBox\", \"messageMenu\"];\n      messageIds = [\"gameMessage_message\", \"nvlGameMessage_message\"];\n      messageBoxes = messageBoxIds.select((function(_this) {\n        return function(id) {\n          return _this.scene.behavior.objectManager.objectById(id);\n        };\n      })(this));\n      messages = messageIds.select((function(_this) {\n        return function(id) {\n          return _this.scene.behavior.objectManager.objectById(id);\n        };\n      })(this));\n      sceneData = {};\n      saveGame = {};\n      saveGame.encodedObjectStore = null;\n      saveGame.sceneUid = this.scene.sceneDocument.uid;\n      saveGame.data = {\n        resourceContext: this.scene.behavior.resourceContext.toDataBundle(),\n        currentCharacter: this.scene.currentCharacter,\n        characterParams: this.characterParams,\n        frameCount: Graphics.frameCount,\n        tempFields: this.tempFields,\n        viewport: this.scene.viewport,\n        characters: this.scene.characters,\n        characterNames: RecordManager.charactersArray.select(function(c) {\n          return {\n            name: c.name,\n            index: c.index\n          };\n        }),\n        backgrounds: this.scene.backgrounds,\n        pictures: this.scene.pictureContainer.subObjectsByDomain,\n        texts: this.scene.textContainer.subObjectsByDomain,\n        videos: this.scene.videoContainer.subObjectsByDomain,\n        viewports: this.scene.viewportContainer.subObjects,\n        commonEvents: this.scene.commonEventContainer.subObjects,\n        hotspots: this.scene.hotspotContainer.subObjectsByDomain,\n        interpreter: this.scene.interpreter,\n        choices: this.scene.choices,\n        messageBoxes: messageBoxes.select((function(_this) {\n          return function(mb, i) {\n            return {\n              visible: mb.visible,\n              id: mb.id,\n              message: messages[i]\n            };\n          };\n        })(this)),\n        backlog: this.backlog,\n        variableStore: this.variableStore,\n        defaults: this.defaults,\n        transitionData: SceneManager.transitionData,\n        audio: {\n          audioBuffers: AudioManager.audioBuffers,\n          audioBuffersByLayer: AudioManager.audioBuffersByLayer,\n          audioLayers: AudioManager.audioLayers,\n          soundReferences: AudioManager.soundReferences\n        },\n        messageAreas: this.scene.messageAreaContainer.subObjectsByDomain\n      };\n      saveGame.data = gs.ObjectCodec.encode(saveGame.data, context);\n      saveGame.encodedObjectStore = context.encodedObjectStore;\n      return this.saveGame = saveGame;\n    };\n\n    GameManager.prototype.createSaveGameSlot = function(header) {\n      var slot;\n      slot = {\n        \"date\": new Date().toDateString(),\n        \"chapter\": this.scene.chapter.items.name,\n        \"scene\": this.scene.sceneDocument.items.name,\n        \"image\": header.image\n      };\n      return slot;\n    };\n\n    GameManager.prototype.createSaveGameHeader = function(thumbWidth, thumbHeight) {\n      var header, thumbImage;\n      thumbImage = this.createSaveGameThumbImage(thumbWidth, thumbHeight);\n      header = {\n        \"date\": new Date().toDateString(),\n        \"chapterUid\": this.scene.chapter.uid,\n        \"sceneUid\": this.scene.sceneDocument.uid,\n        \"image\": thumbImage != null ? thumbImage.image.toDataURL() : void 0\n      };\n      if (thumbImage != null) {\n        thumbImage.dispose();\n      }\n      return header;\n    };\n\n    GameManager.prototype.createSaveGameThumbImage = function(width, height) {\n      var snapshot, thumbImage;\n      snapshot = ResourceManager.getBitmap(\"$snapshot\");\n      thumbImage = null;\n      if (snapshot && snapshot.loaded) {\n        if (width && height) {\n          thumbImage = new Bitmap(width, height);\n        } else {\n          thumbImage = new Bitmap(Graphics.width / 8, Graphics.height / 8);\n        }\n        thumbImage.stretchBlt(new Rect(0, 0, thumbImage.width, thumbImage.height), snapshot, new Rect(0, 0, snapshot.width, snapshot.height));\n      }\n      return thumbImage;\n    };\n\n    GameManager.prototype.storeSaveGame = function(name, saveGame, header) {\n      if (header) {\n        GameStorage.setData(name + \"_Header\", JSON.stringify(header));\n      }\n      return GameStorage.setData(name, JSON.stringify(saveGame));\n    };\n\n\n    /**\n    * Saves the current game at the specified slot.\n    *\n    * @method save\n    * @param {number} slot - The slot where the game should be saved at.\n    * @param {number} thumbWidth - The width for the snapshot-thumb. You can specify <b>null</b> or 0 to use an auto calculated width.\n    * @param {number} thumbHeight - The height for the snapshot-thumb. You can specify <b>null</b> or 0 to use an auto calculated height.\n     */\n\n    GameManager.prototype.save = function(slot, thumbWidth, thumbHeight) {\n      var header;\n      if (this.saveGame) {\n        header = this.createSaveGameHeader(thumbWidth, thumbHeight);\n        this.saveGameSlots[slot] = this.createSaveGameSlot(header);\n        this.storeSaveGame(\"SaveGame_\" + slot, this.saveGame, header);\n        this.sceneData = {};\n        return this.saveGame;\n      }\n    };\n\n    GameManager.prototype.restore = function(saveGame) {\n      this.backlog = saveGame.data.backlog;\n      this.defaults = saveGame.data.defaults;\n      this.variableStore.restore(saveGame.data.variableStore);\n      this.sceneData = saveGame.data;\n      this.saveGame = null;\n      this.loadedSaveGame = null;\n      this.tempFields = saveGame.data.tempFields;\n      this.characterParams = saveGame.data.characterParams;\n      window.$tempFields = this.tempFields;\n      return window.$dataFields.backlog = this.backlog;\n    };\n\n    GameManager.prototype.prepareLoadGame = function() {\n      return AudioManager.stopAllMusic(30);\n    };\n\n\n    /**\n    * Loads the game from the specified save game slot. This method triggers\n    * a automatic scene change.\n    *\n    * @method load\n    * @param {number} slot - The slot where the game should be loaded from.\n     */\n\n    GameManager.prototype.load = function(slot) {\n      if (!this.saveGameSlots[slot] || this.saveGameSlots[slot].date.trim().length === 0) {\n        return;\n      }\n      this.prepareLoadGame();\n      this.loadedSaveGame = this.loadSaveGame(\"SaveGame_\" + slot);\n      gs.Audio.reset();\n      gs.GlobalEventManager.clear();\n      SceneManager.switchTo(new vn.Object_Scene());\n      return SceneManager.clear();\n    };\n\n    GameManager.prototype.loadSaveGame = function(name) {\n      return JSON.parse(GameStorage.getData(name));\n    };\n\n\n    /**\n    * Gets the save game data for a specified slot.\n    *\n    * @method getSaveGame\n    * @param {number} slot - The slot to get the save data from.\n    * @return {Object} The save game data.\n     */\n\n    GameManager.prototype.getSaveGame = function(slot) {\n      return JSON.parse(GameStorage.getData(\"SaveGame_\" + slot));\n    };\n\n    return GameManager;\n\n  })();\n\n  window.GameManager = new GameManager();\n\n  gs.GameManager = window.GameManager;\n\n}).call(this);\n"
    },
    "summary": [
        "name",
        "type",
        "order"
    ],
    "externalItems": []
}