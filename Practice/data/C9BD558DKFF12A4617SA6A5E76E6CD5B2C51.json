{
    "uid": "C9BD558DKFF12A4617SA6A5E76E6CD5B2C51",
    "isLoaded": true,
    "lastModificationTime": 0,
    "items": {
        "name": "Component_AnimationHandler",
        "type": "game_script",
        "order": 12,
        "parentId": "01A95DA3K01E8A4CB4SBE17E790BCE1FC035",
        "folder": false,
        "content": "# ===================================================================\n#\n#   Script: Component_AnimationHandler\n#\n#   $$COPYRIGHT$$\n#\n# ===================================================================\nclass Component_AnimationHandler extends ui.Component_Handler\n    ###*\n    * An animation-handler component allows a UI game object to execute\n    * a flow of animations. For more information about UI animations, see help-file.\n    * \n    * @module ui\n    * @class Component_AnimationHandler\n    * @extends ui.Component_Handler\n    * @memberof ui\n    * @constructor\n    ###\n    constructor: ->\n        super\n        \n        ###*\n        * @property initialized\n        * @type boolean\n        * @protected\n        ###\n        @initialized = no\n        \n        ###*\n        * @property waitCounter\n        * @type number\n        * @protected\n        ###\n        @waitCounter = 0\n        \n        ###*\n        * @property pointer\n        * @type number\n        * @protected\n        ###\n        @pointer = 0\n        \n    ###*\n    * Initializes the animation-handler.\n    * \n    * @method setup\n    ###\n    setup: ->\n        @initialized = yes\n   \n        return null\n    \n    ###*\n    * Processes the animation targets and starts the animation on each\n    * target object if possible.\n    * \n    * @method processTargets\n    * @param {Object} animation - The animation to start.\n    * @param {gs.Object_Base[]} targets - An array of target objects.\n    * @protected\n    ### \n    processTargets: (animation, targets) ->\n        for target in targets\n            if animation.type?\n                target.visible = yes\n                if !animation.components? then animation.components = []\n                \n                if(!@object.animator)\n                    @object.animator = new gs.Component_Animator()\n                    @object.addComponent(@object.animator)\n\n                animation.components.push(@object.animationExecutor.startAnimation(animation, animation.duration, target, @object.animator))\n\n                target.visible = yes\n                animation.executed = !(animation.repeat ? yes)\n            else\n                animation.executed = !(animation.repeat ? yes)\n    \n        return null\n        \n    ###*\n    * Clears/Resets the specified animation if necessary.\n    * \n    * @method clear\n    * @param {Object} descriptor - The animation descriptor\n    * @protected\n    ###             \n    clear: (descriptor) ->\n        descriptor.cleared = yes\n        descriptor.pointer = 0\n        descriptor.waitCounter = 0\n        for animation in descriptor.flow\n            if animation.components\n                for component in animation.components\n                    #component?.dispose()\n                    target = @object\n                    target.visible = yes\n                    animation.executed = no\n                    if animation.field? and animation.reset?\n                        ui.BindingHandler.resolveFieldPath(target, animation.field).set(target, ui.BindingHandler.fieldValue(target, animation.reset || 0))\n                animation.components = []  \n                \n        @object.needsFullUpdate = yes\n        \n        return null\n    \n    ###*\n    * Processes the animation flow.\n    * \n    * @method processAnimations\n    * @param {Object} descriptor - The animation-descriptor containing the animation-flow.\n    * @protected\n    ### \n    processAnimations: (descriptor) ->\n        while descriptor.pointer < descriptor.flow.length\n            animation = descriptor.flow[descriptor.pointer]\n            descriptor.pointer++\n            \n            if !animation.wait and animation.executed then continue\n            \n            targets = if animation.target? then ui.Component_FormulaHandler.fieldValue(@object, animation.target) else @object\n            targets = if targets.length? then targets else [targets]\n            descriptor.cleared = no\n            \n            @processTargets(animation, targets)\n            \n            if animation.wait\n                if animation.type?\n                    descriptor.waitCounter = animation.duration\n                else\n                    descriptor.waitCounter = animation.wait #ui.Component_FormulaHandler.fieldValue(@object, animation.wait || 0, yes)\n                break\n                \n        return null\n                \n    ###*\n    * Updates the animations.\n    * \n    * @method updateAnimations\n    ###\n    updateAnimations: ->\n        for descriptor, i in @object.animations\n            if @checkObject(descriptor)\n                if descriptor.waitCounter > 0\n                    descriptor.waitCounter--\n                    continue\n                \n                if (not descriptor.pointer?) or descriptor.pointer >= descriptor.flow.length\n                    descriptor.pointer = 0\n                    \n                @processAnimations(descriptor)\n            else if !descriptor.cleared and (descriptor.clear ? yes)\n                @clear(descriptor)\n                \n        return null\n     \n    ###*\n    * Updates the animation-handler.\n    * \n    * @method update\n    ###   \n    update: ->\n        @object.needsUpdate = yes\n        @updateAnimations()\n        \n        \n        \n        \nui.Component_AnimationHandler = Component_AnimationHandler",
        "compiledContent": "// Generated by CoffeeScript 1.12.7\n(function() {\n  var Component_AnimationHandler,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  Component_AnimationHandler = (function(superClass) {\n    extend(Component_AnimationHandler, superClass);\n\n\n    /**\n    * An animation-handler component allows a UI game object to execute\n    * a flow of animations. For more information about UI animations, see help-file.\n    * \n    * @module ui\n    * @class Component_AnimationHandler\n    * @extends ui.Component_Handler\n    * @memberof ui\n    * @constructor\n     */\n\n    function Component_AnimationHandler() {\n      Component_AnimationHandler.__super__.constructor.apply(this, arguments);\n\n      /**\n      * @property initialized\n      * @type boolean\n      * @protected\n       */\n      this.initialized = false;\n\n      /**\n      * @property waitCounter\n      * @type number\n      * @protected\n       */\n      this.waitCounter = 0;\n\n      /**\n      * @property pointer\n      * @type number\n      * @protected\n       */\n      this.pointer = 0;\n    }\n\n\n    /**\n    * Initializes the animation-handler.\n    * \n    * @method setup\n     */\n\n    Component_AnimationHandler.prototype.setup = function() {\n      this.initialized = true;\n      return null;\n    };\n\n\n    /**\n    * Processes the animation targets and starts the animation on each\n    * target object if possible.\n    * \n    * @method processTargets\n    * @param {Object} animation - The animation to start.\n    * @param {gs.Object_Base[]} targets - An array of target objects.\n    * @protected\n     */\n\n    Component_AnimationHandler.prototype.processTargets = function(animation, targets) {\n      var j, len, ref, ref1, target;\n      for (j = 0, len = targets.length; j < len; j++) {\n        target = targets[j];\n        if (animation.type != null) {\n          target.visible = true;\n          if (animation.components == null) {\n            animation.components = [];\n          }\n          if (!this.object.animator) {\n            this.object.animator = new gs.Component_Animator();\n            this.object.addComponent(this.object.animator);\n          }\n          animation.components.push(this.object.animationExecutor.startAnimation(animation, animation.duration, target, this.object.animator));\n          target.visible = true;\n          animation.executed = !((ref = animation.repeat) != null ? ref : true);\n        } else {\n          animation.executed = !((ref1 = animation.repeat) != null ? ref1 : true);\n        }\n      }\n      return null;\n    };\n\n\n    /**\n    * Clears/Resets the specified animation if necessary.\n    * \n    * @method clear\n    * @param {Object} descriptor - The animation descriptor\n    * @protected\n     */\n\n    Component_AnimationHandler.prototype.clear = function(descriptor) {\n      var animation, component, j, k, len, len1, ref, ref1, target;\n      descriptor.cleared = true;\n      descriptor.pointer = 0;\n      descriptor.waitCounter = 0;\n      ref = descriptor.flow;\n      for (j = 0, len = ref.length; j < len; j++) {\n        animation = ref[j];\n        if (animation.components) {\n          ref1 = animation.components;\n          for (k = 0, len1 = ref1.length; k < len1; k++) {\n            component = ref1[k];\n            target = this.object;\n            target.visible = true;\n            animation.executed = false;\n            if ((animation.field != null) && (animation.reset != null)) {\n              ui.BindingHandler.resolveFieldPath(target, animation.field).set(target, ui.BindingHandler.fieldValue(target, animation.reset || 0));\n            }\n          }\n          animation.components = [];\n        }\n      }\n      this.object.needsFullUpdate = true;\n      return null;\n    };\n\n\n    /**\n    * Processes the animation flow.\n    * \n    * @method processAnimations\n    * @param {Object} descriptor - The animation-descriptor containing the animation-flow.\n    * @protected\n     */\n\n    Component_AnimationHandler.prototype.processAnimations = function(descriptor) {\n      var animation, targets;\n      while (descriptor.pointer < descriptor.flow.length) {\n        animation = descriptor.flow[descriptor.pointer];\n        descriptor.pointer++;\n        if (!animation.wait && animation.executed) {\n          continue;\n        }\n        targets = animation.target != null ? ui.Component_FormulaHandler.fieldValue(this.object, animation.target) : this.object;\n        targets = targets.length != null ? targets : [targets];\n        descriptor.cleared = false;\n        this.processTargets(animation, targets);\n        if (animation.wait) {\n          if (animation.type != null) {\n            descriptor.waitCounter = animation.duration;\n          } else {\n            descriptor.waitCounter = animation.wait;\n          }\n          break;\n        }\n      }\n      return null;\n    };\n\n\n    /**\n    * Updates the animations.\n    * \n    * @method updateAnimations\n     */\n\n    Component_AnimationHandler.prototype.updateAnimations = function() {\n      var descriptor, i, j, len, ref, ref1;\n      ref = this.object.animations;\n      for (i = j = 0, len = ref.length; j < len; i = ++j) {\n        descriptor = ref[i];\n        if (this.checkObject(descriptor)) {\n          if (descriptor.waitCounter > 0) {\n            descriptor.waitCounter--;\n            continue;\n          }\n          if ((descriptor.pointer == null) || descriptor.pointer >= descriptor.flow.length) {\n            descriptor.pointer = 0;\n          }\n          this.processAnimations(descriptor);\n        } else if (!descriptor.cleared && ((ref1 = descriptor.clear) != null ? ref1 : true)) {\n          this.clear(descriptor);\n        }\n      }\n      return null;\n    };\n\n\n    /**\n    * Updates the animation-handler.\n    * \n    * @method update\n     */\n\n    Component_AnimationHandler.prototype.update = function() {\n      this.object.needsUpdate = true;\n      return this.updateAnimations();\n    };\n\n    return Component_AnimationHandler;\n\n  })(ui.Component_Handler);\n\n  ui.Component_AnimationHandler = Component_AnimationHandler;\n\n}).call(this);\n"
    },
    "summary": [
        "name",
        "type",
        "order"
    ],
    "externalItems": []
}