{
    "uid": "922103F9K2F40A4605SB7D6E96ACC3F0E72D",
    "isLoaded": true,
    "lastModificationTime": 0,
    "items": {
        "name": "Component_MoveAnimation",
        "type": "game_script",
        "order": 6,
        "parentId": "A8E9945CKEE5CA4855SAC81E480CB8098E0E",
        "folder": false,
        "content": "# ===================================================================\n#\n#   Script: Component_MoveAnimation\n#\n#   $$COPYRIGHT$$\n#\n# ===================================================================\nclass Component_MoveAnimation extends gs.Component_Animation\n    ###*\n    * Executes a move-animation on a game-object.\n    *\n    * @module gs\n    * @class Component_MoveAnimation\n    * @extends gs.Component_Animation\n    * @memberof gs\n    * @constructor\n    ###\n    constructor: (data) ->\n        super\n        \n        ###*\n        * The easing-object used for the animation.\n        * @property easing\n        * @type gs.Easing\n        ###\n        @easing = new gs.Easing(null, data?.easing)\n        \n        ###*\n        * The move-animation type (move-in, move-out, etc.).\n        * @property animationType\n        * @type gs.MoveAnimationType\n        ###\n        @animationType = data?.animationType || 0\n     \n    ###*\n    * Serializes the move-animation into a data-bundle.\n    *\n    * @method toDataBundle\n    ###      \n    toDataBundle: ->\n        easing: @easing,\n        animationType: @animationType\n     \n    ###*\n    * Updates the move-animation.\n    *\n    * @method update\n    ###      \n    update: ->\n        super()\n        if not @easing.isRunning then return\n        \n        @easing.updatePosition()\n        \n        @updateCoordinates()\n            \n        if not @easing.isRunning\n            if not @easing.isEndless\n                @object.dstRect.x = Math.round(@object.dstRect.x)\n                @object.dstRect.y = Math.round(@object.dstRect.y)\n            @callback?(@object, this)\n     \n    ###*\n    * Updates the game object's coordinates depending on animation type.\n    *\n    * @method updateCoordinates\n    * @protected\n    ###     \n    updateCoordinates: ->\n        switch @animationType\n            when 0\n                @object.offset.x = Math.floor(@easing.x)\n                @object.offset.y = Math.floor(@easing.y)\n            when 1\n                @object.dstRect.x = Math.floor(@easing.x)\n                @object.dstRect.y = Math.floor(@easing.y)\n            when 2\n                @object.visual.scroll.x = Math.round(@easing.x)\n                @object.visual.scroll.y = Math.round(@easing.y)\n                \n    ###*\n    * Scrolls the game object's content with a specified speed if supported.\n    *\n    * @method scroll\n    * @param {number} speedX The speed on x-axis in pixels per frame.\n    * @param {number} speedY The speed on y-axis in pixels per frame.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type used for the animation.\n    * @param {function} [callback] An optional callback-function called when the animation is finished.\n    ###  \n    scroll: (speedX, speedY, duration, easingType, callback) ->\n        @move(speedX, speedY, duration, easingType, callback)\n        @animationType = 2\n        \n    ###*\n    * Scrolls the game object to a specified position.\n    *\n    * @method scrollTo\n    * @param {number} x The x-coordinate of the position.\n    * @param {number} y The y-coordinate of the position.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    * @param {function} [callback] An optional callback-function called when the animation is finished.\n    ###      \n    scrollTo: (x, y, duration, easingType, callback) ->\n        @animationType = 2\n        @callback = callback\n        if @object.visual.scroll.x == x and @object.visual.scroll.y == y then return\n        \n        @easing.type = easingType || gs.Easings.EASE_LINEAR[gs.EasingTypes.EASE_IN]\n        if duration == 0 or @isInstantSkip()\n            @object.visual.scroll.x = x\n            @object.visual.scroll.y = y\n            @callback?(@object, this)\n        else\n            @easing.start(@object.visual.scroll.x, @object.visual.scroll.y, x, y, duration)\n            @targetX = x\n            @targetY = y\n        \n    ###*\n    * Moves the game object with a specified speed.\n    *\n    * @method move\n    * @param {number} speedX The speed on x-axis in pixels per frame.\n    * @param {number} speedY The speed on y-axis in pixels per frame.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type used for the animation.\n    * @param {function} [callback] An optional callback-function called when the animation is finished.\n    ###        \n    move: (speedX, speedY, duration, easingType, callback) ->\n        @animationType = 1\n        @targetX = duration * speedX\n        @targetY = duration * speedY\n        @callback = callback\n        \n        @easing.type = easingType || gs.Easings.EASE_LINEAR[gs.EasingTypes.EASE_IN]\n        if duration == 0 or @isInstantSkip()\n            @easing.startEndless(speedX, speedY)\n        else\n            @easing.start(@object.dstRect.x, @object.dstRect.y, @targetX, @targetY, duration)\n    \n    ###*\n    * Moves the game object to a specified position.\n    *\n    * @method moveTo\n    * @param {number} x The x-coordinate of the position.\n    * @param {number} y The y-coordinate of the position.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    * @param {function} [callback] An optional callback-function called when the animation is finished.\n    ###      \n    moveTo: (x, y, duration, easingType, callback) ->\n        @animationType = 1\n        @callback = callback\n        if @object.dstRect.x == x and @object.dstRect.y == y then return\n        \n        @easing.type = easingType || gs.Easings.EASE_LINEAR[gs.EasingTypes.EASE_IN]\n        if duration == 0 or @isInstantSkip()\n            @easing.x = x\n            @easing.y = y\n            @updateCoordinates()\n        else\n            @easing.start(@object.dstRect.x, @object.dstRect.y, x, y, duration)\n            @targetX = x\n            @targetY = y\n    \n    ###*\n    * Lets a game object appear on screen from left, top, right or bottom using \n    * a move-animation\n    *\n    * @method moveIn\n    * @param {number} x The x-coordinate of the target-position.\n    * @param {number} y The y-coordinate of the target-position.\n    * @param {number} type The movement-direction from where the game object should move-in.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    * @param {function} [callback] An optional callback-function called when the animation is finished. \n    ###         \n    moveIn: (x, y, type, duration, easing, callback) ->\n        @animationType = 0\n        @object.offset.x = 0\n        @object.offset.y = 0\n        \n        if duration == 0 or @isInstantSkip()\n            @object.update()\n            return callback?(@object, this)\n        \n        @easing.type = easing\n        @callback = callback\n        \n        rect = if @object.angle? then @object.dstRect.rotate(@object.angle) else @object.dstRect\n        width = rect.width * @object.zoom.x\n        height = rect.height * @object.zoom.y\n        x = @object.dstRect.x - (width-rect.width) * @object.anchor.x\n        y = @object.dstRect.y - (height-rect.height) * @object.anchor.y\n        \n        switch type\n            when 0 # Left\n                @object.offset.y = 0\n                @object.offset.x = -(x+width+@object.origin.x)\n            when 1 # Top\n                @object.offset.y = -(y+height+@object.origin.y)\n                @object.offset.x = 0\n            when 2 # Right\n                @object.offset.x = (@object.viewport||Graphics.viewport).rect.width - x\n                @object.offset.y = 0\n            when 3 # Bottom\n                @object.offset.x = 0\n                @object.offset.y = (@object.viewport||Graphics.viewport).rect.height - y\n\n        @object.update()\n        @easing.start(@object.offset.x, @object.offset.y, 0, 0, duration)\n       \n    ###*\n    * Lets a game object disappear from screen to the left, top, right or bottom using \n    * a move-animation\n    *\n    * @method moveOut\n    * @param {number} type The movement-direction in which the game object should move-out.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    * @param {function} [callback] An optional callback-function called when the animation is finished. \n    ###    \n    moveOut: (type, duration, easing, callback) ->\n        #if duration == 0 or @isInstantSkip()\n        #    return callback?(@object, this)\n            \n        @animationType = 0\n        @easing.type = easing\n        @callback = callback\n        \n        \n            \n        x = 0\n        y = 0\n        viewport = Graphics.viewport\n        \n        \n        rect = if @object.angle? then @object.dstRect.rotate(@object.angle) else @object.dstRect\n        width = rect.width * @object.zoom.x\n        height = rect.height * @object.zoom.y\n        x = @object.dstRect.x - (width-rect.width) * @object.anchor.x\n        y = @object.dstRect.y - (height-rect.height) * @object.anchor.y\n        \n        switch type\n            when 0 # Left\n                x = -(@object.origin.x+x+width)\n                y = 0\n            when 1 # Top\n                y = -(@object.origin.y+y+height)\n                x = 0\n            when 2 # Right\n                x = (@object.viewport||Graphics.viewport).rect.width\n                y = 0 \n            when 3 # Bottom\n                y = (@object.viewport||Graphics.viewport).rect.height\n                x = 0\n                \n        if duration == 0 or @isInstantSkip()\n            @object.offset.x = x\n            @object.offset.y = y\n            @callback?(@object, this)\n        else\n            @easing.start(@object.offset.x, @object.offset.y, x, y, duration)\n        \ngs.Component_MoveAnimation = Component_MoveAnimation",
        "compiledContent": "// Generated by CoffeeScript 1.12.7\n(function() {\n  var Component_MoveAnimation,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  Component_MoveAnimation = (function(superClass) {\n    extend(Component_MoveAnimation, superClass);\n\n\n    /**\n    * Executes a move-animation on a game-object.\n    *\n    * @module gs\n    * @class Component_MoveAnimation\n    * @extends gs.Component_Animation\n    * @memberof gs\n    * @constructor\n     */\n\n    function Component_MoveAnimation(data) {\n      Component_MoveAnimation.__super__.constructor.apply(this, arguments);\n\n      /**\n      * The easing-object used for the animation.\n      * @property easing\n      * @type gs.Easing\n       */\n      this.easing = new gs.Easing(null, data != null ? data.easing : void 0);\n\n      /**\n      * The move-animation type (move-in, move-out, etc.).\n      * @property animationType\n      * @type gs.MoveAnimationType\n       */\n      this.animationType = (data != null ? data.animationType : void 0) || 0;\n    }\n\n\n    /**\n    * Serializes the move-animation into a data-bundle.\n    *\n    * @method toDataBundle\n     */\n\n    Component_MoveAnimation.prototype.toDataBundle = function() {\n      return {\n        easing: this.easing,\n        animationType: this.animationType\n      };\n    };\n\n\n    /**\n    * Updates the move-animation.\n    *\n    * @method update\n     */\n\n    Component_MoveAnimation.prototype.update = function() {\n      Component_MoveAnimation.__super__.update.call(this);\n      if (!this.easing.isRunning) {\n        return;\n      }\n      this.easing.updatePosition();\n      this.updateCoordinates();\n      if (!this.easing.isRunning) {\n        if (!this.easing.isEndless) {\n          this.object.dstRect.x = Math.round(this.object.dstRect.x);\n          this.object.dstRect.y = Math.round(this.object.dstRect.y);\n        }\n        return typeof this.callback === \"function\" ? this.callback(this.object, this) : void 0;\n      }\n    };\n\n\n    /**\n    * Updates the game object's coordinates depending on animation type.\n    *\n    * @method updateCoordinates\n    * @protected\n     */\n\n    Component_MoveAnimation.prototype.updateCoordinates = function() {\n      switch (this.animationType) {\n        case 0:\n          this.object.offset.x = Math.floor(this.easing.x);\n          return this.object.offset.y = Math.floor(this.easing.y);\n        case 1:\n          this.object.dstRect.x = Math.floor(this.easing.x);\n          return this.object.dstRect.y = Math.floor(this.easing.y);\n        case 2:\n          this.object.visual.scroll.x = Math.round(this.easing.x);\n          return this.object.visual.scroll.y = Math.round(this.easing.y);\n      }\n    };\n\n\n    /**\n    * Scrolls the game object's content with a specified speed if supported.\n    *\n    * @method scroll\n    * @param {number} speedX The speed on x-axis in pixels per frame.\n    * @param {number} speedY The speed on y-axis in pixels per frame.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type used for the animation.\n    * @param {function} [callback] An optional callback-function called when the animation is finished.\n     */\n\n    Component_MoveAnimation.prototype.scroll = function(speedX, speedY, duration, easingType, callback) {\n      this.move(speedX, speedY, duration, easingType, callback);\n      return this.animationType = 2;\n    };\n\n\n    /**\n    * Scrolls the game object to a specified position.\n    *\n    * @method scrollTo\n    * @param {number} x The x-coordinate of the position.\n    * @param {number} y The y-coordinate of the position.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    * @param {function} [callback] An optional callback-function called when the animation is finished.\n     */\n\n    Component_MoveAnimation.prototype.scrollTo = function(x, y, duration, easingType, callback) {\n      this.animationType = 2;\n      this.callback = callback;\n      if (this.object.visual.scroll.x === x && this.object.visual.scroll.y === y) {\n        return;\n      }\n      this.easing.type = easingType || gs.Easings.EASE_LINEAR[gs.EasingTypes.EASE_IN];\n      if (duration === 0 || this.isInstantSkip()) {\n        this.object.visual.scroll.x = x;\n        this.object.visual.scroll.y = y;\n        return typeof this.callback === \"function\" ? this.callback(this.object, this) : void 0;\n      } else {\n        this.easing.start(this.object.visual.scroll.x, this.object.visual.scroll.y, x, y, duration);\n        this.targetX = x;\n        return this.targetY = y;\n      }\n    };\n\n\n    /**\n    * Moves the game object with a specified speed.\n    *\n    * @method move\n    * @param {number} speedX The speed on x-axis in pixels per frame.\n    * @param {number} speedY The speed on y-axis in pixels per frame.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type used for the animation.\n    * @param {function} [callback] An optional callback-function called when the animation is finished.\n     */\n\n    Component_MoveAnimation.prototype.move = function(speedX, speedY, duration, easingType, callback) {\n      this.animationType = 1;\n      this.targetX = duration * speedX;\n      this.targetY = duration * speedY;\n      this.callback = callback;\n      this.easing.type = easingType || gs.Easings.EASE_LINEAR[gs.EasingTypes.EASE_IN];\n      if (duration === 0 || this.isInstantSkip()) {\n        return this.easing.startEndless(speedX, speedY);\n      } else {\n        return this.easing.start(this.object.dstRect.x, this.object.dstRect.y, this.targetX, this.targetY, duration);\n      }\n    };\n\n\n    /**\n    * Moves the game object to a specified position.\n    *\n    * @method moveTo\n    * @param {number} x The x-coordinate of the position.\n    * @param {number} y The y-coordinate of the position.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    * @param {function} [callback] An optional callback-function called when the animation is finished.\n     */\n\n    Component_MoveAnimation.prototype.moveTo = function(x, y, duration, easingType, callback) {\n      this.animationType = 1;\n      this.callback = callback;\n      if (this.object.dstRect.x === x && this.object.dstRect.y === y) {\n        return;\n      }\n      this.easing.type = easingType || gs.Easings.EASE_LINEAR[gs.EasingTypes.EASE_IN];\n      if (duration === 0 || this.isInstantSkip()) {\n        this.easing.x = x;\n        this.easing.y = y;\n        return this.updateCoordinates();\n      } else {\n        this.easing.start(this.object.dstRect.x, this.object.dstRect.y, x, y, duration);\n        this.targetX = x;\n        return this.targetY = y;\n      }\n    };\n\n\n    /**\n    * Lets a game object appear on screen from left, top, right or bottom using \n    * a move-animation\n    *\n    * @method moveIn\n    * @param {number} x The x-coordinate of the target-position.\n    * @param {number} y The y-coordinate of the target-position.\n    * @param {number} type The movement-direction from where the game object should move-in.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    * @param {function} [callback] An optional callback-function called when the animation is finished.\n     */\n\n    Component_MoveAnimation.prototype.moveIn = function(x, y, type, duration, easing, callback) {\n      var height, rect, width;\n      this.animationType = 0;\n      this.object.offset.x = 0;\n      this.object.offset.y = 0;\n      if (duration === 0 || this.isInstantSkip()) {\n        this.object.update();\n        return typeof callback === \"function\" ? callback(this.object, this) : void 0;\n      }\n      this.easing.type = easing;\n      this.callback = callback;\n      rect = this.object.angle != null ? this.object.dstRect.rotate(this.object.angle) : this.object.dstRect;\n      width = rect.width * this.object.zoom.x;\n      height = rect.height * this.object.zoom.y;\n      x = this.object.dstRect.x - (width - rect.width) * this.object.anchor.x;\n      y = this.object.dstRect.y - (height - rect.height) * this.object.anchor.y;\n      switch (type) {\n        case 0:\n          this.object.offset.y = 0;\n          this.object.offset.x = -(x + width + this.object.origin.x);\n          break;\n        case 1:\n          this.object.offset.y = -(y + height + this.object.origin.y);\n          this.object.offset.x = 0;\n          break;\n        case 2:\n          this.object.offset.x = (this.object.viewport || Graphics.viewport).rect.width - x;\n          this.object.offset.y = 0;\n          break;\n        case 3:\n          this.object.offset.x = 0;\n          this.object.offset.y = (this.object.viewport || Graphics.viewport).rect.height - y;\n      }\n      this.object.update();\n      return this.easing.start(this.object.offset.x, this.object.offset.y, 0, 0, duration);\n    };\n\n\n    /**\n    * Lets a game object disappear from screen to the left, top, right or bottom using \n    * a move-animation\n    *\n    * @method moveOut\n    * @param {number} type The movement-direction in which the game object should move-out.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    * @param {function} [callback] An optional callback-function called when the animation is finished.\n     */\n\n    Component_MoveAnimation.prototype.moveOut = function(type, duration, easing, callback) {\n      var height, rect, viewport, width, x, y;\n      this.animationType = 0;\n      this.easing.type = easing;\n      this.callback = callback;\n      x = 0;\n      y = 0;\n      viewport = Graphics.viewport;\n      rect = this.object.angle != null ? this.object.dstRect.rotate(this.object.angle) : this.object.dstRect;\n      width = rect.width * this.object.zoom.x;\n      height = rect.height * this.object.zoom.y;\n      x = this.object.dstRect.x - (width - rect.width) * this.object.anchor.x;\n      y = this.object.dstRect.y - (height - rect.height) * this.object.anchor.y;\n      switch (type) {\n        case 0:\n          x = -(this.object.origin.x + x + width);\n          y = 0;\n          break;\n        case 1:\n          y = -(this.object.origin.y + y + height);\n          x = 0;\n          break;\n        case 2:\n          x = (this.object.viewport || Graphics.viewport).rect.width;\n          y = 0;\n          break;\n        case 3:\n          y = (this.object.viewport || Graphics.viewport).rect.height;\n          x = 0;\n      }\n      if (duration === 0 || this.isInstantSkip()) {\n        this.object.offset.x = x;\n        this.object.offset.y = y;\n        return typeof this.callback === \"function\" ? this.callback(this.object, this) : void 0;\n      } else {\n        return this.easing.start(this.object.offset.x, this.object.offset.y, x, y, duration);\n      }\n    };\n\n    return Component_MoveAnimation;\n\n  })(gs.Component_Animation);\n\n  gs.Component_MoveAnimation = Component_MoveAnimation;\n\n}).call(this);\n"
    },
    "summary": [
        "name",
        "type",
        "order"
    ],
    "externalItems": []
}