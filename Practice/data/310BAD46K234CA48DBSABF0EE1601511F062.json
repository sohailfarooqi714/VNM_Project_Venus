{
    "uid": "310BAD46K234CA48DBSABF0EE1601511F062",
    "isLoaded": true,
    "lastModificationTime": 0,
    "items": {
        "name": "Component_MessageBehavior",
        "type": "game_script",
        "order": 12,
        "parentId": "D3325122KACDEA4515SB731E37A42B9D779F",
        "folder": false,
        "content": "# ===================================================================\n#\n#   Script: Component_MessageBehavior\n#\n#   $$COPYRIGHT$$\n#\n# ===================================================================\n###*\n* An enumeration of game message modes.\n*\n* ADV - Adventure Mode\n* NVL - Novel Mode\n*\n* @typedef MessageMode\n* @memberof vn\n###\nclass MessageMode\n    @ADV = 0\n    @NVL = 1\n    \nvn.MessageMode = MessageMode\n\n\nclass Component_MessageBehavior extends gs.Component\n    @objectCodecBlackList = [\"onMessageWaiting\", \"onMessageFinish\"]\n    \n    ###*\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    * \n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n    ###\n    onDataBundleRestore: (data, context) ->\n        @tempSettings = GameManager.tempSettings\n        @setupEventHandlers()\n        \n    ###*\n    * A behavior-component to define the behavior of a game-message.\n    *\n    * @module vn\n    * @class Component_MessageBehavior\n    * @extends gs.Component\n    * @memberof vn\n    * @constructor\n    ###\n    constructor: ->\n        ###*\n        * Reference to temporary game settings.\n        * @property settings\n        * @type Object\n        * @protected\n        ###\n        @tempSettings = GameManager.tempSettings\n        \n        ###*\n        * Indicates if the message is currently waiting.\n        * @property isWaiting\n        * @type boolean\n        * @readOnly\n        ###\n        @isWaiting = no\n        \n        ###*\n        * Indicates if the message is currently running.\n        * @property isRunning\n        * @type boolean\n        * @readOnly\n        ###\n        @isRunning = no\n        \n        ###*\n        * Indicates if a voice is currently playing together with the message.\n        * @property isVoicePlaying\n        * @type boolean\n        * @readOnly\n        ###\n        @isVoicePlaying = no\n        \n        ###*\n        * Current message caret/cursor position.\n        * @property caretPosition\n        * @type gs.Point\n        * @readOnly\n        ###\n        @caretPosition = new gs.Point(0, 0)\n        \n        ###*\n        * Current raw message text.\n        * @property message\n        * @type string\n        * @readOnly\n        ###\n        @message = \"\"\n        \n        ###*\n        * All currently displayed raw messages.\n        * @property messages\n        * @type string[]\n        * @readOnly\n        ###\n        @messages = []\n        \n        ###*\n        * Voice associated with the current message.\n        * @property voice\n        * @type gs.AudioBufferReference\n        ###\n        @voice = null\n        \n        ###*\n        * Indicates if current message is partial. DEPRECATED. Please do not use.\n        * @property partial\n        * @deprecated\n        * @type boolean\n        * @readOnly\n        ###\n        @partial = no\n        \n        ###*\n        * Indicates if the message is currently waiting in live-preview.\n        * @property waitingPreview\n        * @type boolean\n        * @readOnly\n        ###\n        @waitingPreview = no\n        \n        ###*\n        * Indicates if the auto-message is enabled.\n        * @property autoMessageEnabled\n        * @type boolean\n        * @readOnly\n        ###\n        @autoMessageEnabled = no\n      \n        @onMessageFinish = (sender) =>\n            @object.events.emit \"finish\", this\n            \n            if @object.settings.autoErase or @object.settings.paragraphSpacing > 0\n                @message = \"\"\n            \n        @onMessageWaiting = (sender) =>\n            if !@object.textRenderer.isBatched() or !@object.textRenderer.isBatchInProgress()\n                @object.textRenderer.waitAtEnd = !@partial\n                @object.events.emit \"waiting\", this\n                \n    ###*\n    * Reference to game settings.\n    * @property settings\n    * @type Object\n    * @protected\n    ###\n    @accessors \"settings\", get: -> GameManager.settings\n    \n    ###*\n    * Adds event-handlers\n    *\n    * @method setupEventHandlers\n    ### \n    setupEventHandlers: ->\n        @object.events.offByOwner(\"messageFinish\", this)\n        @object.events.offByOwner(\"messageWaiting\", this)\n        \n        @object.events.on \"messageFinish\", gs.CallBack(\"onMessageFinish\", this), null, this\n        @object.events.on \"messageWaiting\", gs.CallBack(\"onMessageWaiting\", this), null, this\n            \n        gs.GlobalEventManager.offByOwner(\"previewWaiting\", this)\n        gs.GlobalEventManager.offByOwner(\"previewRestart\", this)\n                \n        gs.GlobalEventManager.on \"previewWaiting\", ((sender) =>\n            @waitingPreview = yes\n        ), null, this\n        \n        gs.GlobalEventManager.on \"previewRestart\", ((sender) =>\n            @waitingPreview = no\n        ), null, this\n        \n    ###*\n    * Setup the component. Adds event handlers.\n    *\n    * @method setup\n    ###\n    setup: ->\n        @setupEventHandlers()\n     \n    ###*\n    * Disposes the component.\n    *\n    * @method toDataBundle\n    ###   \n    dispose: ->\n        super\n        \n        gs.GlobalEventManager.offByOwner(\"previewWaiting\", this)\n        gs.GlobalEventManager.offByOwner(\"previewRestart\", this)\n                \n    ###*\n    * Not implemented yet.\n    *\n    * @method toDataBundle\n    ###\n    toDataBundle: ->\n    ###*\n    * Not implemented yet.\n    *\n    * @method restore\n    * @param {Object} bundle - A data bundle.\n    ###    \n    restore: (bundle) ->\n        \n    ###*\n    * Action to show a game message.\n    *\n    * @method showMessage\n    * @param {Object} sender - The sender of this action.\n    * @param {Object} params - An object containing the necessary parameters.\n    ###\n    showMessage: (sender, params) ->\n        gs.GameNotifier.postContextChange(lcsm(params.message))\n        \n        @partial = params.partial\n        @message += lcsm(params.message)\n        @addMessage(params.message, RecordManager.characters[params.characterId], @object.messages.length > 0 and @object.settings.paragraphSpacing > 0, !@partial)\n        \n        if @object.textRenderer.isBatched()\n            @object.textRenderer.waitAtEnd = yes\n        else\n            @object.textRenderer.waitAtEnd = !@partial\n            \n        \n    ###*\n    * Deprecated. Not longer used.\n    *\n    * @method updateBitmap\n    ###\n    updateBitmap: ->\n        if !@object.bitmap or @object.bitmap.width != @object.dstRect.width or @object.bitmap.height != @object.dstRect.height\n            @object.bitmap?.dispose()\n            @object.bitmap = new Bitmap(@object.dstRect.width, @object.dstRect.height)\n            @object.bitmap.font = @object.font\n          \n    ###*\n    * Restores a NVL game message of an array of message-objects. That is\n    * necessary to restore a NVL game message from a save-game.\n    *\n    * @method restoreMessages\n    * @param {Array} messages - An array of messages to restore.\n    ###\n    restoreMessages: (messages) ->\n        @updateBitmap()\n        @clear()\n        \n        @object.opacity = 255\n        @object.srcRect = new Rect(0, 0, @object.dstRect.width, @object.dstRect.height)\n        \n        for message in messages\n            @object.font.color = new Color(message.character?.textColor || Color.WHITE)\n            @object.textRenderer.drawFormattedTextImmediately(0, 0, @object.dstRect.width, @object.dstRect.height, lcsm(message.text ? message), yes)\n\n        return null\n        \n    ###*\n    * Adds a new message.\n    * \n    * @method addMessage\n    * @param {string} message - The message.\n    * @param {Object} character - Database-Record of a character.\n    * @param {boolean} newLine - Indicates if the message should make a line break.\n    ###\n    addMessage: (message, character, newLine, waitAtEnd) ->\n        @object.textRenderer.partialMessage = null\n        @object.offset = x: 0, y: 0\n        @object.visible = yes\n        \n        @object.messages.push({ text: message, character: character})\n        \n        @object.textRenderer.waitAtEnd = waitAtEnd\n        if not @object.settings.autoErase\n            @object.textRenderer.currentY += @object.settings.paragraphSpacing\n        if newLine\n            @object.textRenderer.newLine()\n        @updateBitmap()\n            \n        if character? and @object.settings.useCharacterColor\n            @object.font.color = new Color(character?.textColor || Color.WHITE)\n            \n        @object.opacity = 255\n        @object.srcRect = new Rect(0, 0, @object.dstRect.width, @object.dstRect.height)\n     \n        @update()\n        @object.textRenderer.drawFormattedText(0, 0, @object.dstRect.width, @object.dstRect.height, message, yes)\n\n    ###*\n    * Clears the game message by deleting/clearing all messages.\n    *\n    * @method clear\n    ###\n    clear: -> \n        @object.textRenderer.clear()\n        @object.messages = []\n        @message = \"\"\n        \n    ###*\n    * Closes the game message by making it invisible.\n    *\n    * @method close\n    ###\n    close: -> \n        @object.visible = no\n    \n    ###*\n    * Gets the duration of an associated voice or 0 if no voice is associated.\n    *\n    * @method voiceDuration\n    * @return {number} The duration in frames.\n    ###\n    voiceDuration: ->\n        duration = 0\n        if @voice? and (@settings.autoMessage.waitForVoice or @settings.timeMessageToVoice)\n            duration = Math.round((@voice.source.buffer.duration * (1.0 / @voice.source.playbackRate.value)) * 1000 / 16.6)\n        else\n            duration = 0\n            \n        return if @tempSettings.skip then 1 else duration\n        \n    ###*\n    * Gets the duration of rendering the game-message.\n    *\n    * @method messageDuration\n    * @return {number} The duration in frames.\n    ###\n    messageDuration: -> \n        duration = @object.textRenderer.calculateDuration()\n        \n        return if @tempSettings.skip then 1 else duration\n        \n    ###*\n    * Gets the time between two messages in auto-read mode.\n    *\n    * @method autoMessageTime\n    * @return {number} The time in frames.\n    ###\n    autoMessageTime: -> \n        if @tempSettings.skip\n            return 1\n        else\n            return Math.max(Math.round(@settings.autoMessage.time * Graphics.frameRate), @voiceDuration() - @messageDuration())\n    \n    ###*\n    * Gets the current message speed.\n    *\n    * @method messageSpeed\n    * @return {number} The message speed.\n    ###\n    messageSpeed: -> Math.max(11 - Math.round(GameManager.settings.messageSpeed * 2.5), 0)\n    \n    ###*\n    * Checks if a mouse-button or key was pressed to continue with the message-rendering.\n    *\n    * @method actionTrigger\n    * @return {boolean} If true, the an action-button or action-key is pressed.\n    ###\n    actionTrigger: -> (gs.ObjectManager.current.input and @object.visible and @object.dstRect.contains(Input.Mouse.x - @object.origin.x, Input.Mouse.y - @object.origin.y) and Input.Mouse.buttons[Input.Mouse.LEFT] == 2) or Input.trigger(Input.C)\n    \n    finish: ->\n        #@object.character = null\n        \n        if @object.voice? and GameManager.settings.skipVoiceOnAction\n            AudioManager.stopSound(@object.voice.name)\n    \n    erase: ->\n        fading = GameManager.tempSettings.messageFading\n        duration = if GameManager.tempSettings.skip then 0 else fading.duration\n        \n        @object.animator.disappear(fading.animation, fading.easing, duration, =>\n            SceneManager.scene.currentCharacter = { name: \"\" }\n            @clear()\n            @object.visible = no\n        )\n        \n    ###*\n    * FIXME: Deprecated? It is also a re-definition of gs.Component_Visual.updateOrigin.\n    *\n    * @method updateOrigin\n    ###\n    updateOrigin: ->\n        ox = 0\n        oy = 0\n        if @object.parent? and @object.parent.dstRect?\n            p = @object.parent\n            while p? and p.dstRect?\n                ox += p.dstRect.x\n                oy += p.dstRect.y\n                p = p.parent\n                    \n        @object.origin.x = ox\n        @object.origin.y = oy\n        \n    ###*\n    * Updates the object. \n    *\n    * @method updateObject\n    * @private\n    ###\n    updateObject: ->\n        @updateOrigin()\n        \n        if @tempSettings.skip and not @waitingPreview\n            @object.textRenderer.isWaiting = no\n    \n    ###*\n    * Updates the message.\n    *\n    * @method updateMessage\n    * @private\n    ###\n    updateMessage: ->\n        @caretPosition = @object.textRenderer.caretPosition\n        \n        if @tempSettings.skip and (@settings.allowSkipUnreadMessages or GameManager.globalData.messages[@message]?.read)\n            @object.textRenderer.drawImmediately = yes\n            @object.textRenderer.waitAtEnd = @waitingPreview\n            @object.textRenderer.waitAtEndTime = 0\n        else\n            #@object.textRenderer.drawImmediately = no\n            @updateSpeed()\n            @updateAutoMessage()\n            \n    ###*\n    * Updates the speed of the message. That depends on game-settings if a message\n    * is timed to its voice or not.\n    *\n    * @method updateSpeed\n    * @private\n    ###\n    updateSpeed: ->\n        voiceDuration = @voiceDuration()\n        if voiceDuration > 0 and @settings.timeMessageToVoice\n            @object.textRenderer.speed = voiceDuration / @message.length\n        else\n            @object.textRenderer.speed = @messageSpeed()\n            \n    ###*\n    * Update auto-read mode.\n    *\n    * @method updateAutoMessage\n    * @private\n    ###\n    updateAutoMessage: ->\n        if @settings.autoMessage.stopOnAction and @actionTrigger()\n            @settings.autoMessage.enabled = no\n            \n        if @settings.autoMessage.enabled and not @partial\n            if @object.textRenderer.waitAtEnd\n                @object.textRenderer.isWaiting = no\n            @object.textRenderer.waitAtEndTime = @autoMessageTime()\n            @object.textRenderer.waitAtEnd = no\n        else if @autoMessageEnabled != @settings.autoMessage.enabled\n            @object.textRenderer.waitAtEnd = yes\n            @object.textRenderer.waitAtEndTime = 0\n            \n        @autoMessageEnabled = @settings.autoMessage.enabled\n            \n    ###\n    * Updates the game message behavior\n    *\n    * @method update\n    ###\n    update: ->\n        @object.needsUpdate = yes\n        @updateObject()\n        @updateMessage()\n        \n        if @character != @object.character   \n            gs.GlobalEventManager.emit(\"talkingEnded\", this, character: @character)\n            @character = @object.character\n            \n        if @object.textRenderer.isWaiting != @isWaiting or @object.textRenderer.isRunning != @isRunning or (@voice?.playing && (!@object.character?.timeTalkingToVoiceVolume or @voice.averageVolume > @object.character.talkingVolume)) != @isVoicePlaying\n            @isWaiting = @object.textRenderer.isWaiting\n            @isRunning = @object.textRenderer.isRunning\n            @isVoicePlaying = (@voice?.playing && (!@object.character?.timeTalkingToVoiceVolume or @voice.averageVolume > @object.character.talkingVolume))\n            \n            if not @tempSettings.skip\n                if @voice?.playing\n                    if not @isVoicePlaying\n                        gs.GlobalEventManager.emit(\"talkingEnded\", this, character: @object.character)\n                    else\n                        gs.GlobalEventManager.emit(\"talkingStarted\", this, character: @object.character)\n                else\n                    if @isWaiting\n                        gs.GlobalEventManager.emit(\"talkingEnded\", this, character: @object.character)\n                    else if @isRunning\n                        gs.GlobalEventManager.emit(\"talkingStarted\", this, character: @object.character)\n        \n        if @object.layoutRect? and @object.parent?.dstRect?\n            if @object.layoutRect.x then @object.dstRect.x = @object.layoutRect.x(@object.parent.dstRect.width)\n            if @object.layoutRect.y then @object.dstRect.y = @object.layoutRect.y(@object.parent.dstRect.height)\n            if @object.layoutRect.width then @object.dstRect.width = @object.layoutRect.width(@object.parent.dstRect.width)\n            if @object.layoutRect.height then @object.dstRect.height = @object.layoutRect.height(@object.parent.dstRect.height)\nvn.Component_MessageBehavior = Component_MessageBehavior",
        "compiledContent": "// Generated by CoffeeScript 1.12.7\n\n/**\n* An enumeration of game message modes.\n*\n* ADV - Adventure Mode\n* NVL - Novel Mode\n*\n* @typedef MessageMode\n* @memberof vn\n */\n\n(function() {\n  var Component_MessageBehavior, MessageMode,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  MessageMode = (function() {\n    function MessageMode() {}\n\n    MessageMode.ADV = 0;\n\n    MessageMode.NVL = 1;\n\n    return MessageMode;\n\n  })();\n\n  vn.MessageMode = MessageMode;\n\n  Component_MessageBehavior = (function(superClass) {\n    extend(Component_MessageBehavior, superClass);\n\n    Component_MessageBehavior.objectCodecBlackList = [\"onMessageWaiting\", \"onMessageFinish\"];\n\n\n    /**\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    * \n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n     */\n\n    Component_MessageBehavior.prototype.onDataBundleRestore = function(data, context) {\n      this.tempSettings = GameManager.tempSettings;\n      return this.setupEventHandlers();\n    };\n\n\n    /**\n    * A behavior-component to define the behavior of a game-message.\n    *\n    * @module vn\n    * @class Component_MessageBehavior\n    * @extends gs.Component\n    * @memberof vn\n    * @constructor\n     */\n\n    function Component_MessageBehavior() {\n\n      /**\n      * Reference to temporary game settings.\n      * @property settings\n      * @type Object\n      * @protected\n       */\n      this.tempSettings = GameManager.tempSettings;\n\n      /**\n      * Indicates if the message is currently waiting.\n      * @property isWaiting\n      * @type boolean\n      * @readOnly\n       */\n      this.isWaiting = false;\n\n      /**\n      * Indicates if the message is currently running.\n      * @property isRunning\n      * @type boolean\n      * @readOnly\n       */\n      this.isRunning = false;\n\n      /**\n      * Indicates if a voice is currently playing together with the message.\n      * @property isVoicePlaying\n      * @type boolean\n      * @readOnly\n       */\n      this.isVoicePlaying = false;\n\n      /**\n      * Current message caret/cursor position.\n      * @property caretPosition\n      * @type gs.Point\n      * @readOnly\n       */\n      this.caretPosition = new gs.Point(0, 0);\n\n      /**\n      * Current raw message text.\n      * @property message\n      * @type string\n      * @readOnly\n       */\n      this.message = \"\";\n\n      /**\n      * All currently displayed raw messages.\n      * @property messages\n      * @type string[]\n      * @readOnly\n       */\n      this.messages = [];\n\n      /**\n      * Voice associated with the current message.\n      * @property voice\n      * @type gs.AudioBufferReference\n       */\n      this.voice = null;\n\n      /**\n      * Indicates if current message is partial. DEPRECATED. Please do not use.\n      * @property partial\n      * @deprecated\n      * @type boolean\n      * @readOnly\n       */\n      this.partial = false;\n\n      /**\n      * Indicates if the message is currently waiting in live-preview.\n      * @property waitingPreview\n      * @type boolean\n      * @readOnly\n       */\n      this.waitingPreview = false;\n\n      /**\n      * Indicates if the auto-message is enabled.\n      * @property autoMessageEnabled\n      * @type boolean\n      * @readOnly\n       */\n      this.autoMessageEnabled = false;\n      this.onMessageFinish = (function(_this) {\n        return function(sender) {\n          _this.object.events.emit(\"finish\", _this);\n          if (_this.object.settings.autoErase || _this.object.settings.paragraphSpacing > 0) {\n            return _this.message = \"\";\n          }\n        };\n      })(this);\n      this.onMessageWaiting = (function(_this) {\n        return function(sender) {\n          if (!_this.object.textRenderer.isBatched() || !_this.object.textRenderer.isBatchInProgress()) {\n            _this.object.textRenderer.waitAtEnd = !_this.partial;\n            return _this.object.events.emit(\"waiting\", _this);\n          }\n        };\n      })(this);\n    }\n\n\n    /**\n    * Reference to game settings.\n    * @property settings\n    * @type Object\n    * @protected\n     */\n\n    Component_MessageBehavior.accessors(\"settings\", {\n      get: function() {\n        return GameManager.settings;\n      }\n\n      /**\n      * Adds event-handlers\n      *\n      * @method setupEventHandlers\n       */\n    });\n\n    Component_MessageBehavior.prototype.setupEventHandlers = function() {\n      this.object.events.offByOwner(\"messageFinish\", this);\n      this.object.events.offByOwner(\"messageWaiting\", this);\n      this.object.events.on(\"messageFinish\", gs.CallBack(\"onMessageFinish\", this), null, this);\n      this.object.events.on(\"messageWaiting\", gs.CallBack(\"onMessageWaiting\", this), null, this);\n      gs.GlobalEventManager.offByOwner(\"previewWaiting\", this);\n      gs.GlobalEventManager.offByOwner(\"previewRestart\", this);\n      gs.GlobalEventManager.on(\"previewWaiting\", ((function(_this) {\n        return function(sender) {\n          return _this.waitingPreview = true;\n        };\n      })(this)), null, this);\n      return gs.GlobalEventManager.on(\"previewRestart\", ((function(_this) {\n        return function(sender) {\n          return _this.waitingPreview = false;\n        };\n      })(this)), null, this);\n    };\n\n\n    /**\n    * Setup the component. Adds event handlers.\n    *\n    * @method setup\n     */\n\n    Component_MessageBehavior.prototype.setup = function() {\n      return this.setupEventHandlers();\n    };\n\n\n    /**\n    * Disposes the component.\n    *\n    * @method toDataBundle\n     */\n\n    Component_MessageBehavior.prototype.dispose = function() {\n      Component_MessageBehavior.__super__.dispose.apply(this, arguments);\n      gs.GlobalEventManager.offByOwner(\"previewWaiting\", this);\n      return gs.GlobalEventManager.offByOwner(\"previewRestart\", this);\n    };\n\n\n    /**\n    * Not implemented yet.\n    *\n    * @method toDataBundle\n     */\n\n    Component_MessageBehavior.prototype.toDataBundle = function() {};\n\n\n    /**\n    * Not implemented yet.\n    *\n    * @method restore\n    * @param {Object} bundle - A data bundle.\n     */\n\n    Component_MessageBehavior.prototype.restore = function(bundle) {};\n\n\n    /**\n    * Action to show a game message.\n    *\n    * @method showMessage\n    * @param {Object} sender - The sender of this action.\n    * @param {Object} params - An object containing the necessary parameters.\n     */\n\n    Component_MessageBehavior.prototype.showMessage = function(sender, params) {\n      gs.GameNotifier.postContextChange(lcsm(params.message));\n      this.partial = params.partial;\n      this.message += lcsm(params.message);\n      this.addMessage(params.message, RecordManager.characters[params.characterId], this.object.messages.length > 0 && this.object.settings.paragraphSpacing > 0, !this.partial);\n      if (this.object.textRenderer.isBatched()) {\n        return this.object.textRenderer.waitAtEnd = true;\n      } else {\n        return this.object.textRenderer.waitAtEnd = !this.partial;\n      }\n    };\n\n\n    /**\n    * Deprecated. Not longer used.\n    *\n    * @method updateBitmap\n     */\n\n    Component_MessageBehavior.prototype.updateBitmap = function() {\n      var ref;\n      if (!this.object.bitmap || this.object.bitmap.width !== this.object.dstRect.width || this.object.bitmap.height !== this.object.dstRect.height) {\n        if ((ref = this.object.bitmap) != null) {\n          ref.dispose();\n        }\n        this.object.bitmap = new Bitmap(this.object.dstRect.width, this.object.dstRect.height);\n        return this.object.bitmap.font = this.object.font;\n      }\n    };\n\n\n    /**\n    * Restores a NVL game message of an array of message-objects. That is\n    * necessary to restore a NVL game message from a save-game.\n    *\n    * @method restoreMessages\n    * @param {Array} messages - An array of messages to restore.\n     */\n\n    Component_MessageBehavior.prototype.restoreMessages = function(messages) {\n      var i, len, message, ref, ref1;\n      this.updateBitmap();\n      this.clear();\n      this.object.opacity = 255;\n      this.object.srcRect = new Rect(0, 0, this.object.dstRect.width, this.object.dstRect.height);\n      for (i = 0, len = messages.length; i < len; i++) {\n        message = messages[i];\n        this.object.font.color = new Color(((ref = message.character) != null ? ref.textColor : void 0) || Color.WHITE);\n        this.object.textRenderer.drawFormattedTextImmediately(0, 0, this.object.dstRect.width, this.object.dstRect.height, lcsm((ref1 = message.text) != null ? ref1 : message), true);\n      }\n      return null;\n    };\n\n\n    /**\n    * Adds a new message.\n    * \n    * @method addMessage\n    * @param {string} message - The message.\n    * @param {Object} character - Database-Record of a character.\n    * @param {boolean} newLine - Indicates if the message should make a line break.\n     */\n\n    Component_MessageBehavior.prototype.addMessage = function(message, character, newLine, waitAtEnd) {\n      this.object.textRenderer.partialMessage = null;\n      this.object.offset = {\n        x: 0,\n        y: 0\n      };\n      this.object.visible = true;\n      this.object.messages.push({\n        text: message,\n        character: character\n      });\n      this.object.textRenderer.waitAtEnd = waitAtEnd;\n      if (!this.object.settings.autoErase) {\n        this.object.textRenderer.currentY += this.object.settings.paragraphSpacing;\n      }\n      if (newLine) {\n        this.object.textRenderer.newLine();\n      }\n      this.updateBitmap();\n      if ((character != null) && this.object.settings.useCharacterColor) {\n        this.object.font.color = new Color((character != null ? character.textColor : void 0) || Color.WHITE);\n      }\n      this.object.opacity = 255;\n      this.object.srcRect = new Rect(0, 0, this.object.dstRect.width, this.object.dstRect.height);\n      this.update();\n      return this.object.textRenderer.drawFormattedText(0, 0, this.object.dstRect.width, this.object.dstRect.height, message, true);\n    };\n\n\n    /**\n    * Clears the game message by deleting/clearing all messages.\n    *\n    * @method clear\n     */\n\n    Component_MessageBehavior.prototype.clear = function() {\n      this.object.textRenderer.clear();\n      this.object.messages = [];\n      return this.message = \"\";\n    };\n\n\n    /**\n    * Closes the game message by making it invisible.\n    *\n    * @method close\n     */\n\n    Component_MessageBehavior.prototype.close = function() {\n      return this.object.visible = false;\n    };\n\n\n    /**\n    * Gets the duration of an associated voice or 0 if no voice is associated.\n    *\n    * @method voiceDuration\n    * @return {number} The duration in frames.\n     */\n\n    Component_MessageBehavior.prototype.voiceDuration = function() {\n      var duration;\n      duration = 0;\n      if ((this.voice != null) && (this.settings.autoMessage.waitForVoice || this.settings.timeMessageToVoice)) {\n        duration = Math.round((this.voice.source.buffer.duration * (1.0 / this.voice.source.playbackRate.value)) * 1000 / 16.6);\n      } else {\n        duration = 0;\n      }\n      if (this.tempSettings.skip) {\n        return 1;\n      } else {\n        return duration;\n      }\n    };\n\n\n    /**\n    * Gets the duration of rendering the game-message.\n    *\n    * @method messageDuration\n    * @return {number} The duration in frames.\n     */\n\n    Component_MessageBehavior.prototype.messageDuration = function() {\n      var duration;\n      duration = this.object.textRenderer.calculateDuration();\n      if (this.tempSettings.skip) {\n        return 1;\n      } else {\n        return duration;\n      }\n    };\n\n\n    /**\n    * Gets the time between two messages in auto-read mode.\n    *\n    * @method autoMessageTime\n    * @return {number} The time in frames.\n     */\n\n    Component_MessageBehavior.prototype.autoMessageTime = function() {\n      if (this.tempSettings.skip) {\n        return 1;\n      } else {\n        return Math.max(Math.round(this.settings.autoMessage.time * Graphics.frameRate), this.voiceDuration() - this.messageDuration());\n      }\n    };\n\n\n    /**\n    * Gets the current message speed.\n    *\n    * @method messageSpeed\n    * @return {number} The message speed.\n     */\n\n    Component_MessageBehavior.prototype.messageSpeed = function() {\n      return Math.max(11 - Math.round(GameManager.settings.messageSpeed * 2.5), 0);\n    };\n\n\n    /**\n    * Checks if a mouse-button or key was pressed to continue with the message-rendering.\n    *\n    * @method actionTrigger\n    * @return {boolean} If true, the an action-button or action-key is pressed.\n     */\n\n    Component_MessageBehavior.prototype.actionTrigger = function() {\n      return (gs.ObjectManager.current.input && this.object.visible && this.object.dstRect.contains(Input.Mouse.x - this.object.origin.x, Input.Mouse.y - this.object.origin.y) && Input.Mouse.buttons[Input.Mouse.LEFT] === 2) || Input.trigger(Input.C);\n    };\n\n    Component_MessageBehavior.prototype.finish = function() {\n      if ((this.object.voice != null) && GameManager.settings.skipVoiceOnAction) {\n        return AudioManager.stopSound(this.object.voice.name);\n      }\n    };\n\n    Component_MessageBehavior.prototype.erase = function() {\n      var duration, fading;\n      fading = GameManager.tempSettings.messageFading;\n      duration = GameManager.tempSettings.skip ? 0 : fading.duration;\n      return this.object.animator.disappear(fading.animation, fading.easing, duration, (function(_this) {\n        return function() {\n          SceneManager.scene.currentCharacter = {\n            name: \"\"\n          };\n          _this.clear();\n          return _this.object.visible = false;\n        };\n      })(this));\n    };\n\n\n    /**\n    * FIXME: Deprecated? It is also a re-definition of gs.Component_Visual.updateOrigin.\n    *\n    * @method updateOrigin\n     */\n\n    Component_MessageBehavior.prototype.updateOrigin = function() {\n      var ox, oy, p;\n      ox = 0;\n      oy = 0;\n      if ((this.object.parent != null) && (this.object.parent.dstRect != null)) {\n        p = this.object.parent;\n        while ((p != null) && (p.dstRect != null)) {\n          ox += p.dstRect.x;\n          oy += p.dstRect.y;\n          p = p.parent;\n        }\n      }\n      this.object.origin.x = ox;\n      return this.object.origin.y = oy;\n    };\n\n\n    /**\n    * Updates the object. \n    *\n    * @method updateObject\n    * @private\n     */\n\n    Component_MessageBehavior.prototype.updateObject = function() {\n      this.updateOrigin();\n      if (this.tempSettings.skip && !this.waitingPreview) {\n        return this.object.textRenderer.isWaiting = false;\n      }\n    };\n\n\n    /**\n    * Updates the message.\n    *\n    * @method updateMessage\n    * @private\n     */\n\n    Component_MessageBehavior.prototype.updateMessage = function() {\n      var ref;\n      this.caretPosition = this.object.textRenderer.caretPosition;\n      if (this.tempSettings.skip && (this.settings.allowSkipUnreadMessages || ((ref = GameManager.globalData.messages[this.message]) != null ? ref.read : void 0))) {\n        this.object.textRenderer.drawImmediately = true;\n        this.object.textRenderer.waitAtEnd = this.waitingPreview;\n        return this.object.textRenderer.waitAtEndTime = 0;\n      } else {\n        this.updateSpeed();\n        return this.updateAutoMessage();\n      }\n    };\n\n\n    /**\n    * Updates the speed of the message. That depends on game-settings if a message\n    * is timed to its voice or not.\n    *\n    * @method updateSpeed\n    * @private\n     */\n\n    Component_MessageBehavior.prototype.updateSpeed = function() {\n      var voiceDuration;\n      voiceDuration = this.voiceDuration();\n      if (voiceDuration > 0 && this.settings.timeMessageToVoice) {\n        return this.object.textRenderer.speed = voiceDuration / this.message.length;\n      } else {\n        return this.object.textRenderer.speed = this.messageSpeed();\n      }\n    };\n\n\n    /**\n    * Update auto-read mode.\n    *\n    * @method updateAutoMessage\n    * @private\n     */\n\n    Component_MessageBehavior.prototype.updateAutoMessage = function() {\n      if (this.settings.autoMessage.stopOnAction && this.actionTrigger()) {\n        this.settings.autoMessage.enabled = false;\n      }\n      if (this.settings.autoMessage.enabled && !this.partial) {\n        if (this.object.textRenderer.waitAtEnd) {\n          this.object.textRenderer.isWaiting = false;\n        }\n        this.object.textRenderer.waitAtEndTime = this.autoMessageTime();\n        this.object.textRenderer.waitAtEnd = false;\n      } else if (this.autoMessageEnabled !== this.settings.autoMessage.enabled) {\n        this.object.textRenderer.waitAtEnd = true;\n        this.object.textRenderer.waitAtEndTime = 0;\n      }\n      return this.autoMessageEnabled = this.settings.autoMessage.enabled;\n    };\n\n\n    /*\n    * Updates the game message behavior\n    *\n    * @method update\n     */\n\n    Component_MessageBehavior.prototype.update = function() {\n      var ref, ref1, ref2, ref3, ref4, ref5;\n      this.object.needsUpdate = true;\n      this.updateObject();\n      this.updateMessage();\n      if (this.character !== this.object.character) {\n        gs.GlobalEventManager.emit(\"talkingEnded\", this, {\n          character: this.character\n        });\n        this.character = this.object.character;\n      }\n      if (this.object.textRenderer.isWaiting !== this.isWaiting || this.object.textRenderer.isRunning !== this.isRunning || (((ref = this.voice) != null ? ref.playing : void 0) && (!((ref1 = this.object.character) != null ? ref1.timeTalkingToVoiceVolume : void 0) || this.voice.averageVolume > this.object.character.talkingVolume)) !== this.isVoicePlaying) {\n        this.isWaiting = this.object.textRenderer.isWaiting;\n        this.isRunning = this.object.textRenderer.isRunning;\n        this.isVoicePlaying = ((ref2 = this.voice) != null ? ref2.playing : void 0) && (!((ref3 = this.object.character) != null ? ref3.timeTalkingToVoiceVolume : void 0) || this.voice.averageVolume > this.object.character.talkingVolume);\n        if (!this.tempSettings.skip) {\n          if ((ref4 = this.voice) != null ? ref4.playing : void 0) {\n            if (!this.isVoicePlaying) {\n              gs.GlobalEventManager.emit(\"talkingEnded\", this, {\n                character: this.object.character\n              });\n            } else {\n              gs.GlobalEventManager.emit(\"talkingStarted\", this, {\n                character: this.object.character\n              });\n            }\n          } else {\n            if (this.isWaiting) {\n              gs.GlobalEventManager.emit(\"talkingEnded\", this, {\n                character: this.object.character\n              });\n            } else if (this.isRunning) {\n              gs.GlobalEventManager.emit(\"talkingStarted\", this, {\n                character: this.object.character\n              });\n            }\n          }\n        }\n      }\n      if ((this.object.layoutRect != null) && (((ref5 = this.object.parent) != null ? ref5.dstRect : void 0) != null)) {\n        if (this.object.layoutRect.x) {\n          this.object.dstRect.x = this.object.layoutRect.x(this.object.parent.dstRect.width);\n        }\n        if (this.object.layoutRect.y) {\n          this.object.dstRect.y = this.object.layoutRect.y(this.object.parent.dstRect.height);\n        }\n        if (this.object.layoutRect.width) {\n          this.object.dstRect.width = this.object.layoutRect.width(this.object.parent.dstRect.width);\n        }\n        if (this.object.layoutRect.height) {\n          return this.object.dstRect.height = this.object.layoutRect.height(this.object.parent.dstRect.height);\n        }\n      }\n    };\n\n    return Component_MessageBehavior;\n\n  })(gs.Component);\n\n  vn.Component_MessageBehavior = Component_MessageBehavior;\n\n}).call(this);\n"
    },
    "summary": [
        "name",
        "type",
        "order"
    ],
    "externalItems": []
}