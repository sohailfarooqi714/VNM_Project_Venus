{
    "uid": "2F0E4A9D5A397344415A00371159005172AE",
    "isLoaded": true,
    "lastModificationTime": 0,
    "items": {
        "name": "Component_AnimationExecutor",
        "type": "game_script",
        "order": 13,
        "parentId": "01A95DA3K01E8A4CB4SBE17E790BCE1FC035",
        "folder": false,
        "scriptType": 0,
        "content": "# ===================================================================\n#\n#   Script: Component_AnimationExecutor\n#\n#   $$COPYRIGHT$$\n#\n# ===================================================================\nclass Component_AnimationExecutor extends gs.Component\n    ###*\n    * An animation-handler component allows a UI game object to execute\n    * a flow of animations. For more information about UI animations, see help-file.\n    * \n    * @module ui\n    * @class Component_AnimationExecutor\n    * @extends gs.Component\n    * @memberof ui\n    * @constructor\n    ###\n    constructor: ->\n        super\n        \n        ###*\n        * @property initialized\n        * @type boolean\n        * @protected\n        ###\n        @initialized = no\n        \n        ###*\n        * @property waitCounter\n        * @type number\n        * @protected\n        ###\n        @waitCounter = 0\n        \n        ###*\n        * @property pointer\n        * @type number\n        * @protected\n        ###\n        @pointer = 0\n        \n        @repeat = no\n        \n    ###*\n    * Initializes the animation-handler.\n    * \n    * @method setup\n    ###\n    setup: ->\n        @initialized = yes\n   \n        return null\n    \n    execute: (animation, callback) ->\n        @animation = animation\n        @callback = callback\n        @pointer = 0\n        @waitCounter = 0\n        \n    stop: ->\n        @animation = null\n        \n    ###*\n    * Starts the specified animation.\n    * \n    * @method startAnimation\n    * @param {Object} animation - The animation to start.\n    * @param {gs.Object_Base} target - The target object of the animation.\n    * @protected\n    ###    \n    startAnimation: (animation, duration, target, animator) ->\n        switch animation.type\n            when \"sound\"\n                AudioManager.playSound(animation.sound)\n            when \"maskTo\"\n                easing = if animation.easing then gs.Easings.fromString(animation.easing) else null\n                mask = { value: animation.value, graphic: { name: animation.mask }, vague: animation.vague, sourceType: 0 }\n                animator.maskTo(mask, duration, easing)\n            when \"changeImages\"\n                easing = if animation.easing then gs.Easings.fromString(animation.easing) else null\n                animator.changeImages(animation.images, duration, easing)\n            when \"playAnimation\"\n                record = RecordManager.animations[animation.animationId]\n                if record?\n                    animator.playAnimation(record)\n            when \"changeTo\"\n                value = ui.Component_BindingHandler.fieldValue(target, animation.value)\n                easing = if animation.easing then gs.Easings.fromString(animation.easing) else null\n                \n                animator.change(value, animation.field, duration, easing)\n            when \"blendTo\"\n                easing = if animation.easing then gs.Easings.fromString(animation.easing) else null\n                animator.blendTo(animation.opacity, duration, easing)\n            when \"colorTo\"\n                easing = if animation.easing then gs.Easings.fromString(animation.easing) else null\n                animator.colorTo(Color.fromArray(animation.color), duration, easing) \n            when \"tintTo\"\n                easing = if animation.easing then gs.Easings.fromString(animation.easing) else null\n                animator.tintTo(Tone.fromArray(animation.tone), duration, easing) \n            when \"moveTo\"\n                easing = if animation.easing then gs.Easings.fromString(animation.easing) else null\n                animator.moveTo(animation.position[0], animation.position[1], duration, easing)\n            when \"rotate\"\n                easing = if animation.easing then gs.Easings.fromString(animation.easing) else null\n                animator.rotate(0, animation.speed, duration, easing)\n            when \"rotateTo\"\n                easing = if animation.easing then gs.Easings.fromString(animation.easing) else null\n                animator.rotateTo(animation.angle, duration, easing)\n            when \"moveBy\"\n                easing = if animation.easing then gs.Easings.fromString(animation.easing) else null\n                animator.moveBy(@object.dstRect.x + animation.position[0], @object.dstRect.y + animation.position[1], duration, easing)\n            when \"zoomTo\"\n                easing = if animation.easing then gs.Easings.fromString(animation.easing) else null\n                animator.zoomTo(animation.zoom[0] / 100, animation.zoom[1] / 100, duration, easing)\n            when \"scroll\"\n                easing = if animation.easing then gs.Easings.fromString(animation.easing) else null\n                animator.scroll(animation.speed[0], animation.speed[1], 0, easing)\n            when \"move\"\n                easing = if animation.easing then gs.Easings.fromString(animation.easing) else null\n                animator.move(animation.speed[0], animation.speed[1], duration, easing)\n            when \"shake\"\n                easing = if animation.easing then gs.Easings.fromString(animation.easing) else null\n                return animator.shake({ x: animation.range[0], y: animation.range[1] }, animation.speed, duration, easing)\n            when \"appear\"\n                easing = if animation.easing then gs.Easings.fromString(animation.easing) else null\n                animator.appear(target.dstRect.x, target.dstRect.y, animation.animation, easing, duration)\n            when \"disappear\"\n                easing = if animation.easing then gs.Easings.fromString(animation.easing) else null\n                animator.disappear(animation.animation, easing, duration)\n        \n        if @object.visual\n            @object.visual.update() if duration == 0\n        else if @object.behavior\n            @object.behavior.update() if duration == 0\n\n    ###*\n    * Processes the animation flow.\n    * \n    * @method processAnimation\n    * @param {Object} descriptor - The animation-descriptor containing the animation-flow.\n    * @protected\n    ### \n    processAnimation: ->\n        while @animation and @pointer < @animation.flow.length\n            animation = @animation.flow[@pointer]\n            @pointer++\n            \n            if animation.executed then continue\n            \n            if(!@object.animator)\n                @object.animator = new gs.Component_Animator()\n                @object.addComponent(@object.animator)\n                \n            duration = ui.Component_FormulaHandler.fieldValue(@object, animation.duration || 0, yes)\n            @startAnimation(animation, duration, @object, @object.animator)\n            animation.executed = yes\n            \n            if animation.wait\n                if animation.type?\n                    @waitCounter = duration\n                else\n                    @waitCounter = animation.wait #ui.Component_FormulaHandler.fieldValue(@object, animation.wait || 0, yes)\n                break\n                \n        return null\n                \n    ###*\n    * Updates the animations.\n    * \n    * @method updateAnimations\n    ###\n    updateAnimation: ->\n        if @waitCounter > 0\n            @waitCounter--\n            return\n        \n        if @pointer >= @animation.flow.length\n            @pointer = 0\n            @callback?(@object)\n            if !@repeat\n                @animation = null\n            \n        @processAnimation(@animation) if @animation\n            \n        return null\n     \n    ###*\n    * Updates the animation-handler.\n    * \n    * @method update\n    ###   \n    update: ->\n        @object.needsUpdate = yes\n        @updateAnimation() if @animation\n        \nui.Component_AnimationExecutor = Component_AnimationExecutor",
        "compiledContent": "// Generated by CoffeeScript 1.12.7\n(function() {\n  var Component_AnimationExecutor,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  Component_AnimationExecutor = (function(superClass) {\n    extend(Component_AnimationExecutor, superClass);\n\n\n    /**\n    * An animation-handler component allows a UI game object to execute\n    * a flow of animations. For more information about UI animations, see help-file.\n    * \n    * @module ui\n    * @class Component_AnimationExecutor\n    * @extends gs.Component\n    * @memberof ui\n    * @constructor\n     */\n\n    function Component_AnimationExecutor() {\n      Component_AnimationExecutor.__super__.constructor.apply(this, arguments);\n\n      /**\n      * @property initialized\n      * @type boolean\n      * @protected\n       */\n      this.initialized = false;\n\n      /**\n      * @property waitCounter\n      * @type number\n      * @protected\n       */\n      this.waitCounter = 0;\n\n      /**\n      * @property pointer\n      * @type number\n      * @protected\n       */\n      this.pointer = 0;\n      this.repeat = false;\n    }\n\n\n    /**\n    * Initializes the animation-handler.\n    * \n    * @method setup\n     */\n\n    Component_AnimationExecutor.prototype.setup = function() {\n      this.initialized = true;\n      return null;\n    };\n\n    Component_AnimationExecutor.prototype.execute = function(animation, callback) {\n      this.animation = animation;\n      this.callback = callback;\n      this.pointer = 0;\n      return this.waitCounter = 0;\n    };\n\n    Component_AnimationExecutor.prototype.stop = function() {\n      return this.animation = null;\n    };\n\n\n    /**\n    * Starts the specified animation.\n    * \n    * @method startAnimation\n    * @param {Object} animation - The animation to start.\n    * @param {gs.Object_Base} target - The target object of the animation.\n    * @protected\n     */\n\n    Component_AnimationExecutor.prototype.startAnimation = function(animation, duration, target, animator) {\n      var easing, mask, record, value;\n      switch (animation.type) {\n        case \"sound\":\n          AudioManager.playSound(animation.sound);\n          break;\n        case \"maskTo\":\n          easing = animation.easing ? gs.Easings.fromString(animation.easing) : null;\n          mask = {\n            value: animation.value,\n            graphic: {\n              name: animation.mask\n            },\n            vague: animation.vague,\n            sourceType: 0\n          };\n          animator.maskTo(mask, duration, easing);\n          break;\n        case \"changeImages\":\n          easing = animation.easing ? gs.Easings.fromString(animation.easing) : null;\n          animator.changeImages(animation.images, duration, easing);\n          break;\n        case \"playAnimation\":\n          record = RecordManager.animations[animation.animationId];\n          if (record != null) {\n            animator.playAnimation(record);\n          }\n          break;\n        case \"changeTo\":\n          value = ui.Component_BindingHandler.fieldValue(target, animation.value);\n          easing = animation.easing ? gs.Easings.fromString(animation.easing) : null;\n          animator.change(value, animation.field, duration, easing);\n          break;\n        case \"blendTo\":\n          easing = animation.easing ? gs.Easings.fromString(animation.easing) : null;\n          animator.blendTo(animation.opacity, duration, easing);\n          break;\n        case \"colorTo\":\n          easing = animation.easing ? gs.Easings.fromString(animation.easing) : null;\n          animator.colorTo(Color.fromArray(animation.color), duration, easing);\n          break;\n        case \"tintTo\":\n          easing = animation.easing ? gs.Easings.fromString(animation.easing) : null;\n          animator.tintTo(Tone.fromArray(animation.tone), duration, easing);\n          break;\n        case \"moveTo\":\n          easing = animation.easing ? gs.Easings.fromString(animation.easing) : null;\n          animator.moveTo(animation.position[0], animation.position[1], duration, easing);\n          break;\n        case \"rotate\":\n          easing = animation.easing ? gs.Easings.fromString(animation.easing) : null;\n          animator.rotate(0, animation.speed, duration, easing);\n          break;\n        case \"rotateTo\":\n          easing = animation.easing ? gs.Easings.fromString(animation.easing) : null;\n          animator.rotateTo(animation.angle, duration, easing);\n          break;\n        case \"moveBy\":\n          easing = animation.easing ? gs.Easings.fromString(animation.easing) : null;\n          animator.moveBy(this.object.dstRect.x + animation.position[0], this.object.dstRect.y + animation.position[1], duration, easing);\n          break;\n        case \"zoomTo\":\n          easing = animation.easing ? gs.Easings.fromString(animation.easing) : null;\n          animator.zoomTo(animation.zoom[0] / 100, animation.zoom[1] / 100, duration, easing);\n          break;\n        case \"scroll\":\n          easing = animation.easing ? gs.Easings.fromString(animation.easing) : null;\n          animator.scroll(animation.speed[0], animation.speed[1], 0, easing);\n          break;\n        case \"move\":\n          easing = animation.easing ? gs.Easings.fromString(animation.easing) : null;\n          animator.move(animation.speed[0], animation.speed[1], duration, easing);\n          break;\n        case \"shake\":\n          easing = animation.easing ? gs.Easings.fromString(animation.easing) : null;\n          return animator.shake({\n            x: animation.range[0],\n            y: animation.range[1]\n          }, animation.speed, duration, easing);\n        case \"appear\":\n          easing = animation.easing ? gs.Easings.fromString(animation.easing) : null;\n          animator.appear(target.dstRect.x, target.dstRect.y, animation.animation, easing, duration);\n          break;\n        case \"disappear\":\n          easing = animation.easing ? gs.Easings.fromString(animation.easing) : null;\n          animator.disappear(animation.animation, easing, duration);\n      }\n      if (this.object.visual) {\n        if (duration === 0) {\n          return this.object.visual.update();\n        }\n      } else if (this.object.behavior) {\n        if (duration === 0) {\n          return this.object.behavior.update();\n        }\n      }\n    };\n\n\n    /**\n    * Processes the animation flow.\n    * \n    * @method processAnimation\n    * @param {Object} descriptor - The animation-descriptor containing the animation-flow.\n    * @protected\n     */\n\n    Component_AnimationExecutor.prototype.processAnimation = function() {\n      var animation, duration;\n      while (this.animation && this.pointer < this.animation.flow.length) {\n        animation = this.animation.flow[this.pointer];\n        this.pointer++;\n        if (animation.executed) {\n          continue;\n        }\n        if (!this.object.animator) {\n          this.object.animator = new gs.Component_Animator();\n          this.object.addComponent(this.object.animator);\n        }\n        duration = ui.Component_FormulaHandler.fieldValue(this.object, animation.duration || 0, true);\n        this.startAnimation(animation, duration, this.object, this.object.animator);\n        animation.executed = true;\n        if (animation.wait) {\n          if (animation.type != null) {\n            this.waitCounter = duration;\n          } else {\n            this.waitCounter = animation.wait;\n          }\n          break;\n        }\n      }\n      return null;\n    };\n\n\n    /**\n    * Updates the animations.\n    * \n    * @method updateAnimations\n     */\n\n    Component_AnimationExecutor.prototype.updateAnimation = function() {\n      if (this.waitCounter > 0) {\n        this.waitCounter--;\n        return;\n      }\n      if (this.pointer >= this.animation.flow.length) {\n        this.pointer = 0;\n        if (typeof this.callback === \"function\") {\n          this.callback(this.object);\n        }\n        if (!this.repeat) {\n          this.animation = null;\n        }\n      }\n      if (this.animation) {\n        this.processAnimation(this.animation);\n      }\n      return null;\n    };\n\n\n    /**\n    * Updates the animation-handler.\n    * \n    * @method update\n     */\n\n    Component_AnimationExecutor.prototype.update = function() {\n      this.object.needsUpdate = true;\n      if (this.animation) {\n        return this.updateAnimation();\n      }\n    };\n\n    return Component_AnimationExecutor;\n\n  })(gs.Component);\n\n  ui.Component_AnimationExecutor = Component_AnimationExecutor;\n\n}).call(this);\n"
    },
    "summary": [
        "name",
        "type"
    ],
    "externalItems": []
}