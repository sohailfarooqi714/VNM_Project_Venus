{
    "uid": "B2F84FFAKF97DA4149SAB47E8B89F3C10D30",
    "isLoaded": true,
    "lastModificationTime": 0,
    "items": {
        "name": "Component_Sprite",
        "type": "game_script",
        "order": 4,
        "parentId": "D3325122KACDEA4515SB731E37A42B9D779F",
        "folder": false,
        "content": "# ===================================================================\n#\n#   Script: Component\n#\n#   $$COPYRIGHT$$\n#\n# ===================================================================\nclass Component_Sprite extends gs.Component_Visual\n    ###*\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    * \n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n    ###\n    onDataBundleRestore: (data, context) ->\n        @setupEventHandlers()\n        \n    ###*\n    * A sprite component to display an object on screen. It can be managed or\n    * unmanaged. A managed sprite is automatically added to the graphics-system\n    * and rendered every frame until it gets disposed. An unmanaged sprite needs\n    * to be added and removed manually.\n    *\n    * @module gs\n    * @class Component_Sprite\n    * @extends gs.Component_Visual\n    * @memberof gs\n    * @constructor\n    * @param {boolean} managed - Indicates if the sprite is managed by the graphics system.\n    ###\n    constructor: (managed) ->\n        super()\n\n        ###*\n        * The native sprite object to display the game object on screen.\n        *\n        * @property sprite\n        * @type Sprite\n        * @protected\n        ###\n        @sprite = null\n        \n        ###*\n        * The name of the image to display.\n        *\n        * @property image\n        * @type string\n        * @protected\n        ###\n        @image = null\n        \n        ###*\n        * The name of the video to display.\n        *\n        * @property video\n        * @type string\n        * @protected\n        ###\n        @video = null\n        \n        ###*\n        * The name of the folder from where the image should be loaded.\n        *\n        * @property image\n        * @type string\n        * @protected\n        ###\n        @imageFolder = \"Graphics/Pictures\"\n        \n        ###*\n        * The visibility. If <b>false</b>, the sprite is not rendered.\n        *\n        * @property visible\n        * @type boolean\n        * @protected\n        ###\n        @visible = no\n\n        ###*\n        * Indicates if the image is loaded.\n        *\n        * @property imageLoaded\n        * @type boolean\n        * @protected\n        ###\n        @imageLoaded = no\n        \n        \n        \n    ###*\n    * Disposes the sprite. If the sprite is managed, it will be automatically\n    * removed from the graphics system and viewport.\n    * @method dispose\n    ###\n    dispose: -> \n        super\n        \n        if @sprite\n            @sprite.dispose()\n            \n            if @sprite.video\n                @sprite.video.stop()\n            \n            if not @sprite.managed\n                @sprite.viewport?.removeGraphicObject(@sprite)\n                Graphics.viewport?.removeGraphicObject(@sprite)\n \n    ###*\n    * Adds event-handlers for mouse/touch events\n    *\n    * @method setupEventHandlers\n    ### \n    setupEventHandlers: ->\n        @sprite.onIndexChange = =>\n            @object.rIndex = @sprite.index\n            @object.needsUpdate = yes\n    \n    ###*\n    * Setup the sprite. \n    * @method setupSprite\n    ### \n    setupSprite: ->\n        if !@sprite\n            @sprite = new gs.Sprite(Graphics.viewport, managed ? yes)\n            \n    ###*\n    * Setup the sprite component. This method is automatically called by the\n    * system.\n    * @method setup\n    ###\n    setup: ->\n        @isSetup = yes\n        @setupSprite()\n        @setupEventHandlers()\n        @update()\n        \n    \n    ###*\n    * Updates the source- and destination-rectangle of the game object so that\n    * the associated bitmap fits in. The imageHandling property controls how\n    * the rectangles are resized.\n    * @method updateRect\n    ###\n    updateRect: ->\n        if @sprite.bitmap?\n            if !@object.imageHandling\n                @object.srcRect = new Rect(0, 0, @sprite.bitmap.width, @sprite.bitmap.height)\n                if not @object.fixedSize\n                    @object.dstRect.width = @object.srcRect.width\n                    @object.dstRect.height = @object.srcRect.height\n            else if @object.imageHandling == 1\n                @object.srcRect = new Rect(0, 0, @sprite.bitmap.width, @sprite.bitmap.height / 2)\n                if not @object.fixedSize\n                    @object.dstRect.width = @object.srcRect.width\n                    @object.dstRect.height = @object.srcRect.height\n            else if @object.imageHandling == 2\n                if not @object.fixedSize\n                    @object.dstRect.width = @object.srcRect.width\n                    @object.dstRect.height = @object.srcRect.height\n                    \n    ###*\n    * Updates the bitmap object from the associated image name. The imageFolder\n    * property controls from which resource-folder the image will be loaded.\n    * @method updateBitmap\n    ###\n    updateBitmap: ->\n        @imageLoaded = no\n        @image = @object.image\n        \n        if @object.image.startsWith(\"data:\") || @object.image.startsWith(\"$\")\n            @sprite.bitmap = ResourceManager.getBitmap(@object.image)\n        else\n            @sprite.bitmap = ResourceManager.getBitmap(\"#{@object.imageFolder||@imageFolder}/#{@object.image}\")\n          \n        if @sprite.bitmap?  \n            if not @imageLoaded\n                @imageLoaded = @sprite.bitmap.loaded\n            else\n                delete @sprite.bitmap.loaded_\n            \n        @object.bitmap = @sprite.bitmap\n        \n    ###*\n    * Updates the video object from the associated video name. It also updates\n    * the video-rendering process.\n    * @method updateVideo\n    ###\n    updateVideo: ->\n        if @object.video != @videoName\n            @videoName = @object.video\n            @sprite.video = ResourceManager.getVideo(\"Movies/#{@object.video}\")\n            if @sprite.video?\n                if $PARAMS.preview?.settings.musicDisabled\n                    @sprite.video.volume = 0\n                @sprite.video.loop = @object.loop\n                @sprite.video.play()\n                \n                @object.srcRect = new Rect(0, 0, @sprite.video.width, @sprite.video.height)\n                if not @object.fixedSize\n                    @object.dstRect = new Rect(@object.dstRect.x, @object.dstRect.y, @sprite.video.width, @sprite.video.height)\n                \n        @sprite.video?.update()\n        \n    ###*\n    * Updates the image if the game object has the image-property set.\n    * @method updateImage\n    ###\n    updateImage: ->\n        if @object.image?\n            if @object.image != @image or (!@imageLoaded and @sprite.bitmap?.loaded)\n                @updateBitmap()\n                @updateRect()\n        else if @object.bitmap?    \n            @sprite.bitmap = @object.bitmap\n        else if @object.video? or @videoName != @object.video\n            @updateVideo()\n        else\n            @image = null\n            @object.bitmap = null\n            @sprite.bitmap = null\n            \n    ###*\n    * If the sprite is unmanaged, this method will update the visibility of the\n    * sprite. If the sprite leaves the viewport, it will be removed to save \n    * performance and automatically added back to the viewport if it enters\n    * the viewport.\n    * @method updateVisibility\n    ###\n    updateVisibility: ->\n        if !@sprite.managed\n            visible = Rect.intersect(@object.dstRect.x+@object.origin.x, @object.dstRect.y+@object.origin.y, @object.dstRect.width, @object.dstRect.height, \n                                     0, 0, Graphics.width, Graphics.height)\n            if visible and !@visible\n                (@object.viewport || Graphics.viewport).addGraphicObject(@sprite)\n                @visible = yes\n                \n            if !visible and @visible\n                (@object.viewport || Graphics.viewport).removeGraphicObject(@sprite)\n                @visible = no\n                \n      \n    ###*\n    * Updates the padding.\n    * @method updatePadding\n    ###\n    updatePadding: ->\n        if @object.padding?\n            @sprite.x += @object.padding.left\n            @sprite.y += @object.padding.top\n            @sprite.zoomX -= (@object.padding.left+@object.padding.right) / @object.srcRect.width\n            @sprite.zoomY -= (@object.padding.bottom+@object.padding.bottom) / @object.srcRect.height\n     \n    ###*\n    * Updates the sprite properties from the game object properties.\n    * @method updateProperties\n    ###\n    updateProperties: ->\n        @sprite.width = @object.dstRect.width\n        @sprite.height = @object.dstRect.height\n        @sprite.x = @object.dstRect.x \n        @sprite.y = @object.dstRect.y\n        @sprite.mask = @object.mask ? @mask\n        @sprite.angle = @object.angle || 0\n        @sprite.opacity = @object.opacity ? 255\n        @sprite.clipRect = @object.clipRect\n        @sprite.srcRect = @object.srcRect\n        @sprite.blendingMode = @object.blendMode || 0\n        @sprite.mirror = @object.mirror\n        @sprite.visible = @object.visible and (!@object.parent or !@object.parent.visible? or @object.parent.visible)\n        @sprite.ox = -@object.origin.x\n        @sprite.oy = -@object.origin.y\n        @sprite.z = (@object.zIndex || 0) + (if !@object.parent then 0 else @object.parent.zIndex || 0)\n        \n    ###*\n    * Updates the optional sprite properties from the game object properties.\n    * @method updateOptionalProperties\n    ###\n    updateOptionalProperties: ->\n        if @object.tone?\n            @sprite.tone = @object.tone\n        if @object.color?\n            @sprite.color = @object.color\n        if @object.viewport?\n            @sprite.viewport = @object.viewport\n        if @object.effects?\n            @sprite.effects = @object.effects\n        if @object.anchor?\n            @sprite.anchor.x = @object.anchor.x\n            @sprite.anchor.y = @object.anchor.y\n        if @object.positionAnchor?\n            @sprite.positionAnchor = @object.positionAnchor\n        if @object.zoom?\n            @sprite.zoomX = @object.zoom.x\n            @sprite.zoomY = @object.zoom.y\n        if @object.motionBlur?\n            @sprite.motionBlur = @object.motionBlur\n        \n    ###*\n    * Updates the sprite component by updating its visibility, image, padding and\n    * properties.\n    * @method update\n    ###\n    update: ->\n        super\n        \n        @setup() if not @isSetup\n        @updateVisibility()\n        @updateImage()\n        @updateProperties()\n        @updateOptionalProperties()\n        @updatePadding()\n        \n        @object.rIndex = @sprite.index\n        @sprite.update()\n        \n\n###*\n* Enumeration of appearance animations. \n*\n* @module gs\n* @class AnimationTypes\n* @static\n* @memberof gs\n###\nclass AnimationTypes\n    @initialize: ->    \n        ###*\n        * An object appears or disappears by moving into or out of the screen.\n        * @property MOVEMENT\n        * @type number\n        * @static\n        * @final\n        ###\n        @MOVEMENT = 0\n        ###*\n        * An object appears or disappears using alpha-blending.\n        * @property BLENDING\n        * @type number\n        * @static\n        * @final\n        ###\n        @BLENDING = 1\n        ###*\n        * An object appears or disappears using a mask-image.\n        * @property MASKING\n        * @type number\n        * @static\n        * @final\n        ###\n        @MASKING = 2\n\nAnimationTypes.initialize()    \ngs.AnimationTypes = AnimationTypes\ngs.Component_Sprite = Component_Sprite\n",
        "compiledContent": "// Generated by CoffeeScript 1.12.7\n(function() {\n  var AnimationTypes, Component_Sprite,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  Component_Sprite = (function(superClass) {\n    extend(Component_Sprite, superClass);\n\n\n    /**\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    * \n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n     */\n\n    Component_Sprite.prototype.onDataBundleRestore = function(data, context) {\n      return this.setupEventHandlers();\n    };\n\n\n    /**\n    * A sprite component to display an object on screen. It can be managed or\n    * unmanaged. A managed sprite is automatically added to the graphics-system\n    * and rendered every frame until it gets disposed. An unmanaged sprite needs\n    * to be added and removed manually.\n    *\n    * @module gs\n    * @class Component_Sprite\n    * @extends gs.Component_Visual\n    * @memberof gs\n    * @constructor\n    * @param {boolean} managed - Indicates if the sprite is managed by the graphics system.\n     */\n\n    function Component_Sprite(managed) {\n      Component_Sprite.__super__.constructor.call(this);\n\n      /**\n      * The native sprite object to display the game object on screen.\n      *\n      * @property sprite\n      * @type Sprite\n      * @protected\n       */\n      this.sprite = null;\n\n      /**\n      * The name of the image to display.\n      *\n      * @property image\n      * @type string\n      * @protected\n       */\n      this.image = null;\n\n      /**\n      * The name of the video to display.\n      *\n      * @property video\n      * @type string\n      * @protected\n       */\n      this.video = null;\n\n      /**\n      * The name of the folder from where the image should be loaded.\n      *\n      * @property image\n      * @type string\n      * @protected\n       */\n      this.imageFolder = \"Graphics/Pictures\";\n\n      /**\n      * The visibility. If <b>false</b>, the sprite is not rendered.\n      *\n      * @property visible\n      * @type boolean\n      * @protected\n       */\n      this.visible = false;\n\n      /**\n      * Indicates if the image is loaded.\n      *\n      * @property imageLoaded\n      * @type boolean\n      * @protected\n       */\n      this.imageLoaded = false;\n    }\n\n\n    /**\n    * Disposes the sprite. If the sprite is managed, it will be automatically\n    * removed from the graphics system and viewport.\n    * @method dispose\n     */\n\n    Component_Sprite.prototype.dispose = function() {\n      var ref, ref1;\n      Component_Sprite.__super__.dispose.apply(this, arguments);\n      if (this.sprite) {\n        this.sprite.dispose();\n        if (this.sprite.video) {\n          this.sprite.video.stop();\n        }\n        if (!this.sprite.managed) {\n          if ((ref = this.sprite.viewport) != null) {\n            ref.removeGraphicObject(this.sprite);\n          }\n          return (ref1 = Graphics.viewport) != null ? ref1.removeGraphicObject(this.sprite) : void 0;\n        }\n      }\n    };\n\n\n    /**\n    * Adds event-handlers for mouse/touch events\n    *\n    * @method setupEventHandlers\n     */\n\n    Component_Sprite.prototype.setupEventHandlers = function() {\n      return this.sprite.onIndexChange = (function(_this) {\n        return function() {\n          _this.object.rIndex = _this.sprite.index;\n          return _this.object.needsUpdate = true;\n        };\n      })(this);\n    };\n\n\n    /**\n    * Setup the sprite. \n    * @method setupSprite\n     */\n\n    Component_Sprite.prototype.setupSprite = function() {\n      if (!this.sprite) {\n        return this.sprite = new gs.Sprite(Graphics.viewport, typeof managed !== \"undefined\" && managed !== null ? managed : true);\n      }\n    };\n\n\n    /**\n    * Setup the sprite component. This method is automatically called by the\n    * system.\n    * @method setup\n     */\n\n    Component_Sprite.prototype.setup = function() {\n      this.isSetup = true;\n      this.setupSprite();\n      this.setupEventHandlers();\n      return this.update();\n    };\n\n\n    /**\n    * Updates the source- and destination-rectangle of the game object so that\n    * the associated bitmap fits in. The imageHandling property controls how\n    * the rectangles are resized.\n    * @method updateRect\n     */\n\n    Component_Sprite.prototype.updateRect = function() {\n      if (this.sprite.bitmap != null) {\n        if (!this.object.imageHandling) {\n          this.object.srcRect = new Rect(0, 0, this.sprite.bitmap.width, this.sprite.bitmap.height);\n          if (!this.object.fixedSize) {\n            this.object.dstRect.width = this.object.srcRect.width;\n            return this.object.dstRect.height = this.object.srcRect.height;\n          }\n        } else if (this.object.imageHandling === 1) {\n          this.object.srcRect = new Rect(0, 0, this.sprite.bitmap.width, this.sprite.bitmap.height / 2);\n          if (!this.object.fixedSize) {\n            this.object.dstRect.width = this.object.srcRect.width;\n            return this.object.dstRect.height = this.object.srcRect.height;\n          }\n        } else if (this.object.imageHandling === 2) {\n          if (!this.object.fixedSize) {\n            this.object.dstRect.width = this.object.srcRect.width;\n            return this.object.dstRect.height = this.object.srcRect.height;\n          }\n        }\n      }\n    };\n\n\n    /**\n    * Updates the bitmap object from the associated image name. The imageFolder\n    * property controls from which resource-folder the image will be loaded.\n    * @method updateBitmap\n     */\n\n    Component_Sprite.prototype.updateBitmap = function() {\n      this.imageLoaded = false;\n      this.image = this.object.image;\n      if (this.object.image.startsWith(\"data:\") || this.object.image.startsWith(\"$\")) {\n        this.sprite.bitmap = ResourceManager.getBitmap(this.object.image);\n      } else {\n        this.sprite.bitmap = ResourceManager.getBitmap((this.object.imageFolder || this.imageFolder) + \"/\" + this.object.image);\n      }\n      if (this.sprite.bitmap != null) {\n        if (!this.imageLoaded) {\n          this.imageLoaded = this.sprite.bitmap.loaded;\n        } else {\n          delete this.sprite.bitmap.loaded_;\n        }\n      }\n      return this.object.bitmap = this.sprite.bitmap;\n    };\n\n\n    /**\n    * Updates the video object from the associated video name. It also updates\n    * the video-rendering process.\n    * @method updateVideo\n     */\n\n    Component_Sprite.prototype.updateVideo = function() {\n      var ref, ref1;\n      if (this.object.video !== this.videoName) {\n        this.videoName = this.object.video;\n        this.sprite.video = ResourceManager.getVideo(\"Movies/\" + this.object.video);\n        if (this.sprite.video != null) {\n          if ((ref = $PARAMS.preview) != null ? ref.settings.musicDisabled : void 0) {\n            this.sprite.video.volume = 0;\n          }\n          this.sprite.video.loop = this.object.loop;\n          this.sprite.video.play();\n          this.object.srcRect = new Rect(0, 0, this.sprite.video.width, this.sprite.video.height);\n          if (!this.object.fixedSize) {\n            this.object.dstRect = new Rect(this.object.dstRect.x, this.object.dstRect.y, this.sprite.video.width, this.sprite.video.height);\n          }\n        }\n      }\n      return (ref1 = this.sprite.video) != null ? ref1.update() : void 0;\n    };\n\n\n    /**\n    * Updates the image if the game object has the image-property set.\n    * @method updateImage\n     */\n\n    Component_Sprite.prototype.updateImage = function() {\n      var ref;\n      if (this.object.image != null) {\n        if (this.object.image !== this.image || (!this.imageLoaded && ((ref = this.sprite.bitmap) != null ? ref.loaded : void 0))) {\n          this.updateBitmap();\n          return this.updateRect();\n        }\n      } else if (this.object.bitmap != null) {\n        return this.sprite.bitmap = this.object.bitmap;\n      } else if ((this.object.video != null) || this.videoName !== this.object.video) {\n        return this.updateVideo();\n      } else {\n        this.image = null;\n        this.object.bitmap = null;\n        return this.sprite.bitmap = null;\n      }\n    };\n\n\n    /**\n    * If the sprite is unmanaged, this method will update the visibility of the\n    * sprite. If the sprite leaves the viewport, it will be removed to save \n    * performance and automatically added back to the viewport if it enters\n    * the viewport.\n    * @method updateVisibility\n     */\n\n    Component_Sprite.prototype.updateVisibility = function() {\n      var visible;\n      if (!this.sprite.managed) {\n        visible = Rect.intersect(this.object.dstRect.x + this.object.origin.x, this.object.dstRect.y + this.object.origin.y, this.object.dstRect.width, this.object.dstRect.height, 0, 0, Graphics.width, Graphics.height);\n        if (visible && !this.visible) {\n          (this.object.viewport || Graphics.viewport).addGraphicObject(this.sprite);\n          this.visible = true;\n        }\n        if (!visible && this.visible) {\n          (this.object.viewport || Graphics.viewport).removeGraphicObject(this.sprite);\n          return this.visible = false;\n        }\n      }\n    };\n\n\n    /**\n    * Updates the padding.\n    * @method updatePadding\n     */\n\n    Component_Sprite.prototype.updatePadding = function() {\n      if (this.object.padding != null) {\n        this.sprite.x += this.object.padding.left;\n        this.sprite.y += this.object.padding.top;\n        this.sprite.zoomX -= (this.object.padding.left + this.object.padding.right) / this.object.srcRect.width;\n        return this.sprite.zoomY -= (this.object.padding.bottom + this.object.padding.bottom) / this.object.srcRect.height;\n      }\n    };\n\n\n    /**\n    * Updates the sprite properties from the game object properties.\n    * @method updateProperties\n     */\n\n    Component_Sprite.prototype.updateProperties = function() {\n      var ref, ref1;\n      this.sprite.width = this.object.dstRect.width;\n      this.sprite.height = this.object.dstRect.height;\n      this.sprite.x = this.object.dstRect.x;\n      this.sprite.y = this.object.dstRect.y;\n      this.sprite.mask = (ref = this.object.mask) != null ? ref : this.mask;\n      this.sprite.angle = this.object.angle || 0;\n      this.sprite.opacity = (ref1 = this.object.opacity) != null ? ref1 : 255;\n      this.sprite.clipRect = this.object.clipRect;\n      this.sprite.srcRect = this.object.srcRect;\n      this.sprite.blendingMode = this.object.blendMode || 0;\n      this.sprite.mirror = this.object.mirror;\n      this.sprite.visible = this.object.visible && (!this.object.parent || (this.object.parent.visible == null) || this.object.parent.visible);\n      this.sprite.ox = -this.object.origin.x;\n      this.sprite.oy = -this.object.origin.y;\n      return this.sprite.z = (this.object.zIndex || 0) + (!this.object.parent ? 0 : this.object.parent.zIndex || 0);\n    };\n\n\n    /**\n    * Updates the optional sprite properties from the game object properties.\n    * @method updateOptionalProperties\n     */\n\n    Component_Sprite.prototype.updateOptionalProperties = function() {\n      if (this.object.tone != null) {\n        this.sprite.tone = this.object.tone;\n      }\n      if (this.object.color != null) {\n        this.sprite.color = this.object.color;\n      }\n      if (this.object.viewport != null) {\n        this.sprite.viewport = this.object.viewport;\n      }\n      if (this.object.effects != null) {\n        this.sprite.effects = this.object.effects;\n      }\n      if (this.object.anchor != null) {\n        this.sprite.anchor.x = this.object.anchor.x;\n        this.sprite.anchor.y = this.object.anchor.y;\n      }\n      if (this.object.positionAnchor != null) {\n        this.sprite.positionAnchor = this.object.positionAnchor;\n      }\n      if (this.object.zoom != null) {\n        this.sprite.zoomX = this.object.zoom.x;\n        this.sprite.zoomY = this.object.zoom.y;\n      }\n      if (this.object.motionBlur != null) {\n        return this.sprite.motionBlur = this.object.motionBlur;\n      }\n    };\n\n\n    /**\n    * Updates the sprite component by updating its visibility, image, padding and\n    * properties.\n    * @method update\n     */\n\n    Component_Sprite.prototype.update = function() {\n      Component_Sprite.__super__.update.apply(this, arguments);\n      if (!this.isSetup) {\n        this.setup();\n      }\n      this.updateVisibility();\n      this.updateImage();\n      this.updateProperties();\n      this.updateOptionalProperties();\n      this.updatePadding();\n      this.object.rIndex = this.sprite.index;\n      return this.sprite.update();\n    };\n\n    return Component_Sprite;\n\n  })(gs.Component_Visual);\n\n\n  /**\n  * Enumeration of appearance animations. \n  *\n  * @module gs\n  * @class AnimationTypes\n  * @static\n  * @memberof gs\n   */\n\n  AnimationTypes = (function() {\n    function AnimationTypes() {}\n\n    AnimationTypes.initialize = function() {\n\n      /**\n      * An object appears or disappears by moving into or out of the screen.\n      * @property MOVEMENT\n      * @type number\n      * @static\n      * @final\n       */\n      this.MOVEMENT = 0;\n\n      /**\n      * An object appears or disappears using alpha-blending.\n      * @property BLENDING\n      * @type number\n      * @static\n      * @final\n       */\n      this.BLENDING = 1;\n\n      /**\n      * An object appears or disappears using a mask-image.\n      * @property MASKING\n      * @type number\n      * @static\n      * @final\n       */\n      return this.MASKING = 2;\n    };\n\n    return AnimationTypes;\n\n  })();\n\n  AnimationTypes.initialize();\n\n  gs.AnimationTypes = AnimationTypes;\n\n  gs.Component_Sprite = Component_Sprite;\n\n}).call(this);\n"
    },
    "summary": [
        "name",
        "type",
        "order"
    ],
    "externalItems": []
}