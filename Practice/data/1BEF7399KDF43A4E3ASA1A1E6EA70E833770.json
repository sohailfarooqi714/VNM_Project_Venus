{
    "uid": "1BEF7399KDF43A4E3ASA1A1E6EA70E833770",
    "isLoaded": true,
    "lastModificationTime": 1428415344176,
    "items": {
        "name": "VariableStore",
        "type": "game_script",
        "order": 6,
        "parentId": "2EC9F946K6417A4973S8308E368608E89B8B",
        "content": "# ===================================================================\n#\n#   Script: VariableStore\n#\n#   $$COPYRIGHT$$\n#\n# ===================================================================\nclass VariableStore\n    @objectCodecBlackList = [\"persistentNumbers\", \"persistentStrings\", \"persistentBooleans\", \"persistentLists\"]\n\n    ###*\n    * <p>A storage for different kind of game variables. The following scopes\n    * for variables exist:</p>\n    *\n    * - Local Variables -> Only valid for the current scene.\n    * - Global Variables -> Valid for the whole game but bound to a single save-game.\n    * - Persistent Variables -> Valid for the whole game indepentent from the save-games.\n    *\n    * <p>The following data-types exist:</p>\n    * - Strings -> Variables storing text data.\n    * - Numbers -> Variables storing integer number values.\n    * - Booleans -> Variables storing boolean values. (Called \"Switches\" for easier understanding)\n    * - Lists -> Variables storing multiple other variables. Lists can also contain Lists.\n    * <p>\n    * Local variables are stored by scene UID. For each scene UID a list of local variables is stored.</p>\n    *\n    * <p>Global and persistent variables are stored and a specific domain. A domain is just a unique name such\n    * as <i>com.example.game</i> for example. The default domain is an empty string. Domains are useful to avoid\n    * overlapping of variable numbers when sharing content with other users. </p>\n    *\n    * @module gs\n    * @class VariableStore\n    * @memberof gs\n    * @constructor\n    ###\n    constructor: () ->\n        ###*\n        * Current local variable context\n        * @property context\n        * @type Object\n        ###\n        @context = null\n\n        ###*\n        * Current domain for global and persistent variables. Each domain has its own\n        * variables. Please use <b>changeDomain</b> method to change the domain.\n        * @property domain\n        * @type Object\n        * @readOnly\n        ###\n        @domain = \"\"\n\n        ###*\n        * List of available domains for global and persistent variables.\n        * @property domains\n        * @type string[]\n        ###\n        @domains = [\"\"]\n\n        ###*\n        * The global number variables of the current domain.\n        * @property numbers\n        * @type number[]\n        ###\n        @numbers = null\n        ###*\n        * The global boolean variables of the current domain.\n        * @property booleans\n        * @type boolean[]\n        ###\n        @booleans = null\n        ###*\n        * The global string variables of the current domain.\n        * @property strings\n        * @type string[]\n        ###\n        @strings = null\n        ###*\n        * The global list variables of the current domain.\n        * @property lists\n        * @type Object[][]\n        ###\n        @lists = null\n\n        ###*\n        * The storage of all global variables by domain.\n        * @property globalVariablesByDomain\n        * @type Object[][]\n        ###\n        @globalVariablesByDomain = {}\n\n        ###*\n        * The storage of all persistent variables by domain.\n        * @property persistentVariablesByDomain\n        * @type Object[][]\n        ###\n        @persistentVariablesByDomain = {}\n\n        ###*\n        * The persistent number variables of the current domain.\n        * @property persistentNumbers\n        * @type number[]\n        ###\n        @persistentNumbers = []\n        ###*\n        * The persistent string variables of the current domain.\n        * @property persistentStrings\n        * @type string[]\n        ###\n        @persistentStrings = []\n        ###*\n        * The persistent boolean variables of the current domain.\n        * @property persistentBooleans\n        * @type boolean[]\n        ###\n        @persistentBooleans = []\n        ###*\n        * The persistent list variables of the current domain.\n        * @property persistentLists\n        * @type Object[][]\n        ###\n        @persistentLists = []\n        ###*\n        * The local number variables.\n        * @property localNumbers\n        * @type Object\n        ###\n        @localNumbers = {}\n        ###*\n        * The local string variables.\n        * @property localStrings\n        * @type Object\n        ###\n        @localStrings = {}\n        ###*\n        * The local boolean variables.\n        * @property localBooleans\n        * @type Object\n        ###\n        @localBooleans = {}\n        ###*\n        * The local list variables.\n        * @property localLists\n        * @type Object\n        ###\n        @localLists = {}\n        ###*\n        * @property tempNumbers\n        * @type number[]\n        ###\n        @tempNumbers = null\n        ###*\n        * @property tempStrings\n        * @type string[]\n        ###\n        @tempStrings = null\n        ###*\n        * @property localBooleans\n        * @type number[]\n        ###\n        @tempBooleans = null\n        ###*\n        * @property localLists\n        * @type Object[][]\n        ###\n        @tempLists = null\n\n    ###*\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    *\n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n    ###\n    onDataBundleRestore: (data, context) ->\n        domains = DataManager.getDocumentsByType(\"global_variables\").select (d) -> d.items.domain\n\n        for domain, i in domains\n            @numbersByDomain[domain] = @numbersByDomain[i]\n            @stringsByDomain[domain] = @stringsByDomain[i]\n            @booleansByDomain[domain] = @booleansByDomain[i]\n            @listsByDomain[domain] = @listsByDomain[i]\n\n        return null\n\n    setupGlobalDomains: () ->\n        @numbersByDomain = []\n        @stringsByDomain = []\n        @booleansByDomain = []\n        @listsByDomain = []\n\n        for domain, i in @domains\n            @numbersByDomain[i] = new Array(1000)\n            @numbersByDomain[domain] = @numbersByDomain[i]\n            @stringsByDomain[i] = new Array(1000)\n            @stringsByDomain[domain] = @stringsByDomain[i]\n            @booleansByDomain[i] = new Array(1000)\n            @booleansByDomain[domain] = @booleansByDomain[i]\n            @listsByDomain[i] = new Array(1000)\n            @listsByDomain[domain] = @listsByDomain[i]\n\n        @numbers = @numbersByDomain[0]\n        @strings = @stringsByDomain[0]\n        @booleans = @booleansByDomain[0]\n        @lists = @numbersByDomain[0]\n\n    setupPersistentDomains: (domains) ->\n        @persistentNumbersByDomain = {}\n        @persistentStringsByDomain = {}\n        @persistentBooleansByDomain = {}\n        @persistentListsByDomain = {}\n\n        for domain, i in @domains\n            @persistentNumbersByDomain[i] = new Array(10)\n            @persistentNumbersByDomain[domain] = @persistentNumbers[i]\n            @persistentStringsByDomain[i] = new Array(10)\n            @persistentStringsByDomain[domain] = @persistentStrings[i]\n            @persistentBooleansByDomain[i] = new Array(10)\n            @persistentBooleansByDomain[domain] = @persistentBooleans[i]\n            @persistentListsByDomain[i] = new Array(10)\n            @persistentListsByDomain[domain] = @persistentLists[i]\n\n        @persistentNumbers = @persistentNumbersByDomain[0]\n        @persistentStrings = @persistentStringsByDomain[0]\n        @persistentBooleans = @persistentBooleansByDomain[0]\n        @persistentLists = @persistentListsByDomain[0]\n\n    setupDomains: (domains) ->\n        @domains = domains\n        @setupGlobalDomains()\n        @setupPersistentDomains()\n\n\n    ###*\n    * Restores the variable store from a serialized store.\n    ###\n    restore: (store) ->\n        ignore = [\"domains\"]\n        for k of store\n            if !k.startsWith(\"persistent\") and ignore.indexOf(k) == -1\n                this[k] = store[k];\n\n    ###*\n    * Changes the current domain.\n    *\n    * @deprecated\n    * @method changeDomain\n    * @param {string} domain - The domain to change to.\n    ###\n    changeDomain: (domain) ->\n        @domain = domain\n        globalVariables = @globalVariablesByDomain[domain]\n        persistentVariables = @persistentVariablesByDomain[domain]\n\n        if !globalVariables\n            globalVariables = @globalVariablesByDomain[domain] = { numbers: new Array(500), strings: new Array(500), booleans: new Array(500), lists: new Array(500) }\n        if !persistentVariables\n            persistentVariables = @persistentVariablesByDomain[domain] = { numbers: new Array(500), strings: new Array(500), booleans: new Array(500), lists: new Array(500) }\n\n        @numbers = globalVariables.numbers\n        @strings = globalVariables.strings\n        @booleans = globalVariables.booleans\n        @lists = globalVariables.lists\n        @persistentNumbers = persistentVariables.numbers\n        @persistentBooleans = persistentVariables.booleans\n        @persistentStrings = persistentVariables.strings\n        @persistentLists = persistentVariables.lists\n\n    ###*\n    * Clears all global variables\n    *\n    * @method clearGlobalVariables\n    ###\n    clearAllGlobalVariables: ->\n        @setupGlobalDomains()\n        return\n\n        globalVariables = @globalVariablesByDomain[@domain]\n        @numbersByDomain = new Array(1000)\n        globalVariables.booleans = new Array(1000)\n        globalVariables.strings = new Array(1000)\n\n        @numbers = globalVariables.numbers\n        @strings = globalVariables.strings\n        @booleans = globalVariables.booleans\n\n    ###*\n    * Clears all local variables for all contexts/scenes/common-events.\n    *\n    * @method clearAllLocalVariables\n    ###\n    clearAllLocalVariables: ->\n        @localNumbers = {}\n        @localStrings = {}\n        @localBooleans = {}\n        @localLists = {}\n\n    ###*\n    * Clears specified variables.\n    *\n    * @method clearVariables\n    * @param {number[]} numbers - The number variables to clear.\n    * @param {string[]} strings - The string variables to clear.\n    * @param {boolean[]} booleans - The boolean variables to clear.\n    * @param {Array[]} lists - The list variables to clear.\n    * @param {number} type - Determines what kind of variables should be cleared.\n    * <ul>\n    * <li>0 = All</li>\n    * <li>1 = Switches / Booleans</li>\n    * <li>2 = Numbers</li>\n    * <li>3 = Texts</li>\n    * <li>4 = Lists</li>\n    * </ul>\n    * @param {Object} range - The variable id-range to clear. If <b>null</b> all specified variables are cleared.\n    ###\n    clearVariables: (numbers, strings, booleans, lists, type, range) ->\n        switch type\n            when 0 # All\n                numbers?.fill(0, range.start, range.end)\n                strings?.fill(\"\", range.start, range.end)\n                booleans?.fill(false, range.start, range.end)\n                lists?.fill([], range.start, range.end)\n            when 1 # Switch\n                booleans?.fill(false, range.start, range.end)\n            when 2 # Number\n                numbers?.fill(0, range.start, range.end)\n            when 3 # Text\n                strings?.fill(\"\", range.start, range.end)\n            when 4 # List\n                lists?.fill([], range.start, range.end)\n\n    ###*\n    * Clears all local variables for a specified context. If the context is not specified, all\n    * local variables for all contexts/scenes/common-events are cleared.\n    *\n    * @method clearLocalVariables\n    * @param {Object} context - The context to clear the local variables for. If <b>null</b>, all\n    * @param {number} type - Determines what kind of variables should be cleared.\n    * <ul>\n    * <li>0 = All</li>\n    * <li>1 = Switches / Booleans</li>\n    * <li>2 = Numbers</li>\n    * <li>3 = Texts</li>\n    * <li>4 = Lists</li>\n    * </ul>\n    * @param {Object} range - The variable id-range to clear. If <b>null</b> all variables are cleared.\n    ###\n    clearLocalVariables: (context, type, range) ->\n        if context?\n            ids = [context.id]\n        else\n            ids = Object.keys(@localNumbers)\n\n        if range?\n            range = start: range.start, end: range.end + 1\n        else\n            range = start: 0, end: null\n\n        for id in ids\n            @clearVariables(@localNumbers[id], @localStrings[id], @localBooleans[id], @localLists[id], type, range)\n\n    ###*\n    * Clears global variables.\n    *\n    * @method clearGlobalVariables\n    * @param {number} type - Determines what kind of variables should be cleared.\n    * <ul>\n    * <li>0 = All</li>\n    * <li>1 = Switches / Booleans</li>\n    * <li>2 = Numbers</li>\n    * <li>3 = Texts</li>\n    * <li>4 = Lists</li>\n    * </ul>\n    * @param {Object} range - The variable id-range to clear. If <b>null</b> all variables are cleared.\n    ###\n    clearGlobalVariables: (type, range) ->\n        if range?\n            range = start: range.start, end: range.end + 1\n        else\n            range = start: 0, end: null\n\n        @clearVariables(@numbers, @strings, @booleans, @lists, type, range)\n\n    ###*\n    * Clears persistent variables.\n    *\n    * @method clearPersistentVariables\n    * @param {number} type - Determines what kind of variables should be cleared.\n    * <ul>\n    * <li>0 = All</li>\n    * <li>1 = Switches / Booleans</li>\n    * <li>2 = Numbers</li>\n    * <li>3 = Texts</li>\n    * <li>4 = Lists</li>\n    * </ul>\n    * @param {Object} range - The variable id-range to clear. If <b>null</b> all variables are cleared.\n    ###\n    clearPersistentVariables: (type, range) ->\n        if range?\n            range = start: range.start, end: range.end + 1\n        else\n            range = start: 0, end: null\n\n        @clearVariables(@persistentNumbers, @persistentstrings, @persistentBooleans, @persistentLists, type, range)\n\n    ###*\n    * Initializes the variables. Should be called whenever the context changes. (Like after a scene change)\n    *\n    * @method setup\n    * @param {Object} context - The context(current scene) needed for local variables. Needs have at least an id-property.\n    ###\n    setup: (context) ->\n        @setupLocalVariables(context)\n        @setupTempVariables(context)\n\n\n    ###*\n    * Initializes the local variables for the specified context. Should be called on first time use.\n    *\n    * @method setupLocalVariables\n    * @param {Object} context - The context(current scene). Needs have at least an id-property.\n    ###\n    setupLocalVariables: (context) ->\n        @setupVariables(context, \"localNumbers\", 0)\n        @setupVariables(context, \"localStrings\", \"\")\n        @setupVariables(context, \"localBooleans\", no)\n        @setupVariables(context, \"localLists\", [])\n\n    ###*\n    * Initializes the specified kind of variables.\n    *\n    * @method setupVariables\n    * @param {Object} context - The context(current scene). Needs have at least an id-property.\n    * @param {string} property - The kind of variables (property-name).\n    * @param {Object} defaultValue - The default value for each variable.\n    ###\n    setupVariables: (context, property, defaultValue) ->\n        if not this[property][context.id]?\n            this[property][context.id] = []\n\n\n    ###*\n    * Initializes the current temp variables for the specified context. Should be called whenever the context changed.\n    *\n    * @method setupTempVariables\n    * @param {Object} context - The context(current scene). Needs have at least an id-property.\n    ###\n    setupTempVariables: (context) ->\n        @context = context\n        if !@localNumbers[context.id]\n            @setupLocalVariables(context)\n\n        @tempNumbers = @localNumbers[context.id]\n        @tempStrings = @localStrings[context.id]\n        @tempBooleans = @localBooleans[context.id]\n        @tempLists = @localLists[context.id]\n\n    clearTempVariables: (context) ->\n\n\n    ###*\n    * Gets the index for the variable with the specified name. If a variable with that\n    * name cannot be found, the index will be 0.\n    *\n    * @method indexOfTempVariable\n    * @param {string} name - The name of the variable to get the index for.\n    * @param {string} type - The type name: number, string, boolean or list.\n    * @param {number} scope - The variable scope: 0 = local, 1 = global, 2 = persistent.\n    * @param {string} domain - The variable domain to search in. If not specified, the default domain will be used.\n    ###\n    indexOfVariable: (name, type, scope, domain) ->\n        result = 0\n\n        switch scope\n            when 0 # Local\n                result = @indexOfTempVariable(name, type)\n            when 1 # Global\n                result = @indexOfGlobalVariable(name, type, domain)\n            when 2 # Persistent\n                result = @indexOfPersistentVariable(name, type, domain)\n\n        return result\n\n    ###*\n    * Gets the index for the local variable with the specified name. If a variable with that\n    * name cannot be found, the index will be 0.\n    *\n    * @method indexOfTempVariable\n    * @param {string} name - The name of the variable to get the index for.\n    * @param {string} type - The type name: number, string, boolean or list.\n    ###\n    indexOfTempVariable: (name, type) ->\n        result = 0\n\n        if @context?.owner\n            if @context.owner.sceneDocument\n                variable = @context.owner.sceneDocument.items[type + \"Variables\"].first (v) -> v.name == name\n                result = variable.index if variable?\n            else if @context.owner[type + \"Variables\"]\n                variable = @context.owner[type + \"Variables\"].first (v) -> v.name == name\n\n                if variable?\n                    result = variable.index\n                else\n                    console.warn(\"Variable referenced by name not found: \" + name +\"(local, \"+type+\")\")\n\n        return result\n\n    ###*\n    * Gets the index for the global variable with the specified name. If a variable with that\n    * name cannot be found, the index will be 0.\n    *\n    * @method indexOfTempVariable\n    * @param {string} name - The name of the variable to get the index for.\n    * @param {string} type - The type name: number, string, boolean or list.\n    * @param {string} domain - The variable domain to search in. If not specified, the default domain will be used.\n    ###\n    indexOfGlobalVariable: (name, type, domain) ->\n        result = 0\n        variables = DataManager.getDocumentsByType(\"global_variables\")\n        variablesDocument = variables.first (v) -> v.items.domain == domain\n        variablesDocument ?= variables[0]\n\n        if variablesDocument\n            variable = variablesDocument.items[type + \"s\"].first (v) -> v.name == name\n            if variable\n                result = variable.index\n            else\n                console.warn(\"Variable referenced by name not found: #{name} (persistent, #{type})\")\n\n        return result\n\n    ###*\n    * Gets the index for the persistent variable with the specified name. If a variable with that\n    * name cannot be found, the index will be 0.\n    *\n    * @method indexOfTempVariable\n    * @param {string} name - The name of the variable to get the index for.\n    * @param {string} type - The type name: number, string, boolean or list.\n    * @param {string} domain - The variable domain to search in. If not specified, the default domain will be used.\n    ###\n    indexOfPersistentVariable: (name, type, domain) ->\n        result = 0\n        variables = DataManager.getDocumentsByType(\"persistent_variables\")\n        variablesDocument = variables.first (v) -> v.items.domain == domain\n        variablesDocument ?= variables[0]\n\n        if variablesDocument\n            variable = variablesDocument.items[type + \"s\"].first (v) -> v.name == name\n            if variable?\n                result = variable.index\n            else\n                console.warn(\"Variable referenced by name not found: #{name} (persistent, #{type})\")\n\n        return result\n\n    ###*\n    * Sets the value of the number variable at the specified index.\n    *\n    * @method setNumberValueAtIndex\n    * @param {number} scope - The variable scope.\n    * @param {number} type - The variable's index.\n    * @param {number} value - The value to set.\n    ###\n    setNumberValueAtIndex: (scope, index, value, domain) ->\n        if scope == 2\n            @persistentNumbersByDomain[domain][index] = value\n        else if scope == 1\n            @numbersByDomain[domain||0][index] = value\n        else\n            @tempNumbers[index] = value\n\n    ###*\n    * Sets the value of a specified number variable.\n    *\n    * @method setNumberValueAtIndex\n    * @param {number} variable - The variable to set.\n    * @param {number} value - The value to set.\n    ###\n    setNumberValueTo: (variable, value) ->\n        if variable.scope == 2\n            @persistentNumbersByDomain[variable.domain||0][variable.index] = value\n        else if variable.scope == 1\n            @numbersByDomain[variable.domain||0][variable.index] = value\n        else\n            @tempNumbers[variable.index] = value\n\n    ###*\n    * Sets the value of a specified list variable.\n    *\n    * @method setListObjectTo\n    * @param {Object} variable - The variable to set.\n    * @param {Object} value - The value to set.\n    ###\n    setListObjectTo: (variable, value) ->\n        if variable.scope == 2\n            @persistentListsByDomain[variable.domain||0][variable.index] = value\n        else if variable.scope == 1\n            @listsByDomain[variable.domain||0][variable.index] = value\n        else\n            @tempLists[variable.index] = value\n\n\n    ###*\n    * Sets the value of a specified boolean variable.\n    *\n    * @method setBooleanValueTo\n    * @param {Object} variable - The variable to set.\n    * @param {boolean} value - The value to set.\n    ###\n    setBooleanValueTo: (variable, value) ->\n        if variable.scope == 2\n            @persistentBooleansByDomain[variable.domain][variable.index] = value\n        else if variable.scope == 1\n            @booleansByDomain[variable.domain][variable.index] = value\n        else\n            @tempBooleans[variable.index] = value\n\n    ###*\n    * Sets the value of the boolean variable at the specified index.\n    *\n    * @method setBooleanValueAtIndex\n    * @param {number} scope - The variable scope.\n    * @param {number} index - The variable's index.\n    * @param {boolean} value - The value to set.\n    ###\n    setBooleanValueAtIndex: (scope, index, value, domain) ->\n        if scope == 2\n            @persistentBooleansByDomain[domain][index] = value\n        else if scope == 1\n            @booleansByDomain[domain][index] = value\n        else\n            @tempBooleans[index] = value\n\n    ###*\n    * Sets the value of a specified string variable.\n    *\n    * @method setStringValueTo\n    * @param {Object} variable - The variable to set.\n    * @param {string} value - The value to set.\n    ###\n    setStringValueTo: (variable, value) ->\n        if variable.scope == 2\n            @persistentStringsByDomain[variable.domain][variable.index] = value\n        else if variable.scope == 1\n            @stringsByDomain[variable.domain][variable.index] = value\n        else\n            @tempStrings[variable.index] = value\n\n    ###*\n    * Sets the value of the string variable at the specified index.\n    *\n    * @method setStringValueAtIndex\n    * @param {number} scope - The variable scope.\n    * @param {number} index - The variable's index.\n    * @param {string} value - The value to set.\n    ###\n    setStringValueAtIndex: (scope, index, value, domain) ->\n        if scope == 2\n            @persistentStringsByDomain[domain][index] = value\n        else if scope == 1\n            @stringsByDomain[domain][index] = value\n        else\n            @tempStrings[index] = value\n\n    ###*\n    * Gets the value of a specified list variable.\n    *\n    * @method listObjectOf\n    * @param {Object} object - The list-variable/object to get the value from.\n    * @return {Object} The list-object.\n    ###\n    listObjectOf: (object) ->\n        result = 0\n        if object? and object.index?\n            if object.scope == 2\n                result = @persistentListsByDomain[object.domain][object.index]\n            else if object.scope == 1\n                result = @listsByDomain[object.domain][object.index]\n            else\n                result = @tempLists[object.index]\n        else\n            result = object\n\n        return result || []\n\n    ###*\n    * Gets the value of a number variable at the specified index.\n    *\n    * @method numberValueAtIndex\n    * @param {number} scope - The variable scope.\n    * @param {number} index - The variable's index.\n    * @return {Object} The number value of the variable.\n    ###\n    numberValueAtIndex: (scope, index, domain) ->\n        result = 0\n\n        if scope == 2\n            result = @persistentNumbersByDomain[domain][index]\n        else if scope == 1\n            result = @numbersByDomain[domain][index]\n        else\n            result = @tempNumbers[index]\n\n        return result\n\n    ###*\n    * Gets the value of a specified number variable.\n    *\n    * @method numberValueOf\n    * @param {Object} object - The variable to get the value from.\n    * @return {Object} The number value of the variable.\n    ###\n    numberValueOf: (object) ->\n        result = 0\n        if object? and object.index?\n            if object.scope == 2\n                result = @persistentNumbersByDomain[object.domain][object.index]\n            else if object.scope == 1\n                result = @numbersByDomain[object.domain][object.index]\n            else\n                result = @tempNumbers[object.index]\n\n        else\n            result = object\n\n        return result || 0\n\n    ###*\n    * Gets the value of a specified string variable.\n    *\n    * @method stringValueOf\n    * @param {Object} object - The variable to get the value from.\n    * @return {string} The string value of the variable.\n    ###\n    stringValueOf: (object) ->\n        result = \"\"\n        if object? and object.index?\n            if object.scope == 2\n                result = @persistentStringsByDomain[object.domain][object.index]\n            else if object.scope == 1\n                result = @stringsByDomain[object.domain][object.index]\n            else\n                result = @tempStrings[object.index]\n        else\n            result = object\n\n        return result || \"\"\n\n    ###*\n    * Gets the value of a string variable at the specified index.\n    *\n    * @method stringValueAtIndex\n    * @param {number} scope - The variable scope.\n    * @param {number} index - The variable's index.\n    * @return {string} The string value of the variable.\n    ###\n    stringValueAtIndex: (scope, index, domain) ->\n        result = \"\"\n\n        if scope == 2\n            result = @persistentStringsByDomain[domain][index]\n        else if scope == 1\n            result = @stringsByDomain[domain][index]\n        else\n            result = @tempStrings[index]\n\n        return result || \"\"\n\n    ###*\n    * Gets the value of a specified boolean variable.\n    *\n    * @method booleanValueOf\n    * @param {Object} object - The variable to get the value from.\n    * @return {Object} The boolean value of the variable.\n    ###\n    booleanValueOf: (object) ->\n        result = no\n        if object? and object.index?\n            if object.scope == 2\n                result = @persistentBooleansByDomain[object.domain][object.index] || no\n            else if object.scope == 1\n                result = @booleansByDomain[object.domain][object.index] || no\n            else\n                result = @tempBooleans[object.index] || no\n\n        else\n            result = if object then true else false\n\n        return result\n\n    ###*\n    * Gets the value of a boolean variable at the specified index.\n    *\n    * @method booleanValueAtIndex\n    * @param {number} scope - The variable scope.\n    * @param {number} index - The variable's index.\n    * @return {boolean} The boolean value of the variable.\n    ###\n    booleanValueAtIndex: (scope, index, domain) ->\n        result = no\n\n        if scope == 2\n            result = @persistenBooleansByDomain[domain][index] || no\n        else if scope == 1\n            result = @booleansByDomain[domain][index] || no\n        else\n            result = @tempBooleans[index] || no\n\n        return result\n\ngs.VariableStore = VariableStore",
        "compiledContent": "// Generated by CoffeeScript 1.12.7\n(function() {\n  var VariableStore;\n\n  VariableStore = (function() {\n    VariableStore.objectCodecBlackList = [\"persistentNumbers\", \"persistentStrings\", \"persistentBooleans\", \"persistentLists\"];\n\n\n    /**\n    * <p>A storage for different kind of game variables. The following scopes\n    * for variables exist:</p>\n    *\n    * - Local Variables -> Only valid for the current scene.\n    * - Global Variables -> Valid for the whole game but bound to a single save-game.\n    * - Persistent Variables -> Valid for the whole game indepentent from the save-games.\n    *\n    * <p>The following data-types exist:</p>\n    * - Strings -> Variables storing text data.\n    * - Numbers -> Variables storing integer number values.\n    * - Booleans -> Variables storing boolean values. (Called \"Switches\" for easier understanding)\n    * - Lists -> Variables storing multiple other variables. Lists can also contain Lists.\n    * <p>\n    * Local variables are stored by scene UID. For each scene UID a list of local variables is stored.</p>\n    *\n    * <p>Global and persistent variables are stored and a specific domain. A domain is just a unique name such\n    * as <i>com.example.game</i> for example. The default domain is an empty string. Domains are useful to avoid\n    * overlapping of variable numbers when sharing content with other users. </p>\n    *\n    * @module gs\n    * @class VariableStore\n    * @memberof gs\n    * @constructor\n     */\n\n    function VariableStore() {\n\n      /**\n      * Current local variable context\n      * @property context\n      * @type Object\n       */\n      this.context = null;\n\n      /**\n      * Current domain for global and persistent variables. Each domain has its own\n      * variables. Please use <b>changeDomain</b> method to change the domain.\n      * @property domain\n      * @type Object\n      * @readOnly\n       */\n      this.domain = \"\";\n\n      /**\n      * List of available domains for global and persistent variables.\n      * @property domains\n      * @type string[]\n       */\n      this.domains = [\"\"];\n\n      /**\n      * The global number variables of the current domain.\n      * @property numbers\n      * @type number[]\n       */\n      this.numbers = null;\n\n      /**\n      * The global boolean variables of the current domain.\n      * @property booleans\n      * @type boolean[]\n       */\n      this.booleans = null;\n\n      /**\n      * The global string variables of the current domain.\n      * @property strings\n      * @type string[]\n       */\n      this.strings = null;\n\n      /**\n      * The global list variables of the current domain.\n      * @property lists\n      * @type Object[][]\n       */\n      this.lists = null;\n\n      /**\n      * The storage of all global variables by domain.\n      * @property globalVariablesByDomain\n      * @type Object[][]\n       */\n      this.globalVariablesByDomain = {};\n\n      /**\n      * The storage of all persistent variables by domain.\n      * @property persistentVariablesByDomain\n      * @type Object[][]\n       */\n      this.persistentVariablesByDomain = {};\n\n      /**\n      * The persistent number variables of the current domain.\n      * @property persistentNumbers\n      * @type number[]\n       */\n      this.persistentNumbers = [];\n\n      /**\n      * The persistent string variables of the current domain.\n      * @property persistentStrings\n      * @type string[]\n       */\n      this.persistentStrings = [];\n\n      /**\n      * The persistent boolean variables of the current domain.\n      * @property persistentBooleans\n      * @type boolean[]\n       */\n      this.persistentBooleans = [];\n\n      /**\n      * The persistent list variables of the current domain.\n      * @property persistentLists\n      * @type Object[][]\n       */\n      this.persistentLists = [];\n\n      /**\n      * The local number variables.\n      * @property localNumbers\n      * @type Object\n       */\n      this.localNumbers = {};\n\n      /**\n      * The local string variables.\n      * @property localStrings\n      * @type Object\n       */\n      this.localStrings = {};\n\n      /**\n      * The local boolean variables.\n      * @property localBooleans\n      * @type Object\n       */\n      this.localBooleans = {};\n\n      /**\n      * The local list variables.\n      * @property localLists\n      * @type Object\n       */\n      this.localLists = {};\n\n      /**\n      * @property tempNumbers\n      * @type number[]\n       */\n      this.tempNumbers = null;\n\n      /**\n      * @property tempStrings\n      * @type string[]\n       */\n      this.tempStrings = null;\n\n      /**\n      * @property localBooleans\n      * @type number[]\n       */\n      this.tempBooleans = null;\n\n      /**\n      * @property localLists\n      * @type Object[][]\n       */\n      this.tempLists = null;\n    }\n\n\n    /**\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    *\n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n     */\n\n    VariableStore.prototype.onDataBundleRestore = function(data, context) {\n      var domain, domains, i, j, len;\n      domains = DataManager.getDocumentsByType(\"global_variables\").select(function(d) {\n        return d.items.domain;\n      });\n      for (i = j = 0, len = domains.length; j < len; i = ++j) {\n        domain = domains[i];\n        this.numbersByDomain[domain] = this.numbersByDomain[i];\n        this.stringsByDomain[domain] = this.stringsByDomain[i];\n        this.booleansByDomain[domain] = this.booleansByDomain[i];\n        this.listsByDomain[domain] = this.listsByDomain[i];\n      }\n      return null;\n    };\n\n    VariableStore.prototype.setupGlobalDomains = function() {\n      var domain, i, j, len, ref;\n      this.numbersByDomain = [];\n      this.stringsByDomain = [];\n      this.booleansByDomain = [];\n      this.listsByDomain = [];\n      ref = this.domains;\n      for (i = j = 0, len = ref.length; j < len; i = ++j) {\n        domain = ref[i];\n        this.numbersByDomain[i] = new Array(1000);\n        this.numbersByDomain[domain] = this.numbersByDomain[i];\n        this.stringsByDomain[i] = new Array(1000);\n        this.stringsByDomain[domain] = this.stringsByDomain[i];\n        this.booleansByDomain[i] = new Array(1000);\n        this.booleansByDomain[domain] = this.booleansByDomain[i];\n        this.listsByDomain[i] = new Array(1000);\n        this.listsByDomain[domain] = this.listsByDomain[i];\n      }\n      this.numbers = this.numbersByDomain[0];\n      this.strings = this.stringsByDomain[0];\n      this.booleans = this.booleansByDomain[0];\n      return this.lists = this.numbersByDomain[0];\n    };\n\n    VariableStore.prototype.setupPersistentDomains = function(domains) {\n      var domain, i, j, len, ref;\n      this.persistentNumbersByDomain = {};\n      this.persistentStringsByDomain = {};\n      this.persistentBooleansByDomain = {};\n      this.persistentListsByDomain = {};\n      ref = this.domains;\n      for (i = j = 0, len = ref.length; j < len; i = ++j) {\n        domain = ref[i];\n        this.persistentNumbersByDomain[i] = new Array(10);\n        this.persistentNumbersByDomain[domain] = this.persistentNumbers[i];\n        this.persistentStringsByDomain[i] = new Array(10);\n        this.persistentStringsByDomain[domain] = this.persistentStrings[i];\n        this.persistentBooleansByDomain[i] = new Array(10);\n        this.persistentBooleansByDomain[domain] = this.persistentBooleans[i];\n        this.persistentListsByDomain[i] = new Array(10);\n        this.persistentListsByDomain[domain] = this.persistentLists[i];\n      }\n      this.persistentNumbers = this.persistentNumbersByDomain[0];\n      this.persistentStrings = this.persistentStringsByDomain[0];\n      this.persistentBooleans = this.persistentBooleansByDomain[0];\n      return this.persistentLists = this.persistentListsByDomain[0];\n    };\n\n    VariableStore.prototype.setupDomains = function(domains) {\n      this.domains = domains;\n      this.setupGlobalDomains();\n      return this.setupPersistentDomains();\n    };\n\n\n    /**\n    * Restores the variable store from a serialized store.\n     */\n\n    VariableStore.prototype.restore = function(store) {\n      var ignore, k, results;\n      ignore = [\"domains\"];\n      results = [];\n      for (k in store) {\n        if (!k.startsWith(\"persistent\") && ignore.indexOf(k) === -1) {\n          results.push(this[k] = store[k]);\n        } else {\n          results.push(void 0);\n        }\n      }\n      return results;\n    };\n\n\n    /**\n    * Changes the current domain.\n    *\n    * @deprecated\n    * @method changeDomain\n    * @param {string} domain - The domain to change to.\n     */\n\n    VariableStore.prototype.changeDomain = function(domain) {\n      var globalVariables, persistentVariables;\n      this.domain = domain;\n      globalVariables = this.globalVariablesByDomain[domain];\n      persistentVariables = this.persistentVariablesByDomain[domain];\n      if (!globalVariables) {\n        globalVariables = this.globalVariablesByDomain[domain] = {\n          numbers: new Array(500),\n          strings: new Array(500),\n          booleans: new Array(500),\n          lists: new Array(500)\n        };\n      }\n      if (!persistentVariables) {\n        persistentVariables = this.persistentVariablesByDomain[domain] = {\n          numbers: new Array(500),\n          strings: new Array(500),\n          booleans: new Array(500),\n          lists: new Array(500)\n        };\n      }\n      this.numbers = globalVariables.numbers;\n      this.strings = globalVariables.strings;\n      this.booleans = globalVariables.booleans;\n      this.lists = globalVariables.lists;\n      this.persistentNumbers = persistentVariables.numbers;\n      this.persistentBooleans = persistentVariables.booleans;\n      this.persistentStrings = persistentVariables.strings;\n      return this.persistentLists = persistentVariables.lists;\n    };\n\n\n    /**\n    * Clears all global variables\n    *\n    * @method clearGlobalVariables\n     */\n\n    VariableStore.prototype.clearAllGlobalVariables = function() {\n      var globalVariables;\n      this.setupGlobalDomains();\n      return;\n      globalVariables = this.globalVariablesByDomain[this.domain];\n      this.numbersByDomain = new Array(1000);\n      globalVariables.booleans = new Array(1000);\n      globalVariables.strings = new Array(1000);\n      this.numbers = globalVariables.numbers;\n      this.strings = globalVariables.strings;\n      return this.booleans = globalVariables.booleans;\n    };\n\n\n    /**\n    * Clears all local variables for all contexts/scenes/common-events.\n    *\n    * @method clearAllLocalVariables\n     */\n\n    VariableStore.prototype.clearAllLocalVariables = function() {\n      this.localNumbers = {};\n      this.localStrings = {};\n      this.localBooleans = {};\n      return this.localLists = {};\n    };\n\n\n    /**\n    * Clears specified variables.\n    *\n    * @method clearVariables\n    * @param {number[]} numbers - The number variables to clear.\n    * @param {string[]} strings - The string variables to clear.\n    * @param {boolean[]} booleans - The boolean variables to clear.\n    * @param {Array[]} lists - The list variables to clear.\n    * @param {number} type - Determines what kind of variables should be cleared.\n    * <ul>\n    * <li>0 = All</li>\n    * <li>1 = Switches / Booleans</li>\n    * <li>2 = Numbers</li>\n    * <li>3 = Texts</li>\n    * <li>4 = Lists</li>\n    * </ul>\n    * @param {Object} range - The variable id-range to clear. If <b>null</b> all specified variables are cleared.\n     */\n\n    VariableStore.prototype.clearVariables = function(numbers, strings, booleans, lists, type, range) {\n      switch (type) {\n        case 0:\n          if (numbers != null) {\n            numbers.fill(0, range.start, range.end);\n          }\n          if (strings != null) {\n            strings.fill(\"\", range.start, range.end);\n          }\n          if (booleans != null) {\n            booleans.fill(false, range.start, range.end);\n          }\n          return lists != null ? lists.fill([], range.start, range.end) : void 0;\n        case 1:\n          return booleans != null ? booleans.fill(false, range.start, range.end) : void 0;\n        case 2:\n          return numbers != null ? numbers.fill(0, range.start, range.end) : void 0;\n        case 3:\n          return strings != null ? strings.fill(\"\", range.start, range.end) : void 0;\n        case 4:\n          return lists != null ? lists.fill([], range.start, range.end) : void 0;\n      }\n    };\n\n\n    /**\n    * Clears all local variables for a specified context. If the context is not specified, all\n    * local variables for all contexts/scenes/common-events are cleared.\n    *\n    * @method clearLocalVariables\n    * @param {Object} context - The context to clear the local variables for. If <b>null</b>, all\n    * @param {number} type - Determines what kind of variables should be cleared.\n    * <ul>\n    * <li>0 = All</li>\n    * <li>1 = Switches / Booleans</li>\n    * <li>2 = Numbers</li>\n    * <li>3 = Texts</li>\n    * <li>4 = Lists</li>\n    * </ul>\n    * @param {Object} range - The variable id-range to clear. If <b>null</b> all variables are cleared.\n     */\n\n    VariableStore.prototype.clearLocalVariables = function(context, type, range) {\n      var id, ids, j, len, results;\n      if (context != null) {\n        ids = [context.id];\n      } else {\n        ids = Object.keys(this.localNumbers);\n      }\n      if (range != null) {\n        range = {\n          start: range.start,\n          end: range.end + 1\n        };\n      } else {\n        range = {\n          start: 0,\n          end: null\n        };\n      }\n      results = [];\n      for (j = 0, len = ids.length; j < len; j++) {\n        id = ids[j];\n        results.push(this.clearVariables(this.localNumbers[id], this.localStrings[id], this.localBooleans[id], this.localLists[id], type, range));\n      }\n      return results;\n    };\n\n\n    /**\n    * Clears global variables.\n    *\n    * @method clearGlobalVariables\n    * @param {number} type - Determines what kind of variables should be cleared.\n    * <ul>\n    * <li>0 = All</li>\n    * <li>1 = Switches / Booleans</li>\n    * <li>2 = Numbers</li>\n    * <li>3 = Texts</li>\n    * <li>4 = Lists</li>\n    * </ul>\n    * @param {Object} range - The variable id-range to clear. If <b>null</b> all variables are cleared.\n     */\n\n    VariableStore.prototype.clearGlobalVariables = function(type, range) {\n      if (range != null) {\n        range = {\n          start: range.start,\n          end: range.end + 1\n        };\n      } else {\n        range = {\n          start: 0,\n          end: null\n        };\n      }\n      return this.clearVariables(this.numbers, this.strings, this.booleans, this.lists, type, range);\n    };\n\n\n    /**\n    * Clears persistent variables.\n    *\n    * @method clearPersistentVariables\n    * @param {number} type - Determines what kind of variables should be cleared.\n    * <ul>\n    * <li>0 = All</li>\n    * <li>1 = Switches / Booleans</li>\n    * <li>2 = Numbers</li>\n    * <li>3 = Texts</li>\n    * <li>4 = Lists</li>\n    * </ul>\n    * @param {Object} range - The variable id-range to clear. If <b>null</b> all variables are cleared.\n     */\n\n    VariableStore.prototype.clearPersistentVariables = function(type, range) {\n      if (range != null) {\n        range = {\n          start: range.start,\n          end: range.end + 1\n        };\n      } else {\n        range = {\n          start: 0,\n          end: null\n        };\n      }\n      return this.clearVariables(this.persistentNumbers, this.persistentstrings, this.persistentBooleans, this.persistentLists, type, range);\n    };\n\n\n    /**\n    * Initializes the variables. Should be called whenever the context changes. (Like after a scene change)\n    *\n    * @method setup\n    * @param {Object} context - The context(current scene) needed for local variables. Needs have at least an id-property.\n     */\n\n    VariableStore.prototype.setup = function(context) {\n      this.setupLocalVariables(context);\n      return this.setupTempVariables(context);\n    };\n\n\n    /**\n    * Initializes the local variables for the specified context. Should be called on first time use.\n    *\n    * @method setupLocalVariables\n    * @param {Object} context - The context(current scene). Needs have at least an id-property.\n     */\n\n    VariableStore.prototype.setupLocalVariables = function(context) {\n      this.setupVariables(context, \"localNumbers\", 0);\n      this.setupVariables(context, \"localStrings\", \"\");\n      this.setupVariables(context, \"localBooleans\", false);\n      return this.setupVariables(context, \"localLists\", []);\n    };\n\n\n    /**\n    * Initializes the specified kind of variables.\n    *\n    * @method setupVariables\n    * @param {Object} context - The context(current scene). Needs have at least an id-property.\n    * @param {string} property - The kind of variables (property-name).\n    * @param {Object} defaultValue - The default value for each variable.\n     */\n\n    VariableStore.prototype.setupVariables = function(context, property, defaultValue) {\n      if (this[property][context.id] == null) {\n        return this[property][context.id] = [];\n      }\n    };\n\n\n    /**\n    * Initializes the current temp variables for the specified context. Should be called whenever the context changed.\n    *\n    * @method setupTempVariables\n    * @param {Object} context - The context(current scene). Needs have at least an id-property.\n     */\n\n    VariableStore.prototype.setupTempVariables = function(context) {\n      this.context = context;\n      if (!this.localNumbers[context.id]) {\n        this.setupLocalVariables(context);\n      }\n      this.tempNumbers = this.localNumbers[context.id];\n      this.tempStrings = this.localStrings[context.id];\n      this.tempBooleans = this.localBooleans[context.id];\n      return this.tempLists = this.localLists[context.id];\n    };\n\n    VariableStore.prototype.clearTempVariables = function(context) {};\n\n\n    /**\n    * Gets the index for the variable with the specified name. If a variable with that\n    * name cannot be found, the index will be 0.\n    *\n    * @method indexOfTempVariable\n    * @param {string} name - The name of the variable to get the index for.\n    * @param {string} type - The type name: number, string, boolean or list.\n    * @param {number} scope - The variable scope: 0 = local, 1 = global, 2 = persistent.\n    * @param {string} domain - The variable domain to search in. If not specified, the default domain will be used.\n     */\n\n    VariableStore.prototype.indexOfVariable = function(name, type, scope, domain) {\n      var result;\n      result = 0;\n      switch (scope) {\n        case 0:\n          result = this.indexOfTempVariable(name, type);\n          break;\n        case 1:\n          result = this.indexOfGlobalVariable(name, type, domain);\n          break;\n        case 2:\n          result = this.indexOfPersistentVariable(name, type, domain);\n      }\n      return result;\n    };\n\n\n    /**\n    * Gets the index for the local variable with the specified name. If a variable with that\n    * name cannot be found, the index will be 0.\n    *\n    * @method indexOfTempVariable\n    * @param {string} name - The name of the variable to get the index for.\n    * @param {string} type - The type name: number, string, boolean or list.\n     */\n\n    VariableStore.prototype.indexOfTempVariable = function(name, type) {\n      var ref, result, variable;\n      result = 0;\n      if ((ref = this.context) != null ? ref.owner : void 0) {\n        if (this.context.owner.sceneDocument) {\n          variable = this.context.owner.sceneDocument.items[type + \"Variables\"].first(function(v) {\n            return v.name === name;\n          });\n          if (variable != null) {\n            result = variable.index;\n          }\n        } else if (this.context.owner[type + \"Variables\"]) {\n          variable = this.context.owner[type + \"Variables\"].first(function(v) {\n            return v.name === name;\n          });\n          if (variable != null) {\n            result = variable.index;\n          } else {\n            console.warn(\"Variable referenced by name not found: \" + name(+\"(local, \" + type + \")\"));\n          }\n        }\n      }\n      return result;\n    };\n\n\n    /**\n    * Gets the index for the global variable with the specified name. If a variable with that\n    * name cannot be found, the index will be 0.\n    *\n    * @method indexOfTempVariable\n    * @param {string} name - The name of the variable to get the index for.\n    * @param {string} type - The type name: number, string, boolean or list.\n    * @param {string} domain - The variable domain to search in. If not specified, the default domain will be used.\n     */\n\n    VariableStore.prototype.indexOfGlobalVariable = function(name, type, domain) {\n      var result, variable, variables, variablesDocument;\n      result = 0;\n      variables = DataManager.getDocumentsByType(\"global_variables\");\n      variablesDocument = variables.first(function(v) {\n        return v.items.domain === domain;\n      });\n      if (variablesDocument == null) {\n        variablesDocument = variables[0];\n      }\n      if (variablesDocument) {\n        variable = variablesDocument.items[type + \"s\"].first(function(v) {\n          return v.name === name;\n        });\n        if (variable) {\n          result = variable.index;\n        } else {\n          console.warn(\"Variable referenced by name not found: \" + name + \" (persistent, \" + type + \")\");\n        }\n      }\n      return result;\n    };\n\n\n    /**\n    * Gets the index for the persistent variable with the specified name. If a variable with that\n    * name cannot be found, the index will be 0.\n    *\n    * @method indexOfTempVariable\n    * @param {string} name - The name of the variable to get the index for.\n    * @param {string} type - The type name: number, string, boolean or list.\n    * @param {string} domain - The variable domain to search in. If not specified, the default domain will be used.\n     */\n\n    VariableStore.prototype.indexOfPersistentVariable = function(name, type, domain) {\n      var result, variable, variables, variablesDocument;\n      result = 0;\n      variables = DataManager.getDocumentsByType(\"persistent_variables\");\n      variablesDocument = variables.first(function(v) {\n        return v.items.domain === domain;\n      });\n      if (variablesDocument == null) {\n        variablesDocument = variables[0];\n      }\n      if (variablesDocument) {\n        variable = variablesDocument.items[type + \"s\"].first(function(v) {\n          return v.name === name;\n        });\n        if (variable != null) {\n          result = variable.index;\n        } else {\n          console.warn(\"Variable referenced by name not found: \" + name + \" (persistent, \" + type + \")\");\n        }\n      }\n      return result;\n    };\n\n\n    /**\n    * Sets the value of the number variable at the specified index.\n    *\n    * @method setNumberValueAtIndex\n    * @param {number} scope - The variable scope.\n    * @param {number} type - The variable's index.\n    * @param {number} value - The value to set.\n     */\n\n    VariableStore.prototype.setNumberValueAtIndex = function(scope, index, value, domain) {\n      if (scope === 2) {\n        return this.persistentNumbersByDomain[domain][index] = value;\n      } else if (scope === 1) {\n        return this.numbersByDomain[domain || 0][index] = value;\n      } else {\n        return this.tempNumbers[index] = value;\n      }\n    };\n\n\n    /**\n    * Sets the value of a specified number variable.\n    *\n    * @method setNumberValueAtIndex\n    * @param {number} variable - The variable to set.\n    * @param {number} value - The value to set.\n     */\n\n    VariableStore.prototype.setNumberValueTo = function(variable, value) {\n      if (variable.scope === 2) {\n        return this.persistentNumbersByDomain[variable.domain || 0][variable.index] = value;\n      } else if (variable.scope === 1) {\n        return this.numbersByDomain[variable.domain || 0][variable.index] = value;\n      } else {\n        return this.tempNumbers[variable.index] = value;\n      }\n    };\n\n\n    /**\n    * Sets the value of a specified list variable.\n    *\n    * @method setListObjectTo\n    * @param {Object} variable - The variable to set.\n    * @param {Object} value - The value to set.\n     */\n\n    VariableStore.prototype.setListObjectTo = function(variable, value) {\n      if (variable.scope === 2) {\n        return this.persistentListsByDomain[variable.domain || 0][variable.index] = value;\n      } else if (variable.scope === 1) {\n        return this.listsByDomain[variable.domain || 0][variable.index] = value;\n      } else {\n        return this.tempLists[variable.index] = value;\n      }\n    };\n\n\n    /**\n    * Sets the value of a specified boolean variable.\n    *\n    * @method setBooleanValueTo\n    * @param {Object} variable - The variable to set.\n    * @param {boolean} value - The value to set.\n     */\n\n    VariableStore.prototype.setBooleanValueTo = function(variable, value) {\n      if (variable.scope === 2) {\n        return this.persistentBooleansByDomain[variable.domain][variable.index] = value;\n      } else if (variable.scope === 1) {\n        return this.booleansByDomain[variable.domain][variable.index] = value;\n      } else {\n        return this.tempBooleans[variable.index] = value;\n      }\n    };\n\n\n    /**\n    * Sets the value of the boolean variable at the specified index.\n    *\n    * @method setBooleanValueAtIndex\n    * @param {number} scope - The variable scope.\n    * @param {number} index - The variable's index.\n    * @param {boolean} value - The value to set.\n     */\n\n    VariableStore.prototype.setBooleanValueAtIndex = function(scope, index, value, domain) {\n      if (scope === 2) {\n        return this.persistentBooleansByDomain[domain][index] = value;\n      } else if (scope === 1) {\n        return this.booleansByDomain[domain][index] = value;\n      } else {\n        return this.tempBooleans[index] = value;\n      }\n    };\n\n\n    /**\n    * Sets the value of a specified string variable.\n    *\n    * @method setStringValueTo\n    * @param {Object} variable - The variable to set.\n    * @param {string} value - The value to set.\n     */\n\n    VariableStore.prototype.setStringValueTo = function(variable, value) {\n      if (variable.scope === 2) {\n        return this.persistentStringsByDomain[variable.domain][variable.index] = value;\n      } else if (variable.scope === 1) {\n        return this.stringsByDomain[variable.domain][variable.index] = value;\n      } else {\n        return this.tempStrings[variable.index] = value;\n      }\n    };\n\n\n    /**\n    * Sets the value of the string variable at the specified index.\n    *\n    * @method setStringValueAtIndex\n    * @param {number} scope - The variable scope.\n    * @param {number} index - The variable's index.\n    * @param {string} value - The value to set.\n     */\n\n    VariableStore.prototype.setStringValueAtIndex = function(scope, index, value, domain) {\n      if (scope === 2) {\n        return this.persistentStringsByDomain[domain][index] = value;\n      } else if (scope === 1) {\n        return this.stringsByDomain[domain][index] = value;\n      } else {\n        return this.tempStrings[index] = value;\n      }\n    };\n\n\n    /**\n    * Gets the value of a specified list variable.\n    *\n    * @method listObjectOf\n    * @param {Object} object - The list-variable/object to get the value from.\n    * @return {Object} The list-object.\n     */\n\n    VariableStore.prototype.listObjectOf = function(object) {\n      var result;\n      result = 0;\n      if ((object != null) && (object.index != null)) {\n        if (object.scope === 2) {\n          result = this.persistentListsByDomain[object.domain][object.index];\n        } else if (object.scope === 1) {\n          result = this.listsByDomain[object.domain][object.index];\n        } else {\n          result = this.tempLists[object.index];\n        }\n      } else {\n        result = object;\n      }\n      return result || [];\n    };\n\n\n    /**\n    * Gets the value of a number variable at the specified index.\n    *\n    * @method numberValueAtIndex\n    * @param {number} scope - The variable scope.\n    * @param {number} index - The variable's index.\n    * @return {Object} The number value of the variable.\n     */\n\n    VariableStore.prototype.numberValueAtIndex = function(scope, index, domain) {\n      var result;\n      result = 0;\n      if (scope === 2) {\n        result = this.persistentNumbersByDomain[domain][index];\n      } else if (scope === 1) {\n        result = this.numbersByDomain[domain][index];\n      } else {\n        result = this.tempNumbers[index];\n      }\n      return result;\n    };\n\n\n    /**\n    * Gets the value of a specified number variable.\n    *\n    * @method numberValueOf\n    * @param {Object} object - The variable to get the value from.\n    * @return {Object} The number value of the variable.\n     */\n\n    VariableStore.prototype.numberValueOf = function(object) {\n      var result;\n      result = 0;\n      if ((object != null) && (object.index != null)) {\n        if (object.scope === 2) {\n          result = this.persistentNumbersByDomain[object.domain][object.index];\n        } else if (object.scope === 1) {\n          result = this.numbersByDomain[object.domain][object.index];\n        } else {\n          result = this.tempNumbers[object.index];\n        }\n      } else {\n        result = object;\n      }\n      return result || 0;\n    };\n\n\n    /**\n    * Gets the value of a specified string variable.\n    *\n    * @method stringValueOf\n    * @param {Object} object - The variable to get the value from.\n    * @return {string} The string value of the variable.\n     */\n\n    VariableStore.prototype.stringValueOf = function(object) {\n      var result;\n      result = \"\";\n      if ((object != null) && (object.index != null)) {\n        if (object.scope === 2) {\n          result = this.persistentStringsByDomain[object.domain][object.index];\n        } else if (object.scope === 1) {\n          result = this.stringsByDomain[object.domain][object.index];\n        } else {\n          result = this.tempStrings[object.index];\n        }\n      } else {\n        result = object;\n      }\n      return result || \"\";\n    };\n\n\n    /**\n    * Gets the value of a string variable at the specified index.\n    *\n    * @method stringValueAtIndex\n    * @param {number} scope - The variable scope.\n    * @param {number} index - The variable's index.\n    * @return {string} The string value of the variable.\n     */\n\n    VariableStore.prototype.stringValueAtIndex = function(scope, index, domain) {\n      var result;\n      result = \"\";\n      if (scope === 2) {\n        result = this.persistentStringsByDomain[domain][index];\n      } else if (scope === 1) {\n        result = this.stringsByDomain[domain][index];\n      } else {\n        result = this.tempStrings[index];\n      }\n      return result || \"\";\n    };\n\n\n    /**\n    * Gets the value of a specified boolean variable.\n    *\n    * @method booleanValueOf\n    * @param {Object} object - The variable to get the value from.\n    * @return {Object} The boolean value of the variable.\n     */\n\n    VariableStore.prototype.booleanValueOf = function(object) {\n      var result;\n      result = false;\n      if ((object != null) && (object.index != null)) {\n        if (object.scope === 2) {\n          result = this.persistentBooleansByDomain[object.domain][object.index] || false;\n        } else if (object.scope === 1) {\n          result = this.booleansByDomain[object.domain][object.index] || false;\n        } else {\n          result = this.tempBooleans[object.index] || false;\n        }\n      } else {\n        result = object ? true : false;\n      }\n      return result;\n    };\n\n\n    /**\n    * Gets the value of a boolean variable at the specified index.\n    *\n    * @method booleanValueAtIndex\n    * @param {number} scope - The variable scope.\n    * @param {number} index - The variable's index.\n    * @return {boolean} The boolean value of the variable.\n     */\n\n    VariableStore.prototype.booleanValueAtIndex = function(scope, index, domain) {\n      var result;\n      result = false;\n      if (scope === 2) {\n        result = this.persistenBooleansByDomain[domain][index] || false;\n      } else if (scope === 1) {\n        result = this.booleansByDomain[domain][index] || false;\n      } else {\n        result = this.tempBooleans[index] || false;\n      }\n      return result;\n    };\n\n    return VariableStore;\n\n  })();\n\n  gs.VariableStore = VariableStore;\n\n}).call(this);\n"
    },
    "summary": [
        "name",
        "type",
        "order"
    ],
    "externalItems": []
}