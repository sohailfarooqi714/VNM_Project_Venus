{
    "uid": "3A731523KD345A49DAS903FE171A585AEB27",
    "isLoaded": true,
    "lastModificationTime": 1421095528705,
    "items": {
        "name": "DataOptimizer",
        "type": "game_script",
        "order": 0,
        "parentId": "2EC9F946K6417A4973S8308E368608E89B8B",
        "content": "# ===================================================================\n#\n#   Script: DataOptimizer\n#\n#   $$COPYRIGHT$$\n#\n# ===================================================================\nclass DataOptimizer\n    ###*\n    * The data optimizer is to optimize data structures coming from data files to\n    * make processing faster. One way of optimization for example is to convert\n    * regular array to typed arrays.\n    *\n    * @module gs\n    * @class DataOptimizer\n    * @memberof gs\n    * @static\n    * @constructor\n    ###\n    constructor: ->\n        @labels = {}\n        @labelJumps = {}\n        \n    ###*\n    * Converts the specified number-array to a typed Int16 array.\n    *\n    * @method arrayToNativeArray\n    * @param {Array} array - The array to convert.\n    * @return {Int16Array} The typed array.\n    * @static\n    ### \n    arrayToNativeArray: (array) ->\n        result = null\n        length = array.length || Object.keys(array).length\n        if array?\n            if window.ArrayBuffer?\n                result = new ArrayBuffer(length * 2)\n                result = new Int16Array(result)\n            else\n                result = new Array(length)\n           \n            \n            for i in [0...length]\n                result[i] = array[i]\n                \n        return result\n    \n    ###*\n    * Creates a typed Int16 array if supported. Otherwise a regular array is created.\n    *\n    * @method nativeArray16\n    * @param {number} size - The size of the array in elements.(Not in bytes).\n    * @return {Int16Array} The Int16 array.\n    * @static\n    ### \n    nativeArray16: (size) ->\n        #result = new ArrayBuffer(size * 2)\n        #result = new Int16Array(result)\n        result = new Array(size)\n        return result\n    \n    ###*\n    * Creates a typed Int8 array if supported. Otherwise a regular array is created.\n    *\n    * @method nativeArray16\n    * @param {number} size - The size of the array in elements.(Not in bytes).\n    * @return {Int8Array} The Int8 array.\n    * @static\n    ###     \n    nativeArray8: (size) ->\n        result = new Array(size)\n        return result\n     \n     \n    ###*\n    * Removes a single empty command like a comment.\n    *\n    * @method removeEmptyCommand\n    * @private\n    * @param {Object[]} commands - A list of commands.\n    * @param {Object} command - The command to optimize.\n    * @static\n    ### \n    removeEmptyCommand: (command, index, commands) ->\n        return no if GameManager.inLivePreview\n        \n        result = no\n        switch commands[index].id\n            when \"gs.Comment\"\n                commands.splice(index, 1)\n                result = yes\n            when \"gs.EmptyCommand\"\n                commands.splice(index, 1)\n                result = yes\n        return result\n     \n    ###*\n    * Checks if a common event call can be optimized by inline it. In special cases,\n    * such as recursion or parameters, an optimization is no possible.\n    *\n    * @method optimizeCommonEventCall\n    * @private\n    * @param {Object[]} commands - A list of commands.\n    * @param {number} index - Index of the command in command-list.\n    * @param {Object} command - The command to optimize.\n    * @return If <b>true</b> the call can be safly inline. Otherwise <b>false</b>\n    * @static\n    ###    \n    canInlineCommonEventCall: (command, index, commands, callStack) ->\n        result = !(command.params.commonEventId.index?)\n        commonEvent = RecordManager.commonEvents[command.params.commonEventId]\n        if commonEvent?.inline\n            if callStack.indexOf(commonEvent) != -1\n                result = no\n            else\n                callStack.push(commonEvent)\n                for c, i in commonEvent.commands\n                    if c.id == \"gs.CallCommonEvent\"\n                        result = @canInlineCommonEventCall(c, i, commonEvent.commands, callStack)\n        \n        return result\n            \n    ###*\n    * Optimizes a common event call.\n    *\n    * @method optimizeCommonEventCall\n    * @private\n    * @param {Object[]} commands - A list of commands.\n    * @param {number} index - Index of the command in command-list.\n    * @param {Object} command - The command to optimize.\n    * @static\n    ### \n    optimizeCommonEventCall: (command, index, commands) ->\n        commonEvent = RecordManager.commonEvents[command.params.commonEventId]\n        if commonEvent?.inline\n            if @canInlineCommonEventCall(command, index, commands, [])\n                commands.splice(index, 1)\n                commands.splice.apply(commands, [index, 0].concat(Object.copy(commonEvent.commands)))\n    \n    ###*\n    * Optimizes the variable-access by replacing the domain-string with the domain-index\n    * value at runtime to allow faster domain access using integer numbers instead of strings.\n    *\n    * @method optimizeVariableAccess\n    * @param {Object} data - The data to opimize, e.g. the params-object of a command.\n    * @static\n    ###             \n    optimizeVariableAccess: (data) ->\n        return if data?.__optimized\n        data?.__optimized = yes \n        for p of data\n            if data[p] instanceof Array and !data[p].__optimized\n                data[p].__optimized = yes\n                for e in data[p]\n                    @optimizeVariableAccess(e)\n            else if p == \"domain\" and data.scope > 0 and data.index?\n                domainIndex = GameManager.variableStore.domains.indexOf(data[p])\n                data[p] = if domainIndex == -1 then data[p] else domainIndex\n            else if typeof data[p] == \"object\" and !(data[p] instanceof String || data[p] instanceof Array)\n                @optimizeVariableAccess(data[p]) if not data[p]?.__optimized\n                data[p]?.__optimized = yes\n       \n    \n    ###*\n    * Optimizes a single sub-message created by {CP} text code. It will split the sub-message into multiple\n    * independent ShowMessage commands at {P} text code.\n    *\n    * @method optimizeSubMessage\n    * @private\n    * @param {string} message - The sub message.\n    * @param {Object} command - The command to optimize.\n    * @param {number} index - Index of the command in command-list.\n    * @param {Object[]} commands - A list of commands.\n    * @return {number} The current command-pointer where add/insert the next command (If necessary).\n    * @static\n    ###  \n    optimizeSubMessage: (message, command, index, commands) ->\n        subMessages = message.split(\"{P}\")\n        for subMessage, i in subMessages\n            messageCommand = Object.flatCopy(command)\n            messageCommand.params = Object.flatCopy(messageCommand.params)\n            if i == 0\n                messageCommand.params.message = subMessage\n            else\n                messageCommand.params.message = subMessage.replace(\"\\n\", \"\")\n                \n            commands.splice(index, 0, messageCommand)\n            index++\n                \n        return index\n        \n    ###*\n    * Optimizes a single ShowMessage command. It will split the command into multiple\n    * independent ShowMessage commands at {P} text code for example.\n    *\n    * @method optimizeShowMessage\n    * @private\n    * @param {Object} command - The command to optimize.\n    * @param {number} index - Index of the command in command-list.\n    * @param {Object[]} commands - A list of commands.\n    * @return {number} The current command-pointer where add/insert the next command (If necessary).\n    * @static\n    ###     \n    optimizeShowMessage: (command, index, commands) -> \n        msg = lcs(command.params.message)\n        \n        if msg.contains(\"{CP}\") or msg.contains(\"{P}\")\n            commands.splice(index, 1)\n            subMessages = msg.split(\"{CP}\")\n            for subMessage, i in subMessages\n                index = @optimizeSubMessage(subMessage, command, index, commands)\n                \n                if i < subMessages.length-1\n                    clearCommand = { id: \"gs.ClearMessage\", indent: command.indent, params: { fieldFlags: { duration: 1 }, duration: 30, waitForCompletion: yes } }\n                    commands.splice(index, 0, clearCommand)\n                    index++\n                    \n            index--\n                \n        return index\n        \n    ###*\n    * Optimizes a single command.\n    *\n    * @method optimizeCommand\n    * @private\n    * @param {Object[]} commands - A list of commands.\n    * @param {number} index - Index of the command in command-list.\n    * @param {Object} command - The command to optimize.\n    * @static\n    ###     \n    optimizeCommand: (command, index, commands) ->\n        @optimizeVariableAccess(command.params)\n        \n        switch command.id\n            when \"gs.ShowMessage\"\n                index = @optimizeShowMessage(command, index, commands)\n            when \"gs.CallCommonEvent\"\n                @optimizeCommonEventCall(command, index, commands)\n            when \"gs.Label\"\n                @labels[command.params.name] = index\n                @labelJumps[command.params.name]?.forEach (c) -> c.params.labelIndex = index\n            when \"vn.Choice\"\n                command.params.action.labelIndex = @labels[command.params.action.label]\n                if !@labelJumps[command.params.action.label]\n                    @labelJumps[command.params.action.label] = []\n                @labelJumps[command.params.action.label].push(command)\n            when \"gs.CheckSwitch\", \"gs.CheckNumberVariable\", \"gs.CheckTextVariable\"\n                command.params.labelIndex = @labels[command.params.label]\n                if !@labelJumps[command.params.label]\n                    @labelJumps[command.params.label] = []\n                @labelJumps[command.params.label].push(command)\n            #when \"gs.AddHotspot\"\n            #    command.params.actions.onClick\n            when \"gs.JumpToLabel\"\n                command.params.labelIndex = @labels[command.params.name]\n                if !@labelJumps[command.params.name]\n                    @labelJumps[command.params.name] = []\n                @labelJumps[command.params.name].push(command)\n        \n        return index\n        \n    ###*\n    * Optimizes a list of event/scene commands by removing unnecessary commands like\n    * comments or empty commands. It also optimizes label jumps. Adds an <b>optimized</b> to\n    * the specified command-list to indicate that the list was already optimized. If <b>optimized</b>\n    * property of command-list is set to <b>true</b> this method will return immediately.\n    *\n    * @method optimizeEventCommands\n    * @param {Object[]} commands - A list of commands to optimize.\n    * @static\n    ###       \n    optimizeEventCommands: (commands) ->\n        return if commands.optimized\n\n        i = 0\n        @labels = {}\n        @labelJumps = {}\n        if !$PARAMS.preview\n            while i < commands.length\n                commands[i].indent = commands[i].indent || 0\n                if @removeEmptyCommand(commands[i], i, commands)\n                    i--\n                i++\n        i = 0\n        while i < commands.length\n            i = @optimizeCommand(commands[i], i, commands)\n            i++\n        commands.optimized = yes\n        \n        \nwindow.DataOptimizer = new DataOptimizer()\ngs.DataOptimizer = DataOptimizer",
        "compiledContent": "// Generated by CoffeeScript 1.12.7\n(function() {\n  var DataOptimizer;\n\n  DataOptimizer = (function() {\n\n    /**\n    * The data optimizer is to optimize data structures coming from data files to\n    * make processing faster. One way of optimization for example is to convert\n    * regular array to typed arrays.\n    *\n    * @module gs\n    * @class DataOptimizer\n    * @memberof gs\n    * @static\n    * @constructor\n     */\n    function DataOptimizer() {\n      this.labels = {};\n      this.labelJumps = {};\n    }\n\n\n    /**\n    * Converts the specified number-array to a typed Int16 array.\n    *\n    * @method arrayToNativeArray\n    * @param {Array} array - The array to convert.\n    * @return {Int16Array} The typed array.\n    * @static\n     */\n\n    DataOptimizer.prototype.arrayToNativeArray = function(array) {\n      var i, j, length, ref, result;\n      result = null;\n      length = array.length || Object.keys(array).length;\n      if (array != null) {\n        if (window.ArrayBuffer != null) {\n          result = new ArrayBuffer(length * 2);\n          result = new Int16Array(result);\n        } else {\n          result = new Array(length);\n        }\n        for (i = j = 0, ref = length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n          result[i] = array[i];\n        }\n      }\n      return result;\n    };\n\n\n    /**\n    * Creates a typed Int16 array if supported. Otherwise a regular array is created.\n    *\n    * @method nativeArray16\n    * @param {number} size - The size of the array in elements.(Not in bytes).\n    * @return {Int16Array} The Int16 array.\n    * @static\n     */\n\n    DataOptimizer.prototype.nativeArray16 = function(size) {\n      var result;\n      result = new Array(size);\n      return result;\n    };\n\n\n    /**\n    * Creates a typed Int8 array if supported. Otherwise a regular array is created.\n    *\n    * @method nativeArray16\n    * @param {number} size - The size of the array in elements.(Not in bytes).\n    * @return {Int8Array} The Int8 array.\n    * @static\n     */\n\n    DataOptimizer.prototype.nativeArray8 = function(size) {\n      var result;\n      result = new Array(size);\n      return result;\n    };\n\n\n    /**\n    * Removes a single empty command like a comment.\n    *\n    * @method removeEmptyCommand\n    * @private\n    * @param {Object[]} commands - A list of commands.\n    * @param {Object} command - The command to optimize.\n    * @static\n     */\n\n    DataOptimizer.prototype.removeEmptyCommand = function(command, index, commands) {\n      var result;\n      if (GameManager.inLivePreview) {\n        return false;\n      }\n      result = false;\n      switch (commands[index].id) {\n        case \"gs.Comment\":\n          commands.splice(index, 1);\n          result = true;\n          break;\n        case \"gs.EmptyCommand\":\n          commands.splice(index, 1);\n          result = true;\n      }\n      return result;\n    };\n\n\n    /**\n    * Checks if a common event call can be optimized by inline it. In special cases,\n    * such as recursion or parameters, an optimization is no possible.\n    *\n    * @method optimizeCommonEventCall\n    * @private\n    * @param {Object[]} commands - A list of commands.\n    * @param {number} index - Index of the command in command-list.\n    * @param {Object} command - The command to optimize.\n    * @return If <b>true</b> the call can be safly inline. Otherwise <b>false</b>\n    * @static\n     */\n\n    DataOptimizer.prototype.canInlineCommonEventCall = function(command, index, commands, callStack) {\n      var c, commonEvent, i, j, len, ref, result;\n      result = !(command.params.commonEventId.index != null);\n      commonEvent = RecordManager.commonEvents[command.params.commonEventId];\n      if (commonEvent != null ? commonEvent.inline : void 0) {\n        if (callStack.indexOf(commonEvent) !== -1) {\n          result = false;\n        } else {\n          callStack.push(commonEvent);\n          ref = commonEvent.commands;\n          for (i = j = 0, len = ref.length; j < len; i = ++j) {\n            c = ref[i];\n            if (c.id === \"gs.CallCommonEvent\") {\n              result = this.canInlineCommonEventCall(c, i, commonEvent.commands, callStack);\n            }\n          }\n        }\n      }\n      return result;\n    };\n\n\n    /**\n    * Optimizes a common event call.\n    *\n    * @method optimizeCommonEventCall\n    * @private\n    * @param {Object[]} commands - A list of commands.\n    * @param {number} index - Index of the command in command-list.\n    * @param {Object} command - The command to optimize.\n    * @static\n     */\n\n    DataOptimizer.prototype.optimizeCommonEventCall = function(command, index, commands) {\n      var commonEvent;\n      commonEvent = RecordManager.commonEvents[command.params.commonEventId];\n      if (commonEvent != null ? commonEvent.inline : void 0) {\n        if (this.canInlineCommonEventCall(command, index, commands, [])) {\n          commands.splice(index, 1);\n          return commands.splice.apply(commands, [index, 0].concat(Object.copy(commonEvent.commands)));\n        }\n      }\n    };\n\n\n    /**\n    * Optimizes the variable-access by replacing the domain-string with the domain-index\n    * value at runtime to allow faster domain access using integer numbers instead of strings.\n    *\n    * @method optimizeVariableAccess\n    * @param {Object} data - The data to opimize, e.g. the params-object of a command.\n    * @static\n     */\n\n    DataOptimizer.prototype.optimizeVariableAccess = function(data) {\n      var domainIndex, e, p, ref, ref1, results;\n      if (data != null ? data.__optimized : void 0) {\n        return;\n      }\n      if (data != null) {\n        data.__optimized = true;\n      }\n      results = [];\n      for (p in data) {\n        if (data[p] instanceof Array && !data[p].__optimized) {\n          data[p].__optimized = true;\n          results.push((function() {\n            var j, len, ref, results1;\n            ref = data[p];\n            results1 = [];\n            for (j = 0, len = ref.length; j < len; j++) {\n              e = ref[j];\n              results1.push(this.optimizeVariableAccess(e));\n            }\n            return results1;\n          }).call(this));\n        } else if (p === \"domain\" && data.scope > 0 && (data.index != null)) {\n          domainIndex = GameManager.variableStore.domains.indexOf(data[p]);\n          results.push(data[p] = domainIndex === -1 ? data[p] : domainIndex);\n        } else if (typeof data[p] === \"object\" && !(data[p] instanceof String || data[p] instanceof Array)) {\n          if (!((ref = data[p]) != null ? ref.__optimized : void 0)) {\n            this.optimizeVariableAccess(data[p]);\n          }\n          results.push((ref1 = data[p]) != null ? ref1.__optimized = true : void 0);\n        } else {\n          results.push(void 0);\n        }\n      }\n      return results;\n    };\n\n\n    /**\n    * Optimizes a single sub-message created by {CP} text code. It will split the sub-message into multiple\n    * independent ShowMessage commands at {P} text code.\n    *\n    * @method optimizeSubMessage\n    * @private\n    * @param {string} message - The sub message.\n    * @param {Object} command - The command to optimize.\n    * @param {number} index - Index of the command in command-list.\n    * @param {Object[]} commands - A list of commands.\n    * @return {number} The current command-pointer where add/insert the next command (If necessary).\n    * @static\n     */\n\n    DataOptimizer.prototype.optimizeSubMessage = function(message, command, index, commands) {\n      var i, j, len, messageCommand, subMessage, subMessages;\n      subMessages = message.split(\"{P}\");\n      for (i = j = 0, len = subMessages.length; j < len; i = ++j) {\n        subMessage = subMessages[i];\n        messageCommand = Object.flatCopy(command);\n        messageCommand.params = Object.flatCopy(messageCommand.params);\n        if (i === 0) {\n          messageCommand.params.message = subMessage;\n        } else {\n          messageCommand.params.message = subMessage.replace(\"\\n\", \"\");\n        }\n        commands.splice(index, 0, messageCommand);\n        index++;\n      }\n      return index;\n    };\n\n\n    /**\n    * Optimizes a single ShowMessage command. It will split the command into multiple\n    * independent ShowMessage commands at {P} text code for example.\n    *\n    * @method optimizeShowMessage\n    * @private\n    * @param {Object} command - The command to optimize.\n    * @param {number} index - Index of the command in command-list.\n    * @param {Object[]} commands - A list of commands.\n    * @return {number} The current command-pointer where add/insert the next command (If necessary).\n    * @static\n     */\n\n    DataOptimizer.prototype.optimizeShowMessage = function(command, index, commands) {\n      var clearCommand, i, j, len, msg, subMessage, subMessages;\n      msg = lcs(command.params.message);\n      if (msg.contains(\"{CP}\") || msg.contains(\"{P}\")) {\n        commands.splice(index, 1);\n        subMessages = msg.split(\"{CP}\");\n        for (i = j = 0, len = subMessages.length; j < len; i = ++j) {\n          subMessage = subMessages[i];\n          index = this.optimizeSubMessage(subMessage, command, index, commands);\n          if (i < subMessages.length - 1) {\n            clearCommand = {\n              id: \"gs.ClearMessage\",\n              indent: command.indent,\n              params: {\n                fieldFlags: {\n                  duration: 1\n                },\n                duration: 30,\n                waitForCompletion: true\n              }\n            };\n            commands.splice(index, 0, clearCommand);\n            index++;\n          }\n        }\n        index--;\n      }\n      return index;\n    };\n\n\n    /**\n    * Optimizes a single command.\n    *\n    * @method optimizeCommand\n    * @private\n    * @param {Object[]} commands - A list of commands.\n    * @param {number} index - Index of the command in command-list.\n    * @param {Object} command - The command to optimize.\n    * @static\n     */\n\n    DataOptimizer.prototype.optimizeCommand = function(command, index, commands) {\n      var ref;\n      this.optimizeVariableAccess(command.params);\n      switch (command.id) {\n        case \"gs.ShowMessage\":\n          index = this.optimizeShowMessage(command, index, commands);\n          break;\n        case \"gs.CallCommonEvent\":\n          this.optimizeCommonEventCall(command, index, commands);\n          break;\n        case \"gs.Label\":\n          this.labels[command.params.name] = index;\n          if ((ref = this.labelJumps[command.params.name]) != null) {\n            ref.forEach(function(c) {\n              return c.params.labelIndex = index;\n            });\n          }\n          break;\n        case \"vn.Choice\":\n          command.params.action.labelIndex = this.labels[command.params.action.label];\n          if (!this.labelJumps[command.params.action.label]) {\n            this.labelJumps[command.params.action.label] = [];\n          }\n          this.labelJumps[command.params.action.label].push(command);\n          break;\n        case \"gs.CheckSwitch\":\n        case \"gs.CheckNumberVariable\":\n        case \"gs.CheckTextVariable\":\n          command.params.labelIndex = this.labels[command.params.label];\n          if (!this.labelJumps[command.params.label]) {\n            this.labelJumps[command.params.label] = [];\n          }\n          this.labelJumps[command.params.label].push(command);\n          break;\n        case \"gs.JumpToLabel\":\n          command.params.labelIndex = this.labels[command.params.name];\n          if (!this.labelJumps[command.params.name]) {\n            this.labelJumps[command.params.name] = [];\n          }\n          this.labelJumps[command.params.name].push(command);\n      }\n      return index;\n    };\n\n\n    /**\n    * Optimizes a list of event/scene commands by removing unnecessary commands like\n    * comments or empty commands. It also optimizes label jumps. Adds an <b>optimized</b> to\n    * the specified command-list to indicate that the list was already optimized. If <b>optimized</b>\n    * property of command-list is set to <b>true</b> this method will return immediately.\n    *\n    * @method optimizeEventCommands\n    * @param {Object[]} commands - A list of commands to optimize.\n    * @static\n     */\n\n    DataOptimizer.prototype.optimizeEventCommands = function(commands) {\n      var i;\n      if (commands.optimized) {\n        return;\n      }\n      i = 0;\n      this.labels = {};\n      this.labelJumps = {};\n      if (!$PARAMS.preview) {\n        while (i < commands.length) {\n          commands[i].indent = commands[i].indent || 0;\n          if (this.removeEmptyCommand(commands[i], i, commands)) {\n            i--;\n          }\n          i++;\n        }\n      }\n      i = 0;\n      while (i < commands.length) {\n        i = this.optimizeCommand(commands[i], i, commands);\n        i++;\n      }\n      return commands.optimized = true;\n    };\n\n    return DataOptimizer;\n\n  })();\n\n  window.DataOptimizer = new DataOptimizer();\n\n  gs.DataOptimizer = DataOptimizer;\n\n}).call(this);\n"
    },
    "summary": [
        "name",
        "type",
        "order"
    ],
    "externalItems": []
}