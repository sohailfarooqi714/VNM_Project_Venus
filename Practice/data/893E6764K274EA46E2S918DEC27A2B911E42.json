{
    "uid": "893E6764K274EA46E2S918DEC27A2B911E42",
    "isLoaded": true,
    "lastModificationTime": 1429211539921,
    "items": {
        "name": "Component_CommandInterpreter",
        "type": "game_script",
        "order": 18,
        "parentId": "D3325122KACDEA4515SB731E37A42B9D779F",
        "content": "# ===================================================================\n#\n#   Script: Component_CommandInterpreter\n#\n#   $$COPYRIGHT$$\n#\n# ===================================================================\n\nclass LivePreviewInfo\n    ###*\n    * Stores internal preview-info if the game runs currently in Live-Preview.\n    *\n    * @module gs\n    * @class LivePreviewInfo\n    * @memberof gs\n    ###\n    constructor: ->\n        ###*\n        * Timer ID if a timeout for live-preview was configured to exit the game loop after a certain amount of time.\n        * @property timeout\n        * @type number\n        ###\n        @timeout = null\n\n        ###*\n        * Indicates if Live-Preview is currently waiting for the next user-action. (Selecting another command, etc.)\n        * @property waiting\n        * @type boolean\n        ###\n        @waiting = no\n\n        ###*\n        * Counts the amount of executed commands since the last\n        * interpreter-pause(waiting, etc.). If its more than 500, the interpreter will automatically pause for 1 frame to\n        * avoid that Live-Preview freezes the Editor in case of endless loops.\n        * @property executedCommands\n        * @type number\n        ###\n        @executedCommands = 0\n\n        ###*\n        * Indicates that the command to skip to has not been found.\n        * @property commandNotFound\n        * @type boolean\n        ###\n        @commandNotFound = no\n\ngs.LivePreviewInfo = LivePreviewInfo\n\nclass InterpreterContext\n    @objectCodecBlackList = [\"owner\"]\n\n    ###*\n    * Describes an interpreter-context which holds information about\n    * the interpreter's owner and also unique ID used for accessing correct\n    * local variables.\n    *\n    * @module gs\n    * @class InterpreterContext\n    * @memberof gs\n    * @param {number|string} id - A unique ID\n    * @param {Object} owner - The owner of the interpreter\n    ###\n    constructor: (id, owner) ->\n        ###*\n        * A unique numeric or textual ID used for accessing correct local variables.\n        * @property id\n        * @type number|string\n        ###\n        @id = id\n\n        ###*\n        * The owner of the interpreter (e.g. current scene, etc.).\n        * @property owner\n        * @type Object\n        ###\n        @owner = owner\n\n    ###*\n    * Sets the context's data.\n    * @param {number|string} id - A unique ID\n    * @param {Object} owner - The owner of the interpreter\n    * @method set\n    ###\n    set: (id, owner) ->\n        @id = id\n        @owner = owner\n\ngs.InterpreterContext = InterpreterContext\n\nclass Component_CommandInterpreter extends gs.Component\n    @objectCodecBlackList = [\"object\", \"command\", \"onMessageADVWaiting\", \"onMessageADVDisappear\", \"onMessageADVFinish\"]\n\n    ###*\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    *\n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n    ###\n    onDataBundleRestore: (data, context) ->\n\n\n    ###*\n    * A component which allows a game object to process commands like for\n    * scene-objects. For each command a command-function exists. To add\n    * own custom commands to the interpreter just create a sub-class and\n    * override the gs.Component_CommandInterpreter.assignCommand method\n    * and assign the command-function for your custom-command.\n    *\n    * @module gs\n    * @class Component_CommandInterpreter\n    * @extends gs.Component\n    * @memberof gs\n    ###\n    constructor: () ->\n        super()\n\n        ###*\n        * Wait-Counter in frames. If greater than 0, the interpreter will for that amount of frames before continue.\n        * @property waitCounter\n        * @type number\n        ###\n        @waitCounter = 0\n\n        ###*\n        * Index to the next command to execute.\n        * @property pointer\n        * @type number\n        ###\n        @pointer = 0\n\n        ###*\n        * Stores states of conditions.\n        * @property conditions\n        * @type number\n        * @protected\n        ###\n        @conditions = []\n\n        ###*\n        * Stores states of loops.\n        * @property loops\n        * @type number\n        * @protected\n        ###\n        @loops = []\n\n        # FIXME: Should not be stored in the interpreter.\n        @timers = []\n\n        ###*\n        * Indicates if the interpreter is currently running.\n        * @property isRunning\n        * @type boolean\n        * @readOnly\n        ###\n        @isRunning = no\n\n        ###*\n        * Indicates if the interpreter is currently waiting.\n        * @property isWaiting\n        * @type boolean\n        ###\n        @isWaiting = no\n\n        ###*\n        * Indicates if the interpreter is currently waiting until a message processed by another context like a Common Event\n        * is finished.\n        * FIXME: Conflict handling can be removed maybe.\n        * @property isWaitingForMessage\n        * @type boolean\n        ###\n        @isWaitingForMessage = no\n\n        ###*\n        * Stores internal preview-info if the game runs currently in Live-Preview.\n        * <ul>\n        * <li>previewInfo.timeout - Timer ID if a timeout for live-preview was configured to exit the game loop after a certain amount of time.</li>\n        * <li>previewInfo.waiting - Indicates if Live-Preview is currently waiting for the next user-action. (Selecting another command, etc.)</li>\n        * <li>previewInfo.executedCommands - Counts the amount of executed commands since the last\n        * interpreter-pause(waiting, etc.). If its more than 500, the interpreter will automatically pause for 1 frame to\n        * avoid that Live-Preview freezes the Editor in case of endless loops.</li>\n        * </ul>\n        * @property previewInfo\n        * @type boolean\n        * @protected\n        ###\n        @previewInfo = new gs.LivePreviewInfo()\n\n        ###*\n        * Stores Live-Preview related info passed from the VN Maker editor like the command-index the player clicked on, etc.\n        * @property previewData\n        * @type Object\n        * @protected\n        ###\n        @previewData = null\n\n        ###*\n        * Indicates if the interpreter automatically repeats execution after the last command was executed.\n        * @property repeat\n        * @type boolean\n        ###\n        @repeat = no\n\n        ###*\n        * The execution context of the interpreter.\n        * @property context\n        * @type gs.InterpreterContext\n        * @protected\n        ###\n        @context = new gs.InterpreterContext(0, null)\n\n        ###*\n        * Sub-Interpreter from a Common Event Call. The interpreter will wait until the sub-interpreter is done and set back to\n        * <b>null</b>.\n        * @property subInterpreter\n        * @type gs.Component_CommandInterpreter\n        * @protected\n        ###\n        @subInterpreter = null\n\n        ###*\n        * Current indent-level of execution\n        * @property indent\n        * @type number\n        * @protected\n        ###\n        @indent = 0\n\n        ###*\n        * Stores information about for what the interpreter is currently waiting for like for a ADV message, etc. to\n        * restore probably when loaded from a save-game.\n        * @property waitingFor\n        * @type Object\n        * @protected\n        ###\n        @waitingFor = {}\n\n        ###*\n        * Stores interpreter related settings like how to handle messages, etc.\n        * @property settings\n        * @type Object\n        * @protected\n        ###\n        @settings = { message: { byId: {}, autoErase: yes, waitAtEnd: yes, backlog: yes }, screen: { pan: new gs.Point(0, 0) } }\n\n        ###*\n        * Mapping table to quickly get the anchor point for the an inserted anchor-point constant such as\n        * Top-Left(0), Top(1), Top-Right(2) and so on.\n        * @property graphicAnchorPointsByConstant\n        * @type gs.Point[]\n        * @protected\n        ###\n        @graphicAnchorPointsByConstant = [\n            new gs.Point(0.0, 0.0),\n            new gs.Point(0.5, 0.0),\n            new gs.Point(1.0, 0.0),\n            new gs.Point(1.0, 0.5),\n            new gs.Point(1.0, 1.0),\n            new gs.Point(0.5, 1.0),\n            new gs.Point(0.0, 1.0),\n            new gs.Point(0.0, 0.5),\n            new gs.Point(0.5, 0.5)\n        ]\n\n    onHotspotClick: (e, data) ->\n        @executeAction(data.params.actions.onClick, no, data.bindValue)\n    onHotspotEnter: (e, data) ->\n        @executeAction(data.params.actions.onEnter, yes, data.bindValue)\n    onHotspotLeave: (e, data) ->\n        @executeAction(data.params.actions.onLeave, no, data.bindValue)\n    onHotspotDragStart: (e, data) ->\n        @executeAction(data.params.actions.onDrag, yes, data.bindValue)\n    onHotspotDrag: (e, data) ->\n        @executeAction(data.params.actions.onDrag, yes, data.bindValue)\n    onHotspotDragEnd: (e, data) ->\n        @executeAction(data.params.actions.onDrag, no, data.bindValue)\n    onHotspotDrop: (e, data) ->\n        @executeAction(data.params.actions.onDrop, no, data.bindValue)\n        gs.GlobalEventManager.emit(\"hotspotDrop\", e.sender)\n    onHotspotDropReceived: (e, data) ->\n        @executeAction(data.params.actions.onDropReceive, yes, data.bindValue)\n    onHotspotStateChanged: (e, params) ->\n        if e.sender.behavior.selected\n            @executeAction(params.actions.onSelect, yes)\n        else\n            @executeAction(params.actions.onDeselect, no)\n\n    ###*\n    * Called when a ADV message finished rendering and is now waiting\n    * for the user/autom-message timer to proceed.\n    *\n    * @method onMessageADVWaiting\n    * @return {Object} Event Object containing additional data.\n    * @protected\n    ###\n    onMessageADVWaiting: (e) ->\n        messageObject = e.sender.object\n        if !@messageSettings().waitAtEnd\n            if e.data.params.waitForCompletion\n                @isWaiting = no\n            messageObject.textRenderer.isWaiting = no\n            messageObject.textRenderer.isRunning = no\n        messageObject.events.off \"waiting\", e.handler\n\n        if @messageSettings().backlog and (messageObject.settings.autoErase or messageObject.settings.paragraphSpacing > 0)\n            GameManager.backlog.push({ character: messageObject.character, message: messageObject.behavior.message, choices: [] })\n\n    ###*\n    * Called when an ADV message finished fade-out.\n    *\n    * @method onMessageADVDisappear\n    * @return {Object} Event Object containing additional data.\n    * @protected\n    ###\n    onMessageADVDisappear: (messageObject, waitForCompletion) ->\n        SceneManager.scene.currentCharacter = { name: \"\" }\n        messageObject.behavior.clear()\n        messageObject.visible = no\n\n        if messageObject.waitForCompletion\n            @isWaiting = no\n        @waitingFor.messageADV = null\n\n    ###*\n    * Called when an ADV message finished clear.\n    *\n    * @method onMessageADVClear\n    * @return {Object} Event Object containing additional data.\n    * @protected\n    ###\n    onMessageADVClear: (messageObject, waitForCompletion) ->\n        messageObject = @targetMessage()\n        if @messageSettings().backlog\n            GameManager.backlog.push({ character: messageObject.character, message: messageObject.behavior.message, choices: [] })\n        @onMessageADVDisappear(messageObject, waitForCompletion)\n\n\n\n    ###*\n    * Called when a hotspot/image-map sends a \"jumpTo\" event to let the\n    * interpreter jump to the position defined in the event object.\n    *\n    * @method onJumpTo\n    * @return {Object} Event Object containing additional data.\n    * @protected\n    ###\n    onJumpTo: (e) ->\n        @jumpToLabel(e.label)\n        @isWaiting = no\n\n    ###*\n    * Called when a hotspot/image-map sends a \"callCommonEvent\" event to let the\n    * interpreter call the common event defined in the event object.\n    *\n    * @method onJumpTo\n    * @return {Object} Event Object containing additional data.\n    * @protected\n    ###\n    onCallCommonEvent: (e) ->\n        eventId = e.commonEventId\n        event = RecordManager.commonEvents[eventId]\n        if !event\n            event = RecordManager.commonEvents.first (x) => x.name == eventId\n            eventId = event.index if event\n        @callCommonEvent(eventId, e.params || [], !e.finish)\n        @isWaiting = e.waiting ? no\n\n    ###*\n    * Called when a ADV message finishes.\n    *\n    * @method onMessageADVFinish\n    * @return {Object} Event Object containing additional data.\n    * @protected\n    ###\n    onMessageADVFinish: (e) ->\n        messageObject = e.sender.object\n\n        if not @messageSettings().waitAtEnd then return\n\n        GameManager.globalData.messages[lcsm(e.data.params.message)] = { read: yes }\n        GameManager.saveGlobalData()\n        if e.data.params.waitForCompletion\n            @isWaiting = no\n        @waitingFor.messageADV = null\n        pointer = @pointer\n        commands = @object.commands\n\n        messageObject.events.off \"finish\", e.handler\n        #messageObject.character = null\n\n        if messageObject.voice? and GameManager.settings.skipVoiceOnAction\n            AudioManager.stopSound(messageObject.voice.name)\n\n        if not @isMessageCommand(pointer, commands) and @messageSettings().autoErase\n            @isWaiting = yes\n            @waitingFor.messageADV = e.data.params\n\n            fading = GameManager.tempSettings.messageFading\n            duration = if GameManager.tempSettings.skip then 0 else fading.duration\n\n            messageObject.waitForCompletion = e.data.params.waitForCompletion\n            messageObject.animator.disappear(fading.animation, fading.easing, duration, gs.CallBack(\"onMessageADVDisappear\", this, e.data.params.waitForCompletion))\n\n    ###*\n    * Called when a common event finished execution. In most cases, the interpreter\n    * will stop waiting and continue processing after this. But h\n    *\n    * @method onCommonEventFinish\n    * @return {Object} Event Object containing additional data.\n    * @protected\n    ###\n    onCommonEventFinish: (e) ->\n        SceneManager.scene.commonEventContainer.removeObject(e.sender.object)\n        e.sender.object.events.off \"finish\"\n        @subInterpreter = null\n        @isWaiting = e.data.waiting ? no\n\n    ###*\n    * Called when a scene call finished execution.\n    *\n    * @method onCallSceneFinish\n    * @param {Object} sender - The sender of this event.\n    * @protected\n    ###\n    onCallSceneFinish: (sender) ->\n        @isWaiting = no\n        @subInterpreter = null\n\n    ###*\n    * Serializes the interpreter into a data-bundle.\n    *\n    * @method toDataBundle\n    * @return {Object} The data-bundle.\n    ###\n    toDataBundle: ->\n        if @isInputDataCommand(Math.max(@pointer - 1, 0), @object.commands)\n            pointer: Math.max(@pointer - 1 , 0),\n            choice: @choice,\n            conditions: @conditions,\n            loops: @loops,\n            labels: @labels,\n            isWaiting: no,\n            isRunning: @isRunning,\n            waitCounter: @waitCounter,\n            waitingFor: @waitingFor,\n            indent: @indent,\n            settings: @settings\n        else\n            pointer: @pointer,\n            choice: @choice,\n            conditions: @conditions,\n            loops: @loops,\n            labels: @labels,\n            isWaiting: @isWaiting,\n            isRunning: @isRunning,\n            waitCounter: @waitCounter,\n            waitingFor: @waitingFor,\n            indent: @indent,\n            settings: @settings\n\n    ###*\n    # Previews the current scene at the specified pointer. This method is called from the\n    # VN Maker Scene-Editor if live-preview is enabled and the user clicked on a command.\n    #\n    # @method preview\n    ###\n    preview: ->\n        try\n            return if !$PARAMS.preview or !$PARAMS.preview.scene\n            AudioManager.stopAllSounds()\n            AudioManager.stopAllMusic()\n            AudioManager.stopAllVoices()\n            SceneManager.scene.choices = []\n            GameManager.setupCursor()\n            @previewData = $PARAMS.preview\n            gs.GlobalEventManager.emit(\"previewRestart\")\n            if @previewInfo.timeout\n                clearTimeout(@previewInfo.timeout)\n\n            if Graphics.stopped\n                Graphics.stopped = no\n                Graphics.onEachFrame(gs.Main.frameCallback)\n\n            scene = new vn.Object_Scene()\n\n            scene.sceneData.uid = @previewData.scene.uid\n            SceneManager.switchTo(scene)\n        catch ex\n            console.warn(ex)\n\n    ###*\n    # Sets up the interpreter.\n    #\n    # @method setup\n    ###\n    setup: ->\n        super\n\n        @previewData = $PARAMS.preview\n        if @previewData\n            gs.GlobalEventManager.on \"mouseDown\", (=>\n                if @previewInfo.waiting\n                    if @previewInfo.timeout\n                        clearTimeout(@previewInfo.timeout)\n                    @previewInfo.waiting = no\n                    #@isWaiting = no\n                    GameManager.tempSettings.skip = no\n                    @previewData = null\n                    gs.GlobalEventManager.emit(\"previewRestart\")\n                ), null, @object\n\n    ###*\n    # Disposes the interpreter.\n    #\n    # @method dispose\n    ###\n    dispose: ->\n        if @previewData\n            gs.GlobalEventManager.offByOwner(\"mouseDown\", @object)\n\n\n        super\n\n\n    isInstantSkip: -> GameManager.tempSettings.skip and GameManager.tempSettings.skipTime == 0\n\n    ###*\n    * Restores the interpreter from a data-bundle\n    *\n    * @method restore\n    * @param {Object} bundle- The data-bundle.\n    ###\n    restore: ->\n\n    ###*\n    * Gets the default game message for novel-mode.\n    *\n    * @method messageObjectNVL\n    * @return {ui.Object_Message} The NVL game message object.\n    ###\n    messageObjectNVL: -> gs.ObjectManager.current.objectById(\"nvlGameMessage_message\")\n\n    ###*\n    * Gets the default game message for adventure-mode.\n    *\n    * @method messageObjectADV\n    * @return {ui.Object_Message} The ADV game message object.\n    ###\n    messageObjectADV: ->\n        gs.ObjectManager.current.objectById(\"gameMessage_message\")\n\n    ###*\n    * Starts the interpreter\n    *\n    * @method start\n    ###\n    start: ->\n        @conditions = []\n        @loops = []\n        @indent = 0\n        @pointer = 0\n        @isRunning = yes\n        @isWaiting = no\n        @subInterpreter = null\n        @waitCounter = 0\n\n    ###*\n    * Stops the interpreter\n    *\n    * @method stop\n    ###\n    stop: ->\n        @isRunning = no\n\n    ###*\n    * Resumes the interpreter\n    *\n    * @method resume\n    ###\n    resume: ->\n        @isRunning = yes\n\n    ###*\n    * Updates the interpreter and executes all commands until the next wait is\n    * triggered by a command. So in the case of an endless-loop the method will\n    * never return.\n    *\n    * @method update\n    ###\n    update: ->\n        if @subInterpreter?\n            @subInterpreter.update()\n            return\n\n        GameManager.variableStore.setupTempVariables(@context)\n\n        if (not @object.commands? or @pointer >= @object.commands.length) and not @isWaiting\n            if @repeat\n                @start()\n            else if @isRunning\n                @isRunning = no\n                if @onFinish? then @onFinish(this)\n                return\n\n        if not @isRunning then return\n\n        if not @object.commands.optimized\n            DataOptimizer.optimizeEventCommands(@object.commands)\n\n        if @waitCounter > 0\n            @waitCounter--\n            @isWaiting = @waitCounter > 0\n            return\n\n        if @isWaitingForMessage\n            @isWaiting = yes\n            if not @isProcessingMessageInOtherContext()\n                @isWaiting = no\n                @isWaitingForMessage = no\n            else\n                return\n\n        if GameManager.inLivePreview\n            while not (@isWaiting or @previewInfo.waiting) and @pointer < @object.commands.length and @isRunning\n                @executeCommand(@pointer)\n\n                @previewInfo.executedCommands++\n\n                if @previewInfo.executedCommands > 500\n                    @previewInfo.executedCommands = 0\n                    @isWaiting = yes\n                    @waitCounter = 1\n        else\n            while not (@isWaiting or @previewInfo.waiting) and @pointer < @object.commands.length and @isRunning\n                @executeCommand(@pointer)\n\n\n        if @pointer >= @object.commands.length and not @isWaiting\n            if @repeat\n                @start()\n            else if @isRunning\n                @isRunning = no\n                if @onFinish? then @onFinish(this)\n\n\n\n\n    ###*\n    * Assigns the correct command-function to the specified command-object if\n    * necessary.\n    *\n    * @method assignCommand\n    ###\n    assignCommand: (command) ->\n        switch command.id\n            when \"gs.Idle\" then command.execute = @commandIdle\n            when \"gs.StartTimer\" then command.execute = @commandStartTimer\n            when \"gs.PauseTimer\" then command.execute = @commandPauseTimer\n            when \"gs.ResumeTimer\" then command.execute = @commandResumeTimer\n            when \"gs.StopTimer\" then command.execute = @commandStopTimer\n            when \"gs.WaitCommand\" then command.execute = @commandWait\n            when \"gs.LoopCommand\" then command.execute = @commandLoop\n            when \"gs.BreakLoopCommand\" then command.execute = @commandBreakLoop\n            when \"gs.Comment\" then command.execute = -> 0\n            when \"gs.EmptyCommand\" then command.execute = -> 0\n            when \"gs.ListAdd\" then command.execute = @commandListAdd\n            when \"gs.ListPop\" then command.execute = @commandListPop\n            when \"gs.ListShift\" then command.execute = @commandListShift\n            when \"gs.ListRemoveAt\" then command.execute = @commandListRemoveAt\n            when \"gs.ListInsertAt\" then command.execute = @commandListInsertAt\n            when \"gs.ListValueAt\" then command.execute = @commandListValueAt\n            when \"gs.ListClear\" then command.execute = @commandListClear\n            when \"gs.ListShuffle\" then command.execute = @commandListShuffle\n            when \"gs.ListSort\" then command.execute = @commandListSort\n            when \"gs.ListIndexOf\" then command.execute = @commandListIndexOf\n            when \"gs.ListSet\" then command.execute = @commandListSet\n            when \"gs.ListCopy\" then command.execute = @commandListCopy\n            when \"gs.ListLength\" then command.execute = @commandListLength\n            when \"gs.ListJoin\" then command.execute = @commandListJoin\n            when \"gs.ListFromText\" then command.execute = @commandListFromText\n            when \"gs.ResetVariables\" then command.execute = @commandResetVariables\n            when \"gs.ChangeVariableDomain\" then command.execute = @commandChangeVariableDomain\n            when \"gs.ChangeNumberVariables\" then command.execute = @commandChangeNumberVariables\n            when \"gs.ChangeDecimalVariables\" then command.execute = @commandChangeDecimalVariables\n            when \"gs.ChangeBooleanVariables\" then command.execute = @commandChangeBooleanVariables\n            when \"gs.ChangeStringVariables\" then command.execute = @commandChangeStringVariables\n            when \"gs.CheckSwitch\" then command.execute = @commandCheckSwitch\n            when \"gs.CheckNumberVariable\" then command.execute = @commandCheckNumberVariable\n            when \"gs.CheckTextVariable\" then command.execute = @commandCheckTextVariable\n            when \"gs.Condition\" then command.execute = @commandCondition\n            when \"gs.ConditionElse\" then command.execute = @commandConditionElse\n            when \"gs.ConditionElseIf\" then command.execute = @commandConditionElseIf\n            when \"gs.Label\" then command.execute = @commandLabel\n            when \"gs.JumpToLabel\" then command.execute = @commandJumpToLabel\n            when \"gs.SetMessageArea\" then command.execute = @commandSetMessageArea\n            when \"gs.ShowMessage\" then command.execute = @commandShowMessage\n            when \"gs.ShowPartialMessage\" then command.execute = @commandShowPartialMessage\n            when \"gs.MessageFading\" then command.execute = @commandMessageFading\n            when \"gs.MessageSettings\" then command.execute = @commandMessageSettings\n            when \"gs.CreateMessageArea\" then command.execute = @commandCreateMessageArea\n            when \"gs.EraseMessageArea\" then command.execute = @commandEraseMessageArea\n            when \"gs.SetTargetMessage\" then command.execute = @commandSetTargetMessage\n            when \"vn.MessageBoxDefaults\" then command.execute = @commandMessageBoxDefaults\n            when \"vn.MessageBoxVisibility\" then command.execute = @commandMessageBoxVisibility\n            when \"vn.MessageVisibility\" then command.execute = @commandMessageVisibility\n            when \"vn.BacklogVisibility\" then command.execute = @commandBacklogVisibility\n            when \"gs.ClearMessage\" then command.execute = @commandClearMessage\n            when \"gs.ChangeWeather\" then command.execute = @commandChangeWeather\n            when \"gs.FreezeScreen\" then command.execute = @commandFreezeScreen\n            when \"gs.ScreenTransition\" then command.execute = @commandScreenTransition\n            when \"gs.ShakeScreen\" then command.execute = @commandShakeScreen\n            when \"gs.TintScreen\" then command.execute = @commandTintScreen\n            when \"gs.FlashScreen\" then command.execute = @commandFlashScreen\n            when \"gs.ZoomScreen\" then command.execute = @commandZoomScreen\n            when \"gs.RotateScreen\" then command.execute = @commandRotateScreen\n            when \"gs.PanScreen\" then command.execute = @commandPanScreen\n            when \"gs.ScreenEffect\" then command.execute = @commandScreenEffect\n            when \"gs.ShowVideo\" then command.execute = @commandShowVideo\n            when \"gs.MoveVideo\" then command.execute = @commandMoveVideo\n            when \"gs.MoveVideoPath\" then command.execute = @commandMoveVideoPath\n            when \"gs.TintVideo\" then command.execute = @commandTintVideo\n            when \"gs.FlashVideo\" then command.execute = @commandFlashVideo\n            when \"gs.CropVideo\" then command.execute = @commandCropVideo\n            when \"gs.RotateVideo\" then command.execute = @commandRotateVideo\n            when \"gs.ZoomVideo\" then command.execute = @commandZoomVideo\n            when \"gs.BlendVideo\" then command.execute = @commandBlendVideo\n            when \"gs.MaskVideo\" then command.execute = @commandMaskVideo\n            when \"gs.VideoEffect\" then command.execute = @commandVideoEffect\n            when \"gs.VideoMotionBlur\" then command.execute = @commandVideoMotionBlur\n            when \"gs.VideoDefaults\" then command.execute = @commandVideoDefaults\n            when \"gs.EraseVideo\" then command.execute = @commandEraseVideo\n            when \"gs.ShowImageMap\" then command.execute = @commandShowImageMap\n            when \"gs.EraseImageMap\" then command.execute = @commandEraseImageMap\n            when \"gs.AddHotspot\" then command.execute = @commandAddHotspot\n            when \"gs.EraseHotspot\" then command.execute = @commandEraseHotspot\n            when \"gs.ChangeHotspotState\" then command.execute = @commandChangeHotspotState\n            when \"gs.ShowPicture\" then command.execute = @commandShowPicture\n            when \"gs.MovePicture\" then command.execute = @commandMovePicture\n            when \"gs.MovePicturePath\" then command.execute = @commandMovePicturePath\n            when \"gs.TintPicture\" then command.execute = @commandTintPicture\n            when \"gs.FlashPicture\" then command.execute = @commandFlashPicture\n            when \"gs.CropPicture\" then command.execute = @commandCropPicture\n            when \"gs.RotatePicture\" then command.execute = @commandRotatePicture\n            when \"gs.ZoomPicture\" then command.execute = @commandZoomPicture\n            when \"gs.BlendPicture\" then command.execute = @commandBlendPicture\n            when \"gs.ShakePicture\" then command.execute = @commandShakePicture\n            when \"gs.MaskPicture\" then command.execute = @commandMaskPicture\n            when \"gs.PictureEffect\" then command.execute = @commandPictureEffect\n            when \"gs.PictureMotionBlur\" then command.execute = @commandPictureMotionBlur\n            when \"gs.PictureDefaults\" then command.execute = @commandPictureDefaults\n            when \"gs.PlayPictureAnimation\" then command.execute = @commandPlayPictureAnimation\n            when \"gs.ErasePicture\" then command.execute = @commandErasePicture\n            when \"gs.InputNumber\" then command.execute = @commandInputNumber\n            when \"vn.Choice\" then command.execute = @commandShowChoice\n            when \"vn.ChoiceTimer\" then command.execute = @commandChoiceTimer\n            when \"vn.ShowChoices\" then command.execute = @commandShowChoices\n            when \"vn.UnlockCG\" then command.execute = @commandUnlockCG\n            when \"vn.L2DJoinScene\" then command.execute = @commandL2DJoinScene\n            when \"vn.L2DExitScene\" then command.execute = @commandL2DExitScene\n            when \"vn.L2DMotion\" then command.execute = @commandL2DMotion\n            when \"vn.L2DMotionGroup\" then command.execute = @commandL2DMotionGroup\n            when \"vn.L2DExpression\" then command.execute = @commandL2DExpression\n            when \"vn.L2DMove\" then command.execute = @commandL2DMove\n            when \"vn.L2DParameter\" then command.execute = @commandL2DParameter\n            when \"vn.L2DSettings\" then command.execute = @commandL2DSettings\n            when \"vn.L2DDefaults\" then command.execute = @commandL2DDefaults\n            when \"vn.CharacterJoinScene\" then command.execute = @commandCharacterJoinScene\n            when \"vn.CharacterExitScene\" then command.execute = @commandCharacterExitScene\n            when \"vn.CharacterChangeExpression\" then command.execute = @commandCharacterChangeExpression\n            when \"vn.CharacterSetParameter\" then command.execute = @commandCharacterSetParameter\n            when \"vn.CharacterGetParameter\" then command.execute = @commandCharacterGetParameter\n            when \"vn.CharacterDefaults\" then command.execute = @commandCharacterDefaults\n            when \"vn.CharacterEffect\" then command.execute = @commandCharacterEffect\n            when \"vn.ZoomCharacter\" then command.execute = @commandZoomCharacter\n            when \"vn.RotateCharacter\" then command.execute = @commandRotateCharacter\n            when \"vn.BlendCharacter\" then command.execute = @commandBlendCharacter\n            when \"vn.ShakeCharacter\" then command.execute = @commandShakeCharacter\n            when \"vn.MaskCharacter\" then command.execute = @commandMaskCharacter\n            when \"vn.MoveCharacter\" then command.execute = @commandMoveCharacter\n            when \"vn.MoveCharacterPath\" then command.execute = @commandMoveCharacterPath\n            when \"vn.FlashCharacter\" then command.execute = @commandFlashCharacter\n            when \"vn.TintCharacter\" then command.execute = @commandTintCharacter\n            when \"vn.CharacterMotionBlur\" then command.execute = @commandCharacterMotionBlur\n            when \"vn.ChangeBackground\" then command.execute = @commandChangeBackground\n            when \"vn.ShakeBackground\" then command.execute = @commandShakeBackground\n            when \"vn.ScrollBackground\" then command.execute = @commandScrollBackground\n            when \"vn.ScrollBackgroundTo\" then command.execute = @commandScrollBackgroundTo\n            when \"vn.ScrollBackgroundPath\" then command.execute = @commandScrollBackgroundPath\n            when \"vn.ZoomBackground\" then command.execute = @commandZoomBackground\n            when \"vn.RotateBackground\" then command.execute = @commandRotateBackground\n            when \"vn.TintBackground\" then command.execute = @commandTintBackground\n            when \"vn.BlendBackground\" then command.execute = @commandBlendBackground\n            when \"vn.MaskBackground\" then command.execute = @commandMaskBackground\n            when \"vn.BackgroundMotionBlur\" then command.execute = @commandBackgroundMotionBlur\n            when \"vn.BackgroundEffect\" then command.execute = @commandBackgroundEffect\n            when \"vn.BackgroundDefaults\" then command.execute = @commandBackgroundDefaults\n            when \"vn.ChangeScene\" then command.execute = @commandChangeScene\n            when \"vn.ReturnToPreviousScene\" then command.execute = @commandReturnToPreviousScene\n            when \"vn.CallScene\" then command.execute = @commandCallScene\n            when \"vn.SwitchToLayout\" then command.execute = @commandSwitchToLayout\n            when \"gs.ChangeTransition\" then command.execute = @commandChangeTransition\n            when \"gs.ChangeWindowSkin\" then command.execute = @commandChangeWindowSkin\n            when \"gs.ChangeScreenTransitions\" then command.execute = @commandChangeScreenTransitions\n            when \"vn.UIAccess\" then command.execute = @commandUIAccess\n            when \"gs.PlayVideo\" then command.execute = @commandPlayVideo\n            when \"gs.PlayMusic\" then command.execute = @commandPlayMusic\n            when \"gs.StopMusic\" then command.execute = @commandStopMusic\n            when \"gs.PlaySound\" then command.execute = @commandPlaySound\n            when \"gs.StopSound\" then command.execute = @commandStopSound\n            when \"gs.PauseMusic\" then command.execute = @commandPauseMusic\n            when \"gs.ResumeMusic\" then command.execute = @commandResumeMusic\n            when \"gs.AudioDefaults\" then command.execute = @commandAudioDefaults\n            when \"gs.EndCommonEvent\" then command.execute = @commandEndCommonEvent\n            when \"gs.ResumeCommonEvent\" then command.execute = @commandResumeCommonEvent\n            when \"gs.CallCommonEvent\" then command.execute = @commandCallCommonEvent\n            when \"gs.ChangeTimer\" then command.execute = @commandChangeTimer\n            when \"gs.ShowText\" then command.execute = @commandShowText\n            when \"gs.RefreshText\" then command.execute = @commandRefreshText\n            when \"gs.TextMotionBlur\" then command.execute = @commandTextMotionBlur\n            when \"gs.MoveText\" then command.execute = @commandMoveText\n            when \"gs.MoveTextPath\" then command.execute = @commandMoveTextPath\n            when \"gs.RotateText\" then command.execute = @commandRotateText\n            when \"gs.ZoomText\" then command.execute = @commandZoomText\n            when \"gs.BlendText\" then command.execute = @commandBlendText\n            when \"gs.ColorText\" then command.execute = @commandColorText\n            when \"gs.EraseText\" then command.execute = @commandEraseText\n            when \"gs.TextEffect\" then command.execute = @commandTextEffect\n            when \"gs.TextDefaults\" then command.execute = @commandTextDefaults\n            when \"gs.ChangeTextSettings\" then command.execute = @commandChangeTextSettings\n            when \"gs.InputText\" then command.execute = @commandInputText\n            when \"gs.InputName\" then command.execute = @commandInputName\n            when \"gs.SavePersistentData\" then command.execute = @commandSavePersistentData\n            when \"gs.SaveSettings\" then command.execute = @commandSaveSettings\n            when \"gs.PrepareSaveGame\" then command.execute = @commandPrepareSaveGame\n            when \"gs.SaveGame\" then command.execute = @commandSaveGame\n            when \"gs.LoadGame\" then command.execute = @commandLoadGame\n            when \"gs.GetInputData\" then command.execute = @commandGetInputData\n            when \"gs.WaitForInput\" then command.execute = @commandWaitForInput\n            when \"gs.ChangeObjectDomain\" then command.execute = @commandChangeObjectDomain\n            when \"vn.GetGameData\" then command.execute = @commandGetGameData\n            when \"vn.SetGameData\" then command.execute = @commandSetGameData\n            when \"vn.GetObjectData\" then command.execute = @commandGetObjectData\n            when \"vn.SetObjectData\" then command.execute = @commandSetObjectData\n            when \"vn.ChangeSounds\" then command.execute = @commandChangeSounds\n            when \"vn.ChangeColors\" then command.execute = @commandChangeColors\n            when \"gs.ChangeScreenCursor\" then command.execute = @commandChangeScreenCursor\n            when \"gs.ResetGlobalData\" then command.execute = @commandResetGlobalData\n            when \"gs.Script\" then command.execute = @commandScript\n\n    ###*\n    * Executes the command at the specified index and increases the command-pointer.\n    *\n    * @method executeCommand\n    ###\n    executeCommand: (index) ->\n        @command = @object.commands[index]\n\n        if @previewData\n            if @previewData.uid and @previewData.uid != @command.uid\n                GameManager.tempSettings.skip = yes\n                GameManager.tempSettings.skipTime = 0\n            else if @pointer < @previewData.pointer\n                GameManager.tempSettings.skip = yes\n                GameManager.tempSettings.skipTime = 0\n            else\n                GameManager.tempSettings.skip = @previewData.settings.animationDisabled\n                GameManager.tempSettings.skipTime = 0\n                @previewInfo.waiting = yes\n\n                gs.GlobalEventManager.emit(\"previewWaiting\")\n                if @previewData.settings.animationDisabled or @previewData.settings.animationTime > 0\n                    @previewInfo.timeout = setTimeout (-> Graphics.stopped = yes), (@previewData.settings.animationTime)*1000\n\n        if @command.execute?\n            @command.interpreter = this\n            @command.execute() if @command.indent == @indent\n            @pointer++\n\n            @command = @object.commands[@pointer]\n            if @command?\n                indent = @command.indent\n            else\n                indent = @indent\n                while indent > 0 and (not @loops[indent]?)\n                    indent--\n\n            if indent < @indent\n                @indent = indent\n                if @loops[@indent]?\n                    @pointer = @loops[@indent]\n                    @command = @object.commands[@pointer]\n                    @command.interpreter = this\n        else\n            @assignCommand(@command)\n\n            if @command.execute?\n                @command.interpreter = this\n                @command.execute() if @command.indent == @indent\n                @pointer++\n                @command = @object.commands[@pointer]\n                if @command?\n                    indent = @command.indent\n                else\n                    indent = @indent\n                    while indent > 0 and (not @loops[indent]?)\n                        indent--\n\n                if indent < @indent\n                    @indent = indent\n                    if @loops[@indent]?\n                        @pointer = @loops[@indent]\n                        @command = @object.commands[@pointer]\n                        @command.interpreter = this\n            else\n                @pointer++\n    ###*\n    * Skips all commands until a command with the specified indent-level is\n    * found. So for example: To jump from a Condition-Command to the next\n    * Else-Command just pass the indent-level of the Condition/Else command.\n    *\n    * @method skip\n    * @param {number} indent - The indent-level.\n    * @param {boolean} backward - If true the skip runs backward.\n    ###\n    skip: (indent, backward) ->\n        if backward\n            @pointer--\n            while @pointer > 0 and @object.commands[@pointer].indent != indent\n                @pointer--\n        else\n            @pointer++\n            while @pointer < @object.commands.length and @object.commands[@pointer].indent != indent\n                @pointer++\n\n    ###*\n    * Halts the interpreter for the specified amount of time. An optionally\n    * callback function can be passed which is called when the time is up.\n    *\n    * @method wait\n    * @param {number} time - The time to wait\n    * @param {gs.Callback} callback - Called if the wait time is up.\n    ###\n    wait: (time, callback) ->\n        @isWaiting = yes\n        @waitCounter = time\n        @waitCallback = callback\n\n    ###*\n    * Checks if the command at the specified pointer-index is a game message\n    * related command.\n    *\n    * @method isMessageCommand\n    * @param {number} pointer - The pointer/index.\n    * @param {Object[]} commands - The list of commands to check.\n    * @return {boolean} <b>true</b> if its a game message related command. Otherwise <b>false</b>.\n    ###\n    isMessageCommand: (pointer, commands) ->\n        result = yes\n        if pointer >= commands.length or (commands[pointer].id != \"gs.InputNumber\" and\n                                                commands[pointer].id != \"vn.Choice\" and\n                                                commands[pointer].id != \"gs.InputText\" and\n                                                commands[pointer].id != \"gs.InputName\")\n                result = no\n        return result\n\n    ###*\n    * Checks if the command at the specified pointer-index asks for user-input like\n    * the Input Number or Input Text command.\n    *\n    * @method isInputDataCommand\n    * @param {number} pointer - The pointer/index.\n    * @param {Object[]} commands - The list of commands to check.\n    * @return {boolean} <b>true</b> if its an input-data command. Otherwise <b>false</b>\n    ###\n    isInputDataCommand: (pointer, commands) ->\n        pointer < commands.length and (\n            commands[pointer].id == \"gs.InputNumber\" or\n            commands[pointer].id == \"gs.InputText\" or\n            commands[pointer].id == \"vn.Choice\" or\n            commands[pointer].id == \"vn.ShowChoices\"\n        )\n\n    ###*\n    * Checks if a game message is currently running by another interpreter like a\n    * common-event interpreter.\n    *\n    * @method isProcessingMessageInOtherContext\n    * @return {boolean} <b>true</b> a game message is running in another context. Otherwise <b>false</b>\n    ###\n    isProcessingMessageInOtherContext: ->\n        result = no\n        gm = GameManager\n        s = SceneManager.scene\n\n        result =\n                 (s.inputNumberWindow? and s.inputNumberWindow.visible and s.inputNumberWindow.executionContext != @context) or\n                 (s.inputTextWindow? and s.inputTextWindow.active and s.inputTextWindow.executionContext != @context)\n\n        return result\n\n    ###*\n    * If a game message is currently running by an other interpreter like a common-event\n    * interpreter, this method trigger a wait until the other interpreter is finished\n    * with the game message.\n    *\n    * @method waitForMessage\n    * @return {boolean} <b>true</b> a game message is running in another context. Otherwise <b>false</b>\n    ###\n    waitForMessage: ->\n        @isWaitingForMessage = yes\n        @isWaiting = yes\n        @pointer--\n\n\n    ###*\n    * Gets the value the number variable at the specified index.\n    *\n    * @method numberValueAtIndex\n    * @param {number} scope - The variable's scope.\n    * @param {number} index - The index of the variable to get the value from.\n    * @return {Number} The value of the variable.\n    ###\n    numberValueAtIndex: (scope, index, domain) -> GameManager.variableStore.numberValueAtIndex(scope, index, domain)\n\n    ###*\n    * Gets the value of a (possible) number variable. If a constant number value is specified, this method\n    * does nothing an just returns that constant value. That's to make it more comfortable to just pass a value which\n    * can be calculated by variable but also be just a constant value.\n    *\n    * @method numberValueOf\n    * @param {number|Object} object - A number variable or constant number value.\n    * @return {Number} The value of the variable.\n    ###\n    numberValueOf: (object) -> GameManager.variableStore.numberValueOf(object)\n\n    ###*\n    * It does the same like <b>numberValueOf</b> with one difference: If the specified object\n    * is a variable, it's value is considered as a duration-value in milliseconds and automatically converted\n    * into frames.\n    *\n    * @method durationValueOf\n    * @param {number|Object} object - A number variable or constant number value.\n    * @return {Number} The value of the variable.\n    ###\n    durationValueOf: (object) ->\n        if object and object.index?\n            Math.round(GameManager.variableStore.numberValueOf(object) / 1000 * Graphics.frameRate)\n        else\n            Math.round(GameManager.variableStore.numberValueOf(object))\n\n    ###*\n    * Gets a position ({x, y}) for the specified predefined object position configured in\n    * Database - System.\n    *\n    * @method predefinedObjectPosition\n    * @param {number} position - The index/ID of the predefined object position to set.\n    * @param {gs.Object_Base} object - The game object to set the position for.\n    * @param {Object} params - The params object of the scene command.\n    * @return {Object} The position {x, y}.\n    ###\n    predefinedObjectPosition: (position, object, params) ->\n        objectPosition = RecordManager.system.objectPositions[position]\n        if !objectPosition then return { x: 0, y: 0 }\n\n        return objectPosition.func.call(null, object, params) || { x: 0, y: 0 }\n\n    ###*\n    * Sets the value of a number variable at the specified index.\n    *\n    * @method setNumberValueAtIndex\n    * @param {number} scope - The variable's scope.\n    * @param {number} index - The index of the variable to set.\n    * @param {number} value - The number value to set the variable to.\n    ###\n    setNumberValueAtIndex: (scope, index, value, domain) -> GameManager.variableStore.setNumberValueAtIndex(scope, index, value, domain)\n\n    ###*\n    * Sets the value of a number variable.\n    *\n    * @method setNumberValueTo\n    * @param {number} variable - The variable to set.\n    * @param {number} value - The number value to set the variable to.\n    ###\n    setNumberValueTo: (variable, value) -> GameManager.variableStore.setNumberValueTo(variable, value)\n\n    ###*\n    * Sets the value of a list variable.\n    *\n    * @method setListObjectTo\n    * @param {Object} variable - The variable to set.\n    * @param {Object} value - The list object to set the variable to.\n    ###\n    setListObjectTo: (variable, value) -> GameManager.variableStore.setListObjectTo(variable, value)\n\n    ###*\n    * Sets the value of a boolean/switch variable.\n    *\n    * @method setBooleanValueTo\n    * @param {Object} variable - The variable to set.\n    * @param {boolean} value - The boolean value to set the variable to.\n    ###\n    setBooleanValueTo: (variable, value) -> GameManager.variableStore.setBooleanValueTo(variable, value)\n\n    ###*\n    * Sets the value of a number variable at the specified index.\n    *\n    * @method setBooleanValueAtIndex\n    * @param {number} scope - The variable's scope.\n    * @param {number} index - The index of the variable to set.\n    * @param {boolean} value - The boolean value to set the variable to.\n    ###\n    setBooleanValueAtIndex: (scope, index, value, domain) -> GameManager.variableStore.setBooleanValueAtIndex(scope, index, value, domain)\n\n    ###*\n    * Sets the value of a string/text variable.\n    *\n    * @method setStringValueTo\n    * @param {Object} variable - The variable to set.\n    * @param {string} value - The string/text value to set the variable to.\n    ###\n    setStringValueTo: (variable, value) -> GameManager.variableStore.setStringValueTo(variable, value)\n\n    ###*\n    * Sets the value of the string variable at the specified index.\n    *\n    * @method setStringValueAtIndex\n    * @param {number} scope - The variable scope.\n    * @param {number} index - The variable's index.\n    * @param {string} value - The value to set.\n    ###\n    setStringValueAtIndex: (scope, index, value, domain) -> GameManager.variableStore.setStringValueAtIndex(scope, index, value, domain)\n\n    ###*\n    * Gets the value of a (possible) string variable. If a constant string value is specified, this method\n    * does nothing an just returns that constant value. That's to make it more comfortable to just pass a value which\n    * can be calculated by variable but also be just a constant value.\n    *\n    * @method stringValueOf\n    * @param {string|Object} object - A string variable or constant string value.\n    * @return {string} The value of the variable.\n    ###\n    stringValueOf: (object) -> GameManager.variableStore.stringValueOf(object)\n\n    ###*\n    * Gets the value of the string variable at the specified index.\n    *\n    * @method stringValueAtIndex\n    * @param {number} scope - The variable's scope.\n    * @param {number} index - The index of the variable to get the value from.\n    * @return {string} The value of the variable.\n    ###\n    stringValueAtIndex: (scope, index, domain) -> GameManager.variableStore.stringValueAtIndex(scope, index, domain)\n\n    ###*\n    * Gets the value of a (possible) boolean variable. If a constant boolean value is specified, this method\n    * does nothing an just returns that constant value. That's to make it more comfortable to just pass a value which\n    * can be calculated by variable but also be just a constant value.\n    *\n    * @method booleanValueOf\n    * @param {boolean|Object} object - A boolean variable or constant boolean value.\n    * @return {boolean} The value of the variable.\n    ###\n    booleanValueOf: (object) -> GameManager.variableStore.booleanValueOf(object)\n\n    ###*\n    * Gets the value of the boolean variable at the specified index.\n    *\n    * @method booleanValueAtIndex\n    * @param {number} scope - The variable's scope.\n    * @param {number} index - The index of the variable to get the value from.\n    * @return {string} The value of the variable.\n    ###\n    booleanValueAtIndex: (scope, index, domain) -> GameManager.variableStore.booleanValueAtIndex(scope, index, domain)\n\n    ###*\n    * Gets the value of a (possible) list variable.\n    *\n    * @method listObjectOf\n    * @param {Object} object - A list variable.\n    * @return {Object} The value of the list variable.\n    ###\n    listObjectOf: (object) -> GameManager.variableStore.listObjectOf(object)\n\n    ###*\n    * Compares two object using the specified operation and returns the result.\n    *\n    * @method compare\n    * @param {Object} a - Object A.\n    * @param {Object} b - Object B.\n    * @param {number} operation - The compare-operation to compare Object A with Object B.\n    * <ul>\n    * <li>0 = Equal To</li>\n    * <li>1 = Not Equal To</li>\n    * <li>2 = Greater Than</li>\n    * <li>3 = Greater or Equal To</li>\n    * <li>4 = Less Than</li>\n    * <li>5 = Less or Equal To</li>\n    * </ul>\n    * @return {boolean} The comparison result.\n    ###\n    compare: (a, b, operation) ->\n        switch operation\n            when 0 then return `a == b`\n            when 1 then return `a != b`\n            when 2 then return a > b\n            when 3 then return a >= b\n            when 4 then return a < b\n            when 5 then return a <= b\n\n    ###*\n    * Changes number variables and allows decimal values such as 0.5 too.\n    *\n    * @method changeDecimalVariables\n    * @param {Object} params - Input params from the command\n    * @param {Object} roundMethod - The result of the operation will be rounded using the specified method.\n    * <ul>\n    * <li>0 = None. The result will not be rounded.</li>\n    * <li>1 = Commercially</li>\n    * <li>2 = Round Up</li>\n    * <li>3 = Round Down</li>\n    * </ul>\n    ###\n    changeDecimalVariables: (params, roundMethod) ->\n        source = 0\n        roundFunc = null\n\n        switch roundMethod\n            when 0 then roundFunc = (value) -> value\n            when 1 then roundFunc = (value) -> Math.round(value)\n            when 2 then roundFunc = (value) -> Math.ceil(value)\n            when 3 then roundFunc = (value) -> Math.floor(value)\n\n        switch params.source\n            when 0 # Constant Value / Variable Value\n                source = @numberValueOf(params.sourceValue)\n            when 1 # Random\n                start = @numberValueOf(params.sourceRandom.start)\n                end = @numberValueOf(params.sourceRandom.end)\n                diff = end - start\n                source = Math.floor(start + Math.random() * (diff+1))\n            when 2 # Pointer\n                source = @numberValueAtIndex(params.sourceScope, @numberValueOf(params.sourceReference)-1, params.sourceReferenceDomain)\n            when 3 # Game Data\n                source = @numberValueOfGameData(params.sourceValue1)\n            when 4 # Database Data\n                source = @numberValueOfDatabaseData(params.sourceValue1)\n\n        switch params.target\n            when 0 # Variable\n                switch params.operation\n                    when 0 # Set\n                        @setNumberValueTo(params.targetVariable, roundFunc(source))\n                    when 1 # Add\n                        @setNumberValueTo(params.targetVariable, roundFunc(@numberValueOf(params.targetVariable) + source) )\n                    when 2 # Sub\n                        @setNumberValueTo(params.targetVariable, roundFunc(@numberValueOf(params.targetVariable) - source) )\n                    when 3 # Mul\n                        @setNumberValueTo(params.targetVariable, roundFunc(@numberValueOf(params.targetVariable) * source))\n                    when 4 # Div\n                        @setNumberValueTo(params.targetVariable, roundFunc(@numberValueOf(params.targetVariable) / source))\n                    when 5 # Mod\n                        @setNumberValueTo(params.targetVariable, @numberValueOf(params.targetVariable) % source)\n            when 1 # Range\n                scope = params.targetScope\n                start = params.targetRange.start-1\n                end = params.targetRange.end-1\n                for i in [start..end]\n                    switch params.operation\n                        when 0 # Set\n                            @setNumberValueAtIndex(scope, i, roundFunc(source))\n                        when 1 # Add\n                            @setNumberValueAtIndex(scope, i, roundFunc(@numberValueAtIndex(scope, i) + source))\n                        when 2 # Sub\n                            @setNumberValueAtIndex(scope, i, roundFunc(@numberValueAtIndex(scope, i) - source))\n                        when 3 # Mul\n                            @setNumberValueAtIndex(scope, i, roundFunc(@numberValueAtIndex(scope, i) * source))\n                        when 4 # Div\n                            @setNumberValueAtIndex(scope, i, roundFunc(@numberValueAtIndex(scope, i) / source))\n                        when 5 # Mod\n                            @setNumberValueAtIndex(scope, i, @numberValueAtIndex(scope, i) % source)\n            when 2 # Reference\n                index = @numberValueOf(params.targetReference) - 1\n                switch params.operation\n                    when 0 # Set\n                        @setNumberValueAtIndex(params.targetScope, index, roundFunc(source), params.targetReferenceDomain)\n                    when 1 # Add\n                        @setNumberValueAtIndex(params.targetScope, index, roundFunc(@numberValueAtIndex(params.targetScope, index, params.targetReferenceDomain) + source), params.targetReferenceDomain)\n                    when 2 # Sub\n                        @setNumberValueAtIndex(params.targetScope, index, roundFunc(@numberValueAtIndex(params.targetScope, index, params.targetReferenceDomain) - source), params.targetReferenceDomain)\n                    when 3 # Mul\n                        @setNumberValueAtIndex(params.targetScope, index, roundFunc(@numberValueAtIndex(params.targetScope, index, params.targetReferenceDomain) * source), params.targetReferenceDomain)\n                    when 4 # Div\n                        @setNumberValueAtIndex(params.targetScope, index, roundFunc(@numberValueAtIndex(params.targetScope, index, params.targetReferenceDomain) / source), params.targetReferenceDomain)\n                    when 5 # Mod\n                        @setNumberValueAtIndex(params.targetScope, index, @numberValueAtIndex(params.targetScope, index, params.targetReferenceDomain) % source, params.targetReferenceDomain)\n\n        return null\n\n    ###*\n    * Shakes a game object.\n    *\n    * @method shakeObject\n    * @param {gs.Object_Base} object - The game object to shake.\n    * @return {Object} A params object containing additional info about the shake-animation.\n    ###\n    shakeObject: (object, params) ->\n        duration = Math.max(Math.round(@durationValueOf(params.duration)), 2)\n        easing = gs.Easings.fromObject(params.easing)\n\n        object.animator.shake({ x: @numberValueOf(params.range.x), y: @numberValueOf(params.range.y) }, @numberValueOf(params.speed) / 100, duration, easing)\n\n        if params.waitForCompletion and not (duration == 0 or @isInstantSkip())\n            @isWaiting = yes\n            @waitCounter = duration\n\n    ###*\n    * Lets the interpreter wait for the completion of a running operation like an animation, etc.\n    *\n    * @method waitForCompletion\n    * @param {gs.Object_Base} object - The game object the operation is executed on. Can be <b>null</b>.\n    * @return {Object} A params object containing additional info.\n    ###\n    waitForCompletion: (object, params) ->\n        duration = @durationValueOf(params.duration)\n        if params.waitForCompletion and not (duration == 0 or @isInstantSkip())\n            @isWaiting = yes\n            @waitCounter = duration\n\n    ###*\n    * Erases a game object.\n    *\n    * @method eraseObject\n    * @param {gs.Object_Base} object - The game object to erase.\n    * @return {Object} A params object containing additional info.\n    ###\n    eraseObject: (object, params, callback) ->\n        easing = gs.Easings.fromObject(params.easing)\n        duration = @durationValueOf(params.duration)\n        object.animator.disappear(params.animation, easing, duration, (sender) =>\n            sender.dispose()\n            callback?(sender)\n        )\n\n        if params.waitForCompletion and not (duration == 0 or @isInstantSkip())\n            @isWaiting = yes\n            @waitCounter = duration\n\n    ###*\n    * Shows a game object on screen.\n    *\n    * @method showObject\n    * @param {gs.Object_Base} object - The game object to show.\n    * @param {gs.Point} position - The position where the game object should be shown.\n    * @param {Object} A params object containing additional info.\n    ###\n    showObject: (object, position, params) ->\n        x = @numberValueOf(position.x)\n        y = @numberValueOf(position.y)\n        easing = gs.Easings.fromObject(params.easing)\n        duration = @durationValueOf(params.duration)\n\n        object.animator.appear(x, y, params.animation, easing, duration)\n\n        if params.waitForCompletion and not (duration == 0 or @isInstantSkip())\n            @isWaiting = yes\n            @waitCounter = duration\n\n\n    ###*\n    * Moves a game object.\n    *\n    * @method moveObject\n    * @param {gs.Object_Base} object - The game object to move.\n    * @param {gs.Point} position - The position to move the game object to.\n    * @param {Object} A params object containing additional info.\n    ###\n    moveObject: (object, position, params) ->\n        if params.positionType == 0\n            p = @predefinedObjectPosition(params.predefinedPositionId, object, params)\n            x = p.x\n            y = p.y\n        else\n            x = @numberValueOf(position.x)\n            y = @numberValueOf(position.y)\n\n        easing = gs.Easings.fromObject(params.easing)\n        duration = @durationValueOf(params.duration)\n\n        zoom = object.zoom\n        if object.anchor.x != 0 and object.anchor.y != 0\n            bitmap = object.bitmap\n            if bitmap?\n                x += (bitmap.width*zoom.x-bitmap.width) * object.anchor.x\n                y += (bitmap.height*zoom.y-bitmap.height) * object.anchor.y\n\n        object.animator.moveTo(x, y, duration, easing)\n\n        if params.waitForCompletion and not (duration == 0 or @isInstantSkip())\n            @isWaiting = yes\n            @waitCounter = duration\n\n    ###*\n    * Moves a game object along a path.\n    *\n    * @method moveObjectPath\n    * @param {gs.Object_Base} object - The game object to move.\n    * @param {Object} path - The path to move the game object along.\n    * @param {Object} A params object containing additional info.\n    ###\n    moveObjectPath: (object, path, params) ->\n        easing = gs.Easings.fromObject(params.easing)\n        duration = @durationValueOf(params.duration)\n        object.animator.movePath(path.data, params.loopType, duration, easing, path.effects?.data)\n\n        if params.waitForCompletion and not (duration == 0 or @isInstantSkip())\n            @isWaiting = yes\n            @waitCounter = duration\n\n    ###*\n    * Scrolls a scrollable game object along a path.\n    *\n    * @method scrollObjectPath\n    * @param {gs.Object_Base} object - The game object to scroll.\n    * @param {Object} path - The path to scroll the game object along.\n    * @param {Object} A params object containing additional info.\n    ###\n    scrollObjectPath: (object, path, params) ->\n        easing = gs.Easings.fromObject(params.easing)\n        duration = @durationValueOf(params.duration)\n        object.animator.scrollPath(path, params.loopType, duration, easing)\n\n        if params.waitForCompletion and not (duration == 0 or @isInstantSkip())\n            @isWaiting = yes\n            @waitCounter = duration\n\n    ###*\n    * Zooms/Scales a game object.\n    *\n    * @method zoomObject\n    * @param {gs.Object_Base} object - The game object to zoom.\n    * @param {Object} A params object containing additional info.\n    ###\n    zoomObject: (object, params) ->\n        easing = gs.Easings.fromObject(params.easing)\n        duration = @durationValueOf(params.duration)\n        object.animator.zoomTo(@numberValueOf(params.zooming.x) / 100, @numberValueOf(params.zooming.y) / 100, duration, easing)\n\n        if params.waitForCompletion and not (duration == 0 or @isInstantSkip())\n            @isWaiting = yes\n            @waitCounter = duration\n\n    ###*\n    * Rotates a game object.\n    *\n    * @method rotateObject\n    * @param {gs.Object_Base} object - The game object to rotate.\n    * @param {Object} A params object containing additional info.\n    ###\n    rotateObject: (object, params) ->\n        easing = gs.Easings.fromObject(params.easing)\n        duration = @durationValueOf(params.duration)\n\n\n        easing = gs.Easings.fromObject(params.easing)\n\n        #if GameManager.tempSettings.skip\n        #    actualDuration = @durationValueOf(@params.duration)\n        #    duration = @durationValueOf(@duration)\n        #    speed = @numberValueOf(@params.speed) / 100\n        #    speed = Math.round(duration / (actualDuration||1) * speed)\n        #    picture.animator.rotate(@params.direction, speed, actualDuration||1, easing)\n        #    duration = actualDuration\n        #else\n        #    duration = @durationValueOf(params.duration)\n        #    object.animator.rotate(params.direction, @numberValueOf(@params.speed) / 100, duration, easing)\n\n        object.animator.rotate(params.direction, @numberValueOf(params.speed) / 100, duration, easing)\n\n        if params.waitForCompletion and not (duration == 0 or @isInstantSkip())\n            @isWaiting = yes\n            @waitCounter = duration\n\n    ###*\n    * Blends a game object.\n    *\n    * @method blendObject\n    * @param {gs.Object_Base} object - The game object to blend.\n    * @param {Object} A params object containing additional info.\n    ###\n    blendObject: (object, params) ->\n        easing = gs.Easings.fromObject(params.easing)\n        duration = @durationValueOf(params.duration)\n        object.animator.blendTo(@numberValueOf(params.opacity), duration, easing)\n\n        if params.waitForCompletion and not (duration == 0 or @isInstantSkip())\n            @isWaiting = yes\n            @waitCounter = duration\n\n    ###*\n    * Executes a masking-effect on a game object..\n    *\n    * @method maskObject\n    * @param {gs.Object_Base} object - The game object to execute a masking-effect on.\n    * @param {Object} A params object containing additional info.\n    ###\n    maskObject: (object, params) ->\n        easing = gs.Easings.fromObject(params.easing)\n\n        if params.mask.type == 0\n            object.mask.type = 0\n            object.mask.ox = @numberValueOf(params.mask.ox)\n            object.mask.oy = @numberValueOf(params.mask.oy)\n            if object.mask.source?.videoElement?\n                object.mask.source.pause()\n\n            if params.mask.sourceType == 0\n                object.mask.source = ResourceManager.getBitmap(\"Graphics/Masks/#{params.mask.graphic?.name}\")\n            else\n                object.mask.source = ResourceManager.getVideo(\"Movies/#{params.mask.video?.name}\")\n                if object.mask.source\n                    object.mask.source.play()\n                    object.mask.source.loop = yes\n        else\n            duration = @durationValueOf(params.duration)\n            mask = Object.flatCopy(params.mask)\n            mask.value = @numberValueOf(mask.value)\n            object.animator.maskTo(mask, duration, easing)\n\n        if params.waitForCompletion and not (duration == 0 or @isInstantSkip())\n            @isWaiting = yes\n            @waitCounter = duration\n\n    ###*\n    * Tints a game object.\n    *\n    * @method tintObject\n    * @param {gs.Object_Base} object - The game object to tint.\n    * @param {Object} A params object containing additional info.\n    ###\n    tintObject: (object, params) ->\n        duration = @durationValueOf(params.duration)\n        easing = gs.Easings.fromObject(params.easing)\n        object.animator.tintTo(params.tone, duration, easing)\n\n        if params.waitForCompletion and not (duration == 0 or @isInstantSkip())\n            @isWaiting = yes\n            @waitCounter = duration\n\n    ###*\n    * Flashes a game object.\n    *\n    * @method flashObject\n    * @param {gs.Object_Base} object - The game object to flash.\n    * @param {Object} A params object containing additional info.\n    ###\n    flashObject: (object, params) ->\n        duration = @durationValueOf(params.duration)\n        object.animator.flash(new Color(params.color), duration)\n\n        if params.waitForCompletion and not (duration == 0 or @isInstantSkip())\n            @isWaiting = yes\n            @waitCounter = duration\n\n    ###*\n    * Cropes a game object.\n    *\n    * @method cropObject\n    * @param {gs.Object_Base} object - The game object to crop.\n    * @param {Object} A params object containing additional info.\n    ###\n    cropObject: (object, params) ->\n        object.srcRect.x = @numberValueOf(params.x)\n        object.srcRect.y = @numberValueOf(params.y)\n        object.srcRect.width = @numberValueOf(params.width)\n        object.srcRect.height = @numberValueOf(params.height)\n\n        object.dstRect.width = @numberValueOf(params.width)\n        object.dstRect.height = @numberValueOf(params.height)\n\n    ###*\n    * Sets the motion blur settings of a game object.\n    *\n    * @method objectMotionBlur\n    * @param {gs.Object_Base} object - The game object to set the motion blur settings for.\n    * @param {Object} A params object containing additional info.\n    ###\n    objectMotionBlur: (object, params) ->\n        object.motionBlur.set(params.motionBlur)\n\n    ###*\n    * Enables an effect on a game object.\n    *\n    * @method objectEffect\n    * @param {gs.Object_Base} object - The game object to execute a masking-effect on.\n    * @param {Object} A params object containing additional info.\n    ###\n    objectEffect: (object, params) ->\n        duration = @durationValueOf(params.duration)\n        easing = gs.Easings.fromObject(params.easing)\n\n        switch params.type\n            when 0 # Wobble\n                object.animator.wobbleTo(params.wobble.power / 10000, params.wobble.speed / 100, duration, easing)\n                wobble = object.effects.wobble\n                wobble.enabled = params.wobble.power > 0\n                wobble.vertical = params.wobble.orientation == 0 or params.wobble.orientation == 2\n                wobble.horizontal = params.wobble.orientation == 1 or params.wobble.orientation == 2\n            when 1 # Blur\n                object.animator.blurTo(params.blur.power / 100, duration, easing)\n                object.effects.blur.enabled = yes\n            when 2 # Pixelate\n                object.animator.pixelateTo(params.pixelate.size.width, params.pixelate.size.height, duration, easing)\n                object.effects.pixelate.enabled = yes\n\n        if params.waitForCompletion and duration != 0\n            @isWaiting = yes\n            @waitCounter = duration\n\n    ###*\n    * Executes an action like for a hotspot.\n    *\n    * @method executeAction\n    * @param {Object} action - Action-Data.\n    * @param {boolean} stateValue - In case of switch-binding, the switch is set to this value.\n    * @param {number} bindValue - A number value which be put into the action's bind-value variable.\n    ###\n    executeAction: (action, stateValue, bindValue) ->\n        switch action.type\n            when 0 # Jump To Label\n                if action.labelIndex\n                    @pointer = action.labelIndex\n                else\n                    @jumpToLabel(action.label)\n            when 1 # Call Common Event\n                @callCommonEvent(action.commonEventId, null, @isWaiting)\n            when 2 # Bind To Switch\n                domain = GameManager.variableStore.domain\n                @setBooleanValueTo(action.switch, stateValue)\n            when 3 # Call Scene\n                @callScene(action.scene?.uid)\n            when 4 # Bind Value to Variable\n                domain = GameManager.variableStore.domain\n                @setNumberValueTo(action.bindValueVariable, bindValue)\n                if action.labelIndex\n                    @pointer = action.labelIndex\n                else\n                    @jumpToLabel(action.label)\n\n    ###*\n    * Calls a common event and returns the sub-interpreter for it.\n    *\n    * @method callCommonEvent\n    * @param {number} id - The ID of the common event to call.\n    * @param {Object} parameters - Optional common event parameters.\n    * @param {boolean} wait - Indicates if the interpreter should be stay in waiting-mode even if the sub-interpreter is finished.\n    ###\n    callCommonEvent: (id, parameters, wait) ->\n        commonEvent = GameManager.commonEvents[id]\n\n        if commonEvent?\n            if SceneManager.scene.commonEventContainer.subObjects.indexOf(commonEvent) == -1\n                SceneManager.scene.commonEventContainer.addObject(commonEvent)\n            commonEvent.events?.on \"finish\", gs.CallBack(\"onCommonEventFinish\", this), { waiting: wait }\n\n            @subInterpreter = commonEvent.behavior.call(parameters || [], @settings, @context)\n            #GameManager.variableStore.setupLocalVariables(@subInterpreter.context)\n            #GameManager.variableStore.setupTempVariables(@subInterpreter.context)\n            commonEvent.behavior.update()\n\n            if @subInterpreter?\n                @isWaiting = yes\n                @subInterpreter.settings = @settings\n                @subInterpreter.start()\n                @subInterpreter.update()\n\n    ###*\n    * Calls a scene and returns the sub-interpreter for it.\n    *\n    * @method callScene\n    * @param {String} uid - The UID of the scene to call.\n    ###\n    callScene: (uid) ->\n        sceneDocument = DataManager.getDocument(uid)\n\n        if sceneDocument?\n            @isWaiting = yes\n            @subInterpreter = new vn.Component_CallSceneInterpreter()\n            object = { commands: sceneDocument.items.commands }\n            @subInterpreter.repeat = no\n            @subInterpreter.context.set(sceneDocument.uid, sceneDocument)\n            @subInterpreter.object = object\n            @subInterpreter.onFinish = gs.CallBack(\"onCallSceneFinish\", this)\n            @subInterpreter.start()\n            @subInterpreter.settings = @settings\n            @subInterpreter.update()\n\n\n\n    ###*\n    * Calls a common event and returns the sub-interpreter for it.\n    *\n    * @method storeListValue\n    * @param {number} id - The ID of the common event to call.\n    * @param {Object} parameters - Optional common event parameters.\n    * @param {boolean} wait - Indicates if the interpreter should be stay in waiting-mode even if the sub-interpreter is finished.\n    ###\n    storeListValue: (variable, list, value, valueType) ->\n        switch valueType\n            when 0 # Number Value\n                @setNumberValueTo(variable, (if !isNaN(value) then value else 0))\n            when 1 # Switch Value\n                @setBooleanValueTo(variable, (if value then 1 else 0))\n            when 2 # Text Value\n                @setStringValueTo(variable, value.toString())\n            when 3 # List Value\n                @setListObjectTo(variable, (if value.length? then value else []))\n\n    ###*\n    * @method jumpToLabel\n    ###\n    jumpToLabel: (label) ->\n        return if not label\n        found = no\n\n        for i in [0...@object.commands.length]\n            if @object.commands[i].id == \"gs.Label\" and @object.commands[i].params.name == label\n                @pointer = i\n                @indent = @object.commands[i].indent\n                found = yes\n                break\n\n        if found\n            @waitCounter = 0\n            @isWaiting = no\n\n    ###*\n    * Gets the current message box object depending on game mode (ADV or NVL).\n    *\n    * @method messageBoxObject\n    * @return {gs.Object_Base} The message box object.\n    * @protected\n    ###\n    messageBoxObject: (id) ->\n        if SceneManager.scene.layout.visible\n            return gs.ObjectManager.current.objectById(id || \"messageBox\")\n        else\n            return gs.ObjectManager.current.objectById(id || \"nvlMessageBox\")\n\n    ###*\n    * Gets the current message object depending on game mode (ADV or NVL).\n    *\n    * @method messageObject\n    * @return {ui.Object_Message} The message object.\n    * @protected\n    ###\n    messageObject: ->\n        if SceneManager.scene.layout.visible\n            return gs.ObjectManager.current.objectById(\"gameMessage_message\")\n        else\n            return gs.ObjectManager.current.objectById(\"nvlGameMessage_message\")\n    ###*\n    * Gets the current message ID depending on game mode (ADV or NVL).\n    *\n    * @method messageObjectId\n    * @return {string} The message object ID.\n    * @protected\n    ###\n    messageObjectId: ->\n        if SceneManager.scene.layout.visible\n            return \"gameMessage_message\"\n        else\n            return \"nvlGameMessage_message\"\n\n    ###*\n    * Gets the current message settings.\n    *\n    * @method messageSettings\n    * @return {Object} The message settings\n    * @protected\n    ###\n    messageSettings: ->\n        message = @targetMessage()\n\n        return message.settings\n\n    ###*\n    * Gets the current target message object where all message commands are executed on.\n    *\n    * @method targetMessage\n    * @return {ui.Object_Message} The target message object.\n    * @protected\n    ###\n    targetMessage: ->\n        message = @messageObject()\n        target = @settings.message.target\n        if target?\n            switch target.type\n                when 0 # Layout-Based\n                    message = gs.ObjectManager.current.objectById(target.id) ? @messageObject()\n                when 1 # Custom\n                    message = SceneManager.scene.messageAreas[target.id]?.message ? @messageObject()\n\n        return message\n\n    ###*\n    * Gets the current target message box containing the current target message.\n    *\n    * @method targetMessageBox\n    * @return {ui.Object_UIElement} The target message box.\n    * @protected\n    ###\n    targetMessageBox: ->\n        messageBox = @messageObject()\n        target = @settings.message.target\n        if target?\n            switch target.type\n                when 0 # Layout-Based\n                    messageBox = gs.ObjectManager.current.objectById(target.id) ? @messageObject()\n                when 1 # Custom\n                    messageBox = gs.ObjectManager.current.objectById(\"customGameMessage_\"+target.id) ? @messageObject()\n\n        return messageBox\n\n    ###*\n    * Called after an input number dialog was accepted by the user. It takes the user's input and puts\n    * it in the configured number variable.\n    *\n    * @method onInputNumberFinish\n    * @return {Object} Event Object containing additional data like the number, etc.\n    * @protected\n    ###\n    onInputNumberFinish: (e) ->\n        @messageObject().behavior.clear()\n        @setNumberValueTo(@waitingFor.inputNumber.variable, parseInt(ui.Component_FormulaHandler.fieldValue(e.sender, e.number)))\n        @isWaiting = no\n        @waitingFor.inputNumber = null\n        SceneManager.scene.inputNumberBox.dispose()\n\n    ###*\n    * Called after an input text dialog was accepted by the user. It takes the user's text input and puts\n    * it in the configured string variable.\n    *\n    * @method onInputTextFinish\n    * @return {Object} Event Object containing additional data like the text, etc.\n    * @protected\n    ###\n    onInputTextFinish: (e) ->\n        @messageObject().behavior.clear()\n        @setStringValueTo(@waitingFor.inputText.variable, ui.Component_FormulaHandler.fieldValue(e.sender, e.text).replace(/_/g, \"\"))\n        @isWaiting = no\n        @waitingFor.inputText = null\n        SceneManager.scene.inputTextBox.dispose()\n\n    ###*\n    * Called after a choice was selected by the user. It jumps to the corresponding label\n    * and also puts the choice into backlog.\n    *\n    * @method onChoiceAccept\n    * @return {Object} Event Object containing additional data like the label, etc.\n    * @protected\n    ###\n    onChoiceAccept: (e) ->\n        scene = SceneManager.scene\n        scene.choiceTimer.behavior.stop()\n\n        e.isSelected = yes\n        delete e.sender\n\n        GameManager.backlog.push({ character: { name: \"\" }, message: \"\", choice: e, choices: scene.choices, isChoice: yes })\n        scene.choices = []\n        messageObject = @messageObject()\n        if messageObject?.visible\n            @isWaiting = yes\n            fading = GameManager.tempSettings.messageFading\n            duration = if GameManager.tempSettings.skip then 0 else fading.duration\n            messageObject.animator.disappear(fading.animation, fading.easing, duration, =>\n                messageObject.behavior.clear()\n                messageObject.visible = no\n                @isWaiting = no\n                @waitingFor.choice = null\n                @executeAction(e.action, true)\n            )\n        else\n            @isWaiting = no\n            @executeAction(e.action, true)\n        scene.choiceWindow.dispose()\n\n    ###*\n    * Idle\n    * @method commandIdle\n    * @protected\n    ###\n    commandIdle: ->\n        @interpreter.isWaiting = !@interpreter.isInstantSkip()\n\n\n    ###*\n    * Start Timer\n    * @method commandStartTimer\n    * @protected\n    ###\n    commandStartTimer: ->\n        scene = SceneManager.scene\n        timers = scene.timers\n        number = @interpreter.numberValueOf(@params.number)\n        timer = timers[number]\n        if not timer?\n            timer = new gs.Object_IntervalTimer()\n            timers[number] = timer\n\n        timer.events.offByOwner(\"elapsed\", @object)\n        timer.events.on(\"elapsed\", (e) =>\n            params = e.data.params\n            switch params.action.type\n                when 0 # Jump To Label\n                    if params.labelIndex?\n                        SceneManager.scene.interpreter.pointer = params.labelIndex\n                    else\n                        SceneManager.scene.interpreter.jumpToLabel(params.action.data.label)\n                when 1 # Call Common Event\n                    SceneManager.scene.interpreter.callCommonEvent(params.action.data.commonEventId, null, @interpreter.isWaiting)\n        { params: @params }, @object)\n\n        timer.behavior.interval = @interpreter.durationValueOf(@params.interval)\n        timer.behavior.start()\n\n\n    ###*\n    * Resume Timer\n    * @method commandResumeTimer\n    * @protected\n    ###\n    commandResumeTimer: ->\n        timers = SceneManager.scene.timers\n        number = @interpreter.numberValueOf(@params.number)\n        timers[number]?.behavior.resume()\n\n    ###*\n    * Pauses Timer\n    * @method commandPauseTimer\n    * @protected\n    ###\n    commandPauseTimer: ->\n        timers = SceneManager.scene.timers\n        number = @interpreter.numberValueOf(@params.number)\n        timers[number]?.behavior.pause()\n\n    ###*\n    * Stop Timer\n    * @method commandStopTimer\n    * @protected\n    ###\n    commandStopTimer: ->\n        timers = SceneManager.scene.timers\n        number = @interpreter.numberValueOf(@params.number)\n        timers[number]?.behavior.stop()\n\n    ###*\n    * Wait\n    * @method commandWait\n    * @protected\n    ###\n    commandWait: ->\n        time = @interpreter.durationValueOf(@params.time)\n\n        if time? and time > 0 and !@interpreter.previewData\n            @interpreter.waitCounter = time\n            @interpreter.isWaiting = yes\n\n    ###*\n    * Loop\n    * @method commandLoop\n    * @protected\n    ###\n    commandLoop: ->\n        @interpreter.loops[@interpreter.indent] = @interpreter.pointer\n        @interpreter.indent++\n\n    ###*\n    * Break Loop\n    * @method commandBreakLoop\n    * @protected\n    ###\n    commandBreakLoop: ->\n        indent = @indent\n        while not @interpreter.loops[indent]? and indent > 0\n            indent--\n\n        @interpreter.loops[indent] = null\n        @interpreter.indent = indent\n\n    ###*\n    * @method commandListAdd\n    * @protected\n    ###\n    commandListAdd: ->\n        list = @interpreter.listObjectOf(@params.listVariable)\n\n        switch @params.valueType\n            when 0 # Number Value\n                list.push(@interpreter.numberValueOf(@params.numberValue))\n            when 1 # Switch Value\n                list.push(@interpreter.booleanValueOf(@params.switchValue))\n            when 2 # Text Value\n                list.push(@interpreter.stringValueOf(@params.stringValue))\n            when 3 # List Value\n                list.push(@interpreter.listObjectOf(@params.listValue))\n\n        @interpreter.setListObjectTo(@params.listVariable, list)\n\n    ###*\n    * @method commandListPop\n    * @protected\n    ###\n    commandListPop: ->\n        list = @interpreter.listObjectOf(@params.listVariable)\n        value = list.pop() ? 0\n\n        @interpreter.storeListValue(@params.targetVariable, list, value, @params.valueType)\n\n    ###*\n    * @method commandListShift\n    * @protected\n    ###\n    commandListShift: ->\n        list = @interpreter.listObjectOf(@params.listVariable)\n        value = list.shift() ? 0\n\n        @interpreter.storeListValue(@params.targetVariable, list, value, @params.valueType)\n\n    ###*\n    * @method commandListIndexOf\n    * @protected\n    ###\n    commandListIndexOf: ->\n        list = @interpreter.listObjectOf(@params.listVariable)\n        value = -1\n\n        switch @params.valueType\n            when 0 # Number Value\n                value = list.indexOf(@interpreter.numberValueOf(@params.numberValue))\n            when 1 # Switch Value\n                value = list.indexOf(@interpreter.booleanValueOf(@params.switchValue))\n            when 2 # Text Value\n                value = list.indexOf(@interpreter.stringValueOf(@params.stringValue))\n            when 3 # List Value\n                value = list.indexOf(@interpreter.listObjectOf(@params.listValue))\n\n        @interpreter.setNumberValueTo(@params.targetVariable, value)\n\n    ###*\n    * @method commandListClear\n    * @protected\n    ###\n    commandListClear: ->\n        list = @interpreter.listObjectOf(@params.listVariable)\n        list.length = 0\n\n    ###*\n    * @method commandListValueAt\n    * @protected\n    ###\n    commandListValueAt: ->\n        list = @interpreter.listObjectOf(@params.listVariable)\n        index = @interpreter.numberValueOf(@params.index)\n\n        if index >= 0 and index < list.length\n            value = list[index] ? 0\n            @interpreter.storeListValue(@params.targetVariable, list, value, @params.valueType)\n\n    ###*\n    * @method commandListRemoveAt\n    * @protected\n    ###\n    commandListRemoveAt: ->\n        list = @interpreter.listObjectOf(@params.listVariable)\n        index = @interpreter.numberValueOf(@params.index)\n\n        if index >= 0 and index < list.length\n            list.splice(index, 1)\n\n    ###*\n    * @method commandListInsertAt\n    * @protected\n    ###\n    commandListInsertAt: ->\n        list = @interpreter.listObjectOf(@params.listVariable)\n        index = @interpreter.numberValueOf(@params.index)\n\n        if index >= 0 and index < list.length\n            switch @params.valueType\n                when 0 # Number Value\n                    list.splice(index, 0, @interpreter.numberValueOf(@params.numberValue))\n                when 1 # Switch Value\n                    list.splice(index, 0, @interpreter.booleanValueOf(@params.switchValue))\n                when 2 # Text Value\n                    list.splice(index, 0, @interpreter.stringValueOf(@params.stringValue))\n                when 3 # List Value\n                    list.splice(index, 0, @interpreter.listObjectOf(@params.listValue))\n\n            @interpreter.setListObjectTo(@params.listVariable, list)\n\n    ###*\n    * @method commandListSet\n    * @protected\n    ###\n    commandListSet: ->\n        list = @interpreter.listObjectOf(@params.listVariable)\n        index = @interpreter.numberValueOf(@params.index)\n\n        if index >= 0\n            switch @params.valueType\n                when 0 # Number Value\n                    list[index] = @interpreter.numberValueOf(@params.numberValue)\n                when 1 # Switch Value\n                    list[index] = @interpreter.booleanValueOf(@params.switchValue)\n                when 2 # Text Value\n                    list[index] = @interpreter.stringValueOf(@params.stringValue)\n                when 3 # List Value\n                    list[index] = @interpreter.listObjectOf(@params.listValue)\n\n            @interpreter.setListObjectTo(@params.listVariable, list)\n\n    ###*\n    * @method commandListCopy\n    * @protected\n    ###\n    commandListCopy: ->\n        list = @interpreter.listObjectOf(@params.listVariable)\n        copy = Object.deepCopy(list)\n\n        @interpreter.setListObjectTo(@params.targetVariable, copy)\n\n    ###*\n    * @method commandListLength\n    * @protected\n    ###\n    commandListLength: ->\n        list = @interpreter.listObjectOf(@params.listVariable)\n\n        @interpreter.setNumberValueTo(@params.targetVariable, list.length)\n\n    ###*\n    * @method commandListJoin\n    * @protected\n    ###\n    commandListJoin: ->\n        list = @interpreter.listObjectOf(@params.listVariable)\n        value = if @params.order == 0 then list.join(@params.separator||\"\") else list.reverse().join(@params.separator||\"\")\n\n        @interpreter.setStringValueTo(@params.targetVariable, value)\n\n    ###*\n    * @method commandListFromText\n    * @protected\n    ###\n    commandListFromText: ->\n        text = @interpreter.stringValueOf(@params.textVariable)\n        separator = @interpreter.stringValueOf(@params.separator)\n        list = text.split(separator)\n\n        @interpreter.setListObjectTo(@params.targetVariable, list)\n\n    ###*\n    * @method commandListShuffle\n    * @protected\n    ###\n    commandListShuffle: ->\n        list = @interpreter.listObjectOf(@params.listVariable)\n        if list.length == 0 then return\n\n        for i in [list.length-1..1]\n            j = Math.floor(Math.random() * (i+1))\n            tempi = list[i]\n            tempj = list[j]\n            list[i] = tempj\n            list[j] = tempi\n\n    ###*\n    * @method commandListSort\n    * @protected\n    ###\n    commandListSort: ->\n        list = @interpreter.listObjectOf(@params.listVariable)\n        if list.length == 0 then return\n\n        switch @params.sortOrder\n            when 0 # Ascending\n                list.sort (a, b) ->\n                    if a < b then return -1\n                    if a > b then return 1\n                    return 0\n            when 1 # Descending\n                list.sort (a, b) ->\n                    if a > b then return -1\n                    if a < b then return 1\n                    return 0\n\n\n    ###*\n    * @method commandResetVariables\n    * @protected\n    ###\n    commandResetVariables: ->\n        switch @params.target\n            when 0 # All\n                range = null\n            when 1 # Range\n                range = @params.range\n\n        switch @params.scope\n            when 0 # Local\n                if @params.scene\n                    GameManager.variableStore.clearLocalVariables({ id: @params.scene.uid }, @params.type, range)\n            when 1 # All Locals\n                GameManager.variableStore.clearLocalVariables(null, @params.type, range)\n            when 2 # Global\n                GameManager.variableStore.clearGlobalVariables(@params.type, range)\n            when 3 # Persistent\n                GameManager.variableStore.clearPersistentVariables(@params.type, range)\n                GameManager.saveGlobalData()\n\n\n    ###*\n    * @method commandChangeVariableDomain\n    * @protected\n    ###\n    commandChangeVariableDomain: ->\n        GameManager.variableStore.changeDomain(@interpreter.stringValueOf(@params.domain))\n\n    ###*\n    * @method commandChangeDecimalVariables\n    * @protected\n    ###\n    commandChangeDecimalVariables: -> @interpreter.changeDecimalVariables(@params, @params.roundMethod)\n\n    ###*\n    * @method commandChangeNumberVariables\n    * @protected\n    ###\n    commandChangeNumberVariables: ->\n        source = 0\n\n        switch @params.source\n            when 0 # Constant Value / Variable Value\n                source = @interpreter.numberValueOf(@params.sourceValue)\n            when 1 # Random\n                start = @interpreter.numberValueOf(@params.sourceRandom.start)\n                end = @interpreter.numberValueOf(@params.sourceRandom.end)\n                diff = end - start\n                source = Math.floor(start + Math.random() * (diff+1))\n            when 2 # Pointer\n                source = @interpreter.numberValueAtIndex(@params.sourceScope, @interpreter.numberValueOf(@params.sourceReference)-1, @params.sourceReferenceDomain)\n            when 3 # Game Data\n                source = @interpreter.numberValueOfGameData(@params.sourceValue1)\n            when 4 # Database Data\n                source = @interpreter.numberValueOfDatabaseData(@params.sourceValue1)\n\n        switch @params.target\n            when 0 # Variable\n                switch @params.operation\n                    when 0 # Set\n                        @interpreter.setNumberValueTo(@params.targetVariable, source)\n                    when 1 # Add\n                        @interpreter.setNumberValueTo(@params.targetVariable, @interpreter.numberValueOf(@params.targetVariable) + source)\n                    when 2 # Sub\n                        @interpreter.setNumberValueTo(@params.targetVariable, @interpreter.numberValueOf(@params.targetVariable) - source)\n                    when 3 # Mul\n                        @interpreter.setNumberValueTo(@params.targetVariable, @interpreter.numberValueOf(@params.targetVariable) * source)\n                    when 4 # Div\n                        @interpreter.setNumberValueTo(@params.targetVariable, Math.floor(@interpreter.numberValueOf(@params.targetVariable) / source))\n                    when 5 # Mod\n                        @interpreter.setNumberValueTo(@params.targetVariable, @interpreter.numberValueOf(@params.targetVariable) % source)\n            when 1 # Range\n                scope = @params.targetScope\n                start = @params.targetRange.start-1\n                end = @params.targetRange.end-1\n                for i in [start..end]\n                    switch @params.operation\n                        when 0 # Set\n                            @interpreter.setNumberValueAtIndex(scope, i, source)\n                        when 1 # Add\n                            @interpreter.setNumberValueAtIndex(scope, i, @interpreter.numberValueAtIndex(scope, i) + source)\n                        when 2 # Sub\n                            @interpreter.setNumberValueAtIndex(scope, i, @interpreter.numberValueAtIndex(scope, i) - source)\n                        when 3 # Mul\n                            @interpreter.setNumberValueAtIndex(scope, i, @interpreter.numberValueAtIndex(scope, i) * source)\n                        when 4 # Div\n                            @interpreter.setNumberValueAtIndex(scope, i, Math.floor(@interpreter.numberValueAtIndex(scope, i) / source))\n                        when 5 # Mod\n                            @interpreter.setNumberValueAtIndex(scope, i, @interpreter.numberValueAtIndex(scope, i) % source)\n            when 2 # Reference\n                index = @interpreter.numberValueOf(@params.targetReference) - 1\n                switch @params.operation\n                    when 0 # Set\n                        @interpreter.setNumberValueAtIndex(@params.targetScope, index, source, @params.targetReferenceDomain)\n                    when 1 # Add\n                        @interpreter.setNumberValueAtIndex(@params.targetScope, index, @interpreter.numberValueAtIndex(@params.targetScope, index, @params.targetReferenceDomain) + source, @params.targetReferenceDomain)\n                    when 2 # Sub\n                        @interpreter.setNumberValueAtIndex(@params.targetScope, index, @interpreter.numberValueAtIndex(@params.targetScope, index, @params.targetReferenceDomain) - source, @params.targetReferenceDomain)\n                    when 3 # Mul\n                        @interpreter.setNumberValueAtIndex(@params.targetScope, index, @interpreter.numberValueAtIndex(@params.targetScope, index, @params.targetReferenceDomain) * source, @params.targetReferenceDomain)\n                    when 4 # Div\n                        @interpreter.setNumberValueAtIndex(@params.targetScope, index, Math.floor(@interpreter.numberValueAtIndex(@params.targetScope, index, @params.targetReferenceDomain) / source), @params.targetReferenceDomain)\n                    when 5 # Mod\n                        @interpreter.setNumberValueAtIndex(@params.targetScope, index, @interpreter.numberValueAtIndex(@params.targetScope, index, @params.targetReferenceDomain) % source, @params.targetReferenceDomain)\n\n        return null\n\n    ###*\n    * @method commandChangeBooleanVariables\n    * @protected\n    ###\n    commandChangeBooleanVariables: ->\n        source = @interpreter.booleanValueOf(@params.value)\n\n        switch @params.target\n            when 0 # Variable\n                if @params.value == 2 # Trigger\n                    targetValue = @interpreter.booleanValueOf(@params.targetVariable)\n                    @interpreter.setBooleanValueTo(@params.targetVariable, if targetValue then false else true)\n                else\n                    @interpreter.setBooleanValueTo(@params.targetVariable, source)\n            when 1 # Range\n                variable = { index: 0, scope: @params.targetRangeScope }\n                for i in [(@params.rangeStart-1)..(@params.rangeEnd-1)]\n                    variable.index = i\n                    if @params.value == 2 # Trigger\n                        targetValue = @interpreter.booleanValueOf(variable)\n                        @interpreter.setBooleanValueTo(variable, if targetValue then false else true)\n                    else\n                        @interpreter.setBooleanValueTo(variable, source)\n            when 2 # Reference\n                index = @interpreter.numberValueOf(@params.targetReference) - 1\n                @interpreter.setBooleanValueAtIndex(@params.targetRangeScope, index, source, @params.targetReferenceDomain)\n\n        return null\n\n    ###*\n    * @method commandChangeStringVariables\n    * @protected\n    ###\n    commandChangeStringVariables: ->\n        source = \"\"\n        switch @params.source\n            when 0 # Constant Text\n                source = lcs(@params.textValue)\n            when 1 # Variable\n                source = @interpreter.stringValueOf(@params.sourceVariable)\n            when 2 # Database Data\n                source = @interpreter.stringValueOfDatabaseData(@params.databaseData)\n            when 2 # Script\n                try\n                    source = eval(@params.script)\n                catch ex\n                    source = \"ERR: \" + ex.message\n            else\n                source = lcs(@params.textValue)\n\n        switch @params.target\n            when 0 # Variable\n                switch @params.operation\n                    when 0 # Set\n                        @interpreter.setStringValueTo(@params.targetVariable, source)\n                    when 1 # Add\n                        @interpreter.setStringValueTo(@params.targetVariable, @interpreter.stringValueOf(@params.targetVariable) + source)\n                    when 2 # To Upper-Case\n                        @interpreter.setStringValueTo(@params.targetVariable, @interpreter.stringValueOf(@params.targetVariable).toUpperCase())\n                    when 3 # To Lower-Case\n                        @interpreter.setStringValueTo(@params.targetVariable, @interpreter.stringValueOf(@params.targetVariable).toLowerCase())\n\n            when 1 # Range\n                variable = { index: 0, scope: @params.targetRangeScope }\n                for i in [@params.rangeStart-1..@params.rangeEnd-1]\n                    variable.index = i\n                    switch @params.operation\n                        when 0 # Set\n                            @interpreter.setStringValueTo(variable, source)\n                        when 1 # Add\n                            @interpreter.setStringValueTo(variable, @interpreter.stringValueOf(variable) + source)\n                        when 2 # To Upper-Case\n                            @interpreter.setStringValueTo(variable, @interpreter.stringValueOf(variable).toUpperCase())\n                        when 3 # To Lower-Case\n                            @interpreter.setStringValueTo(variable, @interpreter.stringValueOf(variable).toLowerCase())\n\n            when 2 # Reference\n                index = @interpreter.numberValueOf(@params.targetReference) - 1\n                switch @params.operation\n                    when 0 # Set\n                        @interpreter.setStringValueAtIndex(@params.targetRangeScope, index, source, @params.targetReferenceDomain)\n                    when 1 # Add\n                        targetValue = @interpreter.stringValueAtIndex(@params.targetRangeScope, index, @params.targetReferenceDomain)\n                        @interpreter.setStringValueAtIndex(@params.targetRangeScope, index, targetValue + source, @params.targetReferenceDomain)\n                    when 2 # To Upper-Case\n                        targetValue = @interpreter.stringValueAtIndex(@params.targetRangeScope, index, @params.targetReferenceDomain)\n                        @interpreter.setStringValueAtIndex(@params.targetRangeScope, index, targetValue.toUpperCase(), @params.targetReferenceDomain)\n                    when 3 # To Lower-Case\n                        targetValue = @interpreter.stringValueAtIndex(@params.targetRangeScope, index, @params.targetReferenceDomain)\n                        @interpreter.setStringValueTo(@params.targetRangeScope, index, targetValue.toLowerCase(), @params.targetReferenceDomain)\n        return null\n\n    ###*\n    * @method commandCheckSwitch\n    * @protected\n    ###\n    commandCheckSwitch: ->\n        result = @interpreter.booleanValueOf(@params.targetVariable) && @params.value\n        if result\n            @interpreter.pointer = @params.labelIndex\n\n\n    ###*\n    * @method commandNumberCondition\n    * @protected\n    ###\n    commandNumberCondition: ->\n        result = @interpreter.compare(@interpreter.numberValueOf(@params.targetVariable), @interpreter.numberValueOf(@params.value), @params.operation)\n        @interpreter.conditions[@interpreter.indent] = result\n\n        if result\n            @interpreter.indent++\n\n    ###*\n    * @method commandCondition\n    * @protected\n    ###\n    commandCondition: ->\n        switch @params.valueType\n            when 0 # Number\n                result = @interpreter.compare(@interpreter.numberValueOf(@params.variable), @interpreter.numberValueOf(@params.numberValue), @params.operation)\n            when 1 # Switch\n                result = @interpreter.compare(@interpreter.booleanValueOf(@params.variable), @interpreter.booleanValueOf(@params.switchValue), @params.operation)\n            when 2 # Text\n                result = @interpreter.compare(lcs(@interpreter.stringValueOf(@params.variable)), lcs(@interpreter.stringValueOf(@params.textValue)), @params.operation)\n\n        @interpreter.conditions[@interpreter.indent] = result\n        if result\n            @interpreter.indent++\n\n    ###*\n    * @method commandConditionElse\n    * @protected\n    ###\n    commandConditionElse: ->\n        if not @interpreter.conditions[@interpreter.indent]\n            @interpreter.indent++\n\n    ###*\n    * @method commandConditionElseIf\n    * @protected\n    ###\n    commandConditionElseIf: ->\n        if not @interpreter.conditions[@interpreter.indent]\n            @interpreter.commandCondition.call(this)\n\n    ###*\n    * @method commandCheckNumberVariable\n    * @protected\n    ###\n    commandCheckNumberVariable: ->\n        result = @interpreter.compare(@interpreter.numberValueOf(@params.targetVariable), @interpreter.numberValueOf(@params.value), @params.operation)\n        if result\n            @interpreter.pointer = @params.labelIndex\n\n    ###*\n    * @method commandCheckTextVariable\n    * @protected\n    ###\n    commandCheckTextVariable: ->\n        result = no\n        text1 = @interpreter.stringValueOf(@params.targetVariable)\n        text2 = @interpreter.stringValueOf(@params.value)\n        switch @params.operation\n            when 0 then result = text1 == text2\n            when 1 then result = text1 != text2\n            when 2 then result = text1.length > text2.length\n            when 3 then result = text1.length >= text2.length\n            when 4 then result = text1.length < text2.length\n            when 5 then result = text1.length <= text2.length\n\n        if result\n            @interpreter.pointer = @params.labelIndex\n\n    ###*\n    * @method commandLabel\n    * @protected\n    ###\n    commandLabel: -> # Does Nothing\n\n\n    ###*\n    * @method commandJumpToLabel\n    * @protected\n    ###\n    commandJumpToLabel: ->\n        label = @params.labelIndex #@interpreter.labels[@params.name]\n        if label?\n            @interpreter.pointer = label\n            @interpreter.indent = @interpreter.object.commands[label].indent\n        else\n            switch @params.target\n                when \"activeContext\"\n                    @interpreter.jumpToLabel(@interpreter.stringValueOf(@params.name))\n                when \"activeScene\"\n                    SceneManager.scene.interpreter.jumpToLabel(@interpreter.stringValueOf(@params.name))\n                else\n                    @interpreter.jumpToLabel(@interpreter.stringValueOf(@params.name))\n\n    ###*\n    * @method commandClearMessage\n    * @protected\n    ###\n    commandClearMessage: ->\n        scene = SceneManager.scene\n        messageObject = @interpreter.targetMessage()\n        if not messageObject? then return\n\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n        duration = 0\n        fading = GameManager.tempSettings.messageFading\n        if not GameManager.tempSettings.skip\n            duration = if !isLocked(flags.duration) then @interpreter.durationValueOf(@params.duration) else fading.duration\n        messageObject.animator.disappear(fading.animation, fading.easing, duration, gs.CallBack(\"onMessageADVClear\", @interpreter))\n\n        @interpreter.waitForCompletion(messageObject, @params)\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandMessageBoxDefaults\n    * @protected\n    ###\n    commandMessageBoxDefaults: ->\n        defaults = GameManager.defaults.messageBox\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n\n        if !isLocked(flags.appearDuration) then defaults.appearDuration = @interpreter.durationValueOf(@params.appearDuration)\n        if !isLocked(flags.disappearDuration) then defaults.disappearDuration = @interpreter.durationValueOf(@params.disappearDuration)\n        if !isLocked(flags.zOrder) then defaults.zOrder = @interpreter.numberValueOf(@params.zOrder)\n        if !isLocked(flags[\"appearEasing.type\"]) then defaults.appearEasing = @params.appearEasing\n        if !isLocked(flags[\"appearAnimation.type\"]) then defaults.appearAnimation = @params.appearAnimation\n        if !isLocked(flags[\"disappearEasing.type\"]) then defaults.disappearEasing = @params.disappearEasing\n        if !isLocked(flags[\"disappearAnimation.type\"]) then defaults.disappearAnimation = @params.disappearAnimation\n\n\n    ###*\n    * @method commandShowMessage\n    * @protected\n    ###\n    commandShowMessage: ->\n        scene = SceneManager.scene\n        scene.messageMode = vn.MessageMode.ADV\n        character = scene.characters.first (v) => !v.disposed and v.rid == @params.characterId\n\n        showMessage = =>\n            character = RecordManager.characters[@params.characterId]\n\n            scene.layout.visible = yes\n            messageObject = @interpreter.targetMessage()\n\n            if not messageObject? then return\n\n            scene.currentCharacter = character\n            messageObject.character = character\n\n            messageObject.opacity = 255\n            messageObject.events.offByOwner(\"callCommonEvent\", @interpreter)\n            messageObject.events.on(\"callCommonEvent\", gs.CallBack(\"onCallCommonEvent\", @interpreter), params: @params, @interpreter)\n            messageObject.events.once(\"finish\", gs.CallBack(\"onMessageADVFinish\", @interpreter), params: @params, @interpreter)\n            messageObject.events.once(\"waiting\", gs.CallBack(\"onMessageADVWaiting\", @interpreter), params: @params, @interpreter)\n            if messageObject.settings.useCharacterColor\n                messageObject.message.showMessage(@interpreter, @params, character)\n            else\n                messageObject.message.showMessage(@interpreter, @params)\n\n            settings = GameManager.settings\n            voiceSettings = settings.voicesByCharacter[character.index]\n\n            if @params.voice? and GameManager.settings.voiceEnabled and (!voiceSettings or voiceSettings > 0)\n                if (GameManager.settings.skipVoiceOnAction or !AudioManager.voice?.playing) and !GameManager.tempSettings.skip\n                    messageObject.voice = @params.voice\n                    messageObject.behavior.voice = AudioManager.playVoice(@params.voice)\n            else\n                messageObject.behavior.voice = null\n\n        if @params.expressionId? and character?\n            expression = RecordManager.characterExpressions[@params.expressionId || 0]\n            defaults = GameManager.defaults.character\n            duration = if !gs.CommandFieldFlags.isLocked(@params.fieldFlags.duration) then @interpreter.durationValueOf(@params.duration) else defaults.expressionDuration\n            easing = gs.Easings.fromObject(defaults.changeEasing)\n            animation = defaults.changeAnimation\n\n            character.behavior.changeExpression(expression, animation, easing, duration, =>\n                showMessage()\n            )\n        else\n            showMessage()\n\n        @interpreter.isWaiting = (@params.waitForCompletion ? yes) and !(GameManager.tempSettings.skip and GameManager.tempSettings.skipTime == 0)\n        @interpreter.waitingFor.messageADV = @params\n\n    ###*\n    * @method commandSetMessageArea\n    * @protected\n    ###\n    commandSetMessageArea: ->\n        scene = SceneManager.scene\n        number = @interpreter.numberValueOf(@params.number)\n\n        if scene.messageAreas[number]\n            messageLayout = scene.messageAreas[number].layout\n            messageLayout.dstRect.x = @params.box.x\n            messageLayout.dstRect.y = @params.box.y\n            messageLayout.dstRect.width = @params.box.size.width\n            messageLayout.dstRect.height = @params.box.size.height\n            messageLayout.needsUpdate = yes\n\n    ###*\n    * @method commandMessageFading\n    * @protected\n    ###\n    commandMessageFading: ->\n        GameManager.tempSettings.messageFading = duration: @interpreter.durationValueOf(@params.duration), animation: @params.animation, easing: gs.Easings.fromObject(@params.easing)\n\n    ###*\n    * @method commandMessageSettings\n    * @protected\n    ###\n    commandMessageSettings: ->\n        messageObject = @interpreter.targetMessage()\n        if !messageObject then return\n\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n        messageSettings = @interpreter.messageSettings()\n\n        if !isLocked(flags.autoErase)\n            messageSettings.autoErase = @params.autoErase\n\n        if !isLocked(flags.waitAtEnd)\n            messageSettings.waitAtEnd = @params.waitAtEnd\n\n        if !isLocked(flags.backlog)\n            messageSettings.backlog = @params.backlog\n\n        if !isLocked(flags.lineHeight)\n            messageSettings.lineHeight = @params.lineHeight\n\n        if !isLocked(flags.lineSpacing)\n            messageSettings.lineSpacing = @params.lineSpacing\n\n        if !isLocked(flags.linePadding)\n            messageSettings.linePadding = @params.linePadding\n\n        if !isLocked(flags.paragraphSpacing)\n            messageSettings.paragraphSpacing = @params.paragraphSpacing\n\n        if !isLocked(flags.useCharacterColor)\n            messageSettings.useCharacterColor = @params.useCharacterColor\n\n        messageObject.textRenderer.minLineHeight = messageSettings.lineHeight ? 0\n        messageObject.textRenderer.lineSpacing = messageSettings.lineSpacing ? messageObject.textRenderer.lineSpacing\n        messageObject.textRenderer.padding = messageSettings.linePadding ? messageObject.textRenderer.padding\n\n        fontName = if !isLocked(flags.font) then @params.font else messageObject.font.name\n        fontSize = if !isLocked(flags.size) then @params.size else messageObject.font.size\n        font = messageObject.font\n\n        if !isLocked(flags.font) or !isLocked(flags.size)\n            messageObject.font = new Font(fontName, fontSize)\n\n        if !isLocked(flags.bold)\n            messageObject.font.bold = @params.bold\n        if !isLocked(flags.italic)\n            messageObject.font.italic = @params.italic\n        if !isLocked(flags.smallCaps)\n            messageObject.font.smallCaps = @params.smallCaps\n        if !isLocked(flags.underline)\n            messageObject.font.underline = @params.underline\n        if !isLocked(flags.strikeThrough)\n            messageObject.font.strikeThrough = @params.strikeThrough\n        if !isLocked(flags.color)\n            messageObject.font.color = new Color(@params.color)\n\n        messageObject.font.color = if flags.color? and !isLocked(flags.color) then new Color(@params.color) else font.color\n        messageObject.font.border = if flags.outline? and !isLocked(flags.outline) then @params.outline else font.border\n        messageObject.font.borderColor = if flags.outlineColor? and !isLocked(flags.outlineColor) then new Color(@params.outlineColor) else new Color(font.borderColor)\n        messageObject.font.borderSize = if flags.outlineSize? and !isLocked(flags.outlineSize) then (@params.outlineSize ? 4) else font.borderSize\n        messageObject.font.shadow = if flags.shadow? and !isLocked(flags.shadow)then @params.shadow else font.shadow\n        messageObject.font.shadowColor = if flags.shadowColor? and !isLocked(flags.shadowColor) then new Color(@params.shadowColor) else new Color(font.shadowColor)\n        messageObject.font.shadowOffsetX = if flags.shadowOffsetX? and !isLocked(flags.shadowOffsetX) then (@params.shadowOffsetX ? 1) else font.shadowOffsetX\n        messageObject.font.shadowOffsetY = if flags.shadowOffsetY? and !isLocked(flags.shadowOffsetY) then (@params.shadowOffsetY ? 1) else font.shadowOffsetY\n\n        if isLocked(flags.bold) then messageObject.font.bold = font.bold\n        if isLocked(flags.italic) then messageObject.font.italic = font.italic\n        if isLocked(flags.smallCaps) then messageObject.font.smallCaps = font.smallCaps\n\n    ###*\n    * @method commandCreateMessageArea\n    * @protected\n    ###\n    commandCreateMessageArea: ->\n        number = @interpreter.numberValueOf(@params.number)\n        scene = SceneManager.scene\n        scene.behavior.changeMessageAreaDomain(@params.numberDomain)\n        if !scene.messageAreas[number]\n            messageArea = new gs.Object_MessageArea()\n            messageArea.layout = ui.UIManager.createControlFromDescriptor(type: \"ui.CustomGameMessage\", id: \"customGameMessage_\"+number, params: { id: \"customGameMessage_\"+number }, messageArea)\n            messageArea.message = gs.ObjectManager.current.objectById(\"customGameMessage_\"+number+\"_message\")\n            messageArea.message.domain = @params.numberDomain\n            messageArea.addObject(messageArea.layout)\n            messageArea.layout.dstRect.x = @params.box.x\n            messageArea.layout.dstRect.y = @params.box.y\n            messageArea.layout.dstRect.width = @params.box.size.width\n            messageArea.layout.dstRect.height = @params.box.size.height\n            messageArea.layout.needsUpdate = yes\n            scene.messageAreas[number] = messageArea\n\n    ###*\n    * @method commandEraseMessageArea\n    * @protected\n    ###\n    commandEraseMessageArea: ->\n        number = @interpreter.numberValueOf(@params.number)\n        scene = SceneManager.scene\n        scene.behavior.changeMessageAreaDomain(@params.numberDomain)\n        area = scene.messageAreas[number]\n        area?.layout.dispose()\n        scene.messageAreas[number] = null\n\n    ###*\n    * @method commandSetTargetMessage\n    * @protected\n    ###\n    commandSetTargetMessage: ->\n        message = @interpreter.targetMessage()\n        message?.textRenderer.isWaiting = false\n        message?.behavior.isWaiting = false\n\n        scene = SceneManager.scene\n        scene.behavior.changeMessageAreaDomain(@params.numberDomain)\n        target = { type: @params.type, id: null }\n\n        switch @params.type\n            when 0 # Layout-based\n                target.id = @params.id\n            when 1 # Custom\n                target.id = @interpreter.numberValueOf(@params.number)\n\n        @interpreter.settings.message.target = target\n\n        if @params.clear\n            @interpreter.targetMessage()?.behavior.clear()\n        @interpreter.targetMessage()?.visible = yes\n\n    ###*\n    * @method commandBacklogVisibility\n    * @protected\n    ###\n    commandBacklogVisibility: ->\n        if @params.visible\n            control = gs.ObjectManager.current.objectById(\"backlogBox\")\n            if not control? then control = gs.ObjectManager.current.objectById(\"backlog\")\n\n            if control?\n                control.dispose()\n\n            if @params.backgroundVisible\n                control = SceneManager.scene.behavior.createControl(this, { descriptor: \"ui.MessageBacklogBox\" })\n            else\n                control = SceneManager.scene.behavior.createControl(this, { descriptor: \"ui.MessageBacklog\" })\n        else\n            control = gs.ObjectManager.current.objectById(\"backlogBox\")\n            if not control? then control = gs.ObjectManager.current.objectById(\"backlog\")\n            if not control? then control = gs.ObjectManager.current.objectById(\"backlogScrollView\")\n\n            control?.dispose()\n\n    ###*\n    * @method commandMessageVisibility\n    * @protected\n    ###\n    commandMessageVisibility: ->\n        defaults = GameManager.defaults.messageBox\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n\n        message = @interpreter.targetMessage()\n        if not message? or @params.visible == message.visible then return\n\n        if @params.visible\n            duration = if !isLocked(flags.duration) then @interpreter.durationValueOf(@params.duration) else defaults.appearDuration\n            easing = if !isLocked(flags[\"easing.type\"]) then gs.Easings.fromObject(@params.easing) else gs.Easings.fromObject(defaults.appearEasing)\n            animation = if !isLocked(flags[\"animation.type\"]) then @params.animation else defaults.appearAnimation\n            message.animator.appear(message.dstRect.x, message.dstRect.y, @params.animation, easing, duration)\n        else\n            duration = if !isLocked(flags.duration) then @interpreter.durationValueOf(@params.duration) else defaults.disappearDuration\n            easing = if !isLocked(flags[\"easing.type\"]) then gs.Easings.fromObject(@params.easing) else gs.Easings.fromObject(defaults.disappearEasing)\n            animation = if !isLocked(flags[\"animation.type\"]) then @params.animation else defaults.disappearAnimation\n            message.animator.disappear(animation, easing, duration, -> message.visible = no)\n        message.update()\n\n        if @params.waitForCompletion and not (duration == 0 or @interpreter.isInstantSkip())\n            @interpreter.isWaiting = yes\n            @interpreter.waitCounter = duration\n        gs.GameNotifier.postMinorChange()\n    ###*\n    * @method commandMessageBoxVisibility\n    * @protected\n    ###\n    commandMessageBoxVisibility: ->\n        defaults = GameManager.defaults.messageBox\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n        messageBox = @interpreter.messageBoxObject(@interpreter.stringValueOf(@params.id))\n        visible = @params.visible == 1\n        if not messageBox? or visible == messageBox.visible then return\n\n        if @params.visible\n            duration = if !isLocked(flags.duration) then @interpreter.durationValueOf(@params.duration) else defaults.appearDuration\n            easing = if !isLocked(flags[\"easing.type\"]) then gs.Easings.fromObject(@params.easing) else gs.Easings.fromObject(defaults.appearEasing)\n            animation = if !isLocked(flags[\"animation.type\"]) then @params.animation else defaults.appearAnimation\n            messageBox.animator.appear(messageBox.dstRect.x, messageBox.dstRect.y, animation, easing, duration)\n        else\n            duration = if !isLocked(flags.duration) then @interpreter.durationValueOf(@params.duration) else defaults.disappearDuration\n            easing = if !isLocked(flags[\"easing.type\"]) then gs.Easings.fromObject(@params.easing) else gs.Easings.fromObject(defaults.disappearEasing)\n            animation = if !isLocked(flags[\"animation.type\"]) then @params.animation else defaults.disappearAnimation\n            messageBox.animator.disappear(animation, easing, duration, -> messageBox.visible = no)\n        messageBox.update()\n\n        if @params.waitForCompletion and not (duration == 0 or @interpreter.isInstantSkip())\n            @interpreter.isWaiting = yes\n            @interpreter.waitCounter = duration\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandUIAccess\n    * @protected\n    ###\n    commandUIAccess: ->\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n\n        if !isLocked(flags.generalMenu)\n            GameManager.tempSettings.menuAccess = @interpreter.booleanValueOf(@params.generalMenu)\n        if !isLocked(flags.saveMenu)\n            GameManager.tempSettings.saveMenuAccess = @interpreter.booleanValueOf(@params.saveMenu)\n        if !isLocked(flags.loadMenu)\n            GameManager.tempSettings.loadMenuAccess = @interpreter.booleanValueOf(@params.loadMenu)\n        if !isLocked(flags.backlog)\n            GameManager.tempSettings.backlogAccess = @interpreter.booleanValueOf(@params.backlog)\n\n    ###*\n    * @method commandUnlockCG\n    * @protected\n    ###\n    commandUnlockCG: ->\n        cg = RecordManager.cgGallery[@interpreter.stringValueOf(@params.cgId)]\n\n        if cg?\n            GameManager.globalData.cgGallery[cg.index] = { unlocked: yes }\n            GameManager.saveGlobalData()\n\n    ###*\n    * @method commandL2DMove\n    * @protected\n    ###\n    commandL2DMove: ->\n        scene = SceneManager.scene\n        character = scene.characters.first (v) => !v.disposed and v.rid == @params.characterId\n        if not character instanceof vn.Object_Live2DCharacter then return\n\n        @interpreter.moveObject(character, @params.position, @params)\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandL2DMotionGroup\n    * @protected\n    ###\n    commandL2DMotionGroup: ->\n        scene = SceneManager.scene\n        character = scene.characters.first (v) => !v.disposed and v.rid == @params.characterId\n        if not character instanceof vn.Object_Live2DCharacter then return\n\n        character.motionGroup = { name: @params.data.motionGroup, loop: @params.loop, playType: @params.playType }\n        if @params.waitForCompletion and not @params.loop\n            motions = character.model.motionsByGroup[character.motionGroup.name]\n            if motions?\n                @interpreter.isWaiting = yes\n                @interpreter.waitCounter = motions.sum (m) -> m.getDurationMSec() / 16.6\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandL2DMotion\n    * @protected\n    ###\n    commandL2DMotion: ->\n        defaults = GameManager.defaults.live2d\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n        scene = SceneManager.scene\n        character = scene.characters.first (v) => !v.disposed and v.rid == @params.characterId\n        if not character instanceof vn.Object_Live2DCharacter then return\n        fadeInTime = if !isLocked(flags.fadeInTime) then @params.fadeInTime else defaults.motionFadeInTime\n        character.motion = { name: @params.data.motion, fadeInTime: fadeInTime, loop: @params.loop }\n        character.motionGroup = null\n\n        if @params.waitForCompletion and not @params.loop\n            motion = character.model.motions[character.motion.name]\n            if motion?\n                @interpreter.isWaiting = yes\n                @interpreter.waitCounter = motion.getDurationMSec() / 16.6\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandL2DExpression\n    * @protected\n    ###\n    commandL2DExpression: ->\n        defaults = GameManager.defaults.live2d\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n        scene = SceneManager.scene\n        character = scene.characters.first (v) => !v.disposed and v.rid == @params.characterId\n        if not character instanceof vn.Object_Live2DCharacter then return\n        fadeInTime = if !isLocked(flags.fadeInTime) then @params.fadeInTime else defaults.expressionFadeInTime\n\n        character.expression = { name: @params.data.expression, fadeInTime: fadeInTime }\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandL2DExitScene\n    * @protected\n    ###\n    commandL2DExitScene: ->\n        defaults = GameManager.defaults.live2d\n        @interpreter.commandCharacterExitScene.call(this, defaults)\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandL2DSettings\n    * @protected\n    ###\n    commandL2DSettings: ->\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n\n        scene = SceneManager.scene\n        character = scene.characters.first (v) => !v.disposed and v.rid == @params.characterId\n        if not character?.visual.l2dObject then return\n\n\n        if !isLocked(flags.lipSyncSensitivity)\n            character.visual.l2dObject.lipSyncSensitivity = @interpreter.numberValueOf(@params.lipSyncSensitivity)\n        if !isLocked(flags.idleIntensity)\n            character.visual.l2dObject.idleIntensity = @interpreter.numberValueOf(@params.idleIntensity)\n        if !isLocked(flags.breathIntensity)\n            character.visual.l2dObject.breathIntensity = @interpreter.numberValueOf(@params.breathIntensity)\n        if !isLocked(flags[\"eyeBlink.enabled\"])\n            character.visual.l2dObject.eyeBlink.enabled = @params.eyeBlink.enabled\n        if !isLocked(flags[\"eyeBlink.interval\"])\n            character.visual.l2dObject.eyeBlink.blinkIntervalMsec = @interpreter.numberValueOf(@params.eyeBlink.interval)\n        if !isLocked(flags[\"eyeBlink.closedMotionTime\"])\n            character.visual.l2dObject.eyeBlink.closedMotionMsec = @interpreter.numberValueOf(@params.eyeBlink.closedMotionTime)\n        if !isLocked(flags[\"eyeBlink.closingMotionTime\"])\n            character.visual.l2dObject.eyeBlink.closingMotionMsec = @interpreter.numberValueOf(@params.eyeBlink.closingMotionTime)\n        if !isLocked(flags[\"eyeBlink.openingMotionTime\"])\n            character.visual.l2dObject.eyeBlink.openingMotionMsec = @interpreter.numberValueOf(@params.eyeBlink.openingMotionTime)\n\n        gs.GameNotifier.postMinorChange()\n    ###*\n    * @method commandL2DParameter\n    * @protected\n    ###\n    commandL2DParameter: ->\n        scene = SceneManager.scene\n        character = scene.characters.first (v) => !v.disposed and v.rid == @params.characterId\n        if not character instanceof vn.Object_Live2DCharacter then return\n\n        easing = gs.Easings.fromObject(@params.easing)\n        duration = @interpreter.durationValueOf(@params.duration)\n        character.animator.l2dParameterTo(@params.param.name, @interpreter.numberValueOf(@params.param.value), duration, easing)\n\n        if @params.waitForCompletion and not (duration == 0 or @interpreter.isInstantSkip())\n            @interpreter.isWaiting = yes\n            @interpreter.waitCounter = duration\n        gs.GameNotifier.postMinorChange()\n    ###*\n    * @method commandL2DDefaults\n    * @protected\n    ###\n    commandL2DDefaults: ->\n        defaults = GameManager.defaults.live2d\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n\n        if !isLocked(flags.appearDuration) then defaults.appearDuration = @interpreter.durationValueOf(@params.appearDuration)\n        if !isLocked(flags.disappearDuration) then defaults.disappearDuration = @interpreter.durationValueOf(@params.disappearDuration)\n        if !isLocked(flags.zOrder) then defaults.zOrder = @interpreter.numberValueOf(@params.zOrder)\n        if !isLocked(flags.motionFadeInTime) then defaults.motionFadeInTime = @interpreter.numberValueOf(@params.motionFadeInTime)\n        if !isLocked(flags[\"appearEasing.type\"]) then defaults.appearEasing = @params.appearEasing\n        if !isLocked(flags[\"appearAnimation.type\"]) then defaults.appearAnimation = @params.appearAnimation\n        if !isLocked(flags[\"disappearEasing.type\"]) then defaults.disappearEasing = @params.disappearEasing\n        if !isLocked(flags[\"disappearAnimation.type\"]) then defaults.disappearAnimation = @params.disappearAnimation\n\n        gs.GameNotifier.postMinorChange()\n    ###*\n    * @method commandL2DJoinScene\n    * @protected\n    ###\n    commandL2DJoinScene: ->\n        defaults = GameManager.defaults.live2d\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n        scene = SceneManager.scene\n        record = RecordManager.characters[@interpreter.stringValueOf(@params.characterId)]\n        return if !record or scene.characters.first (v) -> !v.disposed and v.rid == record.index\n\n        if @params.positionType == 1\n            x = @params.position.x\n            y = @params.position.y\n        else if @params.positionType == 2\n            x = @interpreter.numberValueOf(@params.position.x)\n            y = @interpreter.numberValueOf(@params.position.y)\n\n        easing = if !isLocked(flags[\"easing.type\"]) then gs.Easings.fromValues(@interpreter.numberValueOf(@params.easing.type), @params.easing.inOut) else gs.Easings.fromObject(defaults.appearEasing)\n        duration = if !isLocked(flags.duration) then @interpreter.durationValueOf(@params.duration) else defaults.appearDuration\n        zIndex = if !isLocked(flags.zOrder) then @interpreter.numberValueOf(@params.zOrder) else defaults.zOrder\n        animation = if !isLocked(flags[\"animation.type\"]) then @params.animation else defaults.appearAnimation\n        motionBlur = if !isLocked(flags[\"motionBlur.enabled\"]) then @params.motionBlur else defaults.motionBlur\n        origin = if !isLocked(flags.origin) then @params.origin else defaults.origin\n        instant = duration == 0 or @interpreter.isInstantSkip()\n        noAnim = duration == 0 or GameManager.tempSettings.skip\n\n        if @params.waitForCompletion and not instant\n            @interpreter.isWaiting = yes\n            @interpreter.waitCounter = duration\n\n\n        character = new vn.Object_Live2DCharacter(record)\n        character.modelName = @params.model?.name || \"\"\n        character.model = ResourceManager.getLive2DModel(\"Live2D/#{character.modelName}\")\n        character.motion = { name: \"\", fadeInTime: 0, loop: true } if character.model.motions\n        #character.expression = { name: Object.keys(character.model.expressions)[0], fadeInTime: 0 } if character.model.expressions\n        character.dstRect.x = x\n        character.dstRect.y = y\n        character.anchor.x = if !origin then 0 else 0.5\n        character.anchor.y = if !origin then 0 else 0.5\n        character.blendMode = @interpreter.numberValueOf(@params.blendMode)\n        character.zoom.x = @params.position.zoom.d\n        character.zoom.y = @params.position.zoom.d\n        character.zIndex = zIndex || 200\n        character.model?.reset()\n        character.setup()\n        character.visual.l2dObject.idleIntensity = record.idleIntensity ? 1.0\n        character.visual.l2dObject.breathIntensity = record.breathIntensity ? 1.0\n        character.visual.l2dObject.lipSyncSensitivity = record.lipSyncSensitivity ? 1.0\n\n        character.update()\n\n        if @params.positionType == 0\n            p = @interpreter.predefinedObjectPosition(@params.predefinedPositionId, character, @params)\n            character.dstRect.x = p.x\n            character.dstRect.y = p.y\n\n        scene.behavior.addCharacter(character, noAnim, { animation: animation, duration: duration, easing: easing, motionBlur: motionBlur})\n\n        if @params.viewport?.type == \"ui\"\n            character.viewport = Graphics.viewport\n\n        gs.GameNotifier.postMinorChange()\n    ###*\n    * @method commandCharacterJoinScene\n    * @protected\n    ###\n    commandCharacterJoinScene: ->\n        defaults = GameManager.defaults.character\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n        scene = SceneManager.scene\n        characterId = @interpreter.stringValueOf(@params.characterId)\n        expressionId = @interpreter.stringValueOf(@params.expressionId) || @params.expressionId\n        record = RecordManager.characters[characterId]\n\n        return if !record or scene.characters.first (v) -> !v.disposed and v.rid == record.index and !v.disposed\n\n        character = new vn.Object_Character(record, null, scene)\n        character.expression = RecordManager.characterExpressions[expressionId ? record.defaultExpressionId||0] #character.expression\n        if character.expression?.idle[0]?.resource.name\n            bitmap = ResourceManager.getBitmap(\"Graphics/Characters/#{character.expression.idle[0].resource.name}\")\n\n        mirror = no\n        angle = 0\n        zoom = 1\n\n        if @params.positionType == 1\n            x = @interpreter.numberValueOf(@params.position.x)\n            y = @interpreter.numberValueOf(@params.position.y)\n            mirror = @params.position.horizontalFlip\n            angle = @params.position.angle||0\n            zoom = @params.position.data?.zoom || 1\n        else if @params.positionType == 2\n            x = @interpreter.numberValueOf(@params.position.x)\n            y = @interpreter.numberValueOf(@params.position.y)\n            mirror = no\n            angle = 0\n            zoom = 1\n\n        easing = if !isLocked(flags[\"easing.type\"]) then gs.Easings.fromValues(@interpreter.numberValueOf(@params.easing.type), @params.easing.inOut) else gs.Easings.fromObject(defaults.appearEasing)\n        duration = if !isLocked(flags.duration) then @interpreter.durationValueOf(@params.duration) else defaults.appearDuration\n        origin = if !isLocked(flags.origin) then @params.origin else defaults.origin\n        zIndex = if !isLocked(flags.zOrder) then @interpreter.numberValueOf(@params.zOrder) else defaults.zOrder\n        animation = if !isLocked(flags[\"animation.type\"]) then @params.animation else defaults.appearAnimation\n        motionBlur = if !isLocked(flags[\"motionBlur.enabled\"]) then @params.motionBlur else defaults.motionBlur\n        instant = duration == 0 or @interpreter.isInstantSkip()\n        noAnim = duration == 0 or GameManager.tempSettings.skip\n\n        if @params.waitForCompletion and not instant\n            @interpreter.isWaiting = yes\n            @interpreter.waitCounter = duration\n\n        if character.expression?.idle[0]?.resource.name\n            bitmap = ResourceManager.getBitmap(\"Graphics/Characters/#{character.expression.idle[0].resource.name}\")\n            if origin == 1 and bitmap?\n                x += (bitmap.width*zoom-bitmap.width)/2\n                y += (bitmap.height*zoom-bitmap.height)/2\n\n        character.mirror = mirror\n        character.anchor.x = if !origin then 0 else 0.5\n        character.anchor.y = if !origin then 0 else 0.5\n        character.zoom.x = zoom\n        character.zoom.y = zoom\n        character.dstRect.x = x\n        character.dstRect.y = y\n        character.zIndex = zIndex ||  200\n        character.blendMode = @interpreter.numberValueOf(@params.blendMode)\n        character.angle = angle\n        character.setup()\n        character.update()\n\n        if @params.positionType == 0\n            p = @interpreter.predefinedObjectPosition(@params.predefinedPositionId, character, @params)\n            character.dstRect.x = p.x\n            character.dstRect.y = p.y\n\n        scene.behavior.addCharacter(character, noAnim, { animation: animation, duration: duration, easing: easing, motionBlur: motionBlur})\n\n        if @params.viewport?.type == \"ui\"\n            character.viewport = Graphics.viewport\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandCharacterExitScene\n    * @protected\n    ###\n    commandCharacterExitScene: (defaults) ->\n        defaults = defaults || GameManager.defaults.character\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n        characterId = @interpreter.stringValueOf(@params.characterId)\n\n        scene = SceneManager.scene\n        character = scene.characters.first (v) => !v.disposed and v.rid == characterId\n\n        easing = if !isLocked(flags[\"easing.type\"]) then gs.Easings.fromValues(@interpreter.numberValueOf(@params.easing.type), @params.easing.inOut) else gs.Easings.fromObject(defaults.disappearEasing)\n        duration = if !isLocked(flags.duration) then @interpreter.durationValueOf(@params.duration) else defaults.disappearDuration\n        animation = if !isLocked(flags[\"animation.type\"]) then @params.animation else defaults.disappearAnimation\n        instant = duration == 0 or @interpreter.isInstantSkip()\n        noAnim = duration == 0 or GameManager.tempSettings.skip\n\n        if @params.waitForCompletion and not instant\n            @interpreter.isWaiting = yes\n            @interpreter.waitCounter = duration\n\n        scene.behavior.removeCharacter(character, noAnim, { animation: animation, duration: duration, easing: easing})\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandCharacterChangeExpression\n    * @protected\n    ###\n    commandCharacterChangeExpression: ->\n        scene = SceneManager.scene\n        characterId = @interpreter.stringValueOf(@params.characterId)\n        character = scene.characters.first (v) => !v.disposed and v.rid == characterId\n        if not character? then return\n        defaults = GameManager.defaults.character\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n\n        duration = if !isLocked(flags.duration) then @interpreter.durationValueOf(@params.duration) else defaults.expressionDuration\n        expression = RecordManager.characterExpressions[@params.expressionId || 0]\n        easing = if !isLocked(flags[\"easing.type\"]) then gs.Easings.fromObject(@params.easing) else gs.Easings.fromObject(defaults.changeEasing)\n        animation = if !isLocked(flags[\"animation.type\"]) then @params.animation else defaults.changeAnimation\n\n        character.behavior.changeExpression(expression, @params.animation, easing, duration)\n\n        if @params.waitForCompletion and not (duration == 0 or @interpreter.isInstantSkip())\n            @interpreter.isWaiting = yes\n            @interpreter.waitCounter = duration\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandCharacterSetParameter\n    * @protected\n    ###\n    commandCharacterSetParameter: ->\n        params = GameManager.characterParams[@interpreter.stringValueOf(@params.characterId)]\n        if not params? or not @params.param? then return\n\n        switch @params.valueType\n            when 0 # Number Value\n                switch @params.param.type\n                    when 0 # Number\n                        params[@params.param.name] = @interpreter.numberValueOf(@params.numberValue)\n                    when 1 # Switch\n                        params[@params.param.name] = @interpreter.numberValueOf(@params.numberValue) > 0\n                    when 2 # Text\n                        params[@params.param.name] = @interpreter.numberValueOf(@params.numberValue).toString()\n            when 1 # Switch Value\n                switch @params.param.type\n                    when 0 # Number\n                        value = @interpreter.booleanValueOf(@params.switchValue)\n                        params[@params.param.name] = if value then 1 else 0\n                    when 1 # Switch\n                        params[@params.param.name] = @interpreter.booleanValueOf(@params.switchValue)\n                    when 2 # Text\n                        value = @interpreter.booleanValueOf(@params.switchValue)\n                        params[@params.param.name] = if value then \"ON\" else \"OFF\"\n            when 2 # Text Value\n                switch @params.param.type\n                    when 0 # Number\n                        value = @interpreter.stringValueOf(@params.textValue)\n                        params[@params.param.name] = value.length\n                    when 1 # Switch\n                        params[@params.param.name] = @interpreter.stringValueOf(@params.textValue) == \"ON\"\n                    when 2 # Text\n                        params[@params.param.name] = @interpreter.stringValueOf(@params.textValue)\n\n\n\n\n    ###*\n    * @method commandCharacterGetParameter\n    * @protected\n    ###\n    commandCharacterGetParameter: ->\n        params = GameManager.characterParams[@interpreter.stringValueOf(@params.characterId)]\n        if not params? or not @params.param? then return\n\n        value = params[@params.param.name]\n\n        switch @params.valueType\n            when 0 # Number Value\n                switch @params.param.type\n                    when 0 # Number\n                        @interpreter.setNumberValueTo(@params.targetVariable, value)\n                    when 1 # Switch\n                        @interpreter.setNumberValueTo(@params.targetVariable, if value then 1 else 0)\n                    when 2 # Text\n                        @interpreter.setNumberValueTo(@params.targetVariable, if value? then value.length else 0)\n            when 1 # Switch Value\n                switch @params.param.type\n                    when 0 # Number\n                        @interpreter.setBooleanValueTo(@params.targetVariable, value > 0)\n                    when 1 # Switch\n                        @interpreter.setBooleanValueTo(@params.targetVariable, value)\n                    when 2 # Text\n                        @interpreter.setBooleanValueTo(@params.targetVariable, value == \"ON\")\n\n            when 2 # Text Value\n                switch @params.param.type\n                    when 0 # Number\n                        @interpreter.setStringValueTo(@params.targetVariable, if value? then value.toString() else \"\")\n                    when 1 # Switch\n                        @interpreter.setStringValueTo(@params.targetVariable, if value then \"ON\" else \"OFF\")\n                    when 2 # Text\n                        @interpreter.setStringValueTo(@params.targetVariable, value)\n\n\n\n    ###*\n    * @method commandCharacterMotionBlur\n    * @protected\n    ###\n    commandCharacterMotionBlur: ->\n        scene = SceneManager.scene\n        characterId = @interpreter.stringValueOf(@params.characterId)\n        character = scene.characters.first (v) => !v.disposed and v.rid == characterId\n        if not character? then return\n\n        character.motionBlur.set(@params.motionBlur)\n\n    ###*\n    * @method commandCharacterDefaults\n    * @protected\n    ###\n    commandCharacterDefaults: ->\n        defaults = GameManager.defaults.character\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n\n        if !isLocked(flags.appearDuration) then defaults.appearDuration = @interpreter.durationValueOf(@params.appearDuration)\n        if !isLocked(flags.disappearDuration) then defaults.disappearDuration = @interpreter.durationValueOf(@params.disappearDuration)\n        if !isLocked(flags.expressionDuration) then defaults.expressionDuration = @interpreter.durationValueOf(@params.expressionDuration)\n        if !isLocked(flags.zOrder) then defaults.zOrder = @interpreter.numberValueOf(@params.zOrder)\n        if !isLocked(flags[\"appearEasing.type\"]) then defaults.appearEasing = @params.appearEasing\n        if !isLocked(flags[\"appearAnimation.type\"]) then defaults.appearAnimation = @params.appearAnimation\n        if !isLocked(flags[\"disappearEasing.type\"]) then defaults.disappearEasing = @params.disappearEasing\n        if !isLocked(flags[\"disappearAnimation.type\"]) then defaults.disappearAnimation = @params.disappearAnimation\n        if !isLocked(flags[\"motionBlur.enabled\"]) then defaults.motionBlur = @params.motionBlur\n        if !isLocked(flags.origin) then defaults.origin = @params.origin\n\n    ###*\n    * @method commandCharacterEffect\n    * @protected\n    ###\n    commandCharacterEffect: ->\n        scene = SceneManager.scene\n        characterId = @interpreter.stringValueOf(@params.characterId)\n        character = scene.characters.first (c) -> !c.disposed and c.rid == characterId\n        if not character? then return\n\n        @interpreter.objectEffect(character, @params)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandFlashCharacter\n    * @protected\n    ###\n    commandFlashCharacter: ->\n        scene = SceneManager.scene\n        characterId = @interpreter.stringValueOf(@params.characterId)\n        character = scene.characters.first (v) => !v.disposed and v.rid == characterId\n        return if not character\n\n        duration = @interpreter.durationValueOf(@params.duration)\n        character.animator.flash(new Color(@params.color), duration)\n        if @params.waitForCompletion and not (duration == 0 or @interpreter.isInstantSkip())\n            @interpreter.isWaiting = yes\n            @interpreter.waitCounter = duration\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandTintCharacter\n    * @protected\n    ###\n    commandTintCharacter: ->\n        scene = SceneManager.scene\n        characterId = @interpreter.stringValueOf(@params.characterId)\n        character = scene.characters.first (v) => !v.disposed and v.rid == characterId\n        easing = gs.Easings.fromValues(@interpreter.numberValueOf(@params.easing.type), @params.easing.inOut)\n        return if not character\n\n        duration = @interpreter.durationValueOf(@params.duration)\n        character.animator.tintTo(@params.tone, duration, easing)\n        if @params.waitForCompletion and not (duration == 0 or @interpreter.isInstantSkip())\n            @interpreter.isWaiting = yes\n            @interpreter.waitCounter = duration\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandZoomCharacter\n    * @protected\n    ###\n    commandZoomCharacter: ->\n        scene = SceneManager.scene\n        characterId = @interpreter.stringValueOf(@params.characterId)\n        character = scene.characters.first (v) => !v.disposed and v.rid == characterId\n        if not character? then return\n\n        @interpreter.zoomObject(character, @params)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandRotateCharacter\n    * @protected\n    ###\n    commandRotateCharacter: ->\n        scene = SceneManager.scene\n        characterId = @interpreter.stringValueOf(@params.characterId)\n        character = scene.characters.first (v) => !v.disposed and v.rid == characterId\n        if not character? then return\n\n        @interpreter.rotateObject(character, @params)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandBlendCharacter\n    * @protected\n    ###\n    commandBlendCharacter: ->\n        characterId = @interpreter.stringValueOf(@params.characterId)\n        character = SceneManager.scene.characters.first (v) => !v.disposed and v.rid == characterId\n        if not character? then return\n\n        @interpreter.blendObject(character, @params)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandShakeCharacter\n    * @protected\n    ###\n    commandShakeCharacter: ->\n        characterId = @interpreter.stringValueOf(@params.characterId)\n        character = SceneManager.scene.characters.first (v) => !v.disposed and  v.rid == characterId\n        if not character? then return\n        @interpreter.shakeObject(character, @params)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandMaskCharacter\n    * @protected\n    ###\n    commandMaskCharacter: ->\n        scene = SceneManager.scene\n        characterId = @interpreter.stringValueOf(@params.characterId)\n        character = scene.characters.first (v) => !v.disposed and v.rid == characterId\n        if not character? then return\n\n        @interpreter.maskObject(character, @params)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandMoveCharacter\n    * @protected\n    ###\n    commandMoveCharacter: ->\n        scene = SceneManager.scene\n        characterId = @interpreter.stringValueOf(@params.characterId)\n        character = scene.characters.first (v) => !v.disposed and v.rid == characterId\n        if not character? then return\n\n        @interpreter.moveObject(character, @params.position, @params)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandMoveCharacterPath\n    * @protected\n    ###\n    commandMoveCharacterPath: ->\n        scene = SceneManager.scene\n        characterId = @interpreter.stringValueOf(@params.characterId)\n        character = scene.characters.first (v) => !v.disposed and v.rid == characterId\n        if not character? then return\n\n        @interpreter.moveObjectPath(character, @params.path, @params)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandShakeBackground\n    * @protected\n    ###\n    commandShakeBackground: ->\n        background = SceneManager.scene.backgrounds[@interpreter.numberValueOf(@params.layer)]\n        if not background? then return\n\n        @interpreter.shakeObject(background, @params)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandScrollBackground\n    * @protected\n    ###\n    commandScrollBackground: ->\n        scene = SceneManager.scene\n        duration = @interpreter.durationValueOf(@params.duration)\n        horizontalSpeed = @interpreter.numberValueOf(@params.horizontalSpeed)\n        verticalSpeed = @interpreter.numberValueOf(@params.verticalSpeed)\n        easing = gs.Easings.fromValues(@interpreter.numberValueOf(@params.easing.type), @params.easing.inOut)\n        layer = @interpreter.numberValueOf(@params.layer)\n        if @params.waitForCompletion and not (duration == 0 or @interpreter.isInstantSkip())\n            @interpreter.isWaiting = yes\n            @interpreter.waitCounter = duration\n\n        scene.backgrounds[layer]?.animator.move(horizontalSpeed, verticalSpeed, duration, easing)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandScrollBackgroundTo\n    * @protected\n    ###\n    commandScrollBackgroundTo: ->\n        scene = SceneManager.scene\n        duration = @interpreter.durationValueOf(@params.duration)\n        x = @interpreter.numberValueOf(@params.background.location.x)\n        y = @interpreter.numberValueOf(@params.background.location.y)\n        easing = gs.Easings.fromValues(@interpreter.numberValueOf(@params.easing.type), @params.easing.inOut)\n        layer = @interpreter.numberValueOf(@params.layer)\n        background = scene.backgrounds[layer]\n        if !background then return\n\n        if @params.waitForCompletion and not (duration == 0 or @interpreter.isInstantSkip())\n            @interpreter.isWaiting = yes\n            @interpreter.waitCounter = duration\n\n        if @params.positionType == 0\n            p = @interpreter.predefinedObjectPosition(@params.predefinedPositionId, background, @params)\n            x = p.x\n            y = p.y\n\n        background.animator.moveTo(x, y, duration, easing)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandScrollBackgroundPath\n    * @protected\n    ###\n    commandScrollBackgroundPath: ->\n        scene = SceneManager.scene\n        background = scene.backgrounds[@interpreter.numberValueOf(@params.layer)]\n        return unless background?\n\n        @interpreter.moveObjectPath(background, @params.path, @params)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandMaskBackground\n    * @protected\n    ###\n    commandMaskBackground: ->\n        scene = SceneManager.scene\n        background = scene.backgrounds[@interpreter.numberValueOf(@params.layer)]\n        return unless background?\n\n        @interpreter.maskObject(background, @params)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandZoomBackground\n    * @protected\n    ###\n    commandZoomBackground: ->\n        scene = SceneManager.scene\n        duration = @interpreter.durationValueOf(@params.duration)\n        x = @interpreter.numberValueOf(@params.zooming.x)\n        y = @interpreter.numberValueOf(@params.zooming.y)\n        easing = gs.Easings.fromValues(@interpreter.numberValueOf(@params.easing.type), @params.easing.inOut)\n        layer = @interpreter.numberValueOf(@params.layer)\n        if @params.waitForCompletion and not (duration == 0 or @interpreter.isInstantSkip())\n            @interpreter.isWaiting = yes\n            @interpreter.waitCounter = duration\n\n        scene.backgrounds[layer]?.animator.zoomTo(x / 100, y / 100, duration, easing)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandRotateBackground\n    * @protected\n    ###\n    commandRotateBackground: ->\n        scene = SceneManager.scene\n        background = scene.backgrounds[@interpreter.numberValueOf(@params.layer)]\n\n        if background\n            @interpreter.rotateObject(background, @params)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandTintBackground\n    * @protected\n    ###\n    commandTintBackground: ->\n        scene = SceneManager.scene\n        layer = @interpreter.numberValueOf(@params.layer)\n        background = scene.backgrounds[layer]\n        if not background? then return\n\n        duration = @interpreter.durationValueOf(@params.duration)\n        easing = gs.Easings.fromObject(@params.easing)\n        background.animator.tintTo(@params.tone, duration, easing)\n\n        @interpreter.waitForCompletion(background, @params)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandBlendBackground\n    * @protected\n    ###\n    commandBlendBackground: ->\n        layer = @interpreter.numberValueOf(@params.layer)\n        background = SceneManager.scene.backgrounds[layer]\n        if not background? then return\n\n        @interpreter.blendObject(background, @params)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandBackgroundEffect\n    * @protected\n    ###\n    commandBackgroundEffect: ->\n        layer = @interpreter.numberValueOf(@params.layer)\n        background = SceneManager.scene.backgrounds[layer]\n        if not background? then return\n\n        @interpreter.objectEffect(background, @params)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandBackgroundDefaults\n    * @protected\n    ###\n    commandBackgroundDefaults: ->\n        defaults = GameManager.defaults.background\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n\n        if !isLocked(flags.duration) then defaults.duration = @interpreter.durationValueOf(@params.duration)\n        if !isLocked(flags.zOrder) then defaults.zOrder = @interpreter.numberValueOf(@params.zOrder)\n        if !isLocked(flags[\"easing.type\"]) then defaults.easing = @params.easing\n        if !isLocked(flags[\"animation.type\"]) then defaults.animation = @params.animation\n        if !isLocked(flags.origin) then defaults.origin = @params.origin\n        if !isLocked(flags.loopHorizontal) then defaults.loopHorizontal = @params.loopHorizontal\n        if !isLocked(flags.loopVertical) then defaults.loopVertical = @params.loopVertical\n\n    ###*\n    * @method commandBackgroundMotionBlur\n    * @protected\n    ###\n    commandBackgroundMotionBlur: ->\n        layer = @interpreter.numberValueOf(@params.layer)\n        background = SceneManager.scene.backgrounds[layer]\n        if not background? then return\n\n        background.motionBlur.set(@params.motionBlur)\n\n    ###*\n    * @method commandChangeBackground\n    * @protected\n    ###\n    commandChangeBackground: ->\n        defaults = GameManager.defaults.background\n        scene = SceneManager.scene\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n        duration = if !isLocked(flags.duration) then @interpreter.durationValueOf(@params.duration) else defaults.duration\n        loopH = if !isLocked(flags.loopHorizontal) then @params.loopHorizontal else defaults.loopHorizontal\n        loopV = if !isLocked(flags.loopVertical) then @params.loopVertical else defaults.loopVertical\n        animation = if !isLocked(flags[\"animation.type\"]) then @params.animation else defaults.animation\n        origin = if !isLocked(flags.origin) then @params.origin else defaults.origin\n        zIndex = if !isLocked(flags.zOrder) then @interpreter.numberValueOf(@params.zOrder) else defaults.zOrder\n\n        if @params.waitForCompletion and not (duration == 0 or @interpreter.isInstantSkip())\n            @interpreter.isWaiting = yes\n            @interpreter.waitCounter = duration\n\n        easing = if !isLocked(flags[\"easing.type\"]) then  gs.Easings.fromObject(@params.easing) else gs.Easings.fromObject(defaults.easing)\n        layer = @interpreter.numberValueOf(@params.layer)\n        scene.behavior.changeBackground(@params.graphic, no, animation, easing, duration, 0, 0, layer, loopH, loopV)\n\n        if scene.backgrounds[layer]\n            if @params.viewport?.type == \"ui\"\n                scene.backgrounds[layer].viewport = Graphics.viewport\n            scene.backgrounds[layer].anchor.x = if origin == 0 then 0 else 0.5\n            scene.backgrounds[layer].anchor.y = if origin == 0 then 0 else 0.5\n            scene.backgrounds[layer].blendMode = @interpreter.numberValueOf(@params.blendMode)\n            scene.backgrounds[layer].zIndex = zIndex + layer\n\n            if origin == 1\n                scene.backgrounds[layer].dstRect.x = scene.backgrounds[layer].dstRect.x# + scene.backgrounds[layer].bitmap.width/2\n                scene.backgrounds[layer].dstRect.y = scene.backgrounds[layer].dstRect.y# + scene.backgrounds[layer].bitmap.height/2\n            scene.backgrounds[layer].setup()\n            scene.backgrounds[layer].update()\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandCallScene\n    * @protected\n    ###\n    commandCallScene: ->\n        @interpreter.callScene(@interpreter.stringValueOf(@params.scene.uid || @params.scene))\n\n    ###*\n    * @method commandChangeScene\n    * @protected\n    ###\n    commandChangeScene: ->\n        if GameManager.inLivePreview then return\n        GameManager.tempSettings.skip = no\n\n        if !@params.savePrevious\n            SceneManager.clear()\n\n        scene = SceneManager.scene\n        if !@params.erasePictures and !@params.savePrevious\n            scene.removeObject(scene.pictureContainer)\n            for picture in scene.pictures\n                ResourceManager.context.remove(\"Graphics/Pictures/#{picture.image}\") if picture\n        if !@params.eraseTexts and !@params.savePrevious\n            scene.removeObject(scene.textContainer)\n      #  if !@params.eraseMessageAreas and !@params.savePrevious\n      #      scene.removeObject(scene.messageAreaContainer)\n      #  if !@params.eraseHotspots and !@params.savePrevious\n      #      scene.removeObject(scene.hotspotContainer)\n        if !@params.eraseVideos and !@params.savePrevious\n            scene.removeObject(scene.videoContainer)\n            for video in scene.videos\n                ResourceManager.context.remove(\"Movies/#{video.video}\") if video\n\n        if @params.scene\n            if @params.savePrevious\n                GameManager.sceneData = uid: uid = @params.scene.uid, pictures: [], texts: [], videos: []\n            else\n                GameManager.sceneData = {\n                    uid: uid = @params.scene.uid,\n                    pictures: scene.pictureContainer.subObjectsByDomain,\n                    texts: scene.textContainer.subObjectsByDomain,\n                    videos: scene.videoContainer.subObjectsByDomain\n                #    messageAreas: scene.messageAreaContainer.subObjectsByDomain,\n                 #   hotspots: scene.hotspotContainer.subObjectsByDomain\n                }\n            flags = @params.fieldFlags || {}\n            isLocked = gs.CommandFieldFlags.isLocked\n            newScene = new vn.Object_Scene()\n            if @params.savePrevious\n                newScene.sceneData = uid: uid = @params.scene.uid, pictures: [], texts: [], videos: [], backlog: GameManager.backlog\n            else\n                newScene.sceneData = uid: uid = @params.scene.uid, pictures: scene.pictureContainer.subObjectsByDomain, texts: scene.textContainer.subObjectsByDomain, videos: scene.videoContainer.subObjectsByDomain\n\n            SceneManager.switchTo(newScene, @params.savePrevious, => @interpreter.isWaiting = no)\n        else\n            SceneManager.switchTo(null)\n\n        @interpreter.isWaiting = yes\n\n    ###*\n    * @method commandReturnToPreviousScene\n    * @protected\n    ###\n    commandReturnToPreviousScene: ->\n        if GameManager.inLivePreview then return\n        SceneManager.returnToPrevious(=> @interpreter.isWaiting = no)\n\n        @interpreter.isWaiting = yes\n\n\n    ###*\n    * @method commandSwitchToLayout\n    * @protected\n    ###\n    commandSwitchToLayout: ->\n        if GameManager.inLivePreview then return\n        if ui.UIManager.layouts[@params.layout.name]?\n            scene = new gs.Object_Layout(@params.layout.name)\n            SceneManager.switchTo(scene, @params.savePrevious, => @interpreter.isWaiting = no)\n            @interpreter.isWaiting = yes\n\n    ###*\n    * @method commandChangeTransition\n    * @protected\n    ###\n    commandChangeTransition: ->\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n\n        if !isLocked(flags.duration)\n            SceneManager.transitionData.duration = @interpreter.durationValueOf(@params.duration)\n        if !isLocked(flags.graphic)\n            SceneManager.transitionData.graphic = @params.graphic\n        if !isLocked(flags.vague)\n            SceneManager.transitionData.vague = @params.vague\n\n    ###*\n    * @method commandFreezeScreen\n    * @protected\n    ###\n    commandFreezeScreen: ->\n        Graphics.freeze()\n\n    ###*\n    * @method commandScreenTransition\n    * @protected\n    ###\n    commandScreenTransition: ->\n        defaults = GameManager.defaults.scene\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n        graphicName = if !isLocked(flags.graphic) then @params.graphic?.name else SceneManager.transitionData.graphic?.name\n\n        if graphicName\n            bitmap = if !isLocked(flags.graphic) then ResourceManager.getBitmap(\"Graphics/Masks/#{graphicName}\") else ResourceManager.getBitmap(\"Graphics/Masks/#{graphicName}\")\n        vague = if !isLocked(flags.vague) then @interpreter.numberValueOf(@params.vague) else SceneManager.transitionData.vague\n        duration = if !isLocked(flags.duration) then @interpreter.durationValueOf(@params.duration) else SceneManager.transitionData.duration\n\n        @interpreter.isWaiting = !GameManager.inLivePreview\n        @interpreter.waitCounter = duration\n\n\n        Graphics.transition(duration, bitmap, vague)\n\n    ###*\n    * @method commandShakeScreen\n    * @protected\n    ###\n    commandShakeScreen: ->\n        if not SceneManager.scene.viewport? then return\n\n        @interpreter.shakeObject(SceneManager.scene.viewport, @params)\n        gs.GameNotifier.postMinorChange()\n\n\n    ###*\n    * @method commandTintScreen\n    * @protected\n    ###\n    commandTintScreen: ->\n        duration = @interpreter.durationValueOf(@params.duration)\n        SceneManager.scene.viewport.animator.tintTo(new Tone(@params.tone), duration, gs.Easings.EASE_LINEAR[0])\n\n        if @params.waitForCompletion and duration > 0\n            @interpreter.isWaiting = yes\n            @interpreter.waitCounter = duration\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandZoomScreen\n    * @protected\n    ###\n    commandZoomScreen: ->\n        easing = gs.Easings.fromObject(@params.easing)\n        duration = @interpreter.durationValueOf(@params.duration)\n        scene = SceneManager.scene\n\n        SceneManager.scene.viewport.anchor.x = 0.5\n        SceneManager.scene.viewport.anchor.y = 0.5\n        SceneManager.scene.viewport.animator.zoomTo(@interpreter.numberValueOf(@params.zooming.x) / 100, @interpreter.numberValueOf(@params.zooming.y) / 100, duration, easing)\n\n        @interpreter.waitForCompletion(null, @params)\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandPanScreen\n    * @protected\n    ###\n    commandPanScreen: ->\n        scene = SceneManager.scene\n        duration = @interpreter.durationValueOf(@params.duration)\n        easing = gs.Easings.fromObject(@params.easing)\n        @interpreter.settings.screen.pan.x -= @params.position.x\n        @interpreter.settings.screen.pan.y -= @params.position.y\n        viewport = SceneManager.scene.viewport\n\n        viewport.animator.scrollTo(-@params.position.x + viewport.dstRect.x, -@params.position.y + viewport.dstRect.y, duration, easing)\n        @interpreter.waitForCompletion(null, @params)\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandRotateScreen\n    * @protected\n    ###\n    commandRotateScreen: ->\n        scene = SceneManager.scene\n\n        easing = gs.Easings.fromObject(@params.easing)\n        duration = @interpreter.durationValueOf(@params.duration)\n        pan = @interpreter.settings.screen.pan\n\n        SceneManager.scene.viewport.anchor.x = 0.5\n        SceneManager.scene.viewport.anchor.y = 0.5\n        SceneManager.scene.viewport.animator.rotate(@params.direction, @interpreter.numberValueOf(@params.speed) / 100, duration, easing)\n\n        @interpreter.waitForCompletion(null, @params)\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandFlashScreen\n    * @protected\n    ###\n    commandFlashScreen: ->\n        duration = @interpreter.durationValueOf(@params.duration)\n        SceneManager.scene.viewport.animator.flash(new Color(@params.color), duration, gs.Easings.EASE_LINEAR[0])\n\n        if @params.waitForCompletion and duration != 0\n            @interpreter.isWaiting = yes\n            @interpreter.waitCounter = duration\n        gs.GameNotifier.postMinorChange()\n\n\n    ###*\n    * @method commandScreenEffect\n    * @protected\n    ###\n    commandScreenEffect: ->\n        scene = SceneManager.scene\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n        duration = @interpreter.durationValueOf(@params.duration)\n        easing = gs.Easings.fromObject(@params.easing)\n\n        if !gs.CommandFieldFlags.isLocked(flags.zOrder)\n            zOrder = @interpreter.numberValueOf(@params.zOrder)\n        else\n            zOrder = SceneManager.scene.viewport.zIndex\n\n        viewport = scene.viewportContainer.subObjects.first (v) -> v.zIndex == zOrder\n\n        if !viewport\n            viewport = new gs.Object_Viewport()\n            viewport.zIndex = zOrder\n            scene.viewportContainer.addObject(viewport)\n\n        switch @params.type\n            when 0 # Wobble\n                viewport.animator.wobbleTo(@params.wobble.power / 10000, @params.wobble.speed / 100, duration, easing)\n                wobble = viewport.effects.wobble\n                wobble.enabled = @params.wobble.power > 0\n                wobble.vertical = @params.wobble.orientation == 0 or @params.wobble.orientation == 2\n                wobble.horizontal = @params.wobble.orientation == 1 or @params.wobble.orientation == 2\n            when 1 # Blur\n                viewport.animator.blurTo(@params.blur.power / 100, duration, easing)\n                viewport.effects.blur.enabled = yes\n            when 2 # Pixelate\n                viewport.animator.pixelateTo(@params.pixelate.size.width, @params.pixelate.size.height, duration, easing)\n                viewport.effects.pixelate.enabled = yes\n\n        if @params.waitForCompletion and duration != 0\n            @interpreter.isWaiting = yes\n            @interpreter.waitCounter = duration\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandVideoDefaults\n    * @protected\n    ###\n    commandVideoDefaults: ->\n        defaults = GameManager.defaults.video\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n\n        if !isLocked(flags.appearDuration) then defaults.appearDuration = @interpreter.durationValueOf(@params.appearDuration)\n        if !isLocked(flags.disappearDuration) then defaults.disappearDuration = @interpreter.durationValueOf(@params.disappearDuration)\n        if !isLocked(flags.zOrder) then defaults.zOrder = @interpreter.numberValueOf(@params.zOrder)\n        if !isLocked(flags[\"appearEasing.type\"]) then defaults.appearEasing = @params.appearEasing\n        if !isLocked(flags[\"appearAnimation.type\"]) then defaults.appearAnimation = @params.appearAnimation\n        if !isLocked(flags[\"disappearEasing.type\"]) then defaults.disappearEasing = @params.disappearEasing\n        if !isLocked(flags[\"disappearAnimation.type\"]) then defaults.disappearAnimation = @params.disappearAnimation\n        if !isLocked(flags[\"motionBlur.enabled\"]) then defaults.motionBlur = @params.motionBlur\n        if !isLocked(flags.origin) then defaults.origin = @params.origin\n\n\n    ###*\n    * @method commandShowVideo\n    * @protected\n    ###\n    commandShowVideo: ->\n        defaults = GameManager.defaults.video\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n        scene = SceneManager.scene\n        scene.behavior.changeVideoDomain(@params.numberDomain)\n        number = @interpreter.numberValueOf(@params.number)\n        videos = scene.videos\n        if not videos[number]? then videos[number] = new gs.Object_Video()\n\n        x = @interpreter.numberValueOf(@params.position.x)\n        y = @interpreter.numberValueOf(@params.position.y)\n\n        easing = if !isLocked(flags[\"easing.type\"]) then gs.Easings.fromValues(@interpreter.numberValueOf(@params.easing.type), @params.easing.inOut) else gs.Easings.fromObject(defaults.appearEasing)\n        duration = if !isLocked(flags.duration) then @interpreter.durationValueOf(@params.duration) else defaults.appearDuration\n        origin = if !isLocked(flags.origin) then @params.origin else defaults.origin\n        zIndex = if !isLocked(flags.zOrder) then @interpreter.numberValueOf(@params.zOrder) else defaults.zOrder\n        animation = if !isLocked(flags[\"animation.type\"]) then @params.animation else defaults.appearAnimation\n\n        video = videos[number]\n        video.domain = @params.numberDomain\n        video.video = @params.video?.name\n        video.loop = @params.loop ? yes\n        video.dstRect.x = x\n        video.dstRect.y = y\n        video.blendMode = @interpreter.numberValueOf(@params.blendMode)\n        video.anchor.x = if origin == 0 then 0 else 0.5\n        video.anchor.y = if origin == 0 then 0 else 0.5\n        video.zIndex = zIndex ||  (1000 + number)\n        if @params.viewport?.type == \"scene\"\n            video.viewport = SceneManager.scene.behavior.viewport\n        video.update()\n\n        if @params.positionType == 0\n            p = @interpreter.predefinedObjectPosition(@params.predefinedPositionId, video, @params)\n            video.dstRect.x = p.x\n            video.dstRect.y = p.y\n\n        video.animator.appear(x, y, animation, easing, duration)\n\n        if @params.waitForCompletion and not (duration == 0 or @interpreter.isInstantSkip())\n            @interpreter.isWaiting = yes\n            @interpreter.waitCounter = duration\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandMoveVideo\n    * @protected\n    ###\n    commandMoveVideo: ->\n        scene = SceneManager.scene\n        scene.behavior.changeVideoDomain(@params.numberDomain)\n        number = @interpreter.numberValueOf(@params.number)\n        video = scene.videos[number]\n        if not video? then return\n\n        @interpreter.moveObject(video, @params.picture.position, @params)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandMoveVideoPath\n    * @protected\n    ###\n    commandMoveVideoPath: ->\n        scene = SceneManager.scene\n        scene.behavior.changeVideoDomain(@params.numberDomain)\n        number = @interpreter.numberValueOf(@params.number)\n        video = scene.videos[number]\n        if not video? then return\n\n        @interpreter.moveObjectPath(video, @params)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandRotateVideo\n    * @protected\n    ###\n    commandRotateVideo: ->\n        scene = SceneManager.scene\n        scene.behavior.changeVideoDomain(@params.numberDomain)\n        number = @interpreter.numberValueOf(@params.number)\n        video = scene.videos[number]\n        if not video? then return\n\n        @interpreter.rotateObject(video, @params)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandZoomVideo\n    * @protected\n    ###\n    commandZoomVideo: ->\n        scene = SceneManager.scene\n        scene.behavior.changeVideoDomain(@params.numberDomain)\n        number = @interpreter.numberValueOf(@params.number)\n        video = scene.videos[number]\n        if not video? then return\n\n        @interpreter.zoomObject(video, @params)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandBlendVideo\n    * @protected\n    ###\n    commandBlendVideo: ->\n        SceneManager.scene.behavior.changeVideoDomain(@params.numberDomain)\n        video = SceneManager.scene.videos[@interpreter.numberValueOf(@params.number)]\n        if not video? then return\n\n        @interpreter.blendObject(video, @params)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandTintVideo\n    * @protected\n    ###\n    commandTintVideo: ->\n        scene = SceneManager.scene\n        scene.behavior.changeVideoDomain(@params.numberDomain)\n        number = @interpreter.numberValueOf(@params.number)\n        video = scene.videos[number]\n        if not video? then return\n\n        @interpreter.tintObject(video, @params)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandFlashVideo\n    * @protected\n    ###\n    commandFlashVideo: ->\n        scene = SceneManager.scene\n        scene.behavior.changeVideoDomain(@params.numberDomain)\n        number = @interpreter.numberValueOf(@params.number)\n        video = scene.videos[number]\n        if not video? then return\n\n        @interpreter.flashObject(video, @params)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandCropVideo\n    * @protected\n    ###\n    commandCropVideo: ->\n        scene = SceneManager.scene\n        scene.behavior.changeVideoDomain(@params.numberDomain)\n        number = @interpreter.numberValueOf(@params.number)\n        video = scene.videos[number]\n        if not video? then return\n\n        @interpreter.cropObject(video, @params)\n\n\n    ###*\n    * @method commandVideoMotionBlur\n    * @protected\n    ###\n    commandVideoMotionBlur: ->\n        scene = SceneManager.scene\n        scene.behavior.changeVideoDomain(@params.numberDomain)\n        number = @interpreter.numberValueOf(@params.number)\n        video = scene.videos[number]\n        if not video? then return\n\n        @interpreter.objectMotionBlur(video, @params)\n\n    ###*\n    * @method commandMaskVideo\n    * @protected\n    ###\n    commandMaskVideo: ->\n        scene = SceneManager.scene\n        scene.behavior.changeVideoDomain(@params.numberDomain)\n        number = @interpreter.numberValueOf(@params.number)\n        video = scene.videos[number]\n        if not video? then return\n\n        @interpreter.maskObject(video, @params)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandVideoEffect\n    * @protected\n    ###\n    commandVideoEffect: ->\n        scene = SceneManager.scene\n        scene.behavior.changeVideoDomain(@params.numberDomain)\n        number = @interpreter.numberValueOf(@params.number)\n        video = scene.videos[number]\n        if not video? then return\n\n        @interpreter.objectEffect(video, @params)\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandEraseVideo\n    * @protected\n    ###\n    commandEraseVideo: ->\n        defaults = GameManager.defaults.video\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n        scene = SceneManager.scene\n        scene.behavior.changeVideoDomain(@params.numberDomain)\n        number = @interpreter.numberValueOf(@params.number)\n        video = scene.videos[number]\n        if not video? then return\n\n        easing = if !isLocked(flags[\"easing.type\"]) then gs.Easings.fromValues(@interpreter.numberValueOf(@params.easing.type), @params.easing.inOut) else gs.Easings.fromObject(defaults.disappearEasing)\n        duration = if !isLocked(flags.duration) then @interpreter.durationValueOf(@params.duration) else defaults.disappearDuration\n        animation = if !isLocked(flags[\"animation.type\"]) then @params.animation else defaults.disappearAnimation\n\n        video.animator.disappear(animation, easing, duration, (sender) =>\n            sender.dispose()\n            scene.behavior.changeTextDomain(sender.domain)\n            scene.videos[number] = null\n          #  sender.video.pause()\n        )\n\n        if @params.waitForCompletion and not (duration == 0 or @interpreter.isInstantSkip())\n            @interpreter.isWaiting = yes\n            @interpreter.waitCounter = duration\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandShowImageMap\n    * @protected\n    ###\n    commandShowImageMap: ->\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n        SceneManager.scene.behavior.changePictureDomain(@params.numberDomain)\n        number = @interpreter.numberValueOf(@params.number)\n        imageMap = SceneManager.scene.pictures[number]\n        if imageMap?\n            imageMap.dispose()\n        imageMap = new gs.Object_ImageMap()\n        imageMap.visual.variableContext = @interpreter.context\n        SceneManager.scene.pictures[number] = imageMap\n        bitmap = ResourceManager.getBitmap(\"Graphics/Pictures/#{@params.ground?.name}\")\n\n        imageMap.dstRect.width = bitmap.width\n        imageMap.dstRect.height = bitmap.height\n\n        if @params.positionType == 0\n            p = @interpreter.predefinedObjectPosition(@params.predefinedPositionId, imageMap, @params)\n            imageMap.dstRect.x = p.x\n            imageMap.dstRect.y = p.y\n        else\n            imageMap.dstRect.x = @interpreter.numberValueOf(@params.position.x)\n            imageMap.dstRect.y = @interpreter.numberValueOf(@params.position.y)\n\n        imageMap.anchor.x = if @params.origin == 1 then 0.5 else 0\n        imageMap.anchor.y = if @params.origin == 1 then 0.5 else 0\n        imageMap.zIndex = if !isLocked(flags.zOrder) then @interpreter.numberValueOf(@params.zOrder) else (700 + number)\n        imageMap.blendMode = if !isLocked(flags.blendMode) then @params.blendMode else 0\n        imageMap.hotspots = @params.hotspots\n        imageMap.images = [\n            @params.ground?.name,\n            @params.hover?.name,\n            @params.unselected?.name,\n            @params.selected?.name,\n            @params.selectedHover?.name\n        ]\n\n        imageMap.events.on \"jumpTo\", gs.CallBack(\"onJumpTo\", @interpreter)\n        imageMap.events.on \"callCommonEvent\", gs.CallBack(\"onCallCommonEvent\", @interpreter)\n\n        imageMap.setup()\n        imageMap.update()\n\n        @interpreter.showObject(imageMap, {x:0, y:0}, @params)\n\n        if @params.waitForCompletion\n            @interpreter.waitCounter = 0\n            @interpreter.isWaiting = yes\n\n        imageMap.events.on \"finish\", (sender) =>\n            @interpreter.isWaiting = no\n           # @interpreter.eraseObject(scene.imageMap, @params)\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandEraseImageMap\n    * @protected\n    ###\n    commandEraseImageMap: ->\n        scene = SceneManager.scene\n        scene.behavior.changePictureDomain(@params.numberDomain)\n        number = @interpreter.numberValueOf(@params.number)\n        imageMap = scene.pictures[number]\n        if not imageMap? then return\n\n        imageMap.events.emit(\"finish\", imageMap)\n        imageMap.visual.active = no\n        @interpreter.eraseObject(imageMap, @params, (sender) =>\n                scene.behavior.changePictureDomain(sender.domain)\n                scene.pictures[number] = null\n        )\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandAddHotspot\n    * @protected\n    ###\n    commandAddHotspot: ->\n        scene = SceneManager.scene\n        scene.behavior.changeHotspotDomain(@params.numberDomain)\n        number = @interpreter.numberValueOf(@params.number)\n        hotspots = scene.hotspots\n\n        if not hotspots[number]?\n            hotspots[number] = new gs.Object_Hotspot()\n\n        hotspot = hotspots[number]\n        hotspot.domain = @params.numberDomain\n        hotspot.data = { params: @params, bindValue: @interpreter.numberValueOf(@params.actions.onDrag.bindValue) }\n\n        switch @params.positionType\n            when 0 # Direct\n                hotspot.dstRect.x = @params.box.x\n                hotspot.dstRect.y = @params.box.y\n                hotspot.dstRect.width = @params.box.size.width\n                hotspot.dstRect.height = @params.box.size.height\n            when 1 # Calculated\n                hotspot.dstRect.x = @interpreter.numberValueOf(@params.box.x)\n                hotspot.dstRect.y = @interpreter.numberValueOf(@params.box.y)\n                hotspot.dstRect.width = @interpreter.numberValueOf(@params.box.size.width)\n                hotspot.dstRect.height = @interpreter.numberValueOf(@params.box.size.height)\n            when 2 # Bind to Picture\n                picture = scene.pictures[@interpreter.numberValueOf(@params.pictureNumber)]\n                if picture?\n                    hotspot.target = picture\n            when 3 # Bind to Text\n                text = scene.texts[@interpreter.numberValueOf(@params.textNumber)]\n                if text?\n                    hotspot.target = text\n\n        hotspot.behavior.shape = @params.shape ? gs.HotspotShape.RECTANGLE\n\n        if text?\n            hotspot.images = null\n        else\n            hotspot.images = [\n                @params.baseGraphic?.name || @interpreter.stringValueOf(@params.baseGraphic) || picture?.image,\n                @params.hoverGraphic?.name || @interpreter.stringValueOf(@params.hoverGraphic),\n                @params.selectedGraphic?.name || @interpreter.stringValueOf(@params.selectedGraphic),\n                @params.selectedHoverGraphic?.name || @interpreter.stringValueOf(@params.selectedHoverGraphic),\n                @params.unselectedGraphic?.name || @interpreter.stringValueOf(@params.unselectedGraphic)\n            ]\n\n\n        if @params.actions.onClick.type != 0 or @params.actions.onClick.label\n            hotspot.events.on \"click\", gs.CallBack(\"onHotspotClick\", @interpreter, { params: @params, bindValue: @interpreter.numberValueOf(@params.actions.onClick.bindValue) })\n        if @params.actions.onEnter.type != 0 or @params.actions.onEnter.label\n            hotspot.events.on \"enter\", gs.CallBack(\"onHotspotEnter\", @interpreter, { params: @params, bindValue: @interpreter.numberValueOf(@params.actions.onEnter.bindValue) })\n        if @params.actions.onLeave.type != 0 or @params.actions.onLeave.label\n            hotspot.events.on \"leave\", gs.CallBack(\"onHotspotLeave\", @interpreter, { params: @params, bindValue: @interpreter.numberValueOf(@params.actions.onLeave.bindValue) })\n        if @params.actions.onDrag.type != 0 or @params.actions.onDrag.label\n            hotspot.events.on \"dragStart\", gs.CallBack(\"onHotspotDragStart\", @interpreter, { params: @params, bindValue: @interpreter.numberValueOf(@params.actions.onDrag.bindValue) })\n            hotspot.events.on \"drag\", gs.CallBack(\"onHotspotDrag\", @interpreter, { params: @params, bindValue: @interpreter.numberValueOf(@params.actions.onDrag.bindValue) })\n            hotspot.events.on \"dragEnd\", gs.CallBack(\"onHotspotDragEnd\", @interpreter, { params: @params, bindValue: @interpreter.numberValueOf(@params.actions.onDrag.bindValue) })\n        if @params.actions.onSelect.type != 0 or @params.actions.onSelect.label or\n           @params.actions.onDeselect.type != 0 or @params.actions.onDeselect.label\n            hotspot.events.on \"stateChanged\", gs.CallBack(\"onHotspotStateChanged\", @interpreter, @params)\n        if @params.dragging.enabled\n            hotspot.events.on \"dragEnd\", gs.CallBack(\"onHotspotDrop\", @interpreter, { params: @params, bindValue: @interpreter.numberValueOf(@params.actions.onDrag.bindValue) })\n        if @params.actions.onDropReceive.type != 0 or @params.actions.onDropReceive.label\n            hotspot.events.on \"dropReceived\", gs.CallBack(\"onHotspotDropReceived\", @interpreter, { params: @params, bindValue: @interpreter.numberValueOf(@params.actions.onDrag.bindValue) })\n\n        hotspot.selectable = yes\n\n\n        if @params.dragging.enabled\n            dragging = @params.dragging\n            hotspot.draggable = {\n                rect: new Rect(dragging.rect.x, dragging.rect.y, dragging.rect.size.width, dragging.rect.size.height),\n                axisX: dragging.horizontal,\n                axisY: dragging.vertical\n            }\n            hotspot.addComponent(new ui.Component_Draggable())\n            hotspot.events.on \"drag\", (e) =>\n                drag = e.sender.draggable\n                GameManager.variableStore.setupTempVariables(@interpreter.context)\n                if @params.dragging.horizontal\n                    @interpreter.setNumberValueTo(@params.dragging.variable, Math.round((e.sender.dstRect.x-drag.rect.x) / (drag.rect.width-e.sender.dstRect.width) * 100))\n                else\n                    @interpreter.setNumberValueTo(@params.dragging.variable, Math.round((e.sender.dstRect.y-drag.rect.y) / (drag.rect.height-e.sender.dstRect.height) * 100))\n\n        hotspot.setup()\n    ###*\n    * @method commandChangeHotspotState\n    * @protected\n    ###\n    commandChangeHotspotState: ->\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n        scene = SceneManager.scene\n        scene.behavior.changeHotspotDomain(@params.numberDomain)\n        number = @interpreter.numberValueOf(@params.number)\n        hotspot = scene.hotspots[number]\n        return if !hotspot\n\n        if !isLocked(flags.selected) then hotspot.behavior.selected = @interpreter.booleanValueOf(@params.selected)\n        if !isLocked(flags.enabled) then hotspot.behavior.enabled = @interpreter.booleanValueOf(@params.enabled)\n\n        hotspot.behavior.updateInput()\n        hotspot.behavior.updateImage()\n\n    ###*\n    * @method commandEraseHotspot\n    * @protected\n    ###\n    commandEraseHotspot: ->\n        scene = SceneManager.scene\n        scene.behavior.changeHotspotDomain(@params.numberDomain)\n        number = @interpreter.numberValueOf(@params.number)\n\n        if scene.hotspots[number]?\n            scene.hotspots[number].dispose()\n            scene.hotspotContainer.eraseObject(number)\n\n    ###*\n    * @method commandChangeObjectDomain\n    * @protected\n    ###\n    commandChangeObjectDomain: ->\n        SceneManager.scene.behavior.changeObjectDomain(@interpreter.stringValueOf(@params.domain))\n\n    ###*\n    * @method commandPictureDefaults\n    * @protected\n    ###\n    commandPictureDefaults: ->\n        defaults = GameManager.defaults.picture\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n\n        if !isLocked(flags.appearDuration) then defaults.appearDuration = @interpreter.durationValueOf(@params.appearDuration)\n        if !isLocked(flags.disappearDuration) then defaults.disappearDuration = @interpreter.durationValueOf(@params.disappearDuration)\n        if !isLocked(flags.zOrder) then defaults.zOrder = @interpreter.numberValueOf(@params.zOrder)\n        if !isLocked(flags[\"appearEasing.type\"]) then defaults.appearEasing = @params.appearEasing\n        if !isLocked(flags[\"appearAnimation.type\"]) then defaults.appearAnimation = @params.appearAnimation\n        if !isLocked(flags[\"disappearEasing.type\"]) then defaults.disappearEasing = @params.disappearEasing\n        if !isLocked(flags[\"disappearAnimation.type\"]) then defaults.disappearAnimation = @params.disappearAnimation\n        if !isLocked(flags[\"motionBlur.enabled\"]) then defaults.motionBlur = @params.motionBlur\n        if !isLocked(flags.origin) then defaults.origin = @params.origin\n\n\n    createPicture: (graphic, params) ->\n        graphic = @stringValueOf(graphic)\n        graphicName = if graphic?.name? then graphic.name else graphic\n        bitmap = ResourceManager.getBitmap(\"Graphics/Pictures/#{graphicName}\")\n        return null if bitmap && !bitmap.loaded\n\n        defaults = GameManager.defaults.picture\n        flags = params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n        scene = SceneManager.scene\n        number = @numberValueOf(params.number)\n        pictures = scene.pictures\n        picture = pictures[number]\n        if not picture?\n            picture = new gs.Object_Picture(null, null, params.visual?.type)\n            picture.domain = params.numberDomain\n            pictures[number] = picture\n            switch params.visual?.type\n                when 1\n                    picture.visual.looping.vertical = yes\n                    picture.visual.looping.horizontal = yes\n                when 2\n                    picture.frameThickness = params.visual.frame.thickness\n                    picture.frameCornerSize = params.visual.frame.cornerSize\n                when 3\n                    picture.visual.orientation = params.visual.threePartImage.orientation\n                when 4\n                    picture.color = gs.Color.fromObject(params.visual.quad.color)\n                when 5\n                    snapshot = Graphics.snapshot()\n                    #ResourceManager.addCustomBitmap(snapshot)\n                    picture.bitmap = snapshot\n                    picture.dstRect.width = snapshot.width\n                    picture.dstRect.height = snapshot.height\n                    picture.srcRect.set(0, 0, snapshot.width, snapshot.height)\n        else\n            picture.bitmap = null\n\n\n        x = @numberValueOf(params.position.x)\n        y = @numberValueOf(params.position.y)\n        picture = pictures[number]\n\n        if !picture.bitmap\n            picture.image = graphicName\n        else\n            picture.image = null\n\n        bitmap = picture.bitmap ? ResourceManager.getBitmap(\"Graphics/Pictures/#{graphicName}\")\n        easing = if !isLocked(flags[\"easing.type\"]) then gs.Easings.fromValues(@numberValueOf(params.easing.type), params.easing.inOut) else gs.Easings.fromObject(defaults.appearEasing)\n        duration = if !isLocked(flags.duration) then @durationValueOf(params.duration) else defaults.appearDuration\n        origin = if !isLocked(flags.origin) then params.origin else defaults.origin\n        zIndex = if !isLocked(flags.zOrder) then @numberValueOf(params.zOrder) else defaults.zOrder\n        animation = if !isLocked(flags[\"animation.type\"]) then params.animation else defaults.appearAnimation\n\n        picture.mirror = params.position.horizontalFlip\n        picture.angle = params.position.angle || 0\n        picture.zoom.x = (params.position.data?.zoom||1)\n        picture.zoom.y = (params.position.data?.zoom||1)\n        picture.blendMode = @numberValueOf(params.blendMode)\n\n        if params.origin == 1 and bitmap?\n            x += (bitmap.width*picture.zoom.x-bitmap.width)/2\n            y += (bitmap.height*picture.zoom.y-bitmap.height)/2\n\n        picture.dstRect.x = x\n        picture.dstRect.y = y\n        picture.anchor.x = if origin == 1 then 0.5 else 0\n        picture.anchor.y = if origin == 1 then 0.5 else 0\n        picture.zIndex = zIndex ||  (700 + number)\n\n        if params.viewport?.type == \"scene\"\n            picture.viewport = SceneManager.scene.behavior.viewport\n\n        if params.size?.type == 1\n            picture.dstRect.width = @numberValueOf(params.size.width)\n            picture.dstRect.height = @numberValueOf(params.size.height)\n\n        picture.update()\n\n        return picture\n    ###*\n    * @method commandShowPicture\n    * @protected\n    ###\n    commandShowPicture: ->\n        SceneManager.scene.behavior.changePictureDomain(@params.numberDomain || \"\")\n        defaults = GameManager.defaults.picture\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n        picture = @interpreter.createPicture(@params.graphic, @params)\n        if !picture\n            @interpreter.pointer--\n            @interpreter.isWaiting = yes\n            @interpreter.waitCounter = 1\n            return\n\n        if @params.positionType == 0\n            p = @interpreter.predefinedObjectPosition(@params.predefinedPositionId, picture, @params)\n            picture.dstRect.x = p.x\n            picture.dstRect.y = p.y\n\n        easing = if !isLocked(flags[\"easing.type\"]) then gs.Easings.fromValues(@interpreter.numberValueOf(@params.easing.type), @params.easing.inOut) else gs.Easings.fromObject(defaults.appearEasing)\n        duration = if !isLocked(flags.duration) then @interpreter.durationValueOf(@params.duration) else defaults.appearDuration\n        animation = if !isLocked(flags[\"animation.type\"]) then @params.animation else defaults.appearAnimation\n\n        picture.animator.appear(picture.dstRect.x, picture.dstRect.y, animation, easing, duration)\n\n        if @params.waitForCompletion and not (duration == 0 or @interpreter.isInstantSkip())\n            @interpreter.isWaiting = yes\n            @interpreter.waitCounter = duration\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandPlayPictureAnimation\n    * @protected\n    ###\n    commandPlayPictureAnimation: ->\n        SceneManager.scene.behavior.changePictureDomain(@params.numberDomain || \"\")\n\n        defaults = GameManager.defaults.picture\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n        picture = null\n\n        easing = if !isLocked(flags[\"easing.type\"]) then gs.Easings.fromValues(@interpreter.numberValueOf(@params.easing.type), @params.easing.inOut) else gs.Easings.fromObject(defaults.appearEasing)\n        duration = if !isLocked(flags.duration) then @interpreter.durationValueOf(@params.duration) else defaults.appearDuration\n        animation = if !isLocked(flags[\"animation.type\"]) then @params.animation else defaults.appearAnimation\n\n        if @params.animationId?\n            record = RecordManager.animations[@params.animationId]\n            if record?\n                picture = @interpreter.createPicture(record.graphic, @params)\n\n                component = picture.findComponent(\"Component_FrameAnimation\")\n                if component?\n                    component.refresh(record)\n                    component.start()\n                else\n                    component = new gs.Component_FrameAnimation(record)\n                    picture.addComponent(component)\n\n                component.update()\n\n                if @params.positionType == 0\n                    p = @interpreter.predefinedObjectPosition(@params.predefinedPositionId, picture, @params)\n                    picture.dstRect.x = p.x\n                    picture.dstRect.y = p.y\n\n                picture.animator.appear(picture.dstRect.x, picture.dstRect.y, animation, easing, duration)\n\n        else\n            picture = SceneManager.scene.pictures[@interpreter.numberValueOf(@params.number)]\n            animation = picture?.findComponent(\"Component_FrameAnimation\")\n\n            if animation?\n                picture.removeComponent(animation)\n                bitmap = ResourceManager.getBitmap(\"Graphics/Animations/#{picture.image}\")\n                if bitmap?\n                    picture.srcRect.set(0, 0, bitmap.width, bitmap.height)\n                    picture.dstRect.width = picture.srcRect.width\n                    picture.dstRect.height = picture.srcRect.height\n\n        if @params.waitForCompletion and not (duration == 0 or @interpreter.isInstantSkip())\n            @interpreter.isWaiting = yes\n            @interpreter.waitCounter = duration\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandMovePicturePath\n    * @protected\n    ###\n    commandMovePicturePath: ->\n        scene = SceneManager.scene\n        scene.behavior.changePictureDomain(@params.numberDomain)\n        number = @interpreter.numberValueOf(@params.number)\n        picture = scene.pictures[number]\n        if not picture? then return\n\n        @interpreter.moveObjectPath(picture, @params.path, @params)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandMovePicture\n    * @protected\n    ###\n    commandMovePicture: ->\n        scene = SceneManager.scene\n        scene.behavior.changePictureDomain(@params.numberDomain)\n        number = @interpreter.numberValueOf(@params.number)\n        picture = scene.pictures[number]\n        if not picture? then return\n\n        @interpreter.moveObject(picture, @params.picture.position, @params)\n\n        gs.GameNotifier.postMinorChange()\n\n\n    ###*\n    * @method commandTintPicture\n    * @protected\n    ###\n    commandTintPicture: ->\n        scene = SceneManager.scene\n        scene.behavior.changePictureDomain(@params.numberDomain || \"\")\n        number = @interpreter.numberValueOf(@params.number)\n        picture = scene.pictures[number]\n        if not picture? then return\n\n        @interpreter.tintObject(picture, @params)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandFlashPicture\n    * @protected\n    ###\n    commandFlashPicture: ->\n        scene = SceneManager.scene\n        scene.behavior.changePictureDomain(@params.numberDomain || \"\")\n        number = @interpreter.numberValueOf(@params.number)\n        picture = scene.pictures[number]\n        if not picture? then return\n\n        @interpreter.flashObject(picture, @params)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandCropPicture\n    * @protected\n    ###\n    commandCropPicture: ->\n        scene = SceneManager.scene\n        scene.behavior.changePictureDomain(@params.numberDomain || \"\")\n        number = @interpreter.numberValueOf(@params.number)\n        picture = scene.pictures[number]\n        if not picture? then return\n\n        @interpreter.cropObject(picture, @params)\n\n    ###*\n    * @method commandRotatePicture\n    * @protected\n    ###\n    commandRotatePicture: ->\n        scene = SceneManager.scene\n        scene.behavior.changePictureDomain(@params.numberDomain || \"\")\n        number = @interpreter.numberValueOf(@params.number)\n        picture = scene.pictures[number]\n        if not picture? then return\n\n        @interpreter.rotateObject(picture, @params)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandZoomPicture\n    * @protected\n    ###\n    commandZoomPicture: ->\n        scene = SceneManager.scene\n        scene.behavior.changePictureDomain(@params.numberDomain || \"\")\n        number = @interpreter.numberValueOf(@params.number)\n        picture = scene.pictures[number]\n        if not picture? then return\n\n        @interpreter.zoomObject(picture, @params)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandBlendPicture\n    * @protected\n    ###\n    commandBlendPicture: ->\n        SceneManager.scene.behavior.changePictureDomain(@params.numberDomain || \"\")\n        picture = SceneManager.scene.pictures[@interpreter.numberValueOf(@params.number)]\n        if not picture? then return\n\n        @interpreter.blendObject(picture, @params)\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandShakePicture\n    * @protected\n    ###\n    commandShakePicture: ->\n        picture = SceneManager.scene.pictures[@interpreter.numberValueOf(@params.number)]\n        if not picture? then return\n\n        @interpreter.shakeObject(picture, @params)\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandMaskPicture\n    * @protected\n    ###\n    commandMaskPicture: ->\n        scene = SceneManager.scene\n        scene.behavior.changePictureDomain(@params.numberDomain || \"\")\n        number = @interpreter.numberValueOf(@params.number)\n        picture = scene.pictures[number]\n        if not picture? then return\n\n        @interpreter.maskObject(picture, @params)\n        gs.GameNotifier.postMinorChange()\n\n\n    ###*\n    * @method commandPictureMotionBlur\n    * @protected\n    ###\n    commandPictureMotionBlur: ->\n        scene = SceneManager.scene\n        scene.behavior.changePictureDomain(@params.numberDomain || \"\")\n        number = @interpreter.numberValueOf(@params.number)\n        picture = scene.pictures[number]\n        if not picture? then return\n\n        @interpreter.objectMotionBlur(picture, @params)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandPictureEffect\n    * @protected\n    ###\n    commandPictureEffect: ->\n        scene = SceneManager.scene\n        scene.behavior.changePictureDomain(@params.numberDomain || \"\")\n        number = @interpreter.numberValueOf(@params.number)\n        picture = scene.pictures[number]\n        if not picture? then return\n\n        @interpreter.objectEffect(picture, @params)\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandErasePicture\n    * @protected\n    ###\n    commandErasePicture: ->\n        defaults = GameManager.defaults.picture\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n\n        scene = SceneManager.scene\n        scene.behavior.changePictureDomain(@params.numberDomain || \"\")\n        number = @interpreter.numberValueOf(@params.number)\n        picture = scene.pictures[number]\n        if not picture? then return\n\n        easing = if !isLocked(flags[\"easing.type\"]) then gs.Easings.fromValues(@interpreter.numberValueOf(@params.easing.type), @params.easing.inOut) else gs.Easings.fromObject(defaults.disappearEasing)\n        duration = if !isLocked(flags.duration) then @interpreter.durationValueOf(@params.duration) else defaults.disappearDuration\n        animation = if !isLocked(flags[\"animation.type\"]) then @params.animation else defaults.disappearAnimation\n\n        picture.animator.disappear(animation, easing, duration,\n            (sender) =>\n                sender.dispose()\n                scene.behavior.changePictureDomain(sender.domain)\n                scene.pictures[number] = null\n        )\n\n        if @params.waitForCompletion and not (duration == 0 or @interpreter.isInstantSkip())\n            @interpreter.isWaiting = yes\n            @interpreter.waitCounter = duration\n\n        gs.GameNotifier.postMinorChange()\n\n\n    ###*\n    * @method commandInputNumber\n    * @protected\n    ###\n    commandInputNumber: ->\n        scene = SceneManager.scene\n        @interpreter.isWaiting = yes\n        if @interpreter.isProcessingMessageInOtherContext()\n            @interpreter.waitForMessage()\n            return\n\n        if (GameManager.settings.allowChoiceSkip||@interpreter.preview) and GameManager.tempSettings.skip\n            @interpreter.isWaiting = no\n            @interpreter.messageObject().behavior.clear()\n            @interpreter.setNumberValueTo(@params.variable, 0)\n            return\n\n        $tempFields.digits = @params.digits\n        scene.behavior.showInputNumber(@params.digits, gs.CallBack(\"onInputNumberFinish\", @interpreter, @params))\n\n        @interpreter.waitingFor.inputNumber = @params\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandChoiceTimer\n    * @protected\n    ###\n    commandChoiceTimer: ->\n        scene = SceneManager.scene\n\n        GameManager.tempFields.choiceTimer = scene.choiceTimer\n        GameManager.tempFields.choiceTimerVisible = @params.visible\n\n        if @params.enabled\n            scene.choiceTimer.behavior.seconds = @interpreter.numberValueOf(@params.seconds)\n            scene.choiceTimer.behavior.minutes = @interpreter.numberValueOf(@params.minutes)\n            scene.choiceTimer.behavior.start()\n            scene.choiceTimer.events.on \"finish\", (sender) =>\n                if  scene.choiceWindow and scene.choices?.length > 0\n                    defaultChoice = (scene.choices.first (c) -> c.isDefault) || scene.choices[0]\n                    #scene.choiceWindow.events.emit(\"selectionAccept\", scene.choiceWindow, { labelIndex: defaultChoice.action.labelIndex })\n                    scene.choiceWindow.events.emit(\"selectionAccept\", scene.choiceWindow, defaultChoice)\n        else\n            scene.choiceTimer.stop()\n\n    ###*\n    * @method commandShowChoices\n    * @protected\n    ###\n    commandShowChoices: ->\n        scene = SceneManager.scene\n        pointer = @interpreter.pointer\n        choices = scene.choices || []\n\n        if (GameManager.settings.allowChoiceSkip||@interpreter.previewData) and GameManager.tempSettings.skip\n            messageObject = @interpreter.messageObject()\n            if messageObject?.visible\n                messageObject.behavior.clear()\n            defaultChoice = (choices.first((c) -> c.isDefault)) || choices[0]\n            if defaultChoice.action.labelIndex?\n                @interpreter.pointer = defaultChoice.action.labelIndex\n            else\n                @interpreter.jumpToLabel(defaultChoice.action.label)\n            scene.choices = []\n        else\n            if choices.length > 0\n                @interpreter.isWaiting = yes\n                scene.behavior.showChoices(gs.CallBack(\"onChoiceAccept\", @interpreter, { pointer: pointer, params: @params }))\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandShowChoice\n    * @protected\n    ###\n    commandShowChoice: ->\n        scene = SceneManager.scene\n        commands = @interpreter.object.commands\n        command = null\n        index = 0\n        pointer = @interpreter.pointer\n        choices = null\n        dstRect = null\n\n        switch @params.positionType\n            when 0 # Auto\n                dstRect = null\n            when 1 # Direct\n                dstRect = new Rect(@params.box.x, @params.box.y, @params.box.size.width, @params.box.size.height)\n\n        if !scene.choices\n            scene.choices = []\n        choices = scene.choices\n        choices.push({\n            dstRect: dstRect,\n            #text: lcs(@params.text),\n            text: @params.text,\n            index: index,\n            action: @params.action,\n            isSelected: no,\n            isDefault: @params.defaultChoice,\n            isEnabled: @interpreter.booleanValueOf(@params.enabled) })\n\n    ###*\n    * @method commandOpenMenu\n    * @protected\n    ###\n    commandOpenMenu: ->\n        SceneManager.switchTo(new gs.Object_Layout(\"menuLayout\"), true)\n        @interpreter.waitCounter = 1\n        @interpreter.isWaiting = yes\n\n    ###*\n    * @method commandOpenLoadMenu\n    * @protected\n    ###\n    commandOpenLoadMenu: ->\n        SceneManager.switchTo(new gs.Object_Layout(\"loadMenuLayout\"), true)\n        @interpreter.waitCounter = 1\n        @interpreter.isWaiting = yes\n\n    ###*\n    * @method commandOpenSaveMenu\n    * @protected\n    ###\n    commandOpenSaveMenu: ->\n        SceneManager.switchTo(new gs.Object_Layout(\"saveMenuLayout\"), true)\n        @interpreter.waitCounter = 1\n        @interpreter.isWaiting = yes\n\n    ###*\n    * @method commandReturnToTitle\n    * @protected\n    ###\n    commandReturnToTitle: ->\n        SceneManager.clear()\n        SceneManager.switchTo(new gs.Object_Layout(\"titleLayout\"))\n        @interpreter.waitCounter = 1\n        @interpreter.isWaiting = yes\n\n\n    ###*\n    * @method commandPlayVideo\n    * @protected\n    ###\n    commandPlayVideo: ->\n        if (GameManager.inLivePreview or GameManager.settings.allowVideoSkip) and GameManager.tempSettings.skip then return\n\n        GameManager.tempSettings.skip = no\n        scene = SceneManager.scene\n\n        if @params.video?.name?\n            scene.video = ResourceManager.getVideo(\"Movies/#{@params.video.name}\")\n\n            @videoSprite = new Sprite(Graphics.viewport)\n            @videoSprite.srcRect = new Rect(0, 0, scene.video.width, scene.video.height)\n            @videoSprite.video = scene.video\n            @videoSprite.zoomX = Graphics.width / scene.video.width\n            @videoSprite.zoomY = Graphics.height / scene.video.height\n            @videoSprite.z = 99999999\n            scene.video.onEnded = =>\n                @interpreter.isWaiting = no\n                @videoSprite.dispose()\n                scene.video = null\n            scene.video.volume = @params.volume / 100\n            scene.video.playbackRate = @params.playbackRate / 100\n            @interpreter.isWaiting = yes\n            scene.video.play()\n        gs.GameNotifier.postMinorChange()\n    ###*\n    * @method commandAudioDefaults\n    * @protected\n    ###\n    commandAudioDefaults: ->\n        defaults = GameManager.defaults.audio\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n\n        if !isLocked(flags.musicFadeInDuration) then defaults.musicFadeInDuration = @params.musicFadeInDuration\n        if !isLocked(flags.musicFadeOutDuration) then defaults.musicFadeOutDuration = @params.musicFadeOutDuration\n        if !isLocked(flags.musicVolume) then defaults.musicVolume = @params.musicVolume\n        if !isLocked(flags.musicPlaybackRate) then defaults.musicPlaybackRate = @params.musicPlaybackRate\n        if !isLocked(flags.soundVolume) then defaults.soundVolume = @params.soundVolume\n        if !isLocked(flags.soundPlaybackRate) then defaults.soundPlaybackRate = @params.soundPlaybackRate\n        if !isLocked(flags.voiceVolume) then defaults.voiceVolume = @params.voiceVolume\n        if !isLocked(flags.voicePlaybackRate) then defaults.voicePlaybackRate = @params.voicePlaybackRate\n\n    ###*\n    * @method commandPlayMusic\n    * @protected\n    ###\n    commandPlayMusic: ->\n        if not @params.music? then return\n        defaults = GameManager.defaults.audio\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n        music = null\n\n        if GameManager.settings.bgmEnabled\n            fadeDuration = if !isLocked(flags.fadeInDuration) then @params.fadeInDuration else defaults.musicFadeInDuration\n            volume = if !isLocked(flags[\"music.volume\"]) then @params.music.volume else defaults.musicVolume\n            playbackRate = if !isLocked(flags[\"music.playbackRate\"]) then @params.music.playbackRate else defaults.musicPlaybackRate\n            music = { name: @params.music.name, volume: volume, playbackRate: playbackRate }\n            if @params.playType == 1\n                playTime = min: @params.playTime.min * 60, max: @params.playTime.max * 60\n                playRange = start: @params.playRange.start * 60, end: @params.playRange.end * 60\n                AudioManager.playMusicRandom(music, fadeDuration, @params.layer || 0, playTime, playRange)\n            else\n                music = AudioManager.playMusic(@params.music.name, volume, playbackRate, fadeDuration, @params.layer || 0, @params.loop)\n\n        if music and @params.waitForCompletion and !@params.loop\n            @interpreter.isWaiting = yes\n            @interpreter.waitCounter = Math.round(music.duration * Graphics.frameRate)\n\n        gs.GameNotifier.postMinorChange()\n    ###*\n    * @method commandStopMusic\n    * @protected\n    ###\n    commandStopMusic: ->\n        defaults = GameManager.defaults.audio\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n        fadeDuration = if !isLocked(flags.fadeOutDuration) then @params.fadeOutDuration else defaults.musicFadeOutDuration\n\n        AudioManager.stopMusic(fadeDuration, @interpreter.numberValueOf(@params.layer))\n\n        gs.GameNotifier.postMinorChange()\n    ###*\n    * @method commandPauseMusic\n    * @protected\n    ###\n    commandPauseMusic: ->\n        defaults = GameManager.defaults.audio\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n        fadeDuration = if !isLocked(flags.fadeOutDuration) then @params.fadeOutDuration else defaults.musicFadeOutDuration\n\n        AudioManager.stopMusic(fadeDuration, @interpreter.numberValueOf(@params.layer))\n\n    ###*\n    * @method commandResumeMusic\n    * @protected\n    ###\n    commandResumeMusic: ->\n        defaults = GameManager.defaults.audio\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n        fadeDuration = if !isLocked(flags.fadeInDuration) then @params.fadeInDuration else defaults.musicFadeInDuration\n\n        AudioManager.resumeMusic(fadeDuration, @interpreter.numberValueOf(@params.layer))\n        gs.GameNotifier.postMinorChange()\n    ###*\n    * @method commandPlaySound\n    * @protected\n    ###\n    commandPlaySound: ->\n        defaults = GameManager.defaults.audio\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n        sound = null\n        if GameManager.settings.soundEnabled and !GameManager.tempSettings.skip\n            volume = if !isLocked(flags[\"sound.volume\"]) then @params.sound.volume else defaults.soundVolume\n            playbackRate = if !isLocked(flags[\"sound.playbackRate\"]) then @params.sound.playbackRate else defaults.soundPlaybackRate\n\n            sound = AudioManager.playSound(@params.sound.name, volume, playbackRate, @params.musicEffect, null, @params.loop)\n        gs.GameNotifier.postMinorChange()\n        if sound and @params.waitForCompletion and !@params.loop\n            @interpreter.isWaiting = yes\n            @interpreter.waitCounter = Math.round(sound.duration * Graphics.frameRate)\n    ###*\n    * @method commandStopSound\n    * @protected\n    ###\n    commandStopSound: ->\n        AudioManager.stopSound(@params.sound.name)\n        gs.GameNotifier.postMinorChange()\n    ###*\n    * @method commandEndCommonEvent\n    * @protected\n    ###\n    commandEndCommonEvent: ->\n        eventId = @interpreter.stringValueOf(@params.commonEventId)\n        event = GameManager.commonEvents[eventId]\n        event?.behavior.stop()\n\n    ###*\n    * @method commandResumeCommonEvent\n    * @protected\n    ###\n    commandResumeCommonEvent: ->\n        eventId = @interpreter.stringValueOf(@params.commonEventId)\n        event = GameManager.commonEvents[eventId]\n        event?.behavior.resume()\n\n    ###*\n    * @method commandCallCommonEvent\n    * @protected\n    ###\n    commandCallCommonEvent: ->\n        scene = SceneManager.scene\n        eventId = null\n\n        if @params.commonEventId.index?\n            eventId = @interpreter.stringValueOf(@params.commonEventId)\n            list = @interpreter.listObjectOf(@params.parameters.values[0])\n            params = { values: list }\n        else\n            params = @params.parameters\n            eventId = @params.commonEventId\n\n        @interpreter.callCommonEvent(eventId, params)\n\n\n    ###*\n    * @method commandChangeTextSettings\n    * @protected\n    ###\n    commandChangeTextSettings: ->\n        scene = SceneManager.scene\n        scene.behavior.changeTextDomain(@params.numberDomain)\n        number = @interpreter.numberValueOf(@params.number)\n        texts = scene.texts\n        if not texts[number]?\n            texts[number] = new gs.Object_Text()\n            texts[number].visible = no\n\n\n        textSprite = texts[number]\n        padding = textSprite.behavior.padding\n        font = textSprite.font\n        fontName = textSprite.font.name\n        fontSize = textSprite.font.size\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n        if !isLocked(flags.lineSpacing) then textSprite.textRenderer.lineSpacing = @params.lineSpacing ? textSprite.textRenderer.lineSpacing\n        if !isLocked(flags.font) then fontName = @interpreter.stringValueOf(@params.font)\n        if !isLocked(flags.size) then fontSize = @interpreter.numberValueOf(@params.size)\n\n        if !isLocked(flags.font) or !isLocked(flags.size)\n            textSprite.font = new Font(fontName, fontSize)\n\n        padding.left = if !isLocked(flags[\"padding.0\"]) then @params.padding?[0] else padding.left\n        padding.top = if !isLocked(flags[\"padding.1\"]) then @params.padding?[1] else padding.top\n        padding.right = if !isLocked(flags[\"padding.2\"]) then @params.padding?[2] else padding.right\n        padding.bottom = if !isLocked(flags[\"padding.3\"]) then @params.padding?[3] else padding.bottom\n\n        if !isLocked(flags.bold)\n            textSprite.font.bold = @params.bold\n        if !isLocked(flags.italic)\n            textSprite.font.italic = @params.italic\n        if !isLocked(flags.smallCaps)\n            textSprite.font.smallCaps = @params.smallCaps\n        if !isLocked(flags.underline)\n            textSprite.font.underline = @params.underline\n        if !isLocked(flags.strikeThrough)\n            textSprite.font.strikeThrough = @params.strikeThrough\n\n        textSprite.font.color = if !isLocked(flags.color) then new Color(@params.color) else font.color\n        textSprite.font.border = if !isLocked(flags.outline)then @params.outline else font.border\n        textSprite.font.borderColor = if !isLocked(flags.outlineColor) then new Color(@params.outlineColor) else new Color(font.borderColor)\n        textSprite.font.borderSize = if !isLocked(flags.outlineSize) then @params.outlineSize else font.borderSize\n        textSprite.font.shadow = if !isLocked(flags.shadow)then @params.shadow else font.shadow\n        textSprite.font.shadowColor = if !isLocked(flags.shadowColor) then new Color(@params.shadowColor) else new Color(font.shadowColor)\n        textSprite.font.shadowOffsetX = if !isLocked(flags.shadowOffsetX) then @params.shadowOffsetX else font.shadowOffsetX\n        textSprite.font.shadowOffsetY = if !isLocked(flags.shadowOffsetY) then @params.shadowOffsetY else font.shadowOffsetY\n        textSprite.behavior.refresh()\n        textSprite.update()\n\n    ###*\n    * @method commandChangeTextSettings\n    * @protected\n    ###\n    commandTextDefaults: ->\n        defaults = GameManager.defaults.text\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n\n        if !isLocked(flags.appearDuration) then defaults.appearDuration = @interpreter.durationValueOf(@params.appearDuration)\n        if !isLocked(flags.disappearDuration) then defaults.disappearDuration = @interpreter.durationValueOf(@params.disappearDuration)\n        if !isLocked(flags.zOrder) then defaults.zOrder = @interpreter.numberValueOf(@params.zOrder)\n        if !isLocked(flags[\"appearEasing.type\"]) then defaults.appearEasing = @params.appearEasing\n        if !isLocked(flags[\"appearAnimation.type\"]) then defaults.appearAnimation = @params.appearAnimation\n        if !isLocked(flags[\"disappearEasing.type\"]) then defaults.disappearEasing = @params.disappearEasing\n        if !isLocked(flags[\"disappearAnimation.type\"]) then defaults.disappearAnimation = @params.disappearAnimation\n        if !isLocked(flags[\"motionBlur.enabled\"]) then defaults.motionBlur = @params.motionBlur\n        if !isLocked(flags.origin) then defaults.origin = @params.origin\n\n    ###*\n    * @method commandShowText\n    * @protected\n    ###\n    commandShowText: ->\n        defaults = GameManager.defaults.text\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n        scene = SceneManager.scene\n        scene.behavior.changeTextDomain(@params.numberDomain)\n        number = @interpreter.numberValueOf(@params.number)\n        text = @params.text\n        texts = scene.texts\n        if not texts[number]? then texts[number] = new gs.Object_Text()\n\n        x = @interpreter.numberValueOf(@params.position.x)\n        y = @interpreter.numberValueOf(@params.position.y)\n        textObject = texts[number]\n        textObject.domain = @params.numberDomain\n\n        easing = if !isLocked(flags[\"easing.type\"]) then gs.Easings.fromValues(@interpreter.numberValueOf(@params.easing.type), @params.easing.inOut) else gs.Easings.fromObject(defaults.appearEasing)\n        duration = if !isLocked(flags.duration) then @interpreter.durationValueOf(@params.duration) else defaults.appearDuration\n        origin = if !isLocked(flags.origin) then @params.origin else defaults.origin\n        zIndex = if !isLocked(flags.zOrder) then @interpreter.numberValueOf(@params.zOrder) else defaults.zOrder\n        animation = if !isLocked(flags[\"animation.type\"]) then @params.animation else defaults.appearAnimation\n        positionAnchor = if !isLocked(flags.positionOrigin) then @interpreter.graphicAnchorPointsByConstant[@params.positionOrigin] || new gs.Point(0, 0) else @interpreter.graphicAnchorPointsByConstant[defaults.positionOrigin]\n\n        textObject.text = text\n        textObject.dstRect.x = x\n        textObject.dstRect.y = y\n        textObject.blendMode = @interpreter.numberValueOf(@params.blendMode)\n        textObject.anchor.x = if origin == 0 then 0 else 0.5\n        textObject.anchor.y = if origin == 0 then 0 else 0.5\n        textObject.positionAnchor.x = positionAnchor.x\n        textObject.positionAnchor.y = positionAnchor.y\n        textObject.zIndex = zIndex ||  (700 + number)\n        textObject.sizeToFit = yes\n        textObject.formatting = yes\n        if @params.viewport?.type == \"scene\"\n            textObject.viewport = SceneManager.scene.behavior.viewport\n        textObject.update()\n\n        if @params.positionType == 0\n            p = @interpreter.predefinedObjectPosition(@params.predefinedPositionId, textObject, @params)\n            textObject.dstRect.x = p.x\n            textObject.dstRect.y = p.y\n\n        textObject.animator.appear(x, y, animation, easing, duration)\n\n        if @params.waitForCompletion and not (duration == 0 or @interpreter.isInstantSkip())\n            @interpreter.isWaiting = yes\n            @interpreter.waitCounter = duration\n\n        gs.GameNotifier.postMinorChange()\n    ###*\n    * @method commandTextMotionBlur\n    * @protected\n    ###\n    commandTextMotionBlur: ->\n        scene = SceneManager.scene\n        scene.behavior.changeTextDomain(@params.numberDomain)\n        number = @interpreter.numberValueOf(@params.number)\n        text = scene.texts[number]\n        if not text? then return\n\n        text.motionBlur.set(@params.motionBlur)\n\n    ###*\n    * @method commandRefreshText\n    * @protected\n    ###\n    commandRefreshText: ->\n        scene = SceneManager.scene\n        scene.behavior.changeTextDomain(@params.numberDomain)\n        number = @interpreter.numberValueOf(@params.number)\n        texts = scene.texts\n        if not texts[number]? then return\n\n        texts[number].behavior.refresh(yes)\n\n    ###*\n    * @method commandMoveText\n    * @protected\n    ###\n    commandMoveText: ->\n        scene = SceneManager.scene\n        scene.behavior.changeTextDomain(@params.numberDomain)\n        number = @interpreter.numberValueOf(@params.number)\n        text = scene.texts[number]\n        if not text? then return\n\n        @interpreter.moveObject(text, @params.picture.position, @params)\n\n        gs.GameNotifier.postMinorChange()\n    ###*\n    * @method commandMoveTextPath\n    * @protected\n    ###\n    commandMoveTextPath: ->\n        scene = SceneManager.scene\n        scene.behavior.changeTextDomain(@params.numberDomain)\n        number = @interpreter.numberValueOf(@params.number)\n        text = scene.texts[number]\n        if not text? then return\n\n        @interpreter.moveObjectPath(text, @params.path, @params)\n\n        gs.GameNotifier.postMinorChange()\n    ###*\n    * @method commandRotateText\n    * @protected\n    ###\n    commandRotateText: ->\n        scene = SceneManager.scene\n        scene.behavior.changeTextDomain(@params.numberDomain)\n        number = @interpreter.numberValueOf(@params.number)\n        text = scene.texts[number]\n        if not text? then return\n\n        @interpreter.rotateObject(text, @params)\n\n        gs.GameNotifier.postMinorChange()\n    ###*\n    * @method commandZoomText\n    * @protected\n    ###\n    commandZoomText: ->\n        scene = SceneManager.scene\n        scene.behavior.changeTextDomain(@params.numberDomain)\n        number = @interpreter.numberValueOf(@params.number)\n        text = scene.texts[number]\n        if not text? then return\n\n        @interpreter.zoomObject(text, @params)\n\n        gs.GameNotifier.postMinorChange()\n\n    ###*\n    * @method commandBlendText\n    * @protected\n    ###\n    commandBlendText: ->\n        SceneManager.scene.behavior.changeTextDomain(@params.numberDomain)\n        text = SceneManager.scene.texts[@interpreter.numberValueOf(@params.number)]\n        if not text? then return\n\n        @interpreter.blendObject(text, @params)\n        gs.GameNotifier.postMinorChange()\n    ###*\n    * @method commandColorText\n    * @protected\n    ###\n    commandColorText: ->\n        scene = SceneManager.scene\n        scene.behavior.changeTextDomain(@params.numberDomain)\n        number = @interpreter.numberValueOf(@params.number)\n        text = scene.texts[number]\n        duration = @interpreter.durationValueOf(@params.duration)\n        easing = gs.Easings.fromObject(@params.easing)\n\n        if text?\n            text.animator.colorTo(new Color(@params.color), duration, easing)\n            if @params.waitForCompletion and not (duration == 0 or @interpreter.isInstantSkip())\n                @interpreter.isWaiting = yes\n                @interpreter.waitCounter = duration\n        gs.GameNotifier.postMinorChange()\n    ###*\n    * @method commandEraseText\n    * @protected\n    ###\n    commandEraseText: ->\n        defaults = GameManager.defaults.text\n        flags = @params.fieldFlags || {}\n        isLocked = gs.CommandFieldFlags.isLocked\n        scene = SceneManager.scene\n        scene.behavior.changeTextDomain(@params.numberDomain)\n        number = @interpreter.numberValueOf(@params.number)\n        text = scene.texts[number]\n        if not text? then return\n\n        easing = if !isLocked(flags[\"easing.type\"]) then gs.Easings.fromValues(@interpreter.numberValueOf(@params.easing.type), @params.easing.inOut) else gs.Easings.fromObject(defaults.disappearEasing)\n        duration = if !isLocked(flags.duration) then @interpreter.durationValueOf(@params.duration) else defaults.disappearDuration\n        animation = if !isLocked(flags[\"animation.type\"]) then @params.animation else defaults.disappearAnimation\n\n\n        text.animator.disappear(animation, easing, duration, (sender) =>\n            sender.dispose()\n            scene.behavior.changeTextDomain(sender.domain)\n            scene.texts[number] = null\n        )\n\n        if @params.waitForCompletion and not (duration == 0 or @interpreter.isInstantSkip())\n            @interpreter.isWaiting = yes\n            @interpreter.waitCounter = duration\n        gs.GameNotifier.postMinorChange()\n    ###*\n    * @method commandTextEffect\n    * @protected\n    ###\n    commandTextEffect: ->\n        scene = SceneManager.scene\n        scene.behavior.changeTextDomain(@params.numberDomain)\n        number = @interpreter.numberValueOf(@params.number)\n        text = scene.texts[number]\n        if not text? then return\n\n        @interpreter.objectEffect(text, @params)\n        gs.GameNotifier.postMinorChange()\n    ###*\n    * @method commandInputText\n    * @protected\n    ###\n    commandInputText: ->\n        scene = SceneManager.scene\n        scene.behavior.changeTextDomain(@params.numberDomain)\n        if (GameManager.settings.allowChoiceSkip||@interpreter.preview) and GameManager.tempSettings.skip\n            @interpreter.messageObject().behavior.clear()\n            @interpreter.setStringValueTo(@params.variable, \"\")\n            return\n\n        @interpreter.isWaiting = yes\n        if @interpreter.isProcessingMessageInOtherContext()\n            @interpreter.waitForMessage()\n            return\n\n        $tempFields.letters = @params.letters\n        scene.behavior.showInputText(@params.letters, gs.CallBack(\"onInputTextFinish\", @interpreter, @interpreter))\n        @interpreter.waitingFor.inputText = @params\n        gs.GameNotifier.postMinorChange()\n    ###*\n    * @method commandSavePersistentData\n    * @protected\n    ###\n    commandSavePersistentData: -> GameManager.saveGlobalData()\n\n    ###*\n    * @method commandSaveSettings\n    * @protected\n    ###\n    commandSaveSettings: -> GameManager.saveSettings()\n\n    ###*\n    * @method commandPrepareSaveGame\n    * @protected\n    ###\n    commandPrepareSaveGame: ->\n        if @interpreter.previewData? then return\n\n        @interpreter.pointer++\n        GameManager.prepareSaveGame(@params.snapshot)\n        @interpreter.pointer--\n\n    ###*\n    * @method commandSaveGame\n    * @protected\n    ###\n    commandSaveGame: ->\n        if @interpreter.previewData? then return\n\n        thumbWidth = @interpreter.numberValueOf(@params.thumbWidth)\n        thumbHeight = @interpreter.numberValueOf(@params.thumbHeight)\n\n        GameManager.save(@interpreter.numberValueOf(@params.slot) - 1, thumbWidth, thumbHeight)\n\n    ###*\n    * @method commandLoadGame\n    * @protected\n    ###\n    commandLoadGame: ->\n        if @interpreter.previewData? then return\n\n        GameManager.load(@interpreter.numberValueOf(@params.slot) - 1)\n\n    ###*\n    * @method commandWaitForInput\n    * @protected\n    ###\n    commandWaitForInput: ->\n        return if @interpreter.isInstantSkip()\n\n        gs.GlobalEventManager.offByOwner(\"mouseDown\", @interpreter.object)\n        gs.GlobalEventManager.offByOwner(\"mouseUp\", @interpreter.object)\n        gs.GlobalEventManager.offByOwner(\"keyDown\", @interpreter.object)\n        gs.GlobalEventManager.offByOwner(\"keyUp\", @interpreter.object)\n\n        f = =>\n            key = @interpreter.numberValueOf(@params.key)\n            executeAction = no\n            if Input.Mouse.isButton(@params.key)\n                executeAction = Input.Mouse.buttons[@params.key] == @params.state\n            else if @params.key == 100\n                executeAction = yes if Input.keyDown and @params.state == 1\n                executeAction = yes if Input.keyUp and @params.state == 2\n            else if @params.key == 101\n                executeAction = yes if Input.Mouse.buttonDown and @params.state == 1\n                executeAction = yes if Input.Mouse.buttonUp and @params.state == 2\n            else if @params.key == 102\n                executeAction = yes if (Input.keyDown or Input.Mouse.buttonDown) and @params.state == 1\n                executeAction = yes if (Input.keyUp or Input.Mouse.buttonUp) and @params.state == 2\n            else\n                key = if key > 100 then key - 100 else key\n                executeAction = Input.keys[key] == @params.state\n\n\n            if executeAction\n                @interpreter.isWaiting = no\n\n                gs.GlobalEventManager.offByOwner(\"mouseDown\", @interpreter.object)\n                gs.GlobalEventManager.offByOwner(\"mouseUp\", @interpreter.object)\n                gs.GlobalEventManager.offByOwner(\"keyDown\", @interpreter.object)\n                gs.GlobalEventManager.offByOwner(\"keyUp\", @interpreter.object)\n\n        gs.GlobalEventManager.on \"mouseDown\", f, null, @interpreter.object\n        gs.GlobalEventManager.on \"mouseUp\", f, null, @interpreter.object\n        gs.GlobalEventManager.on \"keyDown\", f, null, @interpreter.object\n        gs.GlobalEventManager.on \"keyUp\", f, null, @interpreter.object\n\n        @interpreter.isWaiting = yes\n\n    ###*\n    * @method commandGetInputData\n    * @protected\n    ###\n    commandGetInputData: ->\n        switch @params.field\n            when 0 # Button A\n                @interpreter.setNumberValueTo(@params.targetVariable, Input.keys[Input.A])\n            when 1 # Button B\n                @interpreter.setNumberValueTo(@params.targetVariable, Input.keys[Input.B])\n            when 2 # Button X\n                @interpreter.setNumberValueTo(@params.targetVariable, Input.keys[Input.X])\n            when 3 # Button Y\n                @interpreter.setNumberValueTo(@params.targetVariable, Input.keys[Input.Y])\n            when 4 # Button L\n                @interpreter.setNumberValueTo(@params.targetVariable, Input.keys[Input.L])\n            when 5 # Button R\n                @interpreter.setNumberValueTo(@params.targetVariable, Input.keys[Input.R])\n            when 6 # Button START\n                @interpreter.setNumberValueTo(@params.targetVariable, Input.keys[Input.START])\n            when 7 # Button SELECT\n                @interpreter.setNumberValueTo(@params.targetVariable, Input.keys[Input.SELECT])\n            when 8 # Mouse X\n                @interpreter.setNumberValueTo(@params.targetVariable, Input.Mouse.x)\n            when 9 # Mouse Y\n                @interpreter.setNumberValueTo(@params.targetVariable, Input.Mouse.y)\n            when 10 # Mouse Wheel\n                @interpreter.setNumberValueTo(@params.targetVariable, Input.Mouse.wheel)\n            when 11 # Mouse Left\n                @interpreter.setNumberValueTo(@params.targetVariable, Input.Mouse.buttons[Input.Mouse.LEFT])\n            when 12 # Mouse Right\n                @interpreter.setNumberValueTo(@params.targetVariable, Input.Mouse.buttons[Input.Mouse.RIGHT])\n            when 13 # Mouse Middle\n                @interpreter.setNumberValueTo(@params.targetVariable, Input.Mouse.buttons[Input.Mouse.MIDDLE])\n            when 100 # Any Key\n                anyKey = 0\n                anyKey = 1 if Input.keyDown\n                anyKey = 2 if Input.keyUp\n                @interpreter.setNumberValueTo(@params.targetVariable, anyKey)\n            when 101 # Any Button\n                anyButton = 0\n                anyButton = 1 if Input.Mouse.buttonDown\n                anyButton = 2 if Input.Mouse.buttonUp\n                @interpreter.setNumberValueTo(@params.targetVariable, anyButton)\n            when 102 # Any Input\n                anyInput = 0\n                anyInput = 1 if Input.Mouse.buttonDown or Input.keyDown\n                anyInput = 2 if Input.Mouse.buttonUp or Input.keyUp\n                @interpreter.setNumberValueTo(@params.targetVariable, anyInput)\n            else\n                code = @params.field - 100\n                @interpreter.setNumberValueTo(@params.targetVariable, Input.keys[code])\n    ###*\n    * @method commandGetGameData\n    * @protected\n    ###\n    commandGetGameData: ->\n        tempSettings = GameManager.tempSettings\n        settings = GameManager.settings\n\n        switch @params.field\n            when 0 # Scene ID\n                @interpreter.setStringValueTo(@params.targetVariable, SceneManager.scene.sceneDocument.uid)\n            when 1 # Game Time - Seconds\n                @interpreter.setNumberValueTo(@params.targetVariable, Math.round(Graphics.frameCount / 60))\n            when 2 # Game Time - Minutes\n                @interpreter.setNumberValueTo(@params.targetVariable, Math.round(Graphics.frameCount / 60 / 60))\n            when 3 # Game Time - Hours\n                @interpreter.setNumberValueTo(@params.targetVariable, Math.round(Graphics.frameCount / 60 / 60 / 60))\n            when 4 # Date - Day of Month\n                @interpreter.setNumberValueTo(@params.targetVariable, new Date().getDate())\n            when 5 # Date - Day of Week\n                @interpreter.setNumberValueTo(@params.targetVariable, new Date().getDay())\n            when 6 # Date - Month\n                @interpreter.setNumberValueTo(@params.targetVariable, new Date().getMonth())\n            when 7 # Date - Year\n                @interpreter.setNumberValueTo(@params.targetVariable, new Date().getFullYear())\n            when 8\n                @interpreter.setBooleanValueTo(@params.targetVariable, settings.allowSkip)\n            when 9\n                @interpreter.setBooleanValueTo(@params.targetVariable, settings.allowSkipUnreadMessages)\n            when 10\n                @interpreter.setNumberValueTo(@params.targetVariable, settings.messageSpeed)\n            when 11\n                @interpreter.setBooleanValueTo(@params.targetVariable, settings.autoMessage.enabled)\n            when 12\n                @interpreter.setNumberValueTo(@params.targetVariable, settings.autoMessage.time)\n            when 13\n                @interpreter.setBooleanValueTo(@params.targetVariable, settings.autoMessage.waitForVoice)\n            when 14\n                @interpreter.setBooleanValueTo(@params.targetVariable, settings.autoMessage.stopOnAction)\n            when 15\n                @interpreter.setBooleanValueTo(@params.targetVariable, settings.timeMessageToVoice)\n            when 16\n                @interpreter.setBooleanValueTo(@params.targetVariable, settings.allowVideoSkip)\n            when 17\n                @interpreter.setBooleanValueTo(@params.targetVariable, settings.allowChoiceSkip)\n            when 18\n                @interpreter.setBooleanValueTo(@params.targetVariable, settings.skipVoiceOnAction)\n            when 19\n                @interpreter.setBooleanValueTo(@params.targetVariable, settings.fullScreen)\n            when 20\n                @interpreter.setBooleanValueTo(@params.targetVariable, settings.adjustAspectRatio)\n            when 21\n                @interpreter.setBooleanValueTo(@params.targetVariable, settings.confirmation)\n            when 22\n                @interpreter.setNumberValueTo(@params.targetVariable, settings.bgmVolume)\n            when 23\n                @interpreter.setNumberValueTo(@params.targetVariable, settings.voiceVolume)\n            when 24\n                @interpreter.setNumberValueTo(@params.targetVariable, settings.seVolume)\n            when 25\n                @interpreter.setBooleanValueTo(@params.targetVariable, settings.bgmEnabled)\n            when 26\n                @interpreter.setBooleanValueTo(@params.targetVariable, settings.voiceEnabled)\n            when 27\n                @interpreter.setBooleanValueTo(@params.targetVariable, settings.seEnabled)\n            when 28 # Language - Code\n                @interpreter.setStringValueTo(@params.targetVariable, LanguageManager.language?.code || \"\")\n            when 29 # Language - Name\n                @interpreter.setStringValueTo(@params.targetVariable, LanguageManager.language?.name || \"\")\n            when 30\n                @interpreter.setBooleanValueTo(@params.targetVariable, GameManager.tempSettings.skip)\n\n    ###*\n    * @method commandSetGameData\n    * @protected\n    ###\n    commandSetGameData: ->\n        tempSettings = GameManager.tempSettings\n        settings = GameManager.settings\n\n        switch @params.field\n            when 0\n                settings.allowSkip = @interpreter.booleanValueOf(@params.switchValue)\n            when 1\n                settings.allowSkipUnreadMessages = @interpreter.booleanValueOf(@params.switchValue)\n            when 2\n                settings.messageSpeed = @interpreter.numberValueOf(@params.decimalValue)\n            when 3\n                settings.autoMessage.enabled = @interpreter.booleanValueOf(@params.switchValue)\n            when 4\n                settings.autoMessage.time = @interpreter.numberValueOf(@params.numberValue)\n            when 5\n                settings.autoMessage.waitForVoice = @interpreter.booleanValueOf(@params.switchValue)\n            when 6\n                settings.autoMessage.stopOnAction = @interpreter.booleanValueOf(@params.switchValue)\n            when 7\n                settings.timeMessageToVoice = @interpreter.booleanValueOf(@params.switchValue)\n            when 8\n                settings.allowVideoSkip = @interpreter.booleanValueOf(@params.switchValue)\n            when 9\n                settings.allowChoiceSkip = @interpreter.booleanValueOf(@params.switchValue)\n            when 10\n                settings.skipVoiceOnAction = @interpreter.booleanValueOf(@params.switchValue)\n            when 11\n                settings.fullScreen = @interpreter.booleanValueOf(@params.switchValue)\n                if settings.fullScreen\n                    SceneManager.scene.behavior.enterFullScreen()\n                else\n                    SceneManager.scene.behavior.leaveFullScreen()\n            when 12\n                settings.adjustAspectRatio = @interpreter.booleanValueOf(@params.switchValue)\n                Graphics.keepRatio = settings.adjustAspectRatio\n                Graphics.onResize()\n            when 13\n                settings.confirmation = @interpreter.booleanValueOf(@params.switchValue)\n            when 14\n                settings.bgmVolume = @interpreter.numberValueOf(@params.numberValue)\n            when 15\n                settings.voiceVolume = @interpreter.numberValueOf(@params.numberValue)\n            when 16\n                settings.seVolume = @interpreter.numberValueOf(@params.numberValue)\n            when 17\n                settings.bgmEnabled = @interpreter.booleanValueOf(@params.switchValue)\n            when 18\n                settings.voiceEnabled = @interpreter.booleanValueOf(@params.switchValue)\n            when 19\n                settings.seEnabled = @interpreter.booleanValueOf(@params.switchValue)\n            when 20\n                code = @interpreter.stringValueOf(@params.textValue)\n                language = LanguageManager.languages.first (l) => l.code == code\n                LanguageManager.selectLanguage(language) if language\n            when 21\n                GameManager.tempSettings.skip = @interpreter.booleanValueOf(@params.switchValue)\n\n    ###*\n    * @method commandGetObjectData\n    * @protected\n    ###\n    commandGetObjectData: ->\n        scene = SceneManager.scene\n        switch @params.objectType\n            when 0 # Picture\n                scene.behavior.changePictureDomain(@params.numberDomain)\n                object = SceneManager.scene.pictures[@interpreter.numberValueOf(@params.number)]\n            when 1 # Background\n                object = SceneManager.scene.backgrounds[@interpreter.numberValueOf(@params.layer)]\n            when 2 # Text\n                scene.behavior.changeTextDomain(@params.numberDomain)\n                object = SceneManager.scene.texts[@interpreter.numberValueOf(@params.number)]\n            when 3 # Movie\n                scene.behavior.changeVideoDomain(@params.numberDomain)\n                object = SceneManager.scene.videos[@interpreter.numberValueOf(@params.number)]\n            when 4 # Character\n                characterId = @interpreter.stringValueOf(@params.characterId)\n                object = SceneManager.scene.characters.first (v) => !v.disposed and v.rid == characterId\n            when 5 # Message Box\n                object = gs.ObjectManager.current.objectById(\"messageBox\")\n            when 6 # Message Area\n                scene.behavior.changeMessageAreaDomain(@params.numberDomain)\n                area = SceneManager.scene.messageAreas[@interpreter.numberValueOf(@params.number)]\n                object = area?.layout\n            when 7 # Hotspot\n                scene.behavior.changeHotspotDomain(@params.numberDomain)\n                object = SceneManager.scene.hotspots[@interpreter.numberValueOf(@params.number)]\n\n\n        field = @params.field\n        if @params.objectType == 4 # Character\n            switch @params.field\n                when 0 # ID\n                    @interpreter.setStringValueTo(@params.targetVariable, RecordManager.characters[characterId]?.index || \"\")\n                when 1 # Name\n                    @interpreter.setStringValueTo(@params.targetVariable, lcs(RecordManager.characters[characterId]?.name) || \"\")\n            field -= 2\n\n        if @params.objectType == 6 # Message\n            switch field\n                when 0 # Position - X\n                    @interpreter.setNumberValueTo(@params.targetVariable, object.dstRect.x)\n                when 1 # Position - Y\n                    @interpreter.setNumberValueTo(@params.targetVariable, object.dstRect.y)\n                when 2 # Z-Index\n                    @interpreter.setNumberValueTo(@params.targetVariable, object.zIndex)\n                when 3 # Opacity\n                    @interpreter.setNumberValueTo(@params.targetVariable, object.opacity)\n                when 4 # Visible\n                    @interpreter.setBooleanValueTo(@params.targetVariable, object.visible)\n\n        else if object?\n            if field >= 0\n                switch field\n                    when 0 # Resource Name\n                        switch @params.objectType\n                            when 2\n                                @interpreter.setStringValueTo(@params.targetVariable, object.text || \"\")\n                            when 3\n                                @interpreter.setStringValueTo(@params.targetVariable, object.video || \"\")\n                            else\n                                @interpreter.setStringValueTo(@params.targetVariable, object.image || \"\")\n                    when 1 # Position - X\n                        @interpreter.setNumberValueTo(@params.targetVariable, object.dstRect.x)\n                    when 2 # Position - Y\n                        @interpreter.setNumberValueTo(@params.targetVariable, object.dstRect.y)\n                    when 3 # Anchor - X\n                        @interpreter.setNumberValueTo(@params.targetVariable, Math.round(object.anchor.x * 100))\n                    when 4 # Anchor - Y\n                        @interpreter.setNumberValueTo(@params.targetVariable, Math.round(object.anchor.y * 100))\n                    when 5 # Zoom - X\n                        @interpreter.setNumberValueTo(@params.targetVariable, Math.round(object.zoom.x * 100))\n                    when 6 # Zoom - Y\n                        @interpreter.setNumberValueTo(@params.targetVariable, Math.round(object.zoom.y * 100))\n                    when 7 # Size - Width\n                        @interpreter.setNumberValueTo(@params.targetVariable, object.dstRect.width)\n                    when 8 # Size - Height\n                        @interpreter.setNumberValueTo(@params.targetVariable, object.dstRect.height)\n                    when 9 # Z-Index\n                        @interpreter.setNumberValueTo(@params.targetVariable, object.zIndex)\n                    when 10 # Opacity\n                        @interpreter.setNumberValueTo(@params.targetVariable, object.opacity)\n                    when 11 # Angle\n                        @interpreter.setNumberValueTo(@params.targetVariable, object.angle)\n                    when 12 # Visible\n                        @interpreter.setBooleanValueTo(@params.targetVariable, object.visible)\n                    when 13 # Blend Mode\n                        @interpreter.setNumberValueTo(@params.targetVariable, object.blendMode)\n                    when 14 # Flipped\n                        @interpreter.setBooleanValueTo(@params.targetVariable, object.mirror)\n\n    ###*\n    * @method commandSetObjectData\n    * @protected\n    ###\n    commandSetObjectData: ->\n        scene = SceneManager.scene\n\n        switch @params.objectType\n            when 0 # Picture\n                scene.behavior.changePictureDomain(@params.numberDomain)\n                object = SceneManager.scene.pictures[@interpreter.numberValueOf(@params.number)]\n            when 1 # Background\n                object = SceneManager.scene.backgrounds[@interpreter.numberValueOf(@params.layer)]\n            when 2 # Text\n                scene.behavior.changeTextDomain(@params.numberDomain)\n                object = SceneManager.scene.texts[@interpreter.numberValueOf(@params.number)]\n            when 3 # Movie\n                scene.behavior.changeVideoDomain(@params.numberDomain)\n                object = SceneManager.scene.videos[@interpreter.numberValueOf(@params.number)]\n            when 4 # Character\n                characterId = @interpreter.stringValueOf(@params.characterId)\n                object = SceneManager.scene.characters.first (v) => !v.disposed and v.rid == characterId\n            when 5 # Message Box\n                object = gs.ObjectManager.current.objectById(\"messageBox\")\n            when 6 # Message Area\n                scene.behavior.changeMessageAreaDomain(@params.numberDomain)\n                area = SceneManager.scene.messageAreas[@interpreter.numberValueOf(@params.number)]\n                object = area?.layout\n            when 7 # Hotspot\n                scene.behavior.changeHotspotDomain(@params.numberDomain)\n                object = SceneManager.scene.hotspots[@interpreter.numberValueOf(@params.number)]\n\n\n        field = @params.field\n        if @params.objectType == 4 # Character\n            switch field\n                when 0 # Name\n                    name = @interpreter.stringValueOf(@params.textValue)\n                    if object?\n                        object.name = name\n                    RecordManager.characters[characterId]?.name = name\n            field--\n\n        if @params.objectType == 6 # Message\n            switch field\n                when 0 # Position - X\n                    object.dstRect.x = @interpreter.numberValueOf(@params.numberValue)\n                when 1 # Position - Y\n                    object.dstRect.y = @interpreter.numberValueOf(@params.numberValue)\n                when 2 # Z-Index\n                    object.zIndex = @interpreter.numberValueOf(@params.numberValue)\n                when 3 # Opacity\n                    object.opacity= @interpreter.numberValueOf(@params.numberValue)\n                when 4 # Visible\n                    object.visible = @interpreter.booleanValueOf(@params.switchValue)\n\n        else if object?\n            if field >= 0\n                switch field\n                    when 0 # Resource Name / Text\n                        switch @params.objectType\n                            when 2\n                                object.text = @interpreter.stringValueOf(@params.textValue)\n                            when 3\n                                object.video = @interpreter.stringValueOf(@params.textValue)\n                            else\n                                object.image = @interpreter.stringValueOf(@params.textValue)\n                    when 1 # Position - X\n                        object.dstRect.x = @interpreter.numberValueOf(@params.numberValue)\n                    when 2 # Position - Y\n                        object.dstRect.y = @interpreter.numberValueOf(@params.numberValue)\n                    when 3 # Anchor - X\n                        object.anchor.x = @interpreter.numberValueOf(@params.numberValue) / 100\n                    when 4 # Anchor - Y\n                        object.anchor.y = @interpreter.numberValueOf(@params.numberValue) / 100\n                    when 5 # Zoom - X\n                        object.zoom.x = @interpreter.numberValueOf(@params.numberValue) / 100\n                    when 6 # Zoom - Y\n                        object.zoom.y = @interpreter.numberValueOf(@params.numberValue) / 100\n                    when 7 # Z-Index\n                        object.zIndex = @interpreter.numberValueOf(@params.numberValue)\n                    when 8 # Opacity\n                        object.opacity= @interpreter.numberValueOf(@params.numberValue)\n                    when 9 # Angle\n                        object.angle = @interpreter.numberValueOf(@params.numberValue)\n                    when 10 # Visible\n                        object.visible = @interpreter.booleanValueOf(@params.switchValue)\n                    when 11 # Blend Mode\n                        object.blendMode = @interpreter.numberValueOf(@params.numberValue)\n                    when 12 # Flipped\n                        object.mirror = @interpreter.booleanValueOf(@params.switchValue)\n\n    ###*\n    * @method commandChangeSounds\n    * @protected\n    ###\n    commandChangeSounds: ->\n        sounds = RecordManager.system.sounds\n        fieldFlags = @params.fieldFlags || {}\n\n        for sound, i in @params.sounds\n            if !gs.CommandFieldFlags.isLocked(fieldFlags[\"sounds.\"+i])\n                sounds[i] = @params.sounds[i]\n\n    ###*\n    * @method commandChangeColors\n    * @protected\n    ###\n    commandChangeColors: ->\n        colors = RecordManager.system.colors\n        fieldFlags = @params.fieldFlags || {}\n\n        for color, i in @params.colors\n            if !gs.CommandFieldFlags.isLocked(fieldFlags[\"colors.\"+i])\n                colors[i] = new gs.Color(@params.colors[i])\n\n    ###*\n    * @method commandChangeScreenCursor\n    * @protected\n    ###\n    commandChangeScreenCursor: ->\n        if @params.graphic?.name?\n            bitmap = ResourceManager.getBitmap(\"Graphics/Pictures/#{@params.graphic.name}\")\n            Graphics.setCursorBitmap(bitmap, @params.hx, @params.hy)\n        else\n            Graphics.setCursorBitmap(null, 0, 0)\n\n    ###*\n    * @method commandResetGlobalData\n    * @protected\n    ###\n    commandResetGlobalData: ->\n        GameManager.resetGlobalData()\n\n    ###*\n    * @method commandScript\n    * @protected\n    ###\n    commandScript: ->\n        try\n            if !@params.scriptFunc\n                @params.scriptFunc = eval(\"(function(){\" + @params.script + \"})\")\n\n            @params.scriptFunc()\n        catch ex\n            console.log(ex)\n\nwindow.CommandInterpreter = Component_CommandInterpreter\ngs.Component_CommandInterpreter = Component_CommandInterpreter\n\n\n",
        "compiledContent": "// Generated by CoffeeScript 1.12.7\n(function() {\n  var Component_CommandInterpreter, InterpreterContext, LivePreviewInfo,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  LivePreviewInfo = (function() {\n\n    /**\n    * Stores internal preview-info if the game runs currently in Live-Preview.\n    *\n    * @module gs\n    * @class LivePreviewInfo\n    * @memberof gs\n     */\n    function LivePreviewInfo() {\n\n      /**\n      * Timer ID if a timeout for live-preview was configured to exit the game loop after a certain amount of time.\n      * @property timeout\n      * @type number\n       */\n      this.timeout = null;\n\n      /**\n      * Indicates if Live-Preview is currently waiting for the next user-action. (Selecting another command, etc.)\n      * @property waiting\n      * @type boolean\n       */\n      this.waiting = false;\n\n      /**\n      * Counts the amount of executed commands since the last\n      * interpreter-pause(waiting, etc.). If its more than 500, the interpreter will automatically pause for 1 frame to\n      * avoid that Live-Preview freezes the Editor in case of endless loops.\n      * @property executedCommands\n      * @type number\n       */\n      this.executedCommands = 0;\n\n      /**\n      * Indicates that the command to skip to has not been found.\n      * @property commandNotFound\n      * @type boolean\n       */\n      this.commandNotFound = false;\n    }\n\n    return LivePreviewInfo;\n\n  })();\n\n  gs.LivePreviewInfo = LivePreviewInfo;\n\n  InterpreterContext = (function() {\n    InterpreterContext.objectCodecBlackList = [\"owner\"];\n\n\n    /**\n    * Describes an interpreter-context which holds information about\n    * the interpreter's owner and also unique ID used for accessing correct\n    * local variables.\n    *\n    * @module gs\n    * @class InterpreterContext\n    * @memberof gs\n    * @param {number|string} id - A unique ID\n    * @param {Object} owner - The owner of the interpreter\n     */\n\n    function InterpreterContext(id, owner) {\n\n      /**\n      * A unique numeric or textual ID used for accessing correct local variables.\n      * @property id\n      * @type number|string\n       */\n      this.id = id;\n\n      /**\n      * The owner of the interpreter (e.g. current scene, etc.).\n      * @property owner\n      * @type Object\n       */\n      this.owner = owner;\n    }\n\n\n    /**\n    * Sets the context's data.\n    * @param {number|string} id - A unique ID\n    * @param {Object} owner - The owner of the interpreter\n    * @method set\n     */\n\n    InterpreterContext.prototype.set = function(id, owner) {\n      this.id = id;\n      return this.owner = owner;\n    };\n\n    return InterpreterContext;\n\n  })();\n\n  gs.InterpreterContext = InterpreterContext;\n\n  Component_CommandInterpreter = (function(superClass) {\n    extend(Component_CommandInterpreter, superClass);\n\n    Component_CommandInterpreter.objectCodecBlackList = [\"object\", \"command\", \"onMessageADVWaiting\", \"onMessageADVDisappear\", \"onMessageADVFinish\"];\n\n\n    /**\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    *\n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n     */\n\n    Component_CommandInterpreter.prototype.onDataBundleRestore = function(data, context) {};\n\n\n    /**\n    * A component which allows a game object to process commands like for\n    * scene-objects. For each command a command-function exists. To add\n    * own custom commands to the interpreter just create a sub-class and\n    * override the gs.Component_CommandInterpreter.assignCommand method\n    * and assign the command-function for your custom-command.\n    *\n    * @module gs\n    * @class Component_CommandInterpreter\n    * @extends gs.Component\n    * @memberof gs\n     */\n\n    function Component_CommandInterpreter() {\n      Component_CommandInterpreter.__super__.constructor.call(this);\n\n      /**\n      * Wait-Counter in frames. If greater than 0, the interpreter will for that amount of frames before continue.\n      * @property waitCounter\n      * @type number\n       */\n      this.waitCounter = 0;\n\n      /**\n      * Index to the next command to execute.\n      * @property pointer\n      * @type number\n       */\n      this.pointer = 0;\n\n      /**\n      * Stores states of conditions.\n      * @property conditions\n      * @type number\n      * @protected\n       */\n      this.conditions = [];\n\n      /**\n      * Stores states of loops.\n      * @property loops\n      * @type number\n      * @protected\n       */\n      this.loops = [];\n      this.timers = [];\n\n      /**\n      * Indicates if the interpreter is currently running.\n      * @property isRunning\n      * @type boolean\n      * @readOnly\n       */\n      this.isRunning = false;\n\n      /**\n      * Indicates if the interpreter is currently waiting.\n      * @property isWaiting\n      * @type boolean\n       */\n      this.isWaiting = false;\n\n      /**\n      * Indicates if the interpreter is currently waiting until a message processed by another context like a Common Event\n      * is finished.\n      * FIXME: Conflict handling can be removed maybe.\n      * @property isWaitingForMessage\n      * @type boolean\n       */\n      this.isWaitingForMessage = false;\n\n      /**\n      * Stores internal preview-info if the game runs currently in Live-Preview.\n      * <ul>\n      * <li>previewInfo.timeout - Timer ID if a timeout for live-preview was configured to exit the game loop after a certain amount of time.</li>\n      * <li>previewInfo.waiting - Indicates if Live-Preview is currently waiting for the next user-action. (Selecting another command, etc.)</li>\n      * <li>previewInfo.executedCommands - Counts the amount of executed commands since the last\n      * interpreter-pause(waiting, etc.). If its more than 500, the interpreter will automatically pause for 1 frame to\n      * avoid that Live-Preview freezes the Editor in case of endless loops.</li>\n      * </ul>\n      * @property previewInfo\n      * @type boolean\n      * @protected\n       */\n      this.previewInfo = new gs.LivePreviewInfo();\n\n      /**\n      * Stores Live-Preview related info passed from the VN Maker editor like the command-index the player clicked on, etc.\n      * @property previewData\n      * @type Object\n      * @protected\n       */\n      this.previewData = null;\n\n      /**\n      * Indicates if the interpreter automatically repeats execution after the last command was executed.\n      * @property repeat\n      * @type boolean\n       */\n      this.repeat = false;\n\n      /**\n      * The execution context of the interpreter.\n      * @property context\n      * @type gs.InterpreterContext\n      * @protected\n       */\n      this.context = new gs.InterpreterContext(0, null);\n\n      /**\n      * Sub-Interpreter from a Common Event Call. The interpreter will wait until the sub-interpreter is done and set back to\n      * <b>null</b>.\n      * @property subInterpreter\n      * @type gs.Component_CommandInterpreter\n      * @protected\n       */\n      this.subInterpreter = null;\n\n      /**\n      * Current indent-level of execution\n      * @property indent\n      * @type number\n      * @protected\n       */\n      this.indent = 0;\n\n      /**\n      * Stores information about for what the interpreter is currently waiting for like for a ADV message, etc. to\n      * restore probably when loaded from a save-game.\n      * @property waitingFor\n      * @type Object\n      * @protected\n       */\n      this.waitingFor = {};\n\n      /**\n      * Stores interpreter related settings like how to handle messages, etc.\n      * @property settings\n      * @type Object\n      * @protected\n       */\n      this.settings = {\n        message: {\n          byId: {},\n          autoErase: true,\n          waitAtEnd: true,\n          backlog: true\n        },\n        screen: {\n          pan: new gs.Point(0, 0)\n        }\n      };\n\n      /**\n      * Mapping table to quickly get the anchor point for the an inserted anchor-point constant such as\n      * Top-Left(0), Top(1), Top-Right(2) and so on.\n      * @property graphicAnchorPointsByConstant\n      * @type gs.Point[]\n      * @protected\n       */\n      this.graphicAnchorPointsByConstant = [new gs.Point(0.0, 0.0), new gs.Point(0.5, 0.0), new gs.Point(1.0, 0.0), new gs.Point(1.0, 0.5), new gs.Point(1.0, 1.0), new gs.Point(0.5, 1.0), new gs.Point(0.0, 1.0), new gs.Point(0.0, 0.5), new gs.Point(0.5, 0.5)];\n    }\n\n    Component_CommandInterpreter.prototype.onHotspotClick = function(e, data) {\n      return this.executeAction(data.params.actions.onClick, false, data.bindValue);\n    };\n\n    Component_CommandInterpreter.prototype.onHotspotEnter = function(e, data) {\n      return this.executeAction(data.params.actions.onEnter, true, data.bindValue);\n    };\n\n    Component_CommandInterpreter.prototype.onHotspotLeave = function(e, data) {\n      return this.executeAction(data.params.actions.onLeave, false, data.bindValue);\n    };\n\n    Component_CommandInterpreter.prototype.onHotspotDragStart = function(e, data) {\n      return this.executeAction(data.params.actions.onDrag, true, data.bindValue);\n    };\n\n    Component_CommandInterpreter.prototype.onHotspotDrag = function(e, data) {\n      return this.executeAction(data.params.actions.onDrag, true, data.bindValue);\n    };\n\n    Component_CommandInterpreter.prototype.onHotspotDragEnd = function(e, data) {\n      return this.executeAction(data.params.actions.onDrag, false, data.bindValue);\n    };\n\n    Component_CommandInterpreter.prototype.onHotspotDrop = function(e, data) {\n      this.executeAction(data.params.actions.onDrop, false, data.bindValue);\n      return gs.GlobalEventManager.emit(\"hotspotDrop\", e.sender);\n    };\n\n    Component_CommandInterpreter.prototype.onHotspotDropReceived = function(e, data) {\n      return this.executeAction(data.params.actions.onDropReceive, true, data.bindValue);\n    };\n\n    Component_CommandInterpreter.prototype.onHotspotStateChanged = function(e, params) {\n      if (e.sender.behavior.selected) {\n        return this.executeAction(params.actions.onSelect, true);\n      } else {\n        return this.executeAction(params.actions.onDeselect, false);\n      }\n    };\n\n\n    /**\n    * Called when a ADV message finished rendering and is now waiting\n    * for the user/autom-message timer to proceed.\n    *\n    * @method onMessageADVWaiting\n    * @return {Object} Event Object containing additional data.\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.onMessageADVWaiting = function(e) {\n      var messageObject;\n      messageObject = e.sender.object;\n      if (!this.messageSettings().waitAtEnd) {\n        if (e.data.params.waitForCompletion) {\n          this.isWaiting = false;\n        }\n        messageObject.textRenderer.isWaiting = false;\n        messageObject.textRenderer.isRunning = false;\n      }\n      messageObject.events.off(\"waiting\", e.handler);\n      if (this.messageSettings().backlog && (messageObject.settings.autoErase || messageObject.settings.paragraphSpacing > 0)) {\n        return GameManager.backlog.push({\n          character: messageObject.character,\n          message: messageObject.behavior.message,\n          choices: []\n        });\n      }\n    };\n\n\n    /**\n    * Called when an ADV message finished fade-out.\n    *\n    * @method onMessageADVDisappear\n    * @return {Object} Event Object containing additional data.\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.onMessageADVDisappear = function(messageObject, waitForCompletion) {\n      SceneManager.scene.currentCharacter = {\n        name: \"\"\n      };\n      messageObject.behavior.clear();\n      messageObject.visible = false;\n      if (messageObject.waitForCompletion) {\n        this.isWaiting = false;\n      }\n      return this.waitingFor.messageADV = null;\n    };\n\n\n    /**\n    * Called when an ADV message finished clear.\n    *\n    * @method onMessageADVClear\n    * @return {Object} Event Object containing additional data.\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.onMessageADVClear = function(messageObject, waitForCompletion) {\n      messageObject = this.targetMessage();\n      if (this.messageSettings().backlog) {\n        GameManager.backlog.push({\n          character: messageObject.character,\n          message: messageObject.behavior.message,\n          choices: []\n        });\n      }\n      return this.onMessageADVDisappear(messageObject, waitForCompletion);\n    };\n\n\n    /**\n    * Called when a hotspot/image-map sends a \"jumpTo\" event to let the\n    * interpreter jump to the position defined in the event object.\n    *\n    * @method onJumpTo\n    * @return {Object} Event Object containing additional data.\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.onJumpTo = function(e) {\n      this.jumpToLabel(e.label);\n      return this.isWaiting = false;\n    };\n\n\n    /**\n    * Called when a hotspot/image-map sends a \"callCommonEvent\" event to let the\n    * interpreter call the common event defined in the event object.\n    *\n    * @method onJumpTo\n    * @return {Object} Event Object containing additional data.\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.onCallCommonEvent = function(e) {\n      var event, eventId, ref;\n      eventId = e.commonEventId;\n      event = RecordManager.commonEvents[eventId];\n      if (!event) {\n        event = RecordManager.commonEvents.first((function(_this) {\n          return function(x) {\n            return x.name === eventId;\n          };\n        })(this));\n        if (event) {\n          eventId = event.index;\n        }\n      }\n      this.callCommonEvent(eventId, e.params || [], !e.finish);\n      return this.isWaiting = (ref = e.waiting) != null ? ref : false;\n    };\n\n\n    /**\n    * Called when a ADV message finishes.\n    *\n    * @method onMessageADVFinish\n    * @return {Object} Event Object containing additional data.\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.onMessageADVFinish = function(e) {\n      var commands, duration, fading, messageObject, pointer;\n      messageObject = e.sender.object;\n      if (!this.messageSettings().waitAtEnd) {\n        return;\n      }\n      GameManager.globalData.messages[lcsm(e.data.params.message)] = {\n        read: true\n      };\n      GameManager.saveGlobalData();\n      if (e.data.params.waitForCompletion) {\n        this.isWaiting = false;\n      }\n      this.waitingFor.messageADV = null;\n      pointer = this.pointer;\n      commands = this.object.commands;\n      messageObject.events.off(\"finish\", e.handler);\n      if ((messageObject.voice != null) && GameManager.settings.skipVoiceOnAction) {\n        AudioManager.stopSound(messageObject.voice.name);\n      }\n      if (!this.isMessageCommand(pointer, commands) && this.messageSettings().autoErase) {\n        this.isWaiting = true;\n        this.waitingFor.messageADV = e.data.params;\n        fading = GameManager.tempSettings.messageFading;\n        duration = GameManager.tempSettings.skip ? 0 : fading.duration;\n        messageObject.waitForCompletion = e.data.params.waitForCompletion;\n        return messageObject.animator.disappear(fading.animation, fading.easing, duration, gs.CallBack(\"onMessageADVDisappear\", this, e.data.params.waitForCompletion));\n      }\n    };\n\n\n    /**\n    * Called when a common event finished execution. In most cases, the interpreter\n    * will stop waiting and continue processing after this. But h\n    *\n    * @method onCommonEventFinish\n    * @return {Object} Event Object containing additional data.\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.onCommonEventFinish = function(e) {\n      var ref;\n      SceneManager.scene.commonEventContainer.removeObject(e.sender.object);\n      e.sender.object.events.off(\"finish\");\n      this.subInterpreter = null;\n      return this.isWaiting = (ref = e.data.waiting) != null ? ref : false;\n    };\n\n\n    /**\n    * Called when a scene call finished execution.\n    *\n    * @method onCallSceneFinish\n    * @param {Object} sender - The sender of this event.\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.onCallSceneFinish = function(sender) {\n      this.isWaiting = false;\n      return this.subInterpreter = null;\n    };\n\n\n    /**\n    * Serializes the interpreter into a data-bundle.\n    *\n    * @method toDataBundle\n    * @return {Object} The data-bundle.\n     */\n\n    Component_CommandInterpreter.prototype.toDataBundle = function() {\n      if (this.isInputDataCommand(Math.max(this.pointer - 1, 0), this.object.commands)) {\n        return {\n          pointer: Math.max(this.pointer - 1, 0),\n          choice: this.choice,\n          conditions: this.conditions,\n          loops: this.loops,\n          labels: this.labels,\n          isWaiting: false,\n          isRunning: this.isRunning,\n          waitCounter: this.waitCounter,\n          waitingFor: this.waitingFor,\n          indent: this.indent,\n          settings: this.settings\n        };\n      } else {\n        return {\n          pointer: this.pointer,\n          choice: this.choice,\n          conditions: this.conditions,\n          loops: this.loops,\n          labels: this.labels,\n          isWaiting: this.isWaiting,\n          isRunning: this.isRunning,\n          waitCounter: this.waitCounter,\n          waitingFor: this.waitingFor,\n          indent: this.indent,\n          settings: this.settings\n        };\n      }\n    };\n\n\n    /**\n     * Previews the current scene at the specified pointer. This method is called from the\n     * VN Maker Scene-Editor if live-preview is enabled and the user clicked on a command.\n     *\n     * @method preview\n     */\n\n    Component_CommandInterpreter.prototype.preview = function() {\n      var ex, scene;\n      try {\n        if (!$PARAMS.preview || !$PARAMS.preview.scene) {\n          return;\n        }\n        AudioManager.stopAllSounds();\n        AudioManager.stopAllMusic();\n        AudioManager.stopAllVoices();\n        SceneManager.scene.choices = [];\n        GameManager.setupCursor();\n        this.previewData = $PARAMS.preview;\n        gs.GlobalEventManager.emit(\"previewRestart\");\n        if (this.previewInfo.timeout) {\n          clearTimeout(this.previewInfo.timeout);\n        }\n        if (Graphics.stopped) {\n          Graphics.stopped = false;\n          Graphics.onEachFrame(gs.Main.frameCallback);\n        }\n        scene = new vn.Object_Scene();\n        scene.sceneData.uid = this.previewData.scene.uid;\n        return SceneManager.switchTo(scene);\n      } catch (error) {\n        ex = error;\n        return console.warn(ex);\n      }\n    };\n\n\n    /**\n     * Sets up the interpreter.\n     *\n     * @method setup\n     */\n\n    Component_CommandInterpreter.prototype.setup = function() {\n      Component_CommandInterpreter.__super__.setup.apply(this, arguments);\n      this.previewData = $PARAMS.preview;\n      if (this.previewData) {\n        return gs.GlobalEventManager.on(\"mouseDown\", ((function(_this) {\n          return function() {\n            if (_this.previewInfo.waiting) {\n              if (_this.previewInfo.timeout) {\n                clearTimeout(_this.previewInfo.timeout);\n              }\n              _this.previewInfo.waiting = false;\n              GameManager.tempSettings.skip = false;\n              _this.previewData = null;\n              return gs.GlobalEventManager.emit(\"previewRestart\");\n            }\n          };\n        })(this)), null, this.object);\n      }\n    };\n\n\n    /**\n     * Disposes the interpreter.\n     *\n     * @method dispose\n     */\n\n    Component_CommandInterpreter.prototype.dispose = function() {\n      if (this.previewData) {\n        gs.GlobalEventManager.offByOwner(\"mouseDown\", this.object);\n      }\n      return Component_CommandInterpreter.__super__.dispose.apply(this, arguments);\n    };\n\n    Component_CommandInterpreter.prototype.isInstantSkip = function() {\n      return GameManager.tempSettings.skip && GameManager.tempSettings.skipTime === 0;\n    };\n\n\n    /**\n    * Restores the interpreter from a data-bundle\n    *\n    * @method restore\n    * @param {Object} bundle- The data-bundle.\n     */\n\n    Component_CommandInterpreter.prototype.restore = function() {};\n\n\n    /**\n    * Gets the default game message for novel-mode.\n    *\n    * @method messageObjectNVL\n    * @return {ui.Object_Message} The NVL game message object.\n     */\n\n    Component_CommandInterpreter.prototype.messageObjectNVL = function() {\n      return gs.ObjectManager.current.objectById(\"nvlGameMessage_message\");\n    };\n\n\n    /**\n    * Gets the default game message for adventure-mode.\n    *\n    * @method messageObjectADV\n    * @return {ui.Object_Message} The ADV game message object.\n     */\n\n    Component_CommandInterpreter.prototype.messageObjectADV = function() {\n      return gs.ObjectManager.current.objectById(\"gameMessage_message\");\n    };\n\n\n    /**\n    * Starts the interpreter\n    *\n    * @method start\n     */\n\n    Component_CommandInterpreter.prototype.start = function() {\n      this.conditions = [];\n      this.loops = [];\n      this.indent = 0;\n      this.pointer = 0;\n      this.isRunning = true;\n      this.isWaiting = false;\n      this.subInterpreter = null;\n      return this.waitCounter = 0;\n    };\n\n\n    /**\n    * Stops the interpreter\n    *\n    * @method stop\n     */\n\n    Component_CommandInterpreter.prototype.stop = function() {\n      return this.isRunning = false;\n    };\n\n\n    /**\n    * Resumes the interpreter\n    *\n    * @method resume\n     */\n\n    Component_CommandInterpreter.prototype.resume = function() {\n      return this.isRunning = true;\n    };\n\n\n    /**\n    * Updates the interpreter and executes all commands until the next wait is\n    * triggered by a command. So in the case of an endless-loop the method will\n    * never return.\n    *\n    * @method update\n     */\n\n    Component_CommandInterpreter.prototype.update = function() {\n      if (this.subInterpreter != null) {\n        this.subInterpreter.update();\n        return;\n      }\n      GameManager.variableStore.setupTempVariables(this.context);\n      if (((this.object.commands == null) || this.pointer >= this.object.commands.length) && !this.isWaiting) {\n        if (this.repeat) {\n          this.start();\n        } else if (this.isRunning) {\n          this.isRunning = false;\n          if (this.onFinish != null) {\n            this.onFinish(this);\n          }\n          return;\n        }\n      }\n      if (!this.isRunning) {\n        return;\n      }\n      if (!this.object.commands.optimized) {\n        DataOptimizer.optimizeEventCommands(this.object.commands);\n      }\n      if (this.waitCounter > 0) {\n        this.waitCounter--;\n        this.isWaiting = this.waitCounter > 0;\n        return;\n      }\n      if (this.isWaitingForMessage) {\n        this.isWaiting = true;\n        if (!this.isProcessingMessageInOtherContext()) {\n          this.isWaiting = false;\n          this.isWaitingForMessage = false;\n        } else {\n          return;\n        }\n      }\n      if (GameManager.inLivePreview) {\n        while (!(this.isWaiting || this.previewInfo.waiting) && this.pointer < this.object.commands.length && this.isRunning) {\n          this.executeCommand(this.pointer);\n          this.previewInfo.executedCommands++;\n          if (this.previewInfo.executedCommands > 500) {\n            this.previewInfo.executedCommands = 0;\n            this.isWaiting = true;\n            this.waitCounter = 1;\n          }\n        }\n      } else {\n        while (!(this.isWaiting || this.previewInfo.waiting) && this.pointer < this.object.commands.length && this.isRunning) {\n          this.executeCommand(this.pointer);\n        }\n      }\n      if (this.pointer >= this.object.commands.length && !this.isWaiting) {\n        if (this.repeat) {\n          return this.start();\n        } else if (this.isRunning) {\n          this.isRunning = false;\n          if (this.onFinish != null) {\n            return this.onFinish(this);\n          }\n        }\n      }\n    };\n\n\n    /**\n    * Assigns the correct command-function to the specified command-object if\n    * necessary.\n    *\n    * @method assignCommand\n     */\n\n    Component_CommandInterpreter.prototype.assignCommand = function(command) {\n      switch (command.id) {\n        case \"gs.Idle\":\n          return command.execute = this.commandIdle;\n        case \"gs.StartTimer\":\n          return command.execute = this.commandStartTimer;\n        case \"gs.PauseTimer\":\n          return command.execute = this.commandPauseTimer;\n        case \"gs.ResumeTimer\":\n          return command.execute = this.commandResumeTimer;\n        case \"gs.StopTimer\":\n          return command.execute = this.commandStopTimer;\n        case \"gs.WaitCommand\":\n          return command.execute = this.commandWait;\n        case \"gs.LoopCommand\":\n          return command.execute = this.commandLoop;\n        case \"gs.BreakLoopCommand\":\n          return command.execute = this.commandBreakLoop;\n        case \"gs.Comment\":\n          return command.execute = function() {\n            return 0;\n          };\n        case \"gs.EmptyCommand\":\n          return command.execute = function() {\n            return 0;\n          };\n        case \"gs.ListAdd\":\n          return command.execute = this.commandListAdd;\n        case \"gs.ListPop\":\n          return command.execute = this.commandListPop;\n        case \"gs.ListShift\":\n          return command.execute = this.commandListShift;\n        case \"gs.ListRemoveAt\":\n          return command.execute = this.commandListRemoveAt;\n        case \"gs.ListInsertAt\":\n          return command.execute = this.commandListInsertAt;\n        case \"gs.ListValueAt\":\n          return command.execute = this.commandListValueAt;\n        case \"gs.ListClear\":\n          return command.execute = this.commandListClear;\n        case \"gs.ListShuffle\":\n          return command.execute = this.commandListShuffle;\n        case \"gs.ListSort\":\n          return command.execute = this.commandListSort;\n        case \"gs.ListIndexOf\":\n          return command.execute = this.commandListIndexOf;\n        case \"gs.ListSet\":\n          return command.execute = this.commandListSet;\n        case \"gs.ListCopy\":\n          return command.execute = this.commandListCopy;\n        case \"gs.ListLength\":\n          return command.execute = this.commandListLength;\n        case \"gs.ListJoin\":\n          return command.execute = this.commandListJoin;\n        case \"gs.ListFromText\":\n          return command.execute = this.commandListFromText;\n        case \"gs.ResetVariables\":\n          return command.execute = this.commandResetVariables;\n        case \"gs.ChangeVariableDomain\":\n          return command.execute = this.commandChangeVariableDomain;\n        case \"gs.ChangeNumberVariables\":\n          return command.execute = this.commandChangeNumberVariables;\n        case \"gs.ChangeDecimalVariables\":\n          return command.execute = this.commandChangeDecimalVariables;\n        case \"gs.ChangeBooleanVariables\":\n          return command.execute = this.commandChangeBooleanVariables;\n        case \"gs.ChangeStringVariables\":\n          return command.execute = this.commandChangeStringVariables;\n        case \"gs.CheckSwitch\":\n          return command.execute = this.commandCheckSwitch;\n        case \"gs.CheckNumberVariable\":\n          return command.execute = this.commandCheckNumberVariable;\n        case \"gs.CheckTextVariable\":\n          return command.execute = this.commandCheckTextVariable;\n        case \"gs.Condition\":\n          return command.execute = this.commandCondition;\n        case \"gs.ConditionElse\":\n          return command.execute = this.commandConditionElse;\n        case \"gs.ConditionElseIf\":\n          return command.execute = this.commandConditionElseIf;\n        case \"gs.Label\":\n          return command.execute = this.commandLabel;\n        case \"gs.JumpToLabel\":\n          return command.execute = this.commandJumpToLabel;\n        case \"gs.SetMessageArea\":\n          return command.execute = this.commandSetMessageArea;\n        case \"gs.ShowMessage\":\n          return command.execute = this.commandShowMessage;\n        case \"gs.ShowPartialMessage\":\n          return command.execute = this.commandShowPartialMessage;\n        case \"gs.MessageFading\":\n          return command.execute = this.commandMessageFading;\n        case \"gs.MessageSettings\":\n          return command.execute = this.commandMessageSettings;\n        case \"gs.CreateMessageArea\":\n          return command.execute = this.commandCreateMessageArea;\n        case \"gs.EraseMessageArea\":\n          return command.execute = this.commandEraseMessageArea;\n        case \"gs.SetTargetMessage\":\n          return command.execute = this.commandSetTargetMessage;\n        case \"vn.MessageBoxDefaults\":\n          return command.execute = this.commandMessageBoxDefaults;\n        case \"vn.MessageBoxVisibility\":\n          return command.execute = this.commandMessageBoxVisibility;\n        case \"vn.MessageVisibility\":\n          return command.execute = this.commandMessageVisibility;\n        case \"vn.BacklogVisibility\":\n          return command.execute = this.commandBacklogVisibility;\n        case \"gs.ClearMessage\":\n          return command.execute = this.commandClearMessage;\n        case \"gs.ChangeWeather\":\n          return command.execute = this.commandChangeWeather;\n        case \"gs.FreezeScreen\":\n          return command.execute = this.commandFreezeScreen;\n        case \"gs.ScreenTransition\":\n          return command.execute = this.commandScreenTransition;\n        case \"gs.ShakeScreen\":\n          return command.execute = this.commandShakeScreen;\n        case \"gs.TintScreen\":\n          return command.execute = this.commandTintScreen;\n        case \"gs.FlashScreen\":\n          return command.execute = this.commandFlashScreen;\n        case \"gs.ZoomScreen\":\n          return command.execute = this.commandZoomScreen;\n        case \"gs.RotateScreen\":\n          return command.execute = this.commandRotateScreen;\n        case \"gs.PanScreen\":\n          return command.execute = this.commandPanScreen;\n        case \"gs.ScreenEffect\":\n          return command.execute = this.commandScreenEffect;\n        case \"gs.ShowVideo\":\n          return command.execute = this.commandShowVideo;\n        case \"gs.MoveVideo\":\n          return command.execute = this.commandMoveVideo;\n        case \"gs.MoveVideoPath\":\n          return command.execute = this.commandMoveVideoPath;\n        case \"gs.TintVideo\":\n          return command.execute = this.commandTintVideo;\n        case \"gs.FlashVideo\":\n          return command.execute = this.commandFlashVideo;\n        case \"gs.CropVideo\":\n          return command.execute = this.commandCropVideo;\n        case \"gs.RotateVideo\":\n          return command.execute = this.commandRotateVideo;\n        case \"gs.ZoomVideo\":\n          return command.execute = this.commandZoomVideo;\n        case \"gs.BlendVideo\":\n          return command.execute = this.commandBlendVideo;\n        case \"gs.MaskVideo\":\n          return command.execute = this.commandMaskVideo;\n        case \"gs.VideoEffect\":\n          return command.execute = this.commandVideoEffect;\n        case \"gs.VideoMotionBlur\":\n          return command.execute = this.commandVideoMotionBlur;\n        case \"gs.VideoDefaults\":\n          return command.execute = this.commandVideoDefaults;\n        case \"gs.EraseVideo\":\n          return command.execute = this.commandEraseVideo;\n        case \"gs.ShowImageMap\":\n          return command.execute = this.commandShowImageMap;\n        case \"gs.EraseImageMap\":\n          return command.execute = this.commandEraseImageMap;\n        case \"gs.AddHotspot\":\n          return command.execute = this.commandAddHotspot;\n        case \"gs.EraseHotspot\":\n          return command.execute = this.commandEraseHotspot;\n        case \"gs.ChangeHotspotState\":\n          return command.execute = this.commandChangeHotspotState;\n        case \"gs.ShowPicture\":\n          return command.execute = this.commandShowPicture;\n        case \"gs.MovePicture\":\n          return command.execute = this.commandMovePicture;\n        case \"gs.MovePicturePath\":\n          return command.execute = this.commandMovePicturePath;\n        case \"gs.TintPicture\":\n          return command.execute = this.commandTintPicture;\n        case \"gs.FlashPicture\":\n          return command.execute = this.commandFlashPicture;\n        case \"gs.CropPicture\":\n          return command.execute = this.commandCropPicture;\n        case \"gs.RotatePicture\":\n          return command.execute = this.commandRotatePicture;\n        case \"gs.ZoomPicture\":\n          return command.execute = this.commandZoomPicture;\n        case \"gs.BlendPicture\":\n          return command.execute = this.commandBlendPicture;\n        case \"gs.ShakePicture\":\n          return command.execute = this.commandShakePicture;\n        case \"gs.MaskPicture\":\n          return command.execute = this.commandMaskPicture;\n        case \"gs.PictureEffect\":\n          return command.execute = this.commandPictureEffect;\n        case \"gs.PictureMotionBlur\":\n          return command.execute = this.commandPictureMotionBlur;\n        case \"gs.PictureDefaults\":\n          return command.execute = this.commandPictureDefaults;\n        case \"gs.PlayPictureAnimation\":\n          return command.execute = this.commandPlayPictureAnimation;\n        case \"gs.ErasePicture\":\n          return command.execute = this.commandErasePicture;\n        case \"gs.InputNumber\":\n          return command.execute = this.commandInputNumber;\n        case \"vn.Choice\":\n          return command.execute = this.commandShowChoice;\n        case \"vn.ChoiceTimer\":\n          return command.execute = this.commandChoiceTimer;\n        case \"vn.ShowChoices\":\n          return command.execute = this.commandShowChoices;\n        case \"vn.UnlockCG\":\n          return command.execute = this.commandUnlockCG;\n        case \"vn.L2DJoinScene\":\n          return command.execute = this.commandL2DJoinScene;\n        case \"vn.L2DExitScene\":\n          return command.execute = this.commandL2DExitScene;\n        case \"vn.L2DMotion\":\n          return command.execute = this.commandL2DMotion;\n        case \"vn.L2DMotionGroup\":\n          return command.execute = this.commandL2DMotionGroup;\n        case \"vn.L2DExpression\":\n          return command.execute = this.commandL2DExpression;\n        case \"vn.L2DMove\":\n          return command.execute = this.commandL2DMove;\n        case \"vn.L2DParameter\":\n          return command.execute = this.commandL2DParameter;\n        case \"vn.L2DSettings\":\n          return command.execute = this.commandL2DSettings;\n        case \"vn.L2DDefaults\":\n          return command.execute = this.commandL2DDefaults;\n        case \"vn.CharacterJoinScene\":\n          return command.execute = this.commandCharacterJoinScene;\n        case \"vn.CharacterExitScene\":\n          return command.execute = this.commandCharacterExitScene;\n        case \"vn.CharacterChangeExpression\":\n          return command.execute = this.commandCharacterChangeExpression;\n        case \"vn.CharacterSetParameter\":\n          return command.execute = this.commandCharacterSetParameter;\n        case \"vn.CharacterGetParameter\":\n          return command.execute = this.commandCharacterGetParameter;\n        case \"vn.CharacterDefaults\":\n          return command.execute = this.commandCharacterDefaults;\n        case \"vn.CharacterEffect\":\n          return command.execute = this.commandCharacterEffect;\n        case \"vn.ZoomCharacter\":\n          return command.execute = this.commandZoomCharacter;\n        case \"vn.RotateCharacter\":\n          return command.execute = this.commandRotateCharacter;\n        case \"vn.BlendCharacter\":\n          return command.execute = this.commandBlendCharacter;\n        case \"vn.ShakeCharacter\":\n          return command.execute = this.commandShakeCharacter;\n        case \"vn.MaskCharacter\":\n          return command.execute = this.commandMaskCharacter;\n        case \"vn.MoveCharacter\":\n          return command.execute = this.commandMoveCharacter;\n        case \"vn.MoveCharacterPath\":\n          return command.execute = this.commandMoveCharacterPath;\n        case \"vn.FlashCharacter\":\n          return command.execute = this.commandFlashCharacter;\n        case \"vn.TintCharacter\":\n          return command.execute = this.commandTintCharacter;\n        case \"vn.CharacterMotionBlur\":\n          return command.execute = this.commandCharacterMotionBlur;\n        case \"vn.ChangeBackground\":\n          return command.execute = this.commandChangeBackground;\n        case \"vn.ShakeBackground\":\n          return command.execute = this.commandShakeBackground;\n        case \"vn.ScrollBackground\":\n          return command.execute = this.commandScrollBackground;\n        case \"vn.ScrollBackgroundTo\":\n          return command.execute = this.commandScrollBackgroundTo;\n        case \"vn.ScrollBackgroundPath\":\n          return command.execute = this.commandScrollBackgroundPath;\n        case \"vn.ZoomBackground\":\n          return command.execute = this.commandZoomBackground;\n        case \"vn.RotateBackground\":\n          return command.execute = this.commandRotateBackground;\n        case \"vn.TintBackground\":\n          return command.execute = this.commandTintBackground;\n        case \"vn.BlendBackground\":\n          return command.execute = this.commandBlendBackground;\n        case \"vn.MaskBackground\":\n          return command.execute = this.commandMaskBackground;\n        case \"vn.BackgroundMotionBlur\":\n          return command.execute = this.commandBackgroundMotionBlur;\n        case \"vn.BackgroundEffect\":\n          return command.execute = this.commandBackgroundEffect;\n        case \"vn.BackgroundDefaults\":\n          return command.execute = this.commandBackgroundDefaults;\n        case \"vn.ChangeScene\":\n          return command.execute = this.commandChangeScene;\n        case \"vn.ReturnToPreviousScene\":\n          return command.execute = this.commandReturnToPreviousScene;\n        case \"vn.CallScene\":\n          return command.execute = this.commandCallScene;\n        case \"vn.SwitchToLayout\":\n          return command.execute = this.commandSwitchToLayout;\n        case \"gs.ChangeTransition\":\n          return command.execute = this.commandChangeTransition;\n        case \"gs.ChangeWindowSkin\":\n          return command.execute = this.commandChangeWindowSkin;\n        case \"gs.ChangeScreenTransitions\":\n          return command.execute = this.commandChangeScreenTransitions;\n        case \"vn.UIAccess\":\n          return command.execute = this.commandUIAccess;\n        case \"gs.PlayVideo\":\n          return command.execute = this.commandPlayVideo;\n        case \"gs.PlayMusic\":\n          return command.execute = this.commandPlayMusic;\n        case \"gs.StopMusic\":\n          return command.execute = this.commandStopMusic;\n        case \"gs.PlaySound\":\n          return command.execute = this.commandPlaySound;\n        case \"gs.StopSound\":\n          return command.execute = this.commandStopSound;\n        case \"gs.PauseMusic\":\n          return command.execute = this.commandPauseMusic;\n        case \"gs.ResumeMusic\":\n          return command.execute = this.commandResumeMusic;\n        case \"gs.AudioDefaults\":\n          return command.execute = this.commandAudioDefaults;\n        case \"gs.EndCommonEvent\":\n          return command.execute = this.commandEndCommonEvent;\n        case \"gs.ResumeCommonEvent\":\n          return command.execute = this.commandResumeCommonEvent;\n        case \"gs.CallCommonEvent\":\n          return command.execute = this.commandCallCommonEvent;\n        case \"gs.ChangeTimer\":\n          return command.execute = this.commandChangeTimer;\n        case \"gs.ShowText\":\n          return command.execute = this.commandShowText;\n        case \"gs.RefreshText\":\n          return command.execute = this.commandRefreshText;\n        case \"gs.TextMotionBlur\":\n          return command.execute = this.commandTextMotionBlur;\n        case \"gs.MoveText\":\n          return command.execute = this.commandMoveText;\n        case \"gs.MoveTextPath\":\n          return command.execute = this.commandMoveTextPath;\n        case \"gs.RotateText\":\n          return command.execute = this.commandRotateText;\n        case \"gs.ZoomText\":\n          return command.execute = this.commandZoomText;\n        case \"gs.BlendText\":\n          return command.execute = this.commandBlendText;\n        case \"gs.ColorText\":\n          return command.execute = this.commandColorText;\n        case \"gs.EraseText\":\n          return command.execute = this.commandEraseText;\n        case \"gs.TextEffect\":\n          return command.execute = this.commandTextEffect;\n        case \"gs.TextDefaults\":\n          return command.execute = this.commandTextDefaults;\n        case \"gs.ChangeTextSettings\":\n          return command.execute = this.commandChangeTextSettings;\n        case \"gs.InputText\":\n          return command.execute = this.commandInputText;\n        case \"gs.InputName\":\n          return command.execute = this.commandInputName;\n        case \"gs.SavePersistentData\":\n          return command.execute = this.commandSavePersistentData;\n        case \"gs.SaveSettings\":\n          return command.execute = this.commandSaveSettings;\n        case \"gs.PrepareSaveGame\":\n          return command.execute = this.commandPrepareSaveGame;\n        case \"gs.SaveGame\":\n          return command.execute = this.commandSaveGame;\n        case \"gs.LoadGame\":\n          return command.execute = this.commandLoadGame;\n        case \"gs.GetInputData\":\n          return command.execute = this.commandGetInputData;\n        case \"gs.WaitForInput\":\n          return command.execute = this.commandWaitForInput;\n        case \"gs.ChangeObjectDomain\":\n          return command.execute = this.commandChangeObjectDomain;\n        case \"vn.GetGameData\":\n          return command.execute = this.commandGetGameData;\n        case \"vn.SetGameData\":\n          return command.execute = this.commandSetGameData;\n        case \"vn.GetObjectData\":\n          return command.execute = this.commandGetObjectData;\n        case \"vn.SetObjectData\":\n          return command.execute = this.commandSetObjectData;\n        case \"vn.ChangeSounds\":\n          return command.execute = this.commandChangeSounds;\n        case \"vn.ChangeColors\":\n          return command.execute = this.commandChangeColors;\n        case \"gs.ChangeScreenCursor\":\n          return command.execute = this.commandChangeScreenCursor;\n        case \"gs.ResetGlobalData\":\n          return command.execute = this.commandResetGlobalData;\n        case \"gs.Script\":\n          return command.execute = this.commandScript;\n      }\n    };\n\n\n    /**\n    * Executes the command at the specified index and increases the command-pointer.\n    *\n    * @method executeCommand\n     */\n\n    Component_CommandInterpreter.prototype.executeCommand = function(index) {\n      var indent;\n      this.command = this.object.commands[index];\n      if (this.previewData) {\n        if (this.previewData.uid && this.previewData.uid !== this.command.uid) {\n          GameManager.tempSettings.skip = true;\n          GameManager.tempSettings.skipTime = 0;\n        } else if (this.pointer < this.previewData.pointer) {\n          GameManager.tempSettings.skip = true;\n          GameManager.tempSettings.skipTime = 0;\n        } else {\n          GameManager.tempSettings.skip = this.previewData.settings.animationDisabled;\n          GameManager.tempSettings.skipTime = 0;\n          this.previewInfo.waiting = true;\n          gs.GlobalEventManager.emit(\"previewWaiting\");\n          if (this.previewData.settings.animationDisabled || this.previewData.settings.animationTime > 0) {\n            this.previewInfo.timeout = setTimeout((function() {\n              return Graphics.stopped = true;\n            }), this.previewData.settings.animationTime * 1000);\n          }\n        }\n      }\n      if (this.command.execute != null) {\n        this.command.interpreter = this;\n        if (this.command.indent === this.indent) {\n          this.command.execute();\n        }\n        this.pointer++;\n        this.command = this.object.commands[this.pointer];\n        if (this.command != null) {\n          indent = this.command.indent;\n        } else {\n          indent = this.indent;\n          while (indent > 0 && (this.loops[indent] == null)) {\n            indent--;\n          }\n        }\n        if (indent < this.indent) {\n          this.indent = indent;\n          if (this.loops[this.indent] != null) {\n            this.pointer = this.loops[this.indent];\n            this.command = this.object.commands[this.pointer];\n            return this.command.interpreter = this;\n          }\n        }\n      } else {\n        this.assignCommand(this.command);\n        if (this.command.execute != null) {\n          this.command.interpreter = this;\n          if (this.command.indent === this.indent) {\n            this.command.execute();\n          }\n          this.pointer++;\n          this.command = this.object.commands[this.pointer];\n          if (this.command != null) {\n            indent = this.command.indent;\n          } else {\n            indent = this.indent;\n            while (indent > 0 && (this.loops[indent] == null)) {\n              indent--;\n            }\n          }\n          if (indent < this.indent) {\n            this.indent = indent;\n            if (this.loops[this.indent] != null) {\n              this.pointer = this.loops[this.indent];\n              this.command = this.object.commands[this.pointer];\n              return this.command.interpreter = this;\n            }\n          }\n        } else {\n          return this.pointer++;\n        }\n      }\n    };\n\n\n    /**\n    * Skips all commands until a command with the specified indent-level is\n    * found. So for example: To jump from a Condition-Command to the next\n    * Else-Command just pass the indent-level of the Condition/Else command.\n    *\n    * @method skip\n    * @param {number} indent - The indent-level.\n    * @param {boolean} backward - If true the skip runs backward.\n     */\n\n    Component_CommandInterpreter.prototype.skip = function(indent, backward) {\n      var results, results1;\n      if (backward) {\n        this.pointer--;\n        results = [];\n        while (this.pointer > 0 && this.object.commands[this.pointer].indent !== indent) {\n          results.push(this.pointer--);\n        }\n        return results;\n      } else {\n        this.pointer++;\n        results1 = [];\n        while (this.pointer < this.object.commands.length && this.object.commands[this.pointer].indent !== indent) {\n          results1.push(this.pointer++);\n        }\n        return results1;\n      }\n    };\n\n\n    /**\n    * Halts the interpreter for the specified amount of time. An optionally\n    * callback function can be passed which is called when the time is up.\n    *\n    * @method wait\n    * @param {number} time - The time to wait\n    * @param {gs.Callback} callback - Called if the wait time is up.\n     */\n\n    Component_CommandInterpreter.prototype.wait = function(time, callback) {\n      this.isWaiting = true;\n      this.waitCounter = time;\n      return this.waitCallback = callback;\n    };\n\n\n    /**\n    * Checks if the command at the specified pointer-index is a game message\n    * related command.\n    *\n    * @method isMessageCommand\n    * @param {number} pointer - The pointer/index.\n    * @param {Object[]} commands - The list of commands to check.\n    * @return {boolean} <b>true</b> if its a game message related command. Otherwise <b>false</b>.\n     */\n\n    Component_CommandInterpreter.prototype.isMessageCommand = function(pointer, commands) {\n      var result;\n      result = true;\n      if (pointer >= commands.length || (commands[pointer].id !== \"gs.InputNumber\" && commands[pointer].id !== \"vn.Choice\" && commands[pointer].id !== \"gs.InputText\" && commands[pointer].id !== \"gs.InputName\")) {\n        result = false;\n      }\n      return result;\n    };\n\n\n    /**\n    * Checks if the command at the specified pointer-index asks for user-input like\n    * the Input Number or Input Text command.\n    *\n    * @method isInputDataCommand\n    * @param {number} pointer - The pointer/index.\n    * @param {Object[]} commands - The list of commands to check.\n    * @return {boolean} <b>true</b> if its an input-data command. Otherwise <b>false</b>\n     */\n\n    Component_CommandInterpreter.prototype.isInputDataCommand = function(pointer, commands) {\n      return pointer < commands.length && (commands[pointer].id === \"gs.InputNumber\" || commands[pointer].id === \"gs.InputText\" || commands[pointer].id === \"vn.Choice\" || commands[pointer].id === \"vn.ShowChoices\");\n    };\n\n\n    /**\n    * Checks if a game message is currently running by another interpreter like a\n    * common-event interpreter.\n    *\n    * @method isProcessingMessageInOtherContext\n    * @return {boolean} <b>true</b> a game message is running in another context. Otherwise <b>false</b>\n     */\n\n    Component_CommandInterpreter.prototype.isProcessingMessageInOtherContext = function() {\n      var gm, result, s;\n      result = false;\n      gm = GameManager;\n      s = SceneManager.scene;\n      result = ((s.inputNumberWindow != null) && s.inputNumberWindow.visible && s.inputNumberWindow.executionContext !== this.context) || ((s.inputTextWindow != null) && s.inputTextWindow.active && s.inputTextWindow.executionContext !== this.context);\n      return result;\n    };\n\n\n    /**\n    * If a game message is currently running by an other interpreter like a common-event\n    * interpreter, this method trigger a wait until the other interpreter is finished\n    * with the game message.\n    *\n    * @method waitForMessage\n    * @return {boolean} <b>true</b> a game message is running in another context. Otherwise <b>false</b>\n     */\n\n    Component_CommandInterpreter.prototype.waitForMessage = function() {\n      this.isWaitingForMessage = true;\n      this.isWaiting = true;\n      return this.pointer--;\n    };\n\n\n    /**\n    * Gets the value the number variable at the specified index.\n    *\n    * @method numberValueAtIndex\n    * @param {number} scope - The variable's scope.\n    * @param {number} index - The index of the variable to get the value from.\n    * @return {Number} The value of the variable.\n     */\n\n    Component_CommandInterpreter.prototype.numberValueAtIndex = function(scope, index, domain) {\n      return GameManager.variableStore.numberValueAtIndex(scope, index, domain);\n    };\n\n\n    /**\n    * Gets the value of a (possible) number variable. If a constant number value is specified, this method\n    * does nothing an just returns that constant value. That's to make it more comfortable to just pass a value which\n    * can be calculated by variable but also be just a constant value.\n    *\n    * @method numberValueOf\n    * @param {number|Object} object - A number variable or constant number value.\n    * @return {Number} The value of the variable.\n     */\n\n    Component_CommandInterpreter.prototype.numberValueOf = function(object) {\n      return GameManager.variableStore.numberValueOf(object);\n    };\n\n\n    /**\n    * It does the same like <b>numberValueOf</b> with one difference: If the specified object\n    * is a variable, it's value is considered as a duration-value in milliseconds and automatically converted\n    * into frames.\n    *\n    * @method durationValueOf\n    * @param {number|Object} object - A number variable or constant number value.\n    * @return {Number} The value of the variable.\n     */\n\n    Component_CommandInterpreter.prototype.durationValueOf = function(object) {\n      if (object && (object.index != null)) {\n        return Math.round(GameManager.variableStore.numberValueOf(object) / 1000 * Graphics.frameRate);\n      } else {\n        return Math.round(GameManager.variableStore.numberValueOf(object));\n      }\n    };\n\n\n    /**\n    * Gets a position ({x, y}) for the specified predefined object position configured in\n    * Database - System.\n    *\n    * @method predefinedObjectPosition\n    * @param {number} position - The index/ID of the predefined object position to set.\n    * @param {gs.Object_Base} object - The game object to set the position for.\n    * @param {Object} params - The params object of the scene command.\n    * @return {Object} The position {x, y}.\n     */\n\n    Component_CommandInterpreter.prototype.predefinedObjectPosition = function(position, object, params) {\n      var objectPosition;\n      objectPosition = RecordManager.system.objectPositions[position];\n      if (!objectPosition) {\n        return {\n          x: 0,\n          y: 0\n        };\n      }\n      return objectPosition.func.call(null, object, params) || {\n        x: 0,\n        y: 0\n      };\n    };\n\n\n    /**\n    * Sets the value of a number variable at the specified index.\n    *\n    * @method setNumberValueAtIndex\n    * @param {number} scope - The variable's scope.\n    * @param {number} index - The index of the variable to set.\n    * @param {number} value - The number value to set the variable to.\n     */\n\n    Component_CommandInterpreter.prototype.setNumberValueAtIndex = function(scope, index, value, domain) {\n      return GameManager.variableStore.setNumberValueAtIndex(scope, index, value, domain);\n    };\n\n\n    /**\n    * Sets the value of a number variable.\n    *\n    * @method setNumberValueTo\n    * @param {number} variable - The variable to set.\n    * @param {number} value - The number value to set the variable to.\n     */\n\n    Component_CommandInterpreter.prototype.setNumberValueTo = function(variable, value) {\n      return GameManager.variableStore.setNumberValueTo(variable, value);\n    };\n\n\n    /**\n    * Sets the value of a list variable.\n    *\n    * @method setListObjectTo\n    * @param {Object} variable - The variable to set.\n    * @param {Object} value - The list object to set the variable to.\n     */\n\n    Component_CommandInterpreter.prototype.setListObjectTo = function(variable, value) {\n      return GameManager.variableStore.setListObjectTo(variable, value);\n    };\n\n\n    /**\n    * Sets the value of a boolean/switch variable.\n    *\n    * @method setBooleanValueTo\n    * @param {Object} variable - The variable to set.\n    * @param {boolean} value - The boolean value to set the variable to.\n     */\n\n    Component_CommandInterpreter.prototype.setBooleanValueTo = function(variable, value) {\n      return GameManager.variableStore.setBooleanValueTo(variable, value);\n    };\n\n\n    /**\n    * Sets the value of a number variable at the specified index.\n    *\n    * @method setBooleanValueAtIndex\n    * @param {number} scope - The variable's scope.\n    * @param {number} index - The index of the variable to set.\n    * @param {boolean} value - The boolean value to set the variable to.\n     */\n\n    Component_CommandInterpreter.prototype.setBooleanValueAtIndex = function(scope, index, value, domain) {\n      return GameManager.variableStore.setBooleanValueAtIndex(scope, index, value, domain);\n    };\n\n\n    /**\n    * Sets the value of a string/text variable.\n    *\n    * @method setStringValueTo\n    * @param {Object} variable - The variable to set.\n    * @param {string} value - The string/text value to set the variable to.\n     */\n\n    Component_CommandInterpreter.prototype.setStringValueTo = function(variable, value) {\n      return GameManager.variableStore.setStringValueTo(variable, value);\n    };\n\n\n    /**\n    * Sets the value of the string variable at the specified index.\n    *\n    * @method setStringValueAtIndex\n    * @param {number} scope - The variable scope.\n    * @param {number} index - The variable's index.\n    * @param {string} value - The value to set.\n     */\n\n    Component_CommandInterpreter.prototype.setStringValueAtIndex = function(scope, index, value, domain) {\n      return GameManager.variableStore.setStringValueAtIndex(scope, index, value, domain);\n    };\n\n\n    /**\n    * Gets the value of a (possible) string variable. If a constant string value is specified, this method\n    * does nothing an just returns that constant value. That's to make it more comfortable to just pass a value which\n    * can be calculated by variable but also be just a constant value.\n    *\n    * @method stringValueOf\n    * @param {string|Object} object - A string variable or constant string value.\n    * @return {string} The value of the variable.\n     */\n\n    Component_CommandInterpreter.prototype.stringValueOf = function(object) {\n      return GameManager.variableStore.stringValueOf(object);\n    };\n\n\n    /**\n    * Gets the value of the string variable at the specified index.\n    *\n    * @method stringValueAtIndex\n    * @param {number} scope - The variable's scope.\n    * @param {number} index - The index of the variable to get the value from.\n    * @return {string} The value of the variable.\n     */\n\n    Component_CommandInterpreter.prototype.stringValueAtIndex = function(scope, index, domain) {\n      return GameManager.variableStore.stringValueAtIndex(scope, index, domain);\n    };\n\n\n    /**\n    * Gets the value of a (possible) boolean variable. If a constant boolean value is specified, this method\n    * does nothing an just returns that constant value. That's to make it more comfortable to just pass a value which\n    * can be calculated by variable but also be just a constant value.\n    *\n    * @method booleanValueOf\n    * @param {boolean|Object} object - A boolean variable or constant boolean value.\n    * @return {boolean} The value of the variable.\n     */\n\n    Component_CommandInterpreter.prototype.booleanValueOf = function(object) {\n      return GameManager.variableStore.booleanValueOf(object);\n    };\n\n\n    /**\n    * Gets the value of the boolean variable at the specified index.\n    *\n    * @method booleanValueAtIndex\n    * @param {number} scope - The variable's scope.\n    * @param {number} index - The index of the variable to get the value from.\n    * @return {string} The value of the variable.\n     */\n\n    Component_CommandInterpreter.prototype.booleanValueAtIndex = function(scope, index, domain) {\n      return GameManager.variableStore.booleanValueAtIndex(scope, index, domain);\n    };\n\n\n    /**\n    * Gets the value of a (possible) list variable.\n    *\n    * @method listObjectOf\n    * @param {Object} object - A list variable.\n    * @return {Object} The value of the list variable.\n     */\n\n    Component_CommandInterpreter.prototype.listObjectOf = function(object) {\n      return GameManager.variableStore.listObjectOf(object);\n    };\n\n\n    /**\n    * Compares two object using the specified operation and returns the result.\n    *\n    * @method compare\n    * @param {Object} a - Object A.\n    * @param {Object} b - Object B.\n    * @param {number} operation - The compare-operation to compare Object A with Object B.\n    * <ul>\n    * <li>0 = Equal To</li>\n    * <li>1 = Not Equal To</li>\n    * <li>2 = Greater Than</li>\n    * <li>3 = Greater or Equal To</li>\n    * <li>4 = Less Than</li>\n    * <li>5 = Less or Equal To</li>\n    * </ul>\n    * @return {boolean} The comparison result.\n     */\n\n    Component_CommandInterpreter.prototype.compare = function(a, b, operation) {\n      switch (operation) {\n        case 0:\n          return a == b;\n        case 1:\n          return a != b;\n        case 2:\n          return a > b;\n        case 3:\n          return a >= b;\n        case 4:\n          return a < b;\n        case 5:\n          return a <= b;\n      }\n    };\n\n\n    /**\n    * Changes number variables and allows decimal values such as 0.5 too.\n    *\n    * @method changeDecimalVariables\n    * @param {Object} params - Input params from the command\n    * @param {Object} roundMethod - The result of the operation will be rounded using the specified method.\n    * <ul>\n    * <li>0 = None. The result will not be rounded.</li>\n    * <li>1 = Commercially</li>\n    * <li>2 = Round Up</li>\n    * <li>3 = Round Down</li>\n    * </ul>\n     */\n\n    Component_CommandInterpreter.prototype.changeDecimalVariables = function(params, roundMethod) {\n      var diff, end, i, index, k, ref, ref1, roundFunc, scope, source, start;\n      source = 0;\n      roundFunc = null;\n      switch (roundMethod) {\n        case 0:\n          roundFunc = function(value) {\n            return value;\n          };\n          break;\n        case 1:\n          roundFunc = function(value) {\n            return Math.round(value);\n          };\n          break;\n        case 2:\n          roundFunc = function(value) {\n            return Math.ceil(value);\n          };\n          break;\n        case 3:\n          roundFunc = function(value) {\n            return Math.floor(value);\n          };\n      }\n      switch (params.source) {\n        case 0:\n          source = this.numberValueOf(params.sourceValue);\n          break;\n        case 1:\n          start = this.numberValueOf(params.sourceRandom.start);\n          end = this.numberValueOf(params.sourceRandom.end);\n          diff = end - start;\n          source = Math.floor(start + Math.random() * (diff + 1));\n          break;\n        case 2:\n          source = this.numberValueAtIndex(params.sourceScope, this.numberValueOf(params.sourceReference) - 1, params.sourceReferenceDomain);\n          break;\n        case 3:\n          source = this.numberValueOfGameData(params.sourceValue1);\n          break;\n        case 4:\n          source = this.numberValueOfDatabaseData(params.sourceValue1);\n      }\n      switch (params.target) {\n        case 0:\n          switch (params.operation) {\n            case 0:\n              this.setNumberValueTo(params.targetVariable, roundFunc(source));\n              break;\n            case 1:\n              this.setNumberValueTo(params.targetVariable, roundFunc(this.numberValueOf(params.targetVariable) + source));\n              break;\n            case 2:\n              this.setNumberValueTo(params.targetVariable, roundFunc(this.numberValueOf(params.targetVariable) - source));\n              break;\n            case 3:\n              this.setNumberValueTo(params.targetVariable, roundFunc(this.numberValueOf(params.targetVariable) * source));\n              break;\n            case 4:\n              this.setNumberValueTo(params.targetVariable, roundFunc(this.numberValueOf(params.targetVariable) / source));\n              break;\n            case 5:\n              this.setNumberValueTo(params.targetVariable, this.numberValueOf(params.targetVariable) % source);\n          }\n          break;\n        case 1:\n          scope = params.targetScope;\n          start = params.targetRange.start - 1;\n          end = params.targetRange.end - 1;\n          for (i = k = ref = start, ref1 = end; ref <= ref1 ? k <= ref1 : k >= ref1; i = ref <= ref1 ? ++k : --k) {\n            switch (params.operation) {\n              case 0:\n                this.setNumberValueAtIndex(scope, i, roundFunc(source));\n                break;\n              case 1:\n                this.setNumberValueAtIndex(scope, i, roundFunc(this.numberValueAtIndex(scope, i) + source));\n                break;\n              case 2:\n                this.setNumberValueAtIndex(scope, i, roundFunc(this.numberValueAtIndex(scope, i) - source));\n                break;\n              case 3:\n                this.setNumberValueAtIndex(scope, i, roundFunc(this.numberValueAtIndex(scope, i) * source));\n                break;\n              case 4:\n                this.setNumberValueAtIndex(scope, i, roundFunc(this.numberValueAtIndex(scope, i) / source));\n                break;\n              case 5:\n                this.setNumberValueAtIndex(scope, i, this.numberValueAtIndex(scope, i) % source);\n            }\n          }\n          break;\n        case 2:\n          index = this.numberValueOf(params.targetReference) - 1;\n          switch (params.operation) {\n            case 0:\n              this.setNumberValueAtIndex(params.targetScope, index, roundFunc(source), params.targetReferenceDomain);\n              break;\n            case 1:\n              this.setNumberValueAtIndex(params.targetScope, index, roundFunc(this.numberValueAtIndex(params.targetScope, index, params.targetReferenceDomain) + source), params.targetReferenceDomain);\n              break;\n            case 2:\n              this.setNumberValueAtIndex(params.targetScope, index, roundFunc(this.numberValueAtIndex(params.targetScope, index, params.targetReferenceDomain) - source), params.targetReferenceDomain);\n              break;\n            case 3:\n              this.setNumberValueAtIndex(params.targetScope, index, roundFunc(this.numberValueAtIndex(params.targetScope, index, params.targetReferenceDomain) * source), params.targetReferenceDomain);\n              break;\n            case 4:\n              this.setNumberValueAtIndex(params.targetScope, index, roundFunc(this.numberValueAtIndex(params.targetScope, index, params.targetReferenceDomain) / source), params.targetReferenceDomain);\n              break;\n            case 5:\n              this.setNumberValueAtIndex(params.targetScope, index, this.numberValueAtIndex(params.targetScope, index, params.targetReferenceDomain) % source, params.targetReferenceDomain);\n          }\n      }\n      return null;\n    };\n\n\n    /**\n    * Shakes a game object.\n    *\n    * @method shakeObject\n    * @param {gs.Object_Base} object - The game object to shake.\n    * @return {Object} A params object containing additional info about the shake-animation.\n     */\n\n    Component_CommandInterpreter.prototype.shakeObject = function(object, params) {\n      var duration, easing;\n      duration = Math.max(Math.round(this.durationValueOf(params.duration)), 2);\n      easing = gs.Easings.fromObject(params.easing);\n      object.animator.shake({\n        x: this.numberValueOf(params.range.x),\n        y: this.numberValueOf(params.range.y)\n      }, this.numberValueOf(params.speed) / 100, duration, easing);\n      if (params.waitForCompletion && !(duration === 0 || this.isInstantSkip())) {\n        this.isWaiting = true;\n        return this.waitCounter = duration;\n      }\n    };\n\n\n    /**\n    * Lets the interpreter wait for the completion of a running operation like an animation, etc.\n    *\n    * @method waitForCompletion\n    * @param {gs.Object_Base} object - The game object the operation is executed on. Can be <b>null</b>.\n    * @return {Object} A params object containing additional info.\n     */\n\n    Component_CommandInterpreter.prototype.waitForCompletion = function(object, params) {\n      var duration;\n      duration = this.durationValueOf(params.duration);\n      if (params.waitForCompletion && !(duration === 0 || this.isInstantSkip())) {\n        this.isWaiting = true;\n        return this.waitCounter = duration;\n      }\n    };\n\n\n    /**\n    * Erases a game object.\n    *\n    * @method eraseObject\n    * @param {gs.Object_Base} object - The game object to erase.\n    * @return {Object} A params object containing additional info.\n     */\n\n    Component_CommandInterpreter.prototype.eraseObject = function(object, params, callback) {\n      var duration, easing;\n      easing = gs.Easings.fromObject(params.easing);\n      duration = this.durationValueOf(params.duration);\n      object.animator.disappear(params.animation, easing, duration, (function(_this) {\n        return function(sender) {\n          sender.dispose();\n          return typeof callback === \"function\" ? callback(sender) : void 0;\n        };\n      })(this));\n      if (params.waitForCompletion && !(duration === 0 || this.isInstantSkip())) {\n        this.isWaiting = true;\n        return this.waitCounter = duration;\n      }\n    };\n\n\n    /**\n    * Shows a game object on screen.\n    *\n    * @method showObject\n    * @param {gs.Object_Base} object - The game object to show.\n    * @param {gs.Point} position - The position where the game object should be shown.\n    * @param {Object} A params object containing additional info.\n     */\n\n    Component_CommandInterpreter.prototype.showObject = function(object, position, params) {\n      var duration, easing, x, y;\n      x = this.numberValueOf(position.x);\n      y = this.numberValueOf(position.y);\n      easing = gs.Easings.fromObject(params.easing);\n      duration = this.durationValueOf(params.duration);\n      object.animator.appear(x, y, params.animation, easing, duration);\n      if (params.waitForCompletion && !(duration === 0 || this.isInstantSkip())) {\n        this.isWaiting = true;\n        return this.waitCounter = duration;\n      }\n    };\n\n\n    /**\n    * Moves a game object.\n    *\n    * @method moveObject\n    * @param {gs.Object_Base} object - The game object to move.\n    * @param {gs.Point} position - The position to move the game object to.\n    * @param {Object} A params object containing additional info.\n     */\n\n    Component_CommandInterpreter.prototype.moveObject = function(object, position, params) {\n      var bitmap, duration, easing, p, x, y, zoom;\n      if (params.positionType === 0) {\n        p = this.predefinedObjectPosition(params.predefinedPositionId, object, params);\n        x = p.x;\n        y = p.y;\n      } else {\n        x = this.numberValueOf(position.x);\n        y = this.numberValueOf(position.y);\n      }\n      easing = gs.Easings.fromObject(params.easing);\n      duration = this.durationValueOf(params.duration);\n      zoom = object.zoom;\n      if (object.anchor.x !== 0 && object.anchor.y !== 0) {\n        bitmap = object.bitmap;\n        if (bitmap != null) {\n          x += (bitmap.width * zoom.x - bitmap.width) * object.anchor.x;\n          y += (bitmap.height * zoom.y - bitmap.height) * object.anchor.y;\n        }\n      }\n      object.animator.moveTo(x, y, duration, easing);\n      if (params.waitForCompletion && !(duration === 0 || this.isInstantSkip())) {\n        this.isWaiting = true;\n        return this.waitCounter = duration;\n      }\n    };\n\n\n    /**\n    * Moves a game object along a path.\n    *\n    * @method moveObjectPath\n    * @param {gs.Object_Base} object - The game object to move.\n    * @param {Object} path - The path to move the game object along.\n    * @param {Object} A params object containing additional info.\n     */\n\n    Component_CommandInterpreter.prototype.moveObjectPath = function(object, path, params) {\n      var duration, easing, ref;\n      easing = gs.Easings.fromObject(params.easing);\n      duration = this.durationValueOf(params.duration);\n      object.animator.movePath(path.data, params.loopType, duration, easing, (ref = path.effects) != null ? ref.data : void 0);\n      if (params.waitForCompletion && !(duration === 0 || this.isInstantSkip())) {\n        this.isWaiting = true;\n        return this.waitCounter = duration;\n      }\n    };\n\n\n    /**\n    * Scrolls a scrollable game object along a path.\n    *\n    * @method scrollObjectPath\n    * @param {gs.Object_Base} object - The game object to scroll.\n    * @param {Object} path - The path to scroll the game object along.\n    * @param {Object} A params object containing additional info.\n     */\n\n    Component_CommandInterpreter.prototype.scrollObjectPath = function(object, path, params) {\n      var duration, easing;\n      easing = gs.Easings.fromObject(params.easing);\n      duration = this.durationValueOf(params.duration);\n      object.animator.scrollPath(path, params.loopType, duration, easing);\n      if (params.waitForCompletion && !(duration === 0 || this.isInstantSkip())) {\n        this.isWaiting = true;\n        return this.waitCounter = duration;\n      }\n    };\n\n\n    /**\n    * Zooms/Scales a game object.\n    *\n    * @method zoomObject\n    * @param {gs.Object_Base} object - The game object to zoom.\n    * @param {Object} A params object containing additional info.\n     */\n\n    Component_CommandInterpreter.prototype.zoomObject = function(object, params) {\n      var duration, easing;\n      easing = gs.Easings.fromObject(params.easing);\n      duration = this.durationValueOf(params.duration);\n      object.animator.zoomTo(this.numberValueOf(params.zooming.x) / 100, this.numberValueOf(params.zooming.y) / 100, duration, easing);\n      if (params.waitForCompletion && !(duration === 0 || this.isInstantSkip())) {\n        this.isWaiting = true;\n        return this.waitCounter = duration;\n      }\n    };\n\n\n    /**\n    * Rotates a game object.\n    *\n    * @method rotateObject\n    * @param {gs.Object_Base} object - The game object to rotate.\n    * @param {Object} A params object containing additional info.\n     */\n\n    Component_CommandInterpreter.prototype.rotateObject = function(object, params) {\n      var duration, easing;\n      easing = gs.Easings.fromObject(params.easing);\n      duration = this.durationValueOf(params.duration);\n      easing = gs.Easings.fromObject(params.easing);\n      object.animator.rotate(params.direction, this.numberValueOf(params.speed) / 100, duration, easing);\n      if (params.waitForCompletion && !(duration === 0 || this.isInstantSkip())) {\n        this.isWaiting = true;\n        return this.waitCounter = duration;\n      }\n    };\n\n\n    /**\n    * Blends a game object.\n    *\n    * @method blendObject\n    * @param {gs.Object_Base} object - The game object to blend.\n    * @param {Object} A params object containing additional info.\n     */\n\n    Component_CommandInterpreter.prototype.blendObject = function(object, params) {\n      var duration, easing;\n      easing = gs.Easings.fromObject(params.easing);\n      duration = this.durationValueOf(params.duration);\n      object.animator.blendTo(this.numberValueOf(params.opacity), duration, easing);\n      if (params.waitForCompletion && !(duration === 0 || this.isInstantSkip())) {\n        this.isWaiting = true;\n        return this.waitCounter = duration;\n      }\n    };\n\n\n    /**\n    * Executes a masking-effect on a game object..\n    *\n    * @method maskObject\n    * @param {gs.Object_Base} object - The game object to execute a masking-effect on.\n    * @param {Object} A params object containing additional info.\n     */\n\n    Component_CommandInterpreter.prototype.maskObject = function(object, params) {\n      var duration, easing, mask, ref, ref1, ref2;\n      easing = gs.Easings.fromObject(params.easing);\n      if (params.mask.type === 0) {\n        object.mask.type = 0;\n        object.mask.ox = this.numberValueOf(params.mask.ox);\n        object.mask.oy = this.numberValueOf(params.mask.oy);\n        if (((ref = object.mask.source) != null ? ref.videoElement : void 0) != null) {\n          object.mask.source.pause();\n        }\n        if (params.mask.sourceType === 0) {\n          object.mask.source = ResourceManager.getBitmap(\"Graphics/Masks/\" + ((ref1 = params.mask.graphic) != null ? ref1.name : void 0));\n        } else {\n          object.mask.source = ResourceManager.getVideo(\"Movies/\" + ((ref2 = params.mask.video) != null ? ref2.name : void 0));\n          if (object.mask.source) {\n            object.mask.source.play();\n            object.mask.source.loop = true;\n          }\n        }\n      } else {\n        duration = this.durationValueOf(params.duration);\n        mask = Object.flatCopy(params.mask);\n        mask.value = this.numberValueOf(mask.value);\n        object.animator.maskTo(mask, duration, easing);\n      }\n      if (params.waitForCompletion && !(duration === 0 || this.isInstantSkip())) {\n        this.isWaiting = true;\n        return this.waitCounter = duration;\n      }\n    };\n\n\n    /**\n    * Tints a game object.\n    *\n    * @method tintObject\n    * @param {gs.Object_Base} object - The game object to tint.\n    * @param {Object} A params object containing additional info.\n     */\n\n    Component_CommandInterpreter.prototype.tintObject = function(object, params) {\n      var duration, easing;\n      duration = this.durationValueOf(params.duration);\n      easing = gs.Easings.fromObject(params.easing);\n      object.animator.tintTo(params.tone, duration, easing);\n      if (params.waitForCompletion && !(duration === 0 || this.isInstantSkip())) {\n        this.isWaiting = true;\n        return this.waitCounter = duration;\n      }\n    };\n\n\n    /**\n    * Flashes a game object.\n    *\n    * @method flashObject\n    * @param {gs.Object_Base} object - The game object to flash.\n    * @param {Object} A params object containing additional info.\n     */\n\n    Component_CommandInterpreter.prototype.flashObject = function(object, params) {\n      var duration;\n      duration = this.durationValueOf(params.duration);\n      object.animator.flash(new Color(params.color), duration);\n      if (params.waitForCompletion && !(duration === 0 || this.isInstantSkip())) {\n        this.isWaiting = true;\n        return this.waitCounter = duration;\n      }\n    };\n\n\n    /**\n    * Cropes a game object.\n    *\n    * @method cropObject\n    * @param {gs.Object_Base} object - The game object to crop.\n    * @param {Object} A params object containing additional info.\n     */\n\n    Component_CommandInterpreter.prototype.cropObject = function(object, params) {\n      object.srcRect.x = this.numberValueOf(params.x);\n      object.srcRect.y = this.numberValueOf(params.y);\n      object.srcRect.width = this.numberValueOf(params.width);\n      object.srcRect.height = this.numberValueOf(params.height);\n      object.dstRect.width = this.numberValueOf(params.width);\n      return object.dstRect.height = this.numberValueOf(params.height);\n    };\n\n\n    /**\n    * Sets the motion blur settings of a game object.\n    *\n    * @method objectMotionBlur\n    * @param {gs.Object_Base} object - The game object to set the motion blur settings for.\n    * @param {Object} A params object containing additional info.\n     */\n\n    Component_CommandInterpreter.prototype.objectMotionBlur = function(object, params) {\n      return object.motionBlur.set(params.motionBlur);\n    };\n\n\n    /**\n    * Enables an effect on a game object.\n    *\n    * @method objectEffect\n    * @param {gs.Object_Base} object - The game object to execute a masking-effect on.\n    * @param {Object} A params object containing additional info.\n     */\n\n    Component_CommandInterpreter.prototype.objectEffect = function(object, params) {\n      var duration, easing, wobble;\n      duration = this.durationValueOf(params.duration);\n      easing = gs.Easings.fromObject(params.easing);\n      switch (params.type) {\n        case 0:\n          object.animator.wobbleTo(params.wobble.power / 10000, params.wobble.speed / 100, duration, easing);\n          wobble = object.effects.wobble;\n          wobble.enabled = params.wobble.power > 0;\n          wobble.vertical = params.wobble.orientation === 0 || params.wobble.orientation === 2;\n          wobble.horizontal = params.wobble.orientation === 1 || params.wobble.orientation === 2;\n          break;\n        case 1:\n          object.animator.blurTo(params.blur.power / 100, duration, easing);\n          object.effects.blur.enabled = true;\n          break;\n        case 2:\n          object.animator.pixelateTo(params.pixelate.size.width, params.pixelate.size.height, duration, easing);\n          object.effects.pixelate.enabled = true;\n      }\n      if (params.waitForCompletion && duration !== 0) {\n        this.isWaiting = true;\n        return this.waitCounter = duration;\n      }\n    };\n\n\n    /**\n    * Executes an action like for a hotspot.\n    *\n    * @method executeAction\n    * @param {Object} action - Action-Data.\n    * @param {boolean} stateValue - In case of switch-binding, the switch is set to this value.\n    * @param {number} bindValue - A number value which be put into the action's bind-value variable.\n     */\n\n    Component_CommandInterpreter.prototype.executeAction = function(action, stateValue, bindValue) {\n      var domain, ref;\n      switch (action.type) {\n        case 0:\n          if (action.labelIndex) {\n            return this.pointer = action.labelIndex;\n          } else {\n            return this.jumpToLabel(action.label);\n          }\n          break;\n        case 1:\n          return this.callCommonEvent(action.commonEventId, null, this.isWaiting);\n        case 2:\n          domain = GameManager.variableStore.domain;\n          return this.setBooleanValueTo(action[\"switch\"], stateValue);\n        case 3:\n          return this.callScene((ref = action.scene) != null ? ref.uid : void 0);\n        case 4:\n          domain = GameManager.variableStore.domain;\n          this.setNumberValueTo(action.bindValueVariable, bindValue);\n          if (action.labelIndex) {\n            return this.pointer = action.labelIndex;\n          } else {\n            return this.jumpToLabel(action.label);\n          }\n      }\n    };\n\n\n    /**\n    * Calls a common event and returns the sub-interpreter for it.\n    *\n    * @method callCommonEvent\n    * @param {number} id - The ID of the common event to call.\n    * @param {Object} parameters - Optional common event parameters.\n    * @param {boolean} wait - Indicates if the interpreter should be stay in waiting-mode even if the sub-interpreter is finished.\n     */\n\n    Component_CommandInterpreter.prototype.callCommonEvent = function(id, parameters, wait) {\n      var commonEvent, ref;\n      commonEvent = GameManager.commonEvents[id];\n      if (commonEvent != null) {\n        if (SceneManager.scene.commonEventContainer.subObjects.indexOf(commonEvent) === -1) {\n          SceneManager.scene.commonEventContainer.addObject(commonEvent);\n        }\n        if ((ref = commonEvent.events) != null) {\n          ref.on(\"finish\", gs.CallBack(\"onCommonEventFinish\", this), {\n            waiting: wait\n          });\n        }\n        this.subInterpreter = commonEvent.behavior.call(parameters || [], this.settings, this.context);\n        commonEvent.behavior.update();\n        if (this.subInterpreter != null) {\n          this.isWaiting = true;\n          this.subInterpreter.settings = this.settings;\n          this.subInterpreter.start();\n          return this.subInterpreter.update();\n        }\n      }\n    };\n\n\n    /**\n    * Calls a scene and returns the sub-interpreter for it.\n    *\n    * @method callScene\n    * @param {String} uid - The UID of the scene to call.\n     */\n\n    Component_CommandInterpreter.prototype.callScene = function(uid) {\n      var object, sceneDocument;\n      sceneDocument = DataManager.getDocument(uid);\n      if (sceneDocument != null) {\n        this.isWaiting = true;\n        this.subInterpreter = new vn.Component_CallSceneInterpreter();\n        object = {\n          commands: sceneDocument.items.commands\n        };\n        this.subInterpreter.repeat = false;\n        this.subInterpreter.context.set(sceneDocument.uid, sceneDocument);\n        this.subInterpreter.object = object;\n        this.subInterpreter.onFinish = gs.CallBack(\"onCallSceneFinish\", this);\n        this.subInterpreter.start();\n        this.subInterpreter.settings = this.settings;\n        return this.subInterpreter.update();\n      }\n    };\n\n\n    /**\n    * Calls a common event and returns the sub-interpreter for it.\n    *\n    * @method storeListValue\n    * @param {number} id - The ID of the common event to call.\n    * @param {Object} parameters - Optional common event parameters.\n    * @param {boolean} wait - Indicates if the interpreter should be stay in waiting-mode even if the sub-interpreter is finished.\n     */\n\n    Component_CommandInterpreter.prototype.storeListValue = function(variable, list, value, valueType) {\n      switch (valueType) {\n        case 0:\n          return this.setNumberValueTo(variable, (!isNaN(value) ? value : 0));\n        case 1:\n          return this.setBooleanValueTo(variable, (value ? 1 : 0));\n        case 2:\n          return this.setStringValueTo(variable, value.toString());\n        case 3:\n          return this.setListObjectTo(variable, (value.length != null ? value : []));\n      }\n    };\n\n\n    /**\n    * @method jumpToLabel\n     */\n\n    Component_CommandInterpreter.prototype.jumpToLabel = function(label) {\n      var found, i, k, ref;\n      if (!label) {\n        return;\n      }\n      found = false;\n      for (i = k = 0, ref = this.object.commands.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n        if (this.object.commands[i].id === \"gs.Label\" && this.object.commands[i].params.name === label) {\n          this.pointer = i;\n          this.indent = this.object.commands[i].indent;\n          found = true;\n          break;\n        }\n      }\n      if (found) {\n        this.waitCounter = 0;\n        return this.isWaiting = false;\n      }\n    };\n\n\n    /**\n    * Gets the current message box object depending on game mode (ADV or NVL).\n    *\n    * @method messageBoxObject\n    * @return {gs.Object_Base} The message box object.\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.messageBoxObject = function(id) {\n      if (SceneManager.scene.layout.visible) {\n        return gs.ObjectManager.current.objectById(id || \"messageBox\");\n      } else {\n        return gs.ObjectManager.current.objectById(id || \"nvlMessageBox\");\n      }\n    };\n\n\n    /**\n    * Gets the current message object depending on game mode (ADV or NVL).\n    *\n    * @method messageObject\n    * @return {ui.Object_Message} The message object.\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.messageObject = function() {\n      if (SceneManager.scene.layout.visible) {\n        return gs.ObjectManager.current.objectById(\"gameMessage_message\");\n      } else {\n        return gs.ObjectManager.current.objectById(\"nvlGameMessage_message\");\n      }\n    };\n\n\n    /**\n    * Gets the current message ID depending on game mode (ADV or NVL).\n    *\n    * @method messageObjectId\n    * @return {string} The message object ID.\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.messageObjectId = function() {\n      if (SceneManager.scene.layout.visible) {\n        return \"gameMessage_message\";\n      } else {\n        return \"nvlGameMessage_message\";\n      }\n    };\n\n\n    /**\n    * Gets the current message settings.\n    *\n    * @method messageSettings\n    * @return {Object} The message settings\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.messageSettings = function() {\n      var message;\n      message = this.targetMessage();\n      return message.settings;\n    };\n\n\n    /**\n    * Gets the current target message object where all message commands are executed on.\n    *\n    * @method targetMessage\n    * @return {ui.Object_Message} The target message object.\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.targetMessage = function() {\n      var message, ref, ref1, ref2, target;\n      message = this.messageObject();\n      target = this.settings.message.target;\n      if (target != null) {\n        switch (target.type) {\n          case 0:\n            message = (ref = gs.ObjectManager.current.objectById(target.id)) != null ? ref : this.messageObject();\n            break;\n          case 1:\n            message = (ref1 = (ref2 = SceneManager.scene.messageAreas[target.id]) != null ? ref2.message : void 0) != null ? ref1 : this.messageObject();\n        }\n      }\n      return message;\n    };\n\n\n    /**\n    * Gets the current target message box containing the current target message.\n    *\n    * @method targetMessageBox\n    * @return {ui.Object_UIElement} The target message box.\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.targetMessageBox = function() {\n      var messageBox, ref, ref1, target;\n      messageBox = this.messageObject();\n      target = this.settings.message.target;\n      if (target != null) {\n        switch (target.type) {\n          case 0:\n            messageBox = (ref = gs.ObjectManager.current.objectById(target.id)) != null ? ref : this.messageObject();\n            break;\n          case 1:\n            messageBox = (ref1 = gs.ObjectManager.current.objectById(\"customGameMessage_\" + target.id)) != null ? ref1 : this.messageObject();\n        }\n      }\n      return messageBox;\n    };\n\n\n    /**\n    * Called after an input number dialog was accepted by the user. It takes the user's input and puts\n    * it in the configured number variable.\n    *\n    * @method onInputNumberFinish\n    * @return {Object} Event Object containing additional data like the number, etc.\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.onInputNumberFinish = function(e) {\n      this.messageObject().behavior.clear();\n      this.setNumberValueTo(this.waitingFor.inputNumber.variable, parseInt(ui.Component_FormulaHandler.fieldValue(e.sender, e.number)));\n      this.isWaiting = false;\n      this.waitingFor.inputNumber = null;\n      return SceneManager.scene.inputNumberBox.dispose();\n    };\n\n\n    /**\n    * Called after an input text dialog was accepted by the user. It takes the user's text input and puts\n    * it in the configured string variable.\n    *\n    * @method onInputTextFinish\n    * @return {Object} Event Object containing additional data like the text, etc.\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.onInputTextFinish = function(e) {\n      this.messageObject().behavior.clear();\n      this.setStringValueTo(this.waitingFor.inputText.variable, ui.Component_FormulaHandler.fieldValue(e.sender, e.text).replace(/_/g, \"\"));\n      this.isWaiting = false;\n      this.waitingFor.inputText = null;\n      return SceneManager.scene.inputTextBox.dispose();\n    };\n\n\n    /**\n    * Called after a choice was selected by the user. It jumps to the corresponding label\n    * and also puts the choice into backlog.\n    *\n    * @method onChoiceAccept\n    * @return {Object} Event Object containing additional data like the label, etc.\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.onChoiceAccept = function(e) {\n      var duration, fading, messageObject, scene;\n      scene = SceneManager.scene;\n      scene.choiceTimer.behavior.stop();\n      e.isSelected = true;\n      delete e.sender;\n      GameManager.backlog.push({\n        character: {\n          name: \"\"\n        },\n        message: \"\",\n        choice: e,\n        choices: scene.choices,\n        isChoice: true\n      });\n      scene.choices = [];\n      messageObject = this.messageObject();\n      if (messageObject != null ? messageObject.visible : void 0) {\n        this.isWaiting = true;\n        fading = GameManager.tempSettings.messageFading;\n        duration = GameManager.tempSettings.skip ? 0 : fading.duration;\n        messageObject.animator.disappear(fading.animation, fading.easing, duration, (function(_this) {\n          return function() {\n            messageObject.behavior.clear();\n            messageObject.visible = false;\n            _this.isWaiting = false;\n            _this.waitingFor.choice = null;\n            return _this.executeAction(e.action, true);\n          };\n        })(this));\n      } else {\n        this.isWaiting = false;\n        this.executeAction(e.action, true);\n      }\n      return scene.choiceWindow.dispose();\n    };\n\n\n    /**\n    * Idle\n    * @method commandIdle\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandIdle = function() {\n      return this.interpreter.isWaiting = !this.interpreter.isInstantSkip();\n    };\n\n\n    /**\n    * Start Timer\n    * @method commandStartTimer\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandStartTimer = function() {\n      var number, scene, timer, timers;\n      scene = SceneManager.scene;\n      timers = scene.timers;\n      number = this.interpreter.numberValueOf(this.params.number);\n      timer = timers[number];\n      if (timer == null) {\n        timer = new gs.Object_IntervalTimer();\n        timers[number] = timer;\n      }\n      timer.events.offByOwner(\"elapsed\", this.object);\n      timer.events.on(\"elapsed\", (function(_this) {\n        return function(e) {\n          var params;\n          params = e.data.params;\n          switch (params.action.type) {\n            case 0:\n              if (params.labelIndex != null) {\n                return SceneManager.scene.interpreter.pointer = params.labelIndex;\n              } else {\n                return SceneManager.scene.interpreter.jumpToLabel(params.action.data.label);\n              }\n              break;\n            case 1:\n              return SceneManager.scene.interpreter.callCommonEvent(params.action.data.commonEventId, null, _this.interpreter.isWaiting);\n          }\n        };\n      })(this), {\n        params: this.params\n      }, this.object);\n      timer.behavior.interval = this.interpreter.durationValueOf(this.params.interval);\n      return timer.behavior.start();\n    };\n\n\n    /**\n    * Resume Timer\n    * @method commandResumeTimer\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandResumeTimer = function() {\n      var number, ref, timers;\n      timers = SceneManager.scene.timers;\n      number = this.interpreter.numberValueOf(this.params.number);\n      return (ref = timers[number]) != null ? ref.behavior.resume() : void 0;\n    };\n\n\n    /**\n    * Pauses Timer\n    * @method commandPauseTimer\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandPauseTimer = function() {\n      var number, ref, timers;\n      timers = SceneManager.scene.timers;\n      number = this.interpreter.numberValueOf(this.params.number);\n      return (ref = timers[number]) != null ? ref.behavior.pause() : void 0;\n    };\n\n\n    /**\n    * Stop Timer\n    * @method commandStopTimer\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandStopTimer = function() {\n      var number, ref, timers;\n      timers = SceneManager.scene.timers;\n      number = this.interpreter.numberValueOf(this.params.number);\n      return (ref = timers[number]) != null ? ref.behavior.stop() : void 0;\n    };\n\n\n    /**\n    * Wait\n    * @method commandWait\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandWait = function() {\n      var time;\n      time = this.interpreter.durationValueOf(this.params.time);\n      if ((time != null) && time > 0 && !this.interpreter.previewData) {\n        this.interpreter.waitCounter = time;\n        return this.interpreter.isWaiting = true;\n      }\n    };\n\n\n    /**\n    * Loop\n    * @method commandLoop\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandLoop = function() {\n      this.interpreter.loops[this.interpreter.indent] = this.interpreter.pointer;\n      return this.interpreter.indent++;\n    };\n\n\n    /**\n    * Break Loop\n    * @method commandBreakLoop\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandBreakLoop = function() {\n      var indent;\n      indent = this.indent;\n      while ((this.interpreter.loops[indent] == null) && indent > 0) {\n        indent--;\n      }\n      this.interpreter.loops[indent] = null;\n      return this.interpreter.indent = indent;\n    };\n\n\n    /**\n    * @method commandListAdd\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandListAdd = function() {\n      var list;\n      list = this.interpreter.listObjectOf(this.params.listVariable);\n      switch (this.params.valueType) {\n        case 0:\n          list.push(this.interpreter.numberValueOf(this.params.numberValue));\n          break;\n        case 1:\n          list.push(this.interpreter.booleanValueOf(this.params.switchValue));\n          break;\n        case 2:\n          list.push(this.interpreter.stringValueOf(this.params.stringValue));\n          break;\n        case 3:\n          list.push(this.interpreter.listObjectOf(this.params.listValue));\n      }\n      return this.interpreter.setListObjectTo(this.params.listVariable, list);\n    };\n\n\n    /**\n    * @method commandListPop\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandListPop = function() {\n      var list, ref, value;\n      list = this.interpreter.listObjectOf(this.params.listVariable);\n      value = (ref = list.pop()) != null ? ref : 0;\n      return this.interpreter.storeListValue(this.params.targetVariable, list, value, this.params.valueType);\n    };\n\n\n    /**\n    * @method commandListShift\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandListShift = function() {\n      var list, ref, value;\n      list = this.interpreter.listObjectOf(this.params.listVariable);\n      value = (ref = list.shift()) != null ? ref : 0;\n      return this.interpreter.storeListValue(this.params.targetVariable, list, value, this.params.valueType);\n    };\n\n\n    /**\n    * @method commandListIndexOf\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandListIndexOf = function() {\n      var list, value;\n      list = this.interpreter.listObjectOf(this.params.listVariable);\n      value = -1;\n      switch (this.params.valueType) {\n        case 0:\n          value = list.indexOf(this.interpreter.numberValueOf(this.params.numberValue));\n          break;\n        case 1:\n          value = list.indexOf(this.interpreter.booleanValueOf(this.params.switchValue));\n          break;\n        case 2:\n          value = list.indexOf(this.interpreter.stringValueOf(this.params.stringValue));\n          break;\n        case 3:\n          value = list.indexOf(this.interpreter.listObjectOf(this.params.listValue));\n      }\n      return this.interpreter.setNumberValueTo(this.params.targetVariable, value);\n    };\n\n\n    /**\n    * @method commandListClear\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandListClear = function() {\n      var list;\n      list = this.interpreter.listObjectOf(this.params.listVariable);\n      return list.length = 0;\n    };\n\n\n    /**\n    * @method commandListValueAt\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandListValueAt = function() {\n      var index, list, ref, value;\n      list = this.interpreter.listObjectOf(this.params.listVariable);\n      index = this.interpreter.numberValueOf(this.params.index);\n      if (index >= 0 && index < list.length) {\n        value = (ref = list[index]) != null ? ref : 0;\n        return this.interpreter.storeListValue(this.params.targetVariable, list, value, this.params.valueType);\n      }\n    };\n\n\n    /**\n    * @method commandListRemoveAt\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandListRemoveAt = function() {\n      var index, list;\n      list = this.interpreter.listObjectOf(this.params.listVariable);\n      index = this.interpreter.numberValueOf(this.params.index);\n      if (index >= 0 && index < list.length) {\n        return list.splice(index, 1);\n      }\n    };\n\n\n    /**\n    * @method commandListInsertAt\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandListInsertAt = function() {\n      var index, list;\n      list = this.interpreter.listObjectOf(this.params.listVariable);\n      index = this.interpreter.numberValueOf(this.params.index);\n      if (index >= 0 && index < list.length) {\n        switch (this.params.valueType) {\n          case 0:\n            list.splice(index, 0, this.interpreter.numberValueOf(this.params.numberValue));\n            break;\n          case 1:\n            list.splice(index, 0, this.interpreter.booleanValueOf(this.params.switchValue));\n            break;\n          case 2:\n            list.splice(index, 0, this.interpreter.stringValueOf(this.params.stringValue));\n            break;\n          case 3:\n            list.splice(index, 0, this.interpreter.listObjectOf(this.params.listValue));\n        }\n        return this.interpreter.setListObjectTo(this.params.listVariable, list);\n      }\n    };\n\n\n    /**\n    * @method commandListSet\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandListSet = function() {\n      var index, list;\n      list = this.interpreter.listObjectOf(this.params.listVariable);\n      index = this.interpreter.numberValueOf(this.params.index);\n      if (index >= 0) {\n        switch (this.params.valueType) {\n          case 0:\n            list[index] = this.interpreter.numberValueOf(this.params.numberValue);\n            break;\n          case 1:\n            list[index] = this.interpreter.booleanValueOf(this.params.switchValue);\n            break;\n          case 2:\n            list[index] = this.interpreter.stringValueOf(this.params.stringValue);\n            break;\n          case 3:\n            list[index] = this.interpreter.listObjectOf(this.params.listValue);\n        }\n        return this.interpreter.setListObjectTo(this.params.listVariable, list);\n      }\n    };\n\n\n    /**\n    * @method commandListCopy\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandListCopy = function() {\n      var copy, list;\n      list = this.interpreter.listObjectOf(this.params.listVariable);\n      copy = Object.deepCopy(list);\n      return this.interpreter.setListObjectTo(this.params.targetVariable, copy);\n    };\n\n\n    /**\n    * @method commandListLength\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandListLength = function() {\n      var list;\n      list = this.interpreter.listObjectOf(this.params.listVariable);\n      return this.interpreter.setNumberValueTo(this.params.targetVariable, list.length);\n    };\n\n\n    /**\n    * @method commandListJoin\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandListJoin = function() {\n      var list, value;\n      list = this.interpreter.listObjectOf(this.params.listVariable);\n      value = this.params.order === 0 ? list.join(this.params.separator || \"\") : list.reverse().join(this.params.separator || \"\");\n      return this.interpreter.setStringValueTo(this.params.targetVariable, value);\n    };\n\n\n    /**\n    * @method commandListFromText\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandListFromText = function() {\n      var list, separator, text;\n      text = this.interpreter.stringValueOf(this.params.textVariable);\n      separator = this.interpreter.stringValueOf(this.params.separator);\n      list = text.split(separator);\n      return this.interpreter.setListObjectTo(this.params.targetVariable, list);\n    };\n\n\n    /**\n    * @method commandListShuffle\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandListShuffle = function() {\n      var i, j, k, list, ref, results, tempi, tempj;\n      list = this.interpreter.listObjectOf(this.params.listVariable);\n      if (list.length === 0) {\n        return;\n      }\n      results = [];\n      for (i = k = ref = list.length - 1; ref <= 1 ? k <= 1 : k >= 1; i = ref <= 1 ? ++k : --k) {\n        j = Math.floor(Math.random() * (i + 1));\n        tempi = list[i];\n        tempj = list[j];\n        list[i] = tempj;\n        results.push(list[j] = tempi);\n      }\n      return results;\n    };\n\n\n    /**\n    * @method commandListSort\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandListSort = function() {\n      var list;\n      list = this.interpreter.listObjectOf(this.params.listVariable);\n      if (list.length === 0) {\n        return;\n      }\n      switch (this.params.sortOrder) {\n        case 0:\n          return list.sort(function(a, b) {\n            if (a < b) {\n              return -1;\n            }\n            if (a > b) {\n              return 1;\n            }\n            return 0;\n          });\n        case 1:\n          return list.sort(function(a, b) {\n            if (a > b) {\n              return -1;\n            }\n            if (a < b) {\n              return 1;\n            }\n            return 0;\n          });\n      }\n    };\n\n\n    /**\n    * @method commandResetVariables\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandResetVariables = function() {\n      var range;\n      switch (this.params.target) {\n        case 0:\n          range = null;\n          break;\n        case 1:\n          range = this.params.range;\n      }\n      switch (this.params.scope) {\n        case 0:\n          if (this.params.scene) {\n            return GameManager.variableStore.clearLocalVariables({\n              id: this.params.scene.uid\n            }, this.params.type, range);\n          }\n          break;\n        case 1:\n          return GameManager.variableStore.clearLocalVariables(null, this.params.type, range);\n        case 2:\n          return GameManager.variableStore.clearGlobalVariables(this.params.type, range);\n        case 3:\n          GameManager.variableStore.clearPersistentVariables(this.params.type, range);\n          return GameManager.saveGlobalData();\n      }\n    };\n\n\n    /**\n    * @method commandChangeVariableDomain\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandChangeVariableDomain = function() {\n      return GameManager.variableStore.changeDomain(this.interpreter.stringValueOf(this.params.domain));\n    };\n\n\n    /**\n    * @method commandChangeDecimalVariables\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandChangeDecimalVariables = function() {\n      return this.interpreter.changeDecimalVariables(this.params, this.params.roundMethod);\n    };\n\n\n    /**\n    * @method commandChangeNumberVariables\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandChangeNumberVariables = function() {\n      var diff, end, i, index, k, ref, ref1, scope, source, start;\n      source = 0;\n      switch (this.params.source) {\n        case 0:\n          source = this.interpreter.numberValueOf(this.params.sourceValue);\n          break;\n        case 1:\n          start = this.interpreter.numberValueOf(this.params.sourceRandom.start);\n          end = this.interpreter.numberValueOf(this.params.sourceRandom.end);\n          diff = end - start;\n          source = Math.floor(start + Math.random() * (diff + 1));\n          break;\n        case 2:\n          source = this.interpreter.numberValueAtIndex(this.params.sourceScope, this.interpreter.numberValueOf(this.params.sourceReference) - 1, this.params.sourceReferenceDomain);\n          break;\n        case 3:\n          source = this.interpreter.numberValueOfGameData(this.params.sourceValue1);\n          break;\n        case 4:\n          source = this.interpreter.numberValueOfDatabaseData(this.params.sourceValue1);\n      }\n      switch (this.params.target) {\n        case 0:\n          switch (this.params.operation) {\n            case 0:\n              this.interpreter.setNumberValueTo(this.params.targetVariable, source);\n              break;\n            case 1:\n              this.interpreter.setNumberValueTo(this.params.targetVariable, this.interpreter.numberValueOf(this.params.targetVariable) + source);\n              break;\n            case 2:\n              this.interpreter.setNumberValueTo(this.params.targetVariable, this.interpreter.numberValueOf(this.params.targetVariable) - source);\n              break;\n            case 3:\n              this.interpreter.setNumberValueTo(this.params.targetVariable, this.interpreter.numberValueOf(this.params.targetVariable) * source);\n              break;\n            case 4:\n              this.interpreter.setNumberValueTo(this.params.targetVariable, Math.floor(this.interpreter.numberValueOf(this.params.targetVariable) / source));\n              break;\n            case 5:\n              this.interpreter.setNumberValueTo(this.params.targetVariable, this.interpreter.numberValueOf(this.params.targetVariable) % source);\n          }\n          break;\n        case 1:\n          scope = this.params.targetScope;\n          start = this.params.targetRange.start - 1;\n          end = this.params.targetRange.end - 1;\n          for (i = k = ref = start, ref1 = end; ref <= ref1 ? k <= ref1 : k >= ref1; i = ref <= ref1 ? ++k : --k) {\n            switch (this.params.operation) {\n              case 0:\n                this.interpreter.setNumberValueAtIndex(scope, i, source);\n                break;\n              case 1:\n                this.interpreter.setNumberValueAtIndex(scope, i, this.interpreter.numberValueAtIndex(scope, i) + source);\n                break;\n              case 2:\n                this.interpreter.setNumberValueAtIndex(scope, i, this.interpreter.numberValueAtIndex(scope, i) - source);\n                break;\n              case 3:\n                this.interpreter.setNumberValueAtIndex(scope, i, this.interpreter.numberValueAtIndex(scope, i) * source);\n                break;\n              case 4:\n                this.interpreter.setNumberValueAtIndex(scope, i, Math.floor(this.interpreter.numberValueAtIndex(scope, i) / source));\n                break;\n              case 5:\n                this.interpreter.setNumberValueAtIndex(scope, i, this.interpreter.numberValueAtIndex(scope, i) % source);\n            }\n          }\n          break;\n        case 2:\n          index = this.interpreter.numberValueOf(this.params.targetReference) - 1;\n          switch (this.params.operation) {\n            case 0:\n              this.interpreter.setNumberValueAtIndex(this.params.targetScope, index, source, this.params.targetReferenceDomain);\n              break;\n            case 1:\n              this.interpreter.setNumberValueAtIndex(this.params.targetScope, index, this.interpreter.numberValueAtIndex(this.params.targetScope, index, this.params.targetReferenceDomain) + source, this.params.targetReferenceDomain);\n              break;\n            case 2:\n              this.interpreter.setNumberValueAtIndex(this.params.targetScope, index, this.interpreter.numberValueAtIndex(this.params.targetScope, index, this.params.targetReferenceDomain) - source, this.params.targetReferenceDomain);\n              break;\n            case 3:\n              this.interpreter.setNumberValueAtIndex(this.params.targetScope, index, this.interpreter.numberValueAtIndex(this.params.targetScope, index, this.params.targetReferenceDomain) * source, this.params.targetReferenceDomain);\n              break;\n            case 4:\n              this.interpreter.setNumberValueAtIndex(this.params.targetScope, index, Math.floor(this.interpreter.numberValueAtIndex(this.params.targetScope, index, this.params.targetReferenceDomain) / source), this.params.targetReferenceDomain);\n              break;\n            case 5:\n              this.interpreter.setNumberValueAtIndex(this.params.targetScope, index, this.interpreter.numberValueAtIndex(this.params.targetScope, index, this.params.targetReferenceDomain) % source, this.params.targetReferenceDomain);\n          }\n      }\n      return null;\n    };\n\n\n    /**\n    * @method commandChangeBooleanVariables\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandChangeBooleanVariables = function() {\n      var i, index, k, ref, ref1, source, targetValue, variable;\n      source = this.interpreter.booleanValueOf(this.params.value);\n      switch (this.params.target) {\n        case 0:\n          if (this.params.value === 2) {\n            targetValue = this.interpreter.booleanValueOf(this.params.targetVariable);\n            this.interpreter.setBooleanValueTo(this.params.targetVariable, targetValue ? false : true);\n          } else {\n            this.interpreter.setBooleanValueTo(this.params.targetVariable, source);\n          }\n          break;\n        case 1:\n          variable = {\n            index: 0,\n            scope: this.params.targetRangeScope\n          };\n          for (i = k = ref = this.params.rangeStart - 1, ref1 = this.params.rangeEnd - 1; ref <= ref1 ? k <= ref1 : k >= ref1; i = ref <= ref1 ? ++k : --k) {\n            variable.index = i;\n            if (this.params.value === 2) {\n              targetValue = this.interpreter.booleanValueOf(variable);\n              this.interpreter.setBooleanValueTo(variable, targetValue ? false : true);\n            } else {\n              this.interpreter.setBooleanValueTo(variable, source);\n            }\n          }\n          break;\n        case 2:\n          index = this.interpreter.numberValueOf(this.params.targetReference) - 1;\n          this.interpreter.setBooleanValueAtIndex(this.params.targetRangeScope, index, source, this.params.targetReferenceDomain);\n      }\n      return null;\n    };\n\n\n    /**\n    * @method commandChangeStringVariables\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandChangeStringVariables = function() {\n      var ex, i, index, k, ref, ref1, source, targetValue, variable;\n      source = \"\";\n      switch (this.params.source) {\n        case 0:\n          source = lcs(this.params.textValue);\n          break;\n        case 1:\n          source = this.interpreter.stringValueOf(this.params.sourceVariable);\n          break;\n        case 2:\n          source = this.interpreter.stringValueOfDatabaseData(this.params.databaseData);\n          break;\n        case 2:\n          try {\n            source = eval(this.params.script);\n          } catch (error) {\n            ex = error;\n            source = \"ERR: \" + ex.message;\n          }\n          break;\n        default:\n          source = lcs(this.params.textValue);\n      }\n      switch (this.params.target) {\n        case 0:\n          switch (this.params.operation) {\n            case 0:\n              this.interpreter.setStringValueTo(this.params.targetVariable, source);\n              break;\n            case 1:\n              this.interpreter.setStringValueTo(this.params.targetVariable, this.interpreter.stringValueOf(this.params.targetVariable) + source);\n              break;\n            case 2:\n              this.interpreter.setStringValueTo(this.params.targetVariable, this.interpreter.stringValueOf(this.params.targetVariable).toUpperCase());\n              break;\n            case 3:\n              this.interpreter.setStringValueTo(this.params.targetVariable, this.interpreter.stringValueOf(this.params.targetVariable).toLowerCase());\n          }\n          break;\n        case 1:\n          variable = {\n            index: 0,\n            scope: this.params.targetRangeScope\n          };\n          for (i = k = ref = this.params.rangeStart - 1, ref1 = this.params.rangeEnd - 1; ref <= ref1 ? k <= ref1 : k >= ref1; i = ref <= ref1 ? ++k : --k) {\n            variable.index = i;\n            switch (this.params.operation) {\n              case 0:\n                this.interpreter.setStringValueTo(variable, source);\n                break;\n              case 1:\n                this.interpreter.setStringValueTo(variable, this.interpreter.stringValueOf(variable) + source);\n                break;\n              case 2:\n                this.interpreter.setStringValueTo(variable, this.interpreter.stringValueOf(variable).toUpperCase());\n                break;\n              case 3:\n                this.interpreter.setStringValueTo(variable, this.interpreter.stringValueOf(variable).toLowerCase());\n            }\n          }\n          break;\n        case 2:\n          index = this.interpreter.numberValueOf(this.params.targetReference) - 1;\n          switch (this.params.operation) {\n            case 0:\n              this.interpreter.setStringValueAtIndex(this.params.targetRangeScope, index, source, this.params.targetReferenceDomain);\n              break;\n            case 1:\n              targetValue = this.interpreter.stringValueAtIndex(this.params.targetRangeScope, index, this.params.targetReferenceDomain);\n              this.interpreter.setStringValueAtIndex(this.params.targetRangeScope, index, targetValue + source, this.params.targetReferenceDomain);\n              break;\n            case 2:\n              targetValue = this.interpreter.stringValueAtIndex(this.params.targetRangeScope, index, this.params.targetReferenceDomain);\n              this.interpreter.setStringValueAtIndex(this.params.targetRangeScope, index, targetValue.toUpperCase(), this.params.targetReferenceDomain);\n              break;\n            case 3:\n              targetValue = this.interpreter.stringValueAtIndex(this.params.targetRangeScope, index, this.params.targetReferenceDomain);\n              this.interpreter.setStringValueTo(this.params.targetRangeScope, index, targetValue.toLowerCase(), this.params.targetReferenceDomain);\n          }\n      }\n      return null;\n    };\n\n\n    /**\n    * @method commandCheckSwitch\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandCheckSwitch = function() {\n      var result;\n      result = this.interpreter.booleanValueOf(this.params.targetVariable) && this.params.value;\n      if (result) {\n        return this.interpreter.pointer = this.params.labelIndex;\n      }\n    };\n\n\n    /**\n    * @method commandNumberCondition\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandNumberCondition = function() {\n      var result;\n      result = this.interpreter.compare(this.interpreter.numberValueOf(this.params.targetVariable), this.interpreter.numberValueOf(this.params.value), this.params.operation);\n      this.interpreter.conditions[this.interpreter.indent] = result;\n      if (result) {\n        return this.interpreter.indent++;\n      }\n    };\n\n\n    /**\n    * @method commandCondition\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandCondition = function() {\n      var result;\n      switch (this.params.valueType) {\n        case 0:\n          result = this.interpreter.compare(this.interpreter.numberValueOf(this.params.variable), this.interpreter.numberValueOf(this.params.numberValue), this.params.operation);\n          break;\n        case 1:\n          result = this.interpreter.compare(this.interpreter.booleanValueOf(this.params.variable), this.interpreter.booleanValueOf(this.params.switchValue), this.params.operation);\n          break;\n        case 2:\n          result = this.interpreter.compare(lcs(this.interpreter.stringValueOf(this.params.variable)), lcs(this.interpreter.stringValueOf(this.params.textValue)), this.params.operation);\n      }\n      this.interpreter.conditions[this.interpreter.indent] = result;\n      if (result) {\n        return this.interpreter.indent++;\n      }\n    };\n\n\n    /**\n    * @method commandConditionElse\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandConditionElse = function() {\n      if (!this.interpreter.conditions[this.interpreter.indent]) {\n        return this.interpreter.indent++;\n      }\n    };\n\n\n    /**\n    * @method commandConditionElseIf\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandConditionElseIf = function() {\n      if (!this.interpreter.conditions[this.interpreter.indent]) {\n        return this.interpreter.commandCondition.call(this);\n      }\n    };\n\n\n    /**\n    * @method commandCheckNumberVariable\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandCheckNumberVariable = function() {\n      var result;\n      result = this.interpreter.compare(this.interpreter.numberValueOf(this.params.targetVariable), this.interpreter.numberValueOf(this.params.value), this.params.operation);\n      if (result) {\n        return this.interpreter.pointer = this.params.labelIndex;\n      }\n    };\n\n\n    /**\n    * @method commandCheckTextVariable\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandCheckTextVariable = function() {\n      var result, text1, text2;\n      result = false;\n      text1 = this.interpreter.stringValueOf(this.params.targetVariable);\n      text2 = this.interpreter.stringValueOf(this.params.value);\n      switch (this.params.operation) {\n        case 0:\n          result = text1 === text2;\n          break;\n        case 1:\n          result = text1 !== text2;\n          break;\n        case 2:\n          result = text1.length > text2.length;\n          break;\n        case 3:\n          result = text1.length >= text2.length;\n          break;\n        case 4:\n          result = text1.length < text2.length;\n          break;\n        case 5:\n          result = text1.length <= text2.length;\n      }\n      if (result) {\n        return this.interpreter.pointer = this.params.labelIndex;\n      }\n    };\n\n\n    /**\n    * @method commandLabel\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandLabel = function() {};\n\n\n    /**\n    * @method commandJumpToLabel\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandJumpToLabel = function() {\n      var label;\n      label = this.params.labelIndex;\n      if (label != null) {\n        this.interpreter.pointer = label;\n        return this.interpreter.indent = this.interpreter.object.commands[label].indent;\n      } else {\n        switch (this.params.target) {\n          case \"activeContext\":\n            return this.interpreter.jumpToLabel(this.interpreter.stringValueOf(this.params.name));\n          case \"activeScene\":\n            return SceneManager.scene.interpreter.jumpToLabel(this.interpreter.stringValueOf(this.params.name));\n          default:\n            return this.interpreter.jumpToLabel(this.interpreter.stringValueOf(this.params.name));\n        }\n      }\n    };\n\n\n    /**\n    * @method commandClearMessage\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandClearMessage = function() {\n      var duration, fading, flags, isLocked, messageObject, scene;\n      scene = SceneManager.scene;\n      messageObject = this.interpreter.targetMessage();\n      if (messageObject == null) {\n        return;\n      }\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      duration = 0;\n      fading = GameManager.tempSettings.messageFading;\n      if (!GameManager.tempSettings.skip) {\n        duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : fading.duration;\n      }\n      messageObject.animator.disappear(fading.animation, fading.easing, duration, gs.CallBack(\"onMessageADVClear\", this.interpreter));\n      this.interpreter.waitForCompletion(messageObject, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandMessageBoxDefaults\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandMessageBoxDefaults = function() {\n      var defaults, flags, isLocked;\n      defaults = GameManager.defaults.messageBox;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      if (!isLocked(flags.appearDuration)) {\n        defaults.appearDuration = this.interpreter.durationValueOf(this.params.appearDuration);\n      }\n      if (!isLocked(flags.disappearDuration)) {\n        defaults.disappearDuration = this.interpreter.durationValueOf(this.params.disappearDuration);\n      }\n      if (!isLocked(flags.zOrder)) {\n        defaults.zOrder = this.interpreter.numberValueOf(this.params.zOrder);\n      }\n      if (!isLocked(flags[\"appearEasing.type\"])) {\n        defaults.appearEasing = this.params.appearEasing;\n      }\n      if (!isLocked(flags[\"appearAnimation.type\"])) {\n        defaults.appearAnimation = this.params.appearAnimation;\n      }\n      if (!isLocked(flags[\"disappearEasing.type\"])) {\n        defaults.disappearEasing = this.params.disappearEasing;\n      }\n      if (!isLocked(flags[\"disappearAnimation.type\"])) {\n        return defaults.disappearAnimation = this.params.disappearAnimation;\n      }\n    };\n\n\n    /**\n    * @method commandShowMessage\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandShowMessage = function() {\n      var animation, character, defaults, duration, easing, expression, ref, scene, showMessage;\n      scene = SceneManager.scene;\n      scene.messageMode = vn.MessageMode.ADV;\n      character = scene.characters.first((function(_this) {\n        return function(v) {\n          return !v.disposed && v.rid === _this.params.characterId;\n        };\n      })(this));\n      showMessage = (function(_this) {\n        return function() {\n          var messageObject, ref, settings, voiceSettings;\n          character = RecordManager.characters[_this.params.characterId];\n          scene.layout.visible = true;\n          messageObject = _this.interpreter.targetMessage();\n          if (messageObject == null) {\n            return;\n          }\n          scene.currentCharacter = character;\n          messageObject.character = character;\n          messageObject.opacity = 255;\n          messageObject.events.offByOwner(\"callCommonEvent\", _this.interpreter);\n          messageObject.events.on(\"callCommonEvent\", gs.CallBack(\"onCallCommonEvent\", _this.interpreter), {\n            params: _this.params\n          }, _this.interpreter);\n          messageObject.events.once(\"finish\", gs.CallBack(\"onMessageADVFinish\", _this.interpreter), {\n            params: _this.params\n          }, _this.interpreter);\n          messageObject.events.once(\"waiting\", gs.CallBack(\"onMessageADVWaiting\", _this.interpreter), {\n            params: _this.params\n          }, _this.interpreter);\n          if (messageObject.settings.useCharacterColor) {\n            messageObject.message.showMessage(_this.interpreter, _this.params, character);\n          } else {\n            messageObject.message.showMessage(_this.interpreter, _this.params);\n          }\n          settings = GameManager.settings;\n          voiceSettings = settings.voicesByCharacter[character.index];\n          if ((_this.params.voice != null) && GameManager.settings.voiceEnabled && (!voiceSettings || voiceSettings > 0)) {\n            if ((GameManager.settings.skipVoiceOnAction || !((ref = AudioManager.voice) != null ? ref.playing : void 0)) && !GameManager.tempSettings.skip) {\n              messageObject.voice = _this.params.voice;\n              return messageObject.behavior.voice = AudioManager.playVoice(_this.params.voice);\n            }\n          } else {\n            return messageObject.behavior.voice = null;\n          }\n        };\n      })(this);\n      if ((this.params.expressionId != null) && (character != null)) {\n        expression = RecordManager.characterExpressions[this.params.expressionId || 0];\n        defaults = GameManager.defaults.character;\n        duration = !gs.CommandFieldFlags.isLocked(this.params.fieldFlags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.expressionDuration;\n        easing = gs.Easings.fromObject(defaults.changeEasing);\n        animation = defaults.changeAnimation;\n        character.behavior.changeExpression(expression, animation, easing, duration, (function(_this) {\n          return function() {\n            return showMessage();\n          };\n        })(this));\n      } else {\n        showMessage();\n      }\n      this.interpreter.isWaiting = ((ref = this.params.waitForCompletion) != null ? ref : true) && !(GameManager.tempSettings.skip && GameManager.tempSettings.skipTime === 0);\n      return this.interpreter.waitingFor.messageADV = this.params;\n    };\n\n\n    /**\n    * @method commandSetMessageArea\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandSetMessageArea = function() {\n      var messageLayout, number, scene;\n      scene = SceneManager.scene;\n      number = this.interpreter.numberValueOf(this.params.number);\n      if (scene.messageAreas[number]) {\n        messageLayout = scene.messageAreas[number].layout;\n        messageLayout.dstRect.x = this.params.box.x;\n        messageLayout.dstRect.y = this.params.box.y;\n        messageLayout.dstRect.width = this.params.box.size.width;\n        messageLayout.dstRect.height = this.params.box.size.height;\n        return messageLayout.needsUpdate = true;\n      }\n    };\n\n\n    /**\n    * @method commandMessageFading\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandMessageFading = function() {\n      return GameManager.tempSettings.messageFading = {\n        duration: this.interpreter.durationValueOf(this.params.duration),\n        animation: this.params.animation,\n        easing: gs.Easings.fromObject(this.params.easing)\n      };\n    };\n\n\n    /**\n    * @method commandMessageSettings\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandMessageSettings = function() {\n      var flags, font, fontName, fontSize, isLocked, messageObject, messageSettings, ref, ref1, ref2, ref3, ref4, ref5;\n      messageObject = this.interpreter.targetMessage();\n      if (!messageObject) {\n        return;\n      }\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      messageSettings = this.interpreter.messageSettings();\n      if (!isLocked(flags.autoErase)) {\n        messageSettings.autoErase = this.params.autoErase;\n      }\n      if (!isLocked(flags.waitAtEnd)) {\n        messageSettings.waitAtEnd = this.params.waitAtEnd;\n      }\n      if (!isLocked(flags.backlog)) {\n        messageSettings.backlog = this.params.backlog;\n      }\n      if (!isLocked(flags.lineHeight)) {\n        messageSettings.lineHeight = this.params.lineHeight;\n      }\n      if (!isLocked(flags.lineSpacing)) {\n        messageSettings.lineSpacing = this.params.lineSpacing;\n      }\n      if (!isLocked(flags.linePadding)) {\n        messageSettings.linePadding = this.params.linePadding;\n      }\n      if (!isLocked(flags.paragraphSpacing)) {\n        messageSettings.paragraphSpacing = this.params.paragraphSpacing;\n      }\n      if (!isLocked(flags.useCharacterColor)) {\n        messageSettings.useCharacterColor = this.params.useCharacterColor;\n      }\n      messageObject.textRenderer.minLineHeight = (ref = messageSettings.lineHeight) != null ? ref : 0;\n      messageObject.textRenderer.lineSpacing = (ref1 = messageSettings.lineSpacing) != null ? ref1 : messageObject.textRenderer.lineSpacing;\n      messageObject.textRenderer.padding = (ref2 = messageSettings.linePadding) != null ? ref2 : messageObject.textRenderer.padding;\n      fontName = !isLocked(flags.font) ? this.params.font : messageObject.font.name;\n      fontSize = !isLocked(flags.size) ? this.params.size : messageObject.font.size;\n      font = messageObject.font;\n      if (!isLocked(flags.font) || !isLocked(flags.size)) {\n        messageObject.font = new Font(fontName, fontSize);\n      }\n      if (!isLocked(flags.bold)) {\n        messageObject.font.bold = this.params.bold;\n      }\n      if (!isLocked(flags.italic)) {\n        messageObject.font.italic = this.params.italic;\n      }\n      if (!isLocked(flags.smallCaps)) {\n        messageObject.font.smallCaps = this.params.smallCaps;\n      }\n      if (!isLocked(flags.underline)) {\n        messageObject.font.underline = this.params.underline;\n      }\n      if (!isLocked(flags.strikeThrough)) {\n        messageObject.font.strikeThrough = this.params.strikeThrough;\n      }\n      if (!isLocked(flags.color)) {\n        messageObject.font.color = new Color(this.params.color);\n      }\n      messageObject.font.color = (flags.color != null) && !isLocked(flags.color) ? new Color(this.params.color) : font.color;\n      messageObject.font.border = (flags.outline != null) && !isLocked(flags.outline) ? this.params.outline : font.border;\n      messageObject.font.borderColor = (flags.outlineColor != null) && !isLocked(flags.outlineColor) ? new Color(this.params.outlineColor) : new Color(font.borderColor);\n      messageObject.font.borderSize = (flags.outlineSize != null) && !isLocked(flags.outlineSize) ? (ref3 = this.params.outlineSize) != null ? ref3 : 4 : font.borderSize;\n      messageObject.font.shadow = (flags.shadow != null) && !isLocked(flags.shadow) ? this.params.shadow : font.shadow;\n      messageObject.font.shadowColor = (flags.shadowColor != null) && !isLocked(flags.shadowColor) ? new Color(this.params.shadowColor) : new Color(font.shadowColor);\n      messageObject.font.shadowOffsetX = (flags.shadowOffsetX != null) && !isLocked(flags.shadowOffsetX) ? (ref4 = this.params.shadowOffsetX) != null ? ref4 : 1 : font.shadowOffsetX;\n      messageObject.font.shadowOffsetY = (flags.shadowOffsetY != null) && !isLocked(flags.shadowOffsetY) ? (ref5 = this.params.shadowOffsetY) != null ? ref5 : 1 : font.shadowOffsetY;\n      if (isLocked(flags.bold)) {\n        messageObject.font.bold = font.bold;\n      }\n      if (isLocked(flags.italic)) {\n        messageObject.font.italic = font.italic;\n      }\n      if (isLocked(flags.smallCaps)) {\n        return messageObject.font.smallCaps = font.smallCaps;\n      }\n    };\n\n\n    /**\n    * @method commandCreateMessageArea\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandCreateMessageArea = function() {\n      var messageArea, number, scene;\n      number = this.interpreter.numberValueOf(this.params.number);\n      scene = SceneManager.scene;\n      scene.behavior.changeMessageAreaDomain(this.params.numberDomain);\n      if (!scene.messageAreas[number]) {\n        messageArea = new gs.Object_MessageArea();\n        messageArea.layout = ui.UIManager.createControlFromDescriptor({\n          type: \"ui.CustomGameMessage\",\n          id: \"customGameMessage_\" + number,\n          params: {\n            id: \"customGameMessage_\" + number\n          }\n        }, messageArea);\n        messageArea.message = gs.ObjectManager.current.objectById(\"customGameMessage_\" + number + \"_message\");\n        messageArea.message.domain = this.params.numberDomain;\n        messageArea.addObject(messageArea.layout);\n        messageArea.layout.dstRect.x = this.params.box.x;\n        messageArea.layout.dstRect.y = this.params.box.y;\n        messageArea.layout.dstRect.width = this.params.box.size.width;\n        messageArea.layout.dstRect.height = this.params.box.size.height;\n        messageArea.layout.needsUpdate = true;\n        return scene.messageAreas[number] = messageArea;\n      }\n    };\n\n\n    /**\n    * @method commandEraseMessageArea\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandEraseMessageArea = function() {\n      var area, number, scene;\n      number = this.interpreter.numberValueOf(this.params.number);\n      scene = SceneManager.scene;\n      scene.behavior.changeMessageAreaDomain(this.params.numberDomain);\n      area = scene.messageAreas[number];\n      if (area != null) {\n        area.layout.dispose();\n      }\n      return scene.messageAreas[number] = null;\n    };\n\n\n    /**\n    * @method commandSetTargetMessage\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandSetTargetMessage = function() {\n      var message, ref, ref1, scene, target;\n      message = this.interpreter.targetMessage();\n      if (message != null) {\n        message.textRenderer.isWaiting = false;\n      }\n      if (message != null) {\n        message.behavior.isWaiting = false;\n      }\n      scene = SceneManager.scene;\n      scene.behavior.changeMessageAreaDomain(this.params.numberDomain);\n      target = {\n        type: this.params.type,\n        id: null\n      };\n      switch (this.params.type) {\n        case 0:\n          target.id = this.params.id;\n          break;\n        case 1:\n          target.id = this.interpreter.numberValueOf(this.params.number);\n      }\n      this.interpreter.settings.message.target = target;\n      if (this.params.clear) {\n        if ((ref = this.interpreter.targetMessage()) != null) {\n          ref.behavior.clear();\n        }\n      }\n      return (ref1 = this.interpreter.targetMessage()) != null ? ref1.visible = true : void 0;\n    };\n\n\n    /**\n    * @method commandBacklogVisibility\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandBacklogVisibility = function() {\n      var control;\n      if (this.params.visible) {\n        control = gs.ObjectManager.current.objectById(\"backlogBox\");\n        if (control == null) {\n          control = gs.ObjectManager.current.objectById(\"backlog\");\n        }\n        if (control != null) {\n          control.dispose();\n        }\n        if (this.params.backgroundVisible) {\n          return control = SceneManager.scene.behavior.createControl(this, {\n            descriptor: \"ui.MessageBacklogBox\"\n          });\n        } else {\n          return control = SceneManager.scene.behavior.createControl(this, {\n            descriptor: \"ui.MessageBacklog\"\n          });\n        }\n      } else {\n        control = gs.ObjectManager.current.objectById(\"backlogBox\");\n        if (control == null) {\n          control = gs.ObjectManager.current.objectById(\"backlog\");\n        }\n        if (control == null) {\n          control = gs.ObjectManager.current.objectById(\"backlogScrollView\");\n        }\n        return control != null ? control.dispose() : void 0;\n      }\n    };\n\n\n    /**\n    * @method commandMessageVisibility\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandMessageVisibility = function() {\n      var animation, defaults, duration, easing, flags, isLocked, message;\n      defaults = GameManager.defaults.messageBox;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      message = this.interpreter.targetMessage();\n      if ((message == null) || this.params.visible === message.visible) {\n        return;\n      }\n      if (this.params.visible) {\n        duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.appearDuration;\n        easing = !isLocked(flags[\"easing.type\"]) ? gs.Easings.fromObject(this.params.easing) : gs.Easings.fromObject(defaults.appearEasing);\n        animation = !isLocked(flags[\"animation.type\"]) ? this.params.animation : defaults.appearAnimation;\n        message.animator.appear(message.dstRect.x, message.dstRect.y, this.params.animation, easing, duration);\n      } else {\n        duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.disappearDuration;\n        easing = !isLocked(flags[\"easing.type\"]) ? gs.Easings.fromObject(this.params.easing) : gs.Easings.fromObject(defaults.disappearEasing);\n        animation = !isLocked(flags[\"animation.type\"]) ? this.params.animation : defaults.disappearAnimation;\n        message.animator.disappear(animation, easing, duration, function() {\n          return message.visible = false;\n        });\n      }\n      message.update();\n      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {\n        this.interpreter.isWaiting = true;\n        this.interpreter.waitCounter = duration;\n      }\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandMessageBoxVisibility\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandMessageBoxVisibility = function() {\n      var animation, defaults, duration, easing, flags, isLocked, messageBox, visible;\n      defaults = GameManager.defaults.messageBox;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      messageBox = this.interpreter.messageBoxObject(this.interpreter.stringValueOf(this.params.id));\n      visible = this.params.visible === 1;\n      if ((messageBox == null) || visible === messageBox.visible) {\n        return;\n      }\n      if (this.params.visible) {\n        duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.appearDuration;\n        easing = !isLocked(flags[\"easing.type\"]) ? gs.Easings.fromObject(this.params.easing) : gs.Easings.fromObject(defaults.appearEasing);\n        animation = !isLocked(flags[\"animation.type\"]) ? this.params.animation : defaults.appearAnimation;\n        messageBox.animator.appear(messageBox.dstRect.x, messageBox.dstRect.y, animation, easing, duration);\n      } else {\n        duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.disappearDuration;\n        easing = !isLocked(flags[\"easing.type\"]) ? gs.Easings.fromObject(this.params.easing) : gs.Easings.fromObject(defaults.disappearEasing);\n        animation = !isLocked(flags[\"animation.type\"]) ? this.params.animation : defaults.disappearAnimation;\n        messageBox.animator.disappear(animation, easing, duration, function() {\n          return messageBox.visible = false;\n        });\n      }\n      messageBox.update();\n      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {\n        this.interpreter.isWaiting = true;\n        this.interpreter.waitCounter = duration;\n      }\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandUIAccess\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandUIAccess = function() {\n      var flags, isLocked;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      if (!isLocked(flags.generalMenu)) {\n        GameManager.tempSettings.menuAccess = this.interpreter.booleanValueOf(this.params.generalMenu);\n      }\n      if (!isLocked(flags.saveMenu)) {\n        GameManager.tempSettings.saveMenuAccess = this.interpreter.booleanValueOf(this.params.saveMenu);\n      }\n      if (!isLocked(flags.loadMenu)) {\n        GameManager.tempSettings.loadMenuAccess = this.interpreter.booleanValueOf(this.params.loadMenu);\n      }\n      if (!isLocked(flags.backlog)) {\n        return GameManager.tempSettings.backlogAccess = this.interpreter.booleanValueOf(this.params.backlog);\n      }\n    };\n\n\n    /**\n    * @method commandUnlockCG\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandUnlockCG = function() {\n      var cg;\n      cg = RecordManager.cgGallery[this.interpreter.stringValueOf(this.params.cgId)];\n      if (cg != null) {\n        GameManager.globalData.cgGallery[cg.index] = {\n          unlocked: true\n        };\n        return GameManager.saveGlobalData();\n      }\n    };\n\n\n    /**\n    * @method commandL2DMove\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandL2DMove = function() {\n      var character, scene;\n      scene = SceneManager.scene;\n      character = scene.characters.first((function(_this) {\n        return function(v) {\n          return !v.disposed && v.rid === _this.params.characterId;\n        };\n      })(this));\n      if (!character instanceof vn.Object_Live2DCharacter) {\n        return;\n      }\n      this.interpreter.moveObject(character, this.params.position, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandL2DMotionGroup\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandL2DMotionGroup = function() {\n      var character, motions, scene;\n      scene = SceneManager.scene;\n      character = scene.characters.first((function(_this) {\n        return function(v) {\n          return !v.disposed && v.rid === _this.params.characterId;\n        };\n      })(this));\n      if (!character instanceof vn.Object_Live2DCharacter) {\n        return;\n      }\n      character.motionGroup = {\n        name: this.params.data.motionGroup,\n        loop: this.params.loop,\n        playType: this.params.playType\n      };\n      if (this.params.waitForCompletion && !this.params.loop) {\n        motions = character.model.motionsByGroup[character.motionGroup.name];\n        if (motions != null) {\n          this.interpreter.isWaiting = true;\n          this.interpreter.waitCounter = motions.sum(function(m) {\n            return m.getDurationMSec() / 16.6;\n          });\n        }\n      }\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandL2DMotion\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandL2DMotion = function() {\n      var character, defaults, fadeInTime, flags, isLocked, motion, scene;\n      defaults = GameManager.defaults.live2d;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      scene = SceneManager.scene;\n      character = scene.characters.first((function(_this) {\n        return function(v) {\n          return !v.disposed && v.rid === _this.params.characterId;\n        };\n      })(this));\n      if (!character instanceof vn.Object_Live2DCharacter) {\n        return;\n      }\n      fadeInTime = !isLocked(flags.fadeInTime) ? this.params.fadeInTime : defaults.motionFadeInTime;\n      character.motion = {\n        name: this.params.data.motion,\n        fadeInTime: fadeInTime,\n        loop: this.params.loop\n      };\n      character.motionGroup = null;\n      if (this.params.waitForCompletion && !this.params.loop) {\n        motion = character.model.motions[character.motion.name];\n        if (motion != null) {\n          this.interpreter.isWaiting = true;\n          this.interpreter.waitCounter = motion.getDurationMSec() / 16.6;\n        }\n      }\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandL2DExpression\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandL2DExpression = function() {\n      var character, defaults, fadeInTime, flags, isLocked, scene;\n      defaults = GameManager.defaults.live2d;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      scene = SceneManager.scene;\n      character = scene.characters.first((function(_this) {\n        return function(v) {\n          return !v.disposed && v.rid === _this.params.characterId;\n        };\n      })(this));\n      if (!character instanceof vn.Object_Live2DCharacter) {\n        return;\n      }\n      fadeInTime = !isLocked(flags.fadeInTime) ? this.params.fadeInTime : defaults.expressionFadeInTime;\n      character.expression = {\n        name: this.params.data.expression,\n        fadeInTime: fadeInTime\n      };\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandL2DExitScene\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandL2DExitScene = function() {\n      var defaults;\n      defaults = GameManager.defaults.live2d;\n      this.interpreter.commandCharacterExitScene.call(this, defaults);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandL2DSettings\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandL2DSettings = function() {\n      var character, flags, isLocked, scene;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      scene = SceneManager.scene;\n      character = scene.characters.first((function(_this) {\n        return function(v) {\n          return !v.disposed && v.rid === _this.params.characterId;\n        };\n      })(this));\n      if (!(character != null ? character.visual.l2dObject : void 0)) {\n        return;\n      }\n      if (!isLocked(flags.lipSyncSensitivity)) {\n        character.visual.l2dObject.lipSyncSensitivity = this.interpreter.numberValueOf(this.params.lipSyncSensitivity);\n      }\n      if (!isLocked(flags.idleIntensity)) {\n        character.visual.l2dObject.idleIntensity = this.interpreter.numberValueOf(this.params.idleIntensity);\n      }\n      if (!isLocked(flags.breathIntensity)) {\n        character.visual.l2dObject.breathIntensity = this.interpreter.numberValueOf(this.params.breathIntensity);\n      }\n      if (!isLocked(flags[\"eyeBlink.enabled\"])) {\n        character.visual.l2dObject.eyeBlink.enabled = this.params.eyeBlink.enabled;\n      }\n      if (!isLocked(flags[\"eyeBlink.interval\"])) {\n        character.visual.l2dObject.eyeBlink.blinkIntervalMsec = this.interpreter.numberValueOf(this.params.eyeBlink.interval);\n      }\n      if (!isLocked(flags[\"eyeBlink.closedMotionTime\"])) {\n        character.visual.l2dObject.eyeBlink.closedMotionMsec = this.interpreter.numberValueOf(this.params.eyeBlink.closedMotionTime);\n      }\n      if (!isLocked(flags[\"eyeBlink.closingMotionTime\"])) {\n        character.visual.l2dObject.eyeBlink.closingMotionMsec = this.interpreter.numberValueOf(this.params.eyeBlink.closingMotionTime);\n      }\n      if (!isLocked(flags[\"eyeBlink.openingMotionTime\"])) {\n        character.visual.l2dObject.eyeBlink.openingMotionMsec = this.interpreter.numberValueOf(this.params.eyeBlink.openingMotionTime);\n      }\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandL2DParameter\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandL2DParameter = function() {\n      var character, duration, easing, scene;\n      scene = SceneManager.scene;\n      character = scene.characters.first((function(_this) {\n        return function(v) {\n          return !v.disposed && v.rid === _this.params.characterId;\n        };\n      })(this));\n      if (!character instanceof vn.Object_Live2DCharacter) {\n        return;\n      }\n      easing = gs.Easings.fromObject(this.params.easing);\n      duration = this.interpreter.durationValueOf(this.params.duration);\n      character.animator.l2dParameterTo(this.params.param.name, this.interpreter.numberValueOf(this.params.param.value), duration, easing);\n      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {\n        this.interpreter.isWaiting = true;\n        this.interpreter.waitCounter = duration;\n      }\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandL2DDefaults\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandL2DDefaults = function() {\n      var defaults, flags, isLocked;\n      defaults = GameManager.defaults.live2d;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      if (!isLocked(flags.appearDuration)) {\n        defaults.appearDuration = this.interpreter.durationValueOf(this.params.appearDuration);\n      }\n      if (!isLocked(flags.disappearDuration)) {\n        defaults.disappearDuration = this.interpreter.durationValueOf(this.params.disappearDuration);\n      }\n      if (!isLocked(flags.zOrder)) {\n        defaults.zOrder = this.interpreter.numberValueOf(this.params.zOrder);\n      }\n      if (!isLocked(flags.motionFadeInTime)) {\n        defaults.motionFadeInTime = this.interpreter.numberValueOf(this.params.motionFadeInTime);\n      }\n      if (!isLocked(flags[\"appearEasing.type\"])) {\n        defaults.appearEasing = this.params.appearEasing;\n      }\n      if (!isLocked(flags[\"appearAnimation.type\"])) {\n        defaults.appearAnimation = this.params.appearAnimation;\n      }\n      if (!isLocked(flags[\"disappearEasing.type\"])) {\n        defaults.disappearEasing = this.params.disappearEasing;\n      }\n      if (!isLocked(flags[\"disappearAnimation.type\"])) {\n        defaults.disappearAnimation = this.params.disappearAnimation;\n      }\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandL2DJoinScene\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandL2DJoinScene = function() {\n      var animation, character, defaults, duration, easing, flags, instant, isLocked, motionBlur, noAnim, origin, p, record, ref, ref1, ref2, ref3, ref4, ref5, scene, x, y, zIndex;\n      defaults = GameManager.defaults.live2d;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      scene = SceneManager.scene;\n      record = RecordManager.characters[this.interpreter.stringValueOf(this.params.characterId)];\n      if (!record || scene.characters.first(function(v) {\n        return !v.disposed && v.rid === record.index;\n      })) {\n        return;\n      }\n      if (this.params.positionType === 1) {\n        x = this.params.position.x;\n        y = this.params.position.y;\n      } else if (this.params.positionType === 2) {\n        x = this.interpreter.numberValueOf(this.params.position.x);\n        y = this.interpreter.numberValueOf(this.params.position.y);\n      }\n      easing = !isLocked(flags[\"easing.type\"]) ? gs.Easings.fromValues(this.interpreter.numberValueOf(this.params.easing.type), this.params.easing.inOut) : gs.Easings.fromObject(defaults.appearEasing);\n      duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.appearDuration;\n      zIndex = !isLocked(flags.zOrder) ? this.interpreter.numberValueOf(this.params.zOrder) : defaults.zOrder;\n      animation = !isLocked(flags[\"animation.type\"]) ? this.params.animation : defaults.appearAnimation;\n      motionBlur = !isLocked(flags[\"motionBlur.enabled\"]) ? this.params.motionBlur : defaults.motionBlur;\n      origin = !isLocked(flags.origin) ? this.params.origin : defaults.origin;\n      instant = duration === 0 || this.interpreter.isInstantSkip();\n      noAnim = duration === 0 || GameManager.tempSettings.skip;\n      if (this.params.waitForCompletion && !instant) {\n        this.interpreter.isWaiting = true;\n        this.interpreter.waitCounter = duration;\n      }\n      character = new vn.Object_Live2DCharacter(record);\n      character.modelName = ((ref = this.params.model) != null ? ref.name : void 0) || \"\";\n      character.model = ResourceManager.getLive2DModel(\"Live2D/\" + character.modelName);\n      if (character.model.motions) {\n        character.motion = {\n          name: \"\",\n          fadeInTime: 0,\n          loop: true\n        };\n      }\n      character.dstRect.x = x;\n      character.dstRect.y = y;\n      character.anchor.x = !origin ? 0 : 0.5;\n      character.anchor.y = !origin ? 0 : 0.5;\n      character.blendMode = this.interpreter.numberValueOf(this.params.blendMode);\n      character.zoom.x = this.params.position.zoom.d;\n      character.zoom.y = this.params.position.zoom.d;\n      character.zIndex = zIndex || 200;\n      if ((ref1 = character.model) != null) {\n        ref1.reset();\n      }\n      character.setup();\n      character.visual.l2dObject.idleIntensity = (ref2 = record.idleIntensity) != null ? ref2 : 1.0;\n      character.visual.l2dObject.breathIntensity = (ref3 = record.breathIntensity) != null ? ref3 : 1.0;\n      character.visual.l2dObject.lipSyncSensitivity = (ref4 = record.lipSyncSensitivity) != null ? ref4 : 1.0;\n      character.update();\n      if (this.params.positionType === 0) {\n        p = this.interpreter.predefinedObjectPosition(this.params.predefinedPositionId, character, this.params);\n        character.dstRect.x = p.x;\n        character.dstRect.y = p.y;\n      }\n      scene.behavior.addCharacter(character, noAnim, {\n        animation: animation,\n        duration: duration,\n        easing: easing,\n        motionBlur: motionBlur\n      });\n      if (((ref5 = this.params.viewport) != null ? ref5.type : void 0) === \"ui\") {\n        character.viewport = Graphics.viewport;\n      }\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandCharacterJoinScene\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandCharacterJoinScene = function() {\n      var angle, animation, bitmap, character, characterId, defaults, duration, easing, expressionId, flags, instant, isLocked, mirror, motionBlur, noAnim, origin, p, record, ref, ref1, ref2, ref3, ref4, ref5, scene, x, y, zIndex, zoom;\n      defaults = GameManager.defaults.character;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      scene = SceneManager.scene;\n      characterId = this.interpreter.stringValueOf(this.params.characterId);\n      expressionId = this.interpreter.stringValueOf(this.params.expressionId) || this.params.expressionId;\n      record = RecordManager.characters[characterId];\n      if (!record || scene.characters.first(function(v) {\n        return !v.disposed && v.rid === record.index && !v.disposed;\n      })) {\n        return;\n      }\n      character = new vn.Object_Character(record, null, scene);\n      character.expression = RecordManager.characterExpressions[expressionId != null ? expressionId : record.defaultExpressionId || 0];\n      if ((ref = character.expression) != null ? (ref1 = ref.idle[0]) != null ? ref1.resource.name : void 0 : void 0) {\n        bitmap = ResourceManager.getBitmap(\"Graphics/Characters/\" + character.expression.idle[0].resource.name);\n      }\n      mirror = false;\n      angle = 0;\n      zoom = 1;\n      if (this.params.positionType === 1) {\n        x = this.interpreter.numberValueOf(this.params.position.x);\n        y = this.interpreter.numberValueOf(this.params.position.y);\n        mirror = this.params.position.horizontalFlip;\n        angle = this.params.position.angle || 0;\n        zoom = ((ref2 = this.params.position.data) != null ? ref2.zoom : void 0) || 1;\n      } else if (this.params.positionType === 2) {\n        x = this.interpreter.numberValueOf(this.params.position.x);\n        y = this.interpreter.numberValueOf(this.params.position.y);\n        mirror = false;\n        angle = 0;\n        zoom = 1;\n      }\n      easing = !isLocked(flags[\"easing.type\"]) ? gs.Easings.fromValues(this.interpreter.numberValueOf(this.params.easing.type), this.params.easing.inOut) : gs.Easings.fromObject(defaults.appearEasing);\n      duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.appearDuration;\n      origin = !isLocked(flags.origin) ? this.params.origin : defaults.origin;\n      zIndex = !isLocked(flags.zOrder) ? this.interpreter.numberValueOf(this.params.zOrder) : defaults.zOrder;\n      animation = !isLocked(flags[\"animation.type\"]) ? this.params.animation : defaults.appearAnimation;\n      motionBlur = !isLocked(flags[\"motionBlur.enabled\"]) ? this.params.motionBlur : defaults.motionBlur;\n      instant = duration === 0 || this.interpreter.isInstantSkip();\n      noAnim = duration === 0 || GameManager.tempSettings.skip;\n      if (this.params.waitForCompletion && !instant) {\n        this.interpreter.isWaiting = true;\n        this.interpreter.waitCounter = duration;\n      }\n      if ((ref3 = character.expression) != null ? (ref4 = ref3.idle[0]) != null ? ref4.resource.name : void 0 : void 0) {\n        bitmap = ResourceManager.getBitmap(\"Graphics/Characters/\" + character.expression.idle[0].resource.name);\n        if (origin === 1 && (bitmap != null)) {\n          x += (bitmap.width * zoom - bitmap.width) / 2;\n          y += (bitmap.height * zoom - bitmap.height) / 2;\n        }\n      }\n      character.mirror = mirror;\n      character.anchor.x = !origin ? 0 : 0.5;\n      character.anchor.y = !origin ? 0 : 0.5;\n      character.zoom.x = zoom;\n      character.zoom.y = zoom;\n      character.dstRect.x = x;\n      character.dstRect.y = y;\n      character.zIndex = zIndex || 200;\n      character.blendMode = this.interpreter.numberValueOf(this.params.blendMode);\n      character.angle = angle;\n      character.setup();\n      character.update();\n      if (this.params.positionType === 0) {\n        p = this.interpreter.predefinedObjectPosition(this.params.predefinedPositionId, character, this.params);\n        character.dstRect.x = p.x;\n        character.dstRect.y = p.y;\n      }\n      scene.behavior.addCharacter(character, noAnim, {\n        animation: animation,\n        duration: duration,\n        easing: easing,\n        motionBlur: motionBlur\n      });\n      if (((ref5 = this.params.viewport) != null ? ref5.type : void 0) === \"ui\") {\n        character.viewport = Graphics.viewport;\n      }\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandCharacterExitScene\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandCharacterExitScene = function(defaults) {\n      var animation, character, characterId, duration, easing, flags, instant, isLocked, noAnim, scene;\n      defaults = defaults || GameManager.defaults.character;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      characterId = this.interpreter.stringValueOf(this.params.characterId);\n      scene = SceneManager.scene;\n      character = scene.characters.first((function(_this) {\n        return function(v) {\n          return !v.disposed && v.rid === characterId;\n        };\n      })(this));\n      easing = !isLocked(flags[\"easing.type\"]) ? gs.Easings.fromValues(this.interpreter.numberValueOf(this.params.easing.type), this.params.easing.inOut) : gs.Easings.fromObject(defaults.disappearEasing);\n      duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.disappearDuration;\n      animation = !isLocked(flags[\"animation.type\"]) ? this.params.animation : defaults.disappearAnimation;\n      instant = duration === 0 || this.interpreter.isInstantSkip();\n      noAnim = duration === 0 || GameManager.tempSettings.skip;\n      if (this.params.waitForCompletion && !instant) {\n        this.interpreter.isWaiting = true;\n        this.interpreter.waitCounter = duration;\n      }\n      scene.behavior.removeCharacter(character, noAnim, {\n        animation: animation,\n        duration: duration,\n        easing: easing\n      });\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandCharacterChangeExpression\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandCharacterChangeExpression = function() {\n      var animation, character, characterId, defaults, duration, easing, expression, flags, isLocked, scene;\n      scene = SceneManager.scene;\n      characterId = this.interpreter.stringValueOf(this.params.characterId);\n      character = scene.characters.first((function(_this) {\n        return function(v) {\n          return !v.disposed && v.rid === characterId;\n        };\n      })(this));\n      if (character == null) {\n        return;\n      }\n      defaults = GameManager.defaults.character;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.expressionDuration;\n      expression = RecordManager.characterExpressions[this.params.expressionId || 0];\n      easing = !isLocked(flags[\"easing.type\"]) ? gs.Easings.fromObject(this.params.easing) : gs.Easings.fromObject(defaults.changeEasing);\n      animation = !isLocked(flags[\"animation.type\"]) ? this.params.animation : defaults.changeAnimation;\n      character.behavior.changeExpression(expression, this.params.animation, easing, duration);\n      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {\n        this.interpreter.isWaiting = true;\n        this.interpreter.waitCounter = duration;\n      }\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandCharacterSetParameter\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandCharacterSetParameter = function() {\n      var params, value;\n      params = GameManager.characterParams[this.interpreter.stringValueOf(this.params.characterId)];\n      if ((params == null) || (this.params.param == null)) {\n        return;\n      }\n      switch (this.params.valueType) {\n        case 0:\n          switch (this.params.param.type) {\n            case 0:\n              return params[this.params.param.name] = this.interpreter.numberValueOf(this.params.numberValue);\n            case 1:\n              return params[this.params.param.name] = this.interpreter.numberValueOf(this.params.numberValue) > 0;\n            case 2:\n              return params[this.params.param.name] = this.interpreter.numberValueOf(this.params.numberValue).toString();\n          }\n          break;\n        case 1:\n          switch (this.params.param.type) {\n            case 0:\n              value = this.interpreter.booleanValueOf(this.params.switchValue);\n              return params[this.params.param.name] = value ? 1 : 0;\n            case 1:\n              return params[this.params.param.name] = this.interpreter.booleanValueOf(this.params.switchValue);\n            case 2:\n              value = this.interpreter.booleanValueOf(this.params.switchValue);\n              return params[this.params.param.name] = value ? \"ON\" : \"OFF\";\n          }\n          break;\n        case 2:\n          switch (this.params.param.type) {\n            case 0:\n              value = this.interpreter.stringValueOf(this.params.textValue);\n              return params[this.params.param.name] = value.length;\n            case 1:\n              return params[this.params.param.name] = this.interpreter.stringValueOf(this.params.textValue) === \"ON\";\n            case 2:\n              return params[this.params.param.name] = this.interpreter.stringValueOf(this.params.textValue);\n          }\n      }\n    };\n\n\n    /**\n    * @method commandCharacterGetParameter\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandCharacterGetParameter = function() {\n      var params, value;\n      params = GameManager.characterParams[this.interpreter.stringValueOf(this.params.characterId)];\n      if ((params == null) || (this.params.param == null)) {\n        return;\n      }\n      value = params[this.params.param.name];\n      switch (this.params.valueType) {\n        case 0:\n          switch (this.params.param.type) {\n            case 0:\n              return this.interpreter.setNumberValueTo(this.params.targetVariable, value);\n            case 1:\n              return this.interpreter.setNumberValueTo(this.params.targetVariable, value ? 1 : 0);\n            case 2:\n              return this.interpreter.setNumberValueTo(this.params.targetVariable, value != null ? value.length : 0);\n          }\n          break;\n        case 1:\n          switch (this.params.param.type) {\n            case 0:\n              return this.interpreter.setBooleanValueTo(this.params.targetVariable, value > 0);\n            case 1:\n              return this.interpreter.setBooleanValueTo(this.params.targetVariable, value);\n            case 2:\n              return this.interpreter.setBooleanValueTo(this.params.targetVariable, value === \"ON\");\n          }\n          break;\n        case 2:\n          switch (this.params.param.type) {\n            case 0:\n              return this.interpreter.setStringValueTo(this.params.targetVariable, value != null ? value.toString() : \"\");\n            case 1:\n              return this.interpreter.setStringValueTo(this.params.targetVariable, value ? \"ON\" : \"OFF\");\n            case 2:\n              return this.interpreter.setStringValueTo(this.params.targetVariable, value);\n          }\n      }\n    };\n\n\n    /**\n    * @method commandCharacterMotionBlur\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandCharacterMotionBlur = function() {\n      var character, characterId, scene;\n      scene = SceneManager.scene;\n      characterId = this.interpreter.stringValueOf(this.params.characterId);\n      character = scene.characters.first((function(_this) {\n        return function(v) {\n          return !v.disposed && v.rid === characterId;\n        };\n      })(this));\n      if (character == null) {\n        return;\n      }\n      return character.motionBlur.set(this.params.motionBlur);\n    };\n\n\n    /**\n    * @method commandCharacterDefaults\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandCharacterDefaults = function() {\n      var defaults, flags, isLocked;\n      defaults = GameManager.defaults.character;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      if (!isLocked(flags.appearDuration)) {\n        defaults.appearDuration = this.interpreter.durationValueOf(this.params.appearDuration);\n      }\n      if (!isLocked(flags.disappearDuration)) {\n        defaults.disappearDuration = this.interpreter.durationValueOf(this.params.disappearDuration);\n      }\n      if (!isLocked(flags.expressionDuration)) {\n        defaults.expressionDuration = this.interpreter.durationValueOf(this.params.expressionDuration);\n      }\n      if (!isLocked(flags.zOrder)) {\n        defaults.zOrder = this.interpreter.numberValueOf(this.params.zOrder);\n      }\n      if (!isLocked(flags[\"appearEasing.type\"])) {\n        defaults.appearEasing = this.params.appearEasing;\n      }\n      if (!isLocked(flags[\"appearAnimation.type\"])) {\n        defaults.appearAnimation = this.params.appearAnimation;\n      }\n      if (!isLocked(flags[\"disappearEasing.type\"])) {\n        defaults.disappearEasing = this.params.disappearEasing;\n      }\n      if (!isLocked(flags[\"disappearAnimation.type\"])) {\n        defaults.disappearAnimation = this.params.disappearAnimation;\n      }\n      if (!isLocked(flags[\"motionBlur.enabled\"])) {\n        defaults.motionBlur = this.params.motionBlur;\n      }\n      if (!isLocked(flags.origin)) {\n        return defaults.origin = this.params.origin;\n      }\n    };\n\n\n    /**\n    * @method commandCharacterEffect\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandCharacterEffect = function() {\n      var character, characterId, scene;\n      scene = SceneManager.scene;\n      characterId = this.interpreter.stringValueOf(this.params.characterId);\n      character = scene.characters.first(function(c) {\n        return !c.disposed && c.rid === characterId;\n      });\n      if (character == null) {\n        return;\n      }\n      this.interpreter.objectEffect(character, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandFlashCharacter\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandFlashCharacter = function() {\n      var character, characterId, duration, scene;\n      scene = SceneManager.scene;\n      characterId = this.interpreter.stringValueOf(this.params.characterId);\n      character = scene.characters.first((function(_this) {\n        return function(v) {\n          return !v.disposed && v.rid === characterId;\n        };\n      })(this));\n      if (!character) {\n        return;\n      }\n      duration = this.interpreter.durationValueOf(this.params.duration);\n      character.animator.flash(new Color(this.params.color), duration);\n      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {\n        this.interpreter.isWaiting = true;\n        this.interpreter.waitCounter = duration;\n      }\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandTintCharacter\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandTintCharacter = function() {\n      var character, characterId, duration, easing, scene;\n      scene = SceneManager.scene;\n      characterId = this.interpreter.stringValueOf(this.params.characterId);\n      character = scene.characters.first((function(_this) {\n        return function(v) {\n          return !v.disposed && v.rid === characterId;\n        };\n      })(this));\n      easing = gs.Easings.fromValues(this.interpreter.numberValueOf(this.params.easing.type), this.params.easing.inOut);\n      if (!character) {\n        return;\n      }\n      duration = this.interpreter.durationValueOf(this.params.duration);\n      character.animator.tintTo(this.params.tone, duration, easing);\n      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {\n        this.interpreter.isWaiting = true;\n        this.interpreter.waitCounter = duration;\n      }\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandZoomCharacter\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandZoomCharacter = function() {\n      var character, characterId, scene;\n      scene = SceneManager.scene;\n      characterId = this.interpreter.stringValueOf(this.params.characterId);\n      character = scene.characters.first((function(_this) {\n        return function(v) {\n          return !v.disposed && v.rid === characterId;\n        };\n      })(this));\n      if (character == null) {\n        return;\n      }\n      this.interpreter.zoomObject(character, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandRotateCharacter\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandRotateCharacter = function() {\n      var character, characterId, scene;\n      scene = SceneManager.scene;\n      characterId = this.interpreter.stringValueOf(this.params.characterId);\n      character = scene.characters.first((function(_this) {\n        return function(v) {\n          return !v.disposed && v.rid === characterId;\n        };\n      })(this));\n      if (character == null) {\n        return;\n      }\n      this.interpreter.rotateObject(character, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandBlendCharacter\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandBlendCharacter = function() {\n      var character, characterId;\n      characterId = this.interpreter.stringValueOf(this.params.characterId);\n      character = SceneManager.scene.characters.first((function(_this) {\n        return function(v) {\n          return !v.disposed && v.rid === characterId;\n        };\n      })(this));\n      if (character == null) {\n        return;\n      }\n      this.interpreter.blendObject(character, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandShakeCharacter\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandShakeCharacter = function() {\n      var character, characterId;\n      characterId = this.interpreter.stringValueOf(this.params.characterId);\n      character = SceneManager.scene.characters.first((function(_this) {\n        return function(v) {\n          return !v.disposed && v.rid === characterId;\n        };\n      })(this));\n      if (character == null) {\n        return;\n      }\n      this.interpreter.shakeObject(character, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandMaskCharacter\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandMaskCharacter = function() {\n      var character, characterId, scene;\n      scene = SceneManager.scene;\n      characterId = this.interpreter.stringValueOf(this.params.characterId);\n      character = scene.characters.first((function(_this) {\n        return function(v) {\n          return !v.disposed && v.rid === characterId;\n        };\n      })(this));\n      if (character == null) {\n        return;\n      }\n      this.interpreter.maskObject(character, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandMoveCharacter\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandMoveCharacter = function() {\n      var character, characterId, scene;\n      scene = SceneManager.scene;\n      characterId = this.interpreter.stringValueOf(this.params.characterId);\n      character = scene.characters.first((function(_this) {\n        return function(v) {\n          return !v.disposed && v.rid === characterId;\n        };\n      })(this));\n      if (character == null) {\n        return;\n      }\n      this.interpreter.moveObject(character, this.params.position, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandMoveCharacterPath\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandMoveCharacterPath = function() {\n      var character, characterId, scene;\n      scene = SceneManager.scene;\n      characterId = this.interpreter.stringValueOf(this.params.characterId);\n      character = scene.characters.first((function(_this) {\n        return function(v) {\n          return !v.disposed && v.rid === characterId;\n        };\n      })(this));\n      if (character == null) {\n        return;\n      }\n      this.interpreter.moveObjectPath(character, this.params.path, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandShakeBackground\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandShakeBackground = function() {\n      var background;\n      background = SceneManager.scene.backgrounds[this.interpreter.numberValueOf(this.params.layer)];\n      if (background == null) {\n        return;\n      }\n      this.interpreter.shakeObject(background, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandScrollBackground\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandScrollBackground = function() {\n      var duration, easing, horizontalSpeed, layer, ref, scene, verticalSpeed;\n      scene = SceneManager.scene;\n      duration = this.interpreter.durationValueOf(this.params.duration);\n      horizontalSpeed = this.interpreter.numberValueOf(this.params.horizontalSpeed);\n      verticalSpeed = this.interpreter.numberValueOf(this.params.verticalSpeed);\n      easing = gs.Easings.fromValues(this.interpreter.numberValueOf(this.params.easing.type), this.params.easing.inOut);\n      layer = this.interpreter.numberValueOf(this.params.layer);\n      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {\n        this.interpreter.isWaiting = true;\n        this.interpreter.waitCounter = duration;\n      }\n      if ((ref = scene.backgrounds[layer]) != null) {\n        ref.animator.move(horizontalSpeed, verticalSpeed, duration, easing);\n      }\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandScrollBackgroundTo\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandScrollBackgroundTo = function() {\n      var background, duration, easing, layer, p, scene, x, y;\n      scene = SceneManager.scene;\n      duration = this.interpreter.durationValueOf(this.params.duration);\n      x = this.interpreter.numberValueOf(this.params.background.location.x);\n      y = this.interpreter.numberValueOf(this.params.background.location.y);\n      easing = gs.Easings.fromValues(this.interpreter.numberValueOf(this.params.easing.type), this.params.easing.inOut);\n      layer = this.interpreter.numberValueOf(this.params.layer);\n      background = scene.backgrounds[layer];\n      if (!background) {\n        return;\n      }\n      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {\n        this.interpreter.isWaiting = true;\n        this.interpreter.waitCounter = duration;\n      }\n      if (this.params.positionType === 0) {\n        p = this.interpreter.predefinedObjectPosition(this.params.predefinedPositionId, background, this.params);\n        x = p.x;\n        y = p.y;\n      }\n      background.animator.moveTo(x, y, duration, easing);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandScrollBackgroundPath\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandScrollBackgroundPath = function() {\n      var background, scene;\n      scene = SceneManager.scene;\n      background = scene.backgrounds[this.interpreter.numberValueOf(this.params.layer)];\n      if (background == null) {\n        return;\n      }\n      this.interpreter.moveObjectPath(background, this.params.path, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandMaskBackground\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandMaskBackground = function() {\n      var background, scene;\n      scene = SceneManager.scene;\n      background = scene.backgrounds[this.interpreter.numberValueOf(this.params.layer)];\n      if (background == null) {\n        return;\n      }\n      this.interpreter.maskObject(background, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandZoomBackground\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandZoomBackground = function() {\n      var duration, easing, layer, ref, scene, x, y;\n      scene = SceneManager.scene;\n      duration = this.interpreter.durationValueOf(this.params.duration);\n      x = this.interpreter.numberValueOf(this.params.zooming.x);\n      y = this.interpreter.numberValueOf(this.params.zooming.y);\n      easing = gs.Easings.fromValues(this.interpreter.numberValueOf(this.params.easing.type), this.params.easing.inOut);\n      layer = this.interpreter.numberValueOf(this.params.layer);\n      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {\n        this.interpreter.isWaiting = true;\n        this.interpreter.waitCounter = duration;\n      }\n      if ((ref = scene.backgrounds[layer]) != null) {\n        ref.animator.zoomTo(x / 100, y / 100, duration, easing);\n      }\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandRotateBackground\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandRotateBackground = function() {\n      var background, scene;\n      scene = SceneManager.scene;\n      background = scene.backgrounds[this.interpreter.numberValueOf(this.params.layer)];\n      if (background) {\n        this.interpreter.rotateObject(background, this.params);\n      }\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandTintBackground\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandTintBackground = function() {\n      var background, duration, easing, layer, scene;\n      scene = SceneManager.scene;\n      layer = this.interpreter.numberValueOf(this.params.layer);\n      background = scene.backgrounds[layer];\n      if (background == null) {\n        return;\n      }\n      duration = this.interpreter.durationValueOf(this.params.duration);\n      easing = gs.Easings.fromObject(this.params.easing);\n      background.animator.tintTo(this.params.tone, duration, easing);\n      this.interpreter.waitForCompletion(background, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandBlendBackground\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandBlendBackground = function() {\n      var background, layer;\n      layer = this.interpreter.numberValueOf(this.params.layer);\n      background = SceneManager.scene.backgrounds[layer];\n      if (background == null) {\n        return;\n      }\n      this.interpreter.blendObject(background, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandBackgroundEffect\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandBackgroundEffect = function() {\n      var background, layer;\n      layer = this.interpreter.numberValueOf(this.params.layer);\n      background = SceneManager.scene.backgrounds[layer];\n      if (background == null) {\n        return;\n      }\n      this.interpreter.objectEffect(background, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandBackgroundDefaults\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandBackgroundDefaults = function() {\n      var defaults, flags, isLocked;\n      defaults = GameManager.defaults.background;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      if (!isLocked(flags.duration)) {\n        defaults.duration = this.interpreter.durationValueOf(this.params.duration);\n      }\n      if (!isLocked(flags.zOrder)) {\n        defaults.zOrder = this.interpreter.numberValueOf(this.params.zOrder);\n      }\n      if (!isLocked(flags[\"easing.type\"])) {\n        defaults.easing = this.params.easing;\n      }\n      if (!isLocked(flags[\"animation.type\"])) {\n        defaults.animation = this.params.animation;\n      }\n      if (!isLocked(flags.origin)) {\n        defaults.origin = this.params.origin;\n      }\n      if (!isLocked(flags.loopHorizontal)) {\n        defaults.loopHorizontal = this.params.loopHorizontal;\n      }\n      if (!isLocked(flags.loopVertical)) {\n        return defaults.loopVertical = this.params.loopVertical;\n      }\n    };\n\n\n    /**\n    * @method commandBackgroundMotionBlur\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandBackgroundMotionBlur = function() {\n      var background, layer;\n      layer = this.interpreter.numberValueOf(this.params.layer);\n      background = SceneManager.scene.backgrounds[layer];\n      if (background == null) {\n        return;\n      }\n      return background.motionBlur.set(this.params.motionBlur);\n    };\n\n\n    /**\n    * @method commandChangeBackground\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandChangeBackground = function() {\n      var animation, defaults, duration, easing, flags, isLocked, layer, loopH, loopV, origin, ref, scene, zIndex;\n      defaults = GameManager.defaults.background;\n      scene = SceneManager.scene;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.duration;\n      loopH = !isLocked(flags.loopHorizontal) ? this.params.loopHorizontal : defaults.loopHorizontal;\n      loopV = !isLocked(flags.loopVertical) ? this.params.loopVertical : defaults.loopVertical;\n      animation = !isLocked(flags[\"animation.type\"]) ? this.params.animation : defaults.animation;\n      origin = !isLocked(flags.origin) ? this.params.origin : defaults.origin;\n      zIndex = !isLocked(flags.zOrder) ? this.interpreter.numberValueOf(this.params.zOrder) : defaults.zOrder;\n      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {\n        this.interpreter.isWaiting = true;\n        this.interpreter.waitCounter = duration;\n      }\n      easing = !isLocked(flags[\"easing.type\"]) ? gs.Easings.fromObject(this.params.easing) : gs.Easings.fromObject(defaults.easing);\n      layer = this.interpreter.numberValueOf(this.params.layer);\n      scene.behavior.changeBackground(this.params.graphic, false, animation, easing, duration, 0, 0, layer, loopH, loopV);\n      if (scene.backgrounds[layer]) {\n        if (((ref = this.params.viewport) != null ? ref.type : void 0) === \"ui\") {\n          scene.backgrounds[layer].viewport = Graphics.viewport;\n        }\n        scene.backgrounds[layer].anchor.x = origin === 0 ? 0 : 0.5;\n        scene.backgrounds[layer].anchor.y = origin === 0 ? 0 : 0.5;\n        scene.backgrounds[layer].blendMode = this.interpreter.numberValueOf(this.params.blendMode);\n        scene.backgrounds[layer].zIndex = zIndex + layer;\n        if (origin === 1) {\n          scene.backgrounds[layer].dstRect.x = scene.backgrounds[layer].dstRect.x;\n          scene.backgrounds[layer].dstRect.y = scene.backgrounds[layer].dstRect.y;\n        }\n        scene.backgrounds[layer].setup();\n        scene.backgrounds[layer].update();\n      }\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandCallScene\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandCallScene = function() {\n      return this.interpreter.callScene(this.interpreter.stringValueOf(this.params.scene.uid || this.params.scene));\n    };\n\n\n    /**\n    * @method commandChangeScene\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandChangeScene = function() {\n      var flags, isLocked, k, len, len1, n, newScene, picture, ref, ref1, scene, uid, video;\n      if (GameManager.inLivePreview) {\n        return;\n      }\n      GameManager.tempSettings.skip = false;\n      if (!this.params.savePrevious) {\n        SceneManager.clear();\n      }\n      scene = SceneManager.scene;\n      if (!this.params.erasePictures && !this.params.savePrevious) {\n        scene.removeObject(scene.pictureContainer);\n        ref = scene.pictures;\n        for (k = 0, len = ref.length; k < len; k++) {\n          picture = ref[k];\n          if (picture) {\n            ResourceManager.context.remove(\"Graphics/Pictures/\" + picture.image);\n          }\n        }\n      }\n      if (!this.params.eraseTexts && !this.params.savePrevious) {\n        scene.removeObject(scene.textContainer);\n      }\n      if (!this.params.eraseVideos && !this.params.savePrevious) {\n        scene.removeObject(scene.videoContainer);\n        ref1 = scene.videos;\n        for (n = 0, len1 = ref1.length; n < len1; n++) {\n          video = ref1[n];\n          if (video) {\n            ResourceManager.context.remove(\"Movies/\" + video.video);\n          }\n        }\n      }\n      if (this.params.scene) {\n        if (this.params.savePrevious) {\n          GameManager.sceneData = {\n            uid: uid = this.params.scene.uid,\n            pictures: [],\n            texts: [],\n            videos: []\n          };\n        } else {\n          GameManager.sceneData = {\n            uid: uid = this.params.scene.uid,\n            pictures: scene.pictureContainer.subObjectsByDomain,\n            texts: scene.textContainer.subObjectsByDomain,\n            videos: scene.videoContainer.subObjectsByDomain\n          };\n        }\n        flags = this.params.fieldFlags || {};\n        isLocked = gs.CommandFieldFlags.isLocked;\n        newScene = new vn.Object_Scene();\n        if (this.params.savePrevious) {\n          newScene.sceneData = {\n            uid: uid = this.params.scene.uid,\n            pictures: [],\n            texts: [],\n            videos: [],\n            backlog: GameManager.backlog\n          };\n        } else {\n          newScene.sceneData = {\n            uid: uid = this.params.scene.uid,\n            pictures: scene.pictureContainer.subObjectsByDomain,\n            texts: scene.textContainer.subObjectsByDomain,\n            videos: scene.videoContainer.subObjectsByDomain\n          };\n        }\n        SceneManager.switchTo(newScene, this.params.savePrevious, (function(_this) {\n          return function() {\n            return _this.interpreter.isWaiting = false;\n          };\n        })(this));\n      } else {\n        SceneManager.switchTo(null);\n      }\n      return this.interpreter.isWaiting = true;\n    };\n\n\n    /**\n    * @method commandReturnToPreviousScene\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandReturnToPreviousScene = function() {\n      if (GameManager.inLivePreview) {\n        return;\n      }\n      SceneManager.returnToPrevious((function(_this) {\n        return function() {\n          return _this.interpreter.isWaiting = false;\n        };\n      })(this));\n      return this.interpreter.isWaiting = true;\n    };\n\n\n    /**\n    * @method commandSwitchToLayout\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandSwitchToLayout = function() {\n      var scene;\n      if (GameManager.inLivePreview) {\n        return;\n      }\n      if (ui.UIManager.layouts[this.params.layout.name] != null) {\n        scene = new gs.Object_Layout(this.params.layout.name);\n        SceneManager.switchTo(scene, this.params.savePrevious, (function(_this) {\n          return function() {\n            return _this.interpreter.isWaiting = false;\n          };\n        })(this));\n        return this.interpreter.isWaiting = true;\n      }\n    };\n\n\n    /**\n    * @method commandChangeTransition\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandChangeTransition = function() {\n      var flags, isLocked;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      if (!isLocked(flags.duration)) {\n        SceneManager.transitionData.duration = this.interpreter.durationValueOf(this.params.duration);\n      }\n      if (!isLocked(flags.graphic)) {\n        SceneManager.transitionData.graphic = this.params.graphic;\n      }\n      if (!isLocked(flags.vague)) {\n        return SceneManager.transitionData.vague = this.params.vague;\n      }\n    };\n\n\n    /**\n    * @method commandFreezeScreen\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandFreezeScreen = function() {\n      return Graphics.freeze();\n    };\n\n\n    /**\n    * @method commandScreenTransition\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandScreenTransition = function() {\n      var bitmap, defaults, duration, flags, graphicName, isLocked, ref, ref1, vague;\n      defaults = GameManager.defaults.scene;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      graphicName = !isLocked(flags.graphic) ? (ref = this.params.graphic) != null ? ref.name : void 0 : (ref1 = SceneManager.transitionData.graphic) != null ? ref1.name : void 0;\n      if (graphicName) {\n        bitmap = !isLocked(flags.graphic) ? ResourceManager.getBitmap(\"Graphics/Masks/\" + graphicName) : ResourceManager.getBitmap(\"Graphics/Masks/\" + graphicName);\n      }\n      vague = !isLocked(flags.vague) ? this.interpreter.numberValueOf(this.params.vague) : SceneManager.transitionData.vague;\n      duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : SceneManager.transitionData.duration;\n      this.interpreter.isWaiting = !GameManager.inLivePreview;\n      this.interpreter.waitCounter = duration;\n      return Graphics.transition(duration, bitmap, vague);\n    };\n\n\n    /**\n    * @method commandShakeScreen\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandShakeScreen = function() {\n      if (SceneManager.scene.viewport == null) {\n        return;\n      }\n      this.interpreter.shakeObject(SceneManager.scene.viewport, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandTintScreen\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandTintScreen = function() {\n      var duration;\n      duration = this.interpreter.durationValueOf(this.params.duration);\n      SceneManager.scene.viewport.animator.tintTo(new Tone(this.params.tone), duration, gs.Easings.EASE_LINEAR[0]);\n      if (this.params.waitForCompletion && duration > 0) {\n        this.interpreter.isWaiting = true;\n        this.interpreter.waitCounter = duration;\n      }\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandZoomScreen\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandZoomScreen = function() {\n      var duration, easing, scene;\n      easing = gs.Easings.fromObject(this.params.easing);\n      duration = this.interpreter.durationValueOf(this.params.duration);\n      scene = SceneManager.scene;\n      SceneManager.scene.viewport.anchor.x = 0.5;\n      SceneManager.scene.viewport.anchor.y = 0.5;\n      SceneManager.scene.viewport.animator.zoomTo(this.interpreter.numberValueOf(this.params.zooming.x) / 100, this.interpreter.numberValueOf(this.params.zooming.y) / 100, duration, easing);\n      this.interpreter.waitForCompletion(null, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandPanScreen\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandPanScreen = function() {\n      var duration, easing, scene, viewport;\n      scene = SceneManager.scene;\n      duration = this.interpreter.durationValueOf(this.params.duration);\n      easing = gs.Easings.fromObject(this.params.easing);\n      this.interpreter.settings.screen.pan.x -= this.params.position.x;\n      this.interpreter.settings.screen.pan.y -= this.params.position.y;\n      viewport = SceneManager.scene.viewport;\n      viewport.animator.scrollTo(-this.params.position.x + viewport.dstRect.x, -this.params.position.y + viewport.dstRect.y, duration, easing);\n      this.interpreter.waitForCompletion(null, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandRotateScreen\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandRotateScreen = function() {\n      var duration, easing, pan, scene;\n      scene = SceneManager.scene;\n      easing = gs.Easings.fromObject(this.params.easing);\n      duration = this.interpreter.durationValueOf(this.params.duration);\n      pan = this.interpreter.settings.screen.pan;\n      SceneManager.scene.viewport.anchor.x = 0.5;\n      SceneManager.scene.viewport.anchor.y = 0.5;\n      SceneManager.scene.viewport.animator.rotate(this.params.direction, this.interpreter.numberValueOf(this.params.speed) / 100, duration, easing);\n      this.interpreter.waitForCompletion(null, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandFlashScreen\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandFlashScreen = function() {\n      var duration;\n      duration = this.interpreter.durationValueOf(this.params.duration);\n      SceneManager.scene.viewport.animator.flash(new Color(this.params.color), duration, gs.Easings.EASE_LINEAR[0]);\n      if (this.params.waitForCompletion && duration !== 0) {\n        this.interpreter.isWaiting = true;\n        this.interpreter.waitCounter = duration;\n      }\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandScreenEffect\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandScreenEffect = function() {\n      var duration, easing, flags, isLocked, scene, viewport, wobble, zOrder;\n      scene = SceneManager.scene;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      duration = this.interpreter.durationValueOf(this.params.duration);\n      easing = gs.Easings.fromObject(this.params.easing);\n      if (!gs.CommandFieldFlags.isLocked(flags.zOrder)) {\n        zOrder = this.interpreter.numberValueOf(this.params.zOrder);\n      } else {\n        zOrder = SceneManager.scene.viewport.zIndex;\n      }\n      viewport = scene.viewportContainer.subObjects.first(function(v) {\n        return v.zIndex === zOrder;\n      });\n      if (!viewport) {\n        viewport = new gs.Object_Viewport();\n        viewport.zIndex = zOrder;\n        scene.viewportContainer.addObject(viewport);\n      }\n      switch (this.params.type) {\n        case 0:\n          viewport.animator.wobbleTo(this.params.wobble.power / 10000, this.params.wobble.speed / 100, duration, easing);\n          wobble = viewport.effects.wobble;\n          wobble.enabled = this.params.wobble.power > 0;\n          wobble.vertical = this.params.wobble.orientation === 0 || this.params.wobble.orientation === 2;\n          wobble.horizontal = this.params.wobble.orientation === 1 || this.params.wobble.orientation === 2;\n          break;\n        case 1:\n          viewport.animator.blurTo(this.params.blur.power / 100, duration, easing);\n          viewport.effects.blur.enabled = true;\n          break;\n        case 2:\n          viewport.animator.pixelateTo(this.params.pixelate.size.width, this.params.pixelate.size.height, duration, easing);\n          viewport.effects.pixelate.enabled = true;\n      }\n      if (this.params.waitForCompletion && duration !== 0) {\n        this.interpreter.isWaiting = true;\n        this.interpreter.waitCounter = duration;\n      }\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandVideoDefaults\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandVideoDefaults = function() {\n      var defaults, flags, isLocked;\n      defaults = GameManager.defaults.video;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      if (!isLocked(flags.appearDuration)) {\n        defaults.appearDuration = this.interpreter.durationValueOf(this.params.appearDuration);\n      }\n      if (!isLocked(flags.disappearDuration)) {\n        defaults.disappearDuration = this.interpreter.durationValueOf(this.params.disappearDuration);\n      }\n      if (!isLocked(flags.zOrder)) {\n        defaults.zOrder = this.interpreter.numberValueOf(this.params.zOrder);\n      }\n      if (!isLocked(flags[\"appearEasing.type\"])) {\n        defaults.appearEasing = this.params.appearEasing;\n      }\n      if (!isLocked(flags[\"appearAnimation.type\"])) {\n        defaults.appearAnimation = this.params.appearAnimation;\n      }\n      if (!isLocked(flags[\"disappearEasing.type\"])) {\n        defaults.disappearEasing = this.params.disappearEasing;\n      }\n      if (!isLocked(flags[\"disappearAnimation.type\"])) {\n        defaults.disappearAnimation = this.params.disappearAnimation;\n      }\n      if (!isLocked(flags[\"motionBlur.enabled\"])) {\n        defaults.motionBlur = this.params.motionBlur;\n      }\n      if (!isLocked(flags.origin)) {\n        return defaults.origin = this.params.origin;\n      }\n    };\n\n\n    /**\n    * @method commandShowVideo\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandShowVideo = function() {\n      var animation, defaults, duration, easing, flags, isLocked, number, origin, p, ref, ref1, ref2, scene, video, videos, x, y, zIndex;\n      defaults = GameManager.defaults.video;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      scene = SceneManager.scene;\n      scene.behavior.changeVideoDomain(this.params.numberDomain);\n      number = this.interpreter.numberValueOf(this.params.number);\n      videos = scene.videos;\n      if (videos[number] == null) {\n        videos[number] = new gs.Object_Video();\n      }\n      x = this.interpreter.numberValueOf(this.params.position.x);\n      y = this.interpreter.numberValueOf(this.params.position.y);\n      easing = !isLocked(flags[\"easing.type\"]) ? gs.Easings.fromValues(this.interpreter.numberValueOf(this.params.easing.type), this.params.easing.inOut) : gs.Easings.fromObject(defaults.appearEasing);\n      duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.appearDuration;\n      origin = !isLocked(flags.origin) ? this.params.origin : defaults.origin;\n      zIndex = !isLocked(flags.zOrder) ? this.interpreter.numberValueOf(this.params.zOrder) : defaults.zOrder;\n      animation = !isLocked(flags[\"animation.type\"]) ? this.params.animation : defaults.appearAnimation;\n      video = videos[number];\n      video.domain = this.params.numberDomain;\n      video.video = (ref = this.params.video) != null ? ref.name : void 0;\n      video.loop = (ref1 = this.params.loop) != null ? ref1 : true;\n      video.dstRect.x = x;\n      video.dstRect.y = y;\n      video.blendMode = this.interpreter.numberValueOf(this.params.blendMode);\n      video.anchor.x = origin === 0 ? 0 : 0.5;\n      video.anchor.y = origin === 0 ? 0 : 0.5;\n      video.zIndex = zIndex || (1000 + number);\n      if (((ref2 = this.params.viewport) != null ? ref2.type : void 0) === \"scene\") {\n        video.viewport = SceneManager.scene.behavior.viewport;\n      }\n      video.update();\n      if (this.params.positionType === 0) {\n        p = this.interpreter.predefinedObjectPosition(this.params.predefinedPositionId, video, this.params);\n        video.dstRect.x = p.x;\n        video.dstRect.y = p.y;\n      }\n      video.animator.appear(x, y, animation, easing, duration);\n      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {\n        this.interpreter.isWaiting = true;\n        this.interpreter.waitCounter = duration;\n      }\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandMoveVideo\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandMoveVideo = function() {\n      var number, scene, video;\n      scene = SceneManager.scene;\n      scene.behavior.changeVideoDomain(this.params.numberDomain);\n      number = this.interpreter.numberValueOf(this.params.number);\n      video = scene.videos[number];\n      if (video == null) {\n        return;\n      }\n      this.interpreter.moveObject(video, this.params.picture.position, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandMoveVideoPath\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandMoveVideoPath = function() {\n      var number, scene, video;\n      scene = SceneManager.scene;\n      scene.behavior.changeVideoDomain(this.params.numberDomain);\n      number = this.interpreter.numberValueOf(this.params.number);\n      video = scene.videos[number];\n      if (video == null) {\n        return;\n      }\n      this.interpreter.moveObjectPath(video, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandRotateVideo\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandRotateVideo = function() {\n      var number, scene, video;\n      scene = SceneManager.scene;\n      scene.behavior.changeVideoDomain(this.params.numberDomain);\n      number = this.interpreter.numberValueOf(this.params.number);\n      video = scene.videos[number];\n      if (video == null) {\n        return;\n      }\n      this.interpreter.rotateObject(video, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandZoomVideo\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandZoomVideo = function() {\n      var number, scene, video;\n      scene = SceneManager.scene;\n      scene.behavior.changeVideoDomain(this.params.numberDomain);\n      number = this.interpreter.numberValueOf(this.params.number);\n      video = scene.videos[number];\n      if (video == null) {\n        return;\n      }\n      this.interpreter.zoomObject(video, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandBlendVideo\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandBlendVideo = function() {\n      var video;\n      SceneManager.scene.behavior.changeVideoDomain(this.params.numberDomain);\n      video = SceneManager.scene.videos[this.interpreter.numberValueOf(this.params.number)];\n      if (video == null) {\n        return;\n      }\n      this.interpreter.blendObject(video, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandTintVideo\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandTintVideo = function() {\n      var number, scene, video;\n      scene = SceneManager.scene;\n      scene.behavior.changeVideoDomain(this.params.numberDomain);\n      number = this.interpreter.numberValueOf(this.params.number);\n      video = scene.videos[number];\n      if (video == null) {\n        return;\n      }\n      this.interpreter.tintObject(video, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandFlashVideo\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandFlashVideo = function() {\n      var number, scene, video;\n      scene = SceneManager.scene;\n      scene.behavior.changeVideoDomain(this.params.numberDomain);\n      number = this.interpreter.numberValueOf(this.params.number);\n      video = scene.videos[number];\n      if (video == null) {\n        return;\n      }\n      this.interpreter.flashObject(video, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandCropVideo\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandCropVideo = function() {\n      var number, scene, video;\n      scene = SceneManager.scene;\n      scene.behavior.changeVideoDomain(this.params.numberDomain);\n      number = this.interpreter.numberValueOf(this.params.number);\n      video = scene.videos[number];\n      if (video == null) {\n        return;\n      }\n      return this.interpreter.cropObject(video, this.params);\n    };\n\n\n    /**\n    * @method commandVideoMotionBlur\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandVideoMotionBlur = function() {\n      var number, scene, video;\n      scene = SceneManager.scene;\n      scene.behavior.changeVideoDomain(this.params.numberDomain);\n      number = this.interpreter.numberValueOf(this.params.number);\n      video = scene.videos[number];\n      if (video == null) {\n        return;\n      }\n      return this.interpreter.objectMotionBlur(video, this.params);\n    };\n\n\n    /**\n    * @method commandMaskVideo\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandMaskVideo = function() {\n      var number, scene, video;\n      scene = SceneManager.scene;\n      scene.behavior.changeVideoDomain(this.params.numberDomain);\n      number = this.interpreter.numberValueOf(this.params.number);\n      video = scene.videos[number];\n      if (video == null) {\n        return;\n      }\n      this.interpreter.maskObject(video, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandVideoEffect\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandVideoEffect = function() {\n      var number, scene, video;\n      scene = SceneManager.scene;\n      scene.behavior.changeVideoDomain(this.params.numberDomain);\n      number = this.interpreter.numberValueOf(this.params.number);\n      video = scene.videos[number];\n      if (video == null) {\n        return;\n      }\n      this.interpreter.objectEffect(video, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandEraseVideo\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandEraseVideo = function() {\n      var animation, defaults, duration, easing, flags, isLocked, number, scene, video;\n      defaults = GameManager.defaults.video;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      scene = SceneManager.scene;\n      scene.behavior.changeVideoDomain(this.params.numberDomain);\n      number = this.interpreter.numberValueOf(this.params.number);\n      video = scene.videos[number];\n      if (video == null) {\n        return;\n      }\n      easing = !isLocked(flags[\"easing.type\"]) ? gs.Easings.fromValues(this.interpreter.numberValueOf(this.params.easing.type), this.params.easing.inOut) : gs.Easings.fromObject(defaults.disappearEasing);\n      duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.disappearDuration;\n      animation = !isLocked(flags[\"animation.type\"]) ? this.params.animation : defaults.disappearAnimation;\n      video.animator.disappear(animation, easing, duration, (function(_this) {\n        return function(sender) {\n          sender.dispose();\n          scene.behavior.changeTextDomain(sender.domain);\n          return scene.videos[number] = null;\n        };\n      })(this));\n      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {\n        this.interpreter.isWaiting = true;\n        this.interpreter.waitCounter = duration;\n      }\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandShowImageMap\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandShowImageMap = function() {\n      var bitmap, flags, imageMap, isLocked, number, p, ref, ref1, ref2, ref3, ref4, ref5;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      SceneManager.scene.behavior.changePictureDomain(this.params.numberDomain);\n      number = this.interpreter.numberValueOf(this.params.number);\n      imageMap = SceneManager.scene.pictures[number];\n      if (imageMap != null) {\n        imageMap.dispose();\n      }\n      imageMap = new gs.Object_ImageMap();\n      imageMap.visual.variableContext = this.interpreter.context;\n      SceneManager.scene.pictures[number] = imageMap;\n      bitmap = ResourceManager.getBitmap(\"Graphics/Pictures/\" + ((ref = this.params.ground) != null ? ref.name : void 0));\n      imageMap.dstRect.width = bitmap.width;\n      imageMap.dstRect.height = bitmap.height;\n      if (this.params.positionType === 0) {\n        p = this.interpreter.predefinedObjectPosition(this.params.predefinedPositionId, imageMap, this.params);\n        imageMap.dstRect.x = p.x;\n        imageMap.dstRect.y = p.y;\n      } else {\n        imageMap.dstRect.x = this.interpreter.numberValueOf(this.params.position.x);\n        imageMap.dstRect.y = this.interpreter.numberValueOf(this.params.position.y);\n      }\n      imageMap.anchor.x = this.params.origin === 1 ? 0.5 : 0;\n      imageMap.anchor.y = this.params.origin === 1 ? 0.5 : 0;\n      imageMap.zIndex = !isLocked(flags.zOrder) ? this.interpreter.numberValueOf(this.params.zOrder) : 700 + number;\n      imageMap.blendMode = !isLocked(flags.blendMode) ? this.params.blendMode : 0;\n      imageMap.hotspots = this.params.hotspots;\n      imageMap.images = [(ref1 = this.params.ground) != null ? ref1.name : void 0, (ref2 = this.params.hover) != null ? ref2.name : void 0, (ref3 = this.params.unselected) != null ? ref3.name : void 0, (ref4 = this.params.selected) != null ? ref4.name : void 0, (ref5 = this.params.selectedHover) != null ? ref5.name : void 0];\n      imageMap.events.on(\"jumpTo\", gs.CallBack(\"onJumpTo\", this.interpreter));\n      imageMap.events.on(\"callCommonEvent\", gs.CallBack(\"onCallCommonEvent\", this.interpreter));\n      imageMap.setup();\n      imageMap.update();\n      this.interpreter.showObject(imageMap, {\n        x: 0,\n        y: 0\n      }, this.params);\n      if (this.params.waitForCompletion) {\n        this.interpreter.waitCounter = 0;\n        this.interpreter.isWaiting = true;\n      }\n      imageMap.events.on(\"finish\", (function(_this) {\n        return function(sender) {\n          return _this.interpreter.isWaiting = false;\n        };\n      })(this));\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandEraseImageMap\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandEraseImageMap = function() {\n      var imageMap, number, scene;\n      scene = SceneManager.scene;\n      scene.behavior.changePictureDomain(this.params.numberDomain);\n      number = this.interpreter.numberValueOf(this.params.number);\n      imageMap = scene.pictures[number];\n      if (imageMap == null) {\n        return;\n      }\n      imageMap.events.emit(\"finish\", imageMap);\n      imageMap.visual.active = false;\n      this.interpreter.eraseObject(imageMap, this.params, (function(_this) {\n        return function(sender) {\n          scene.behavior.changePictureDomain(sender.domain);\n          return scene.pictures[number] = null;\n        };\n      })(this));\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandAddHotspot\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandAddHotspot = function() {\n      var dragging, hotspot, hotspots, number, picture, ref, ref1, ref2, ref3, ref4, ref5, scene, text;\n      scene = SceneManager.scene;\n      scene.behavior.changeHotspotDomain(this.params.numberDomain);\n      number = this.interpreter.numberValueOf(this.params.number);\n      hotspots = scene.hotspots;\n      if (hotspots[number] == null) {\n        hotspots[number] = new gs.Object_Hotspot();\n      }\n      hotspot = hotspots[number];\n      hotspot.domain = this.params.numberDomain;\n      hotspot.data = {\n        params: this.params,\n        bindValue: this.interpreter.numberValueOf(this.params.actions.onDrag.bindValue)\n      };\n      switch (this.params.positionType) {\n        case 0:\n          hotspot.dstRect.x = this.params.box.x;\n          hotspot.dstRect.y = this.params.box.y;\n          hotspot.dstRect.width = this.params.box.size.width;\n          hotspot.dstRect.height = this.params.box.size.height;\n          break;\n        case 1:\n          hotspot.dstRect.x = this.interpreter.numberValueOf(this.params.box.x);\n          hotspot.dstRect.y = this.interpreter.numberValueOf(this.params.box.y);\n          hotspot.dstRect.width = this.interpreter.numberValueOf(this.params.box.size.width);\n          hotspot.dstRect.height = this.interpreter.numberValueOf(this.params.box.size.height);\n          break;\n        case 2:\n          picture = scene.pictures[this.interpreter.numberValueOf(this.params.pictureNumber)];\n          if (picture != null) {\n            hotspot.target = picture;\n          }\n          break;\n        case 3:\n          text = scene.texts[this.interpreter.numberValueOf(this.params.textNumber)];\n          if (text != null) {\n            hotspot.target = text;\n          }\n      }\n      hotspot.behavior.shape = (ref = this.params.shape) != null ? ref : gs.HotspotShape.RECTANGLE;\n      if (text != null) {\n        hotspot.images = null;\n      } else {\n        hotspot.images = [((ref1 = this.params.baseGraphic) != null ? ref1.name : void 0) || this.interpreter.stringValueOf(this.params.baseGraphic) || (picture != null ? picture.image : void 0), ((ref2 = this.params.hoverGraphic) != null ? ref2.name : void 0) || this.interpreter.stringValueOf(this.params.hoverGraphic), ((ref3 = this.params.selectedGraphic) != null ? ref3.name : void 0) || this.interpreter.stringValueOf(this.params.selectedGraphic), ((ref4 = this.params.selectedHoverGraphic) != null ? ref4.name : void 0) || this.interpreter.stringValueOf(this.params.selectedHoverGraphic), ((ref5 = this.params.unselectedGraphic) != null ? ref5.name : void 0) || this.interpreter.stringValueOf(this.params.unselectedGraphic)];\n      }\n      if (this.params.actions.onClick.type !== 0 || this.params.actions.onClick.label) {\n        hotspot.events.on(\"click\", gs.CallBack(\"onHotspotClick\", this.interpreter, {\n          params: this.params,\n          bindValue: this.interpreter.numberValueOf(this.params.actions.onClick.bindValue)\n        }));\n      }\n      if (this.params.actions.onEnter.type !== 0 || this.params.actions.onEnter.label) {\n        hotspot.events.on(\"enter\", gs.CallBack(\"onHotspotEnter\", this.interpreter, {\n          params: this.params,\n          bindValue: this.interpreter.numberValueOf(this.params.actions.onEnter.bindValue)\n        }));\n      }\n      if (this.params.actions.onLeave.type !== 0 || this.params.actions.onLeave.label) {\n        hotspot.events.on(\"leave\", gs.CallBack(\"onHotspotLeave\", this.interpreter, {\n          params: this.params,\n          bindValue: this.interpreter.numberValueOf(this.params.actions.onLeave.bindValue)\n        }));\n      }\n      if (this.params.actions.onDrag.type !== 0 || this.params.actions.onDrag.label) {\n        hotspot.events.on(\"dragStart\", gs.CallBack(\"onHotspotDragStart\", this.interpreter, {\n          params: this.params,\n          bindValue: this.interpreter.numberValueOf(this.params.actions.onDrag.bindValue)\n        }));\n        hotspot.events.on(\"drag\", gs.CallBack(\"onHotspotDrag\", this.interpreter, {\n          params: this.params,\n          bindValue: this.interpreter.numberValueOf(this.params.actions.onDrag.bindValue)\n        }));\n        hotspot.events.on(\"dragEnd\", gs.CallBack(\"onHotspotDragEnd\", this.interpreter, {\n          params: this.params,\n          bindValue: this.interpreter.numberValueOf(this.params.actions.onDrag.bindValue)\n        }));\n      }\n      if (this.params.actions.onSelect.type !== 0 || this.params.actions.onSelect.label || this.params.actions.onDeselect.type !== 0 || this.params.actions.onDeselect.label) {\n        hotspot.events.on(\"stateChanged\", gs.CallBack(\"onHotspotStateChanged\", this.interpreter, this.params));\n      }\n      if (this.params.dragging.enabled) {\n        hotspot.events.on(\"dragEnd\", gs.CallBack(\"onHotspotDrop\", this.interpreter, {\n          params: this.params,\n          bindValue: this.interpreter.numberValueOf(this.params.actions.onDrag.bindValue)\n        }));\n      }\n      if (this.params.actions.onDropReceive.type !== 0 || this.params.actions.onDropReceive.label) {\n        hotspot.events.on(\"dropReceived\", gs.CallBack(\"onHotspotDropReceived\", this.interpreter, {\n          params: this.params,\n          bindValue: this.interpreter.numberValueOf(this.params.actions.onDrag.bindValue)\n        }));\n      }\n      hotspot.selectable = true;\n      if (this.params.dragging.enabled) {\n        dragging = this.params.dragging;\n        hotspot.draggable = {\n          rect: new Rect(dragging.rect.x, dragging.rect.y, dragging.rect.size.width, dragging.rect.size.height),\n          axisX: dragging.horizontal,\n          axisY: dragging.vertical\n        };\n        hotspot.addComponent(new ui.Component_Draggable());\n        hotspot.events.on(\"drag\", (function(_this) {\n          return function(e) {\n            var drag;\n            drag = e.sender.draggable;\n            GameManager.variableStore.setupTempVariables(_this.interpreter.context);\n            if (_this.params.dragging.horizontal) {\n              return _this.interpreter.setNumberValueTo(_this.params.dragging.variable, Math.round((e.sender.dstRect.x - drag.rect.x) / (drag.rect.width - e.sender.dstRect.width) * 100));\n            } else {\n              return _this.interpreter.setNumberValueTo(_this.params.dragging.variable, Math.round((e.sender.dstRect.y - drag.rect.y) / (drag.rect.height - e.sender.dstRect.height) * 100));\n            }\n          };\n        })(this));\n      }\n      return hotspot.setup();\n    };\n\n\n    /**\n    * @method commandChangeHotspotState\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandChangeHotspotState = function() {\n      var flags, hotspot, isLocked, number, scene;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      scene = SceneManager.scene;\n      scene.behavior.changeHotspotDomain(this.params.numberDomain);\n      number = this.interpreter.numberValueOf(this.params.number);\n      hotspot = scene.hotspots[number];\n      if (!hotspot) {\n        return;\n      }\n      if (!isLocked(flags.selected)) {\n        hotspot.behavior.selected = this.interpreter.booleanValueOf(this.params.selected);\n      }\n      if (!isLocked(flags.enabled)) {\n        hotspot.behavior.enabled = this.interpreter.booleanValueOf(this.params.enabled);\n      }\n      hotspot.behavior.updateInput();\n      return hotspot.behavior.updateImage();\n    };\n\n\n    /**\n    * @method commandEraseHotspot\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandEraseHotspot = function() {\n      var number, scene;\n      scene = SceneManager.scene;\n      scene.behavior.changeHotspotDomain(this.params.numberDomain);\n      number = this.interpreter.numberValueOf(this.params.number);\n      if (scene.hotspots[number] != null) {\n        scene.hotspots[number].dispose();\n        return scene.hotspotContainer.eraseObject(number);\n      }\n    };\n\n\n    /**\n    * @method commandChangeObjectDomain\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandChangeObjectDomain = function() {\n      return SceneManager.scene.behavior.changeObjectDomain(this.interpreter.stringValueOf(this.params.domain));\n    };\n\n\n    /**\n    * @method commandPictureDefaults\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandPictureDefaults = function() {\n      var defaults, flags, isLocked;\n      defaults = GameManager.defaults.picture;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      if (!isLocked(flags.appearDuration)) {\n        defaults.appearDuration = this.interpreter.durationValueOf(this.params.appearDuration);\n      }\n      if (!isLocked(flags.disappearDuration)) {\n        defaults.disappearDuration = this.interpreter.durationValueOf(this.params.disappearDuration);\n      }\n      if (!isLocked(flags.zOrder)) {\n        defaults.zOrder = this.interpreter.numberValueOf(this.params.zOrder);\n      }\n      if (!isLocked(flags[\"appearEasing.type\"])) {\n        defaults.appearEasing = this.params.appearEasing;\n      }\n      if (!isLocked(flags[\"appearAnimation.type\"])) {\n        defaults.appearAnimation = this.params.appearAnimation;\n      }\n      if (!isLocked(flags[\"disappearEasing.type\"])) {\n        defaults.disappearEasing = this.params.disappearEasing;\n      }\n      if (!isLocked(flags[\"disappearAnimation.type\"])) {\n        defaults.disappearAnimation = this.params.disappearAnimation;\n      }\n      if (!isLocked(flags[\"motionBlur.enabled\"])) {\n        defaults.motionBlur = this.params.motionBlur;\n      }\n      if (!isLocked(flags.origin)) {\n        return defaults.origin = this.params.origin;\n      }\n    };\n\n    Component_CommandInterpreter.prototype.createPicture = function(graphic, params) {\n      var animation, bitmap, defaults, duration, easing, flags, graphicName, isLocked, number, origin, picture, pictures, ref, ref1, ref2, ref3, ref4, ref5, ref6, scene, snapshot, x, y, zIndex;\n      graphic = this.stringValueOf(graphic);\n      graphicName = (graphic != null ? graphic.name : void 0) != null ? graphic.name : graphic;\n      bitmap = ResourceManager.getBitmap(\"Graphics/Pictures/\" + graphicName);\n      if (bitmap && !bitmap.loaded) {\n        return null;\n      }\n      defaults = GameManager.defaults.picture;\n      flags = params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      scene = SceneManager.scene;\n      number = this.numberValueOf(params.number);\n      pictures = scene.pictures;\n      picture = pictures[number];\n      if (picture == null) {\n        picture = new gs.Object_Picture(null, null, (ref = params.visual) != null ? ref.type : void 0);\n        picture.domain = params.numberDomain;\n        pictures[number] = picture;\n        switch ((ref1 = params.visual) != null ? ref1.type : void 0) {\n          case 1:\n            picture.visual.looping.vertical = true;\n            picture.visual.looping.horizontal = true;\n            break;\n          case 2:\n            picture.frameThickness = params.visual.frame.thickness;\n            picture.frameCornerSize = params.visual.frame.cornerSize;\n            break;\n          case 3:\n            picture.visual.orientation = params.visual.threePartImage.orientation;\n            break;\n          case 4:\n            picture.color = gs.Color.fromObject(params.visual.quad.color);\n            break;\n          case 5:\n            snapshot = Graphics.snapshot();\n            picture.bitmap = snapshot;\n            picture.dstRect.width = snapshot.width;\n            picture.dstRect.height = snapshot.height;\n            picture.srcRect.set(0, 0, snapshot.width, snapshot.height);\n        }\n      } else {\n        picture.bitmap = null;\n      }\n      x = this.numberValueOf(params.position.x);\n      y = this.numberValueOf(params.position.y);\n      picture = pictures[number];\n      if (!picture.bitmap) {\n        picture.image = graphicName;\n      } else {\n        picture.image = null;\n      }\n      bitmap = (ref2 = picture.bitmap) != null ? ref2 : ResourceManager.getBitmap(\"Graphics/Pictures/\" + graphicName);\n      easing = !isLocked(flags[\"easing.type\"]) ? gs.Easings.fromValues(this.numberValueOf(params.easing.type), params.easing.inOut) : gs.Easings.fromObject(defaults.appearEasing);\n      duration = !isLocked(flags.duration) ? this.durationValueOf(params.duration) : defaults.appearDuration;\n      origin = !isLocked(flags.origin) ? params.origin : defaults.origin;\n      zIndex = !isLocked(flags.zOrder) ? this.numberValueOf(params.zOrder) : defaults.zOrder;\n      animation = !isLocked(flags[\"animation.type\"]) ? params.animation : defaults.appearAnimation;\n      picture.mirror = params.position.horizontalFlip;\n      picture.angle = params.position.angle || 0;\n      picture.zoom.x = ((ref3 = params.position.data) != null ? ref3.zoom : void 0) || 1;\n      picture.zoom.y = ((ref4 = params.position.data) != null ? ref4.zoom : void 0) || 1;\n      picture.blendMode = this.numberValueOf(params.blendMode);\n      if (params.origin === 1 && (bitmap != null)) {\n        x += (bitmap.width * picture.zoom.x - bitmap.width) / 2;\n        y += (bitmap.height * picture.zoom.y - bitmap.height) / 2;\n      }\n      picture.dstRect.x = x;\n      picture.dstRect.y = y;\n      picture.anchor.x = origin === 1 ? 0.5 : 0;\n      picture.anchor.y = origin === 1 ? 0.5 : 0;\n      picture.zIndex = zIndex || (700 + number);\n      if (((ref5 = params.viewport) != null ? ref5.type : void 0) === \"scene\") {\n        picture.viewport = SceneManager.scene.behavior.viewport;\n      }\n      if (((ref6 = params.size) != null ? ref6.type : void 0) === 1) {\n        picture.dstRect.width = this.numberValueOf(params.size.width);\n        picture.dstRect.height = this.numberValueOf(params.size.height);\n      }\n      picture.update();\n      return picture;\n    };\n\n\n    /**\n    * @method commandShowPicture\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandShowPicture = function() {\n      var animation, defaults, duration, easing, flags, isLocked, p, picture;\n      SceneManager.scene.behavior.changePictureDomain(this.params.numberDomain || \"\");\n      defaults = GameManager.defaults.picture;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      picture = this.interpreter.createPicture(this.params.graphic, this.params);\n      if (!picture) {\n        this.interpreter.pointer--;\n        this.interpreter.isWaiting = true;\n        this.interpreter.waitCounter = 1;\n        return;\n      }\n      if (this.params.positionType === 0) {\n        p = this.interpreter.predefinedObjectPosition(this.params.predefinedPositionId, picture, this.params);\n        picture.dstRect.x = p.x;\n        picture.dstRect.y = p.y;\n      }\n      easing = !isLocked(flags[\"easing.type\"]) ? gs.Easings.fromValues(this.interpreter.numberValueOf(this.params.easing.type), this.params.easing.inOut) : gs.Easings.fromObject(defaults.appearEasing);\n      duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.appearDuration;\n      animation = !isLocked(flags[\"animation.type\"]) ? this.params.animation : defaults.appearAnimation;\n      picture.animator.appear(picture.dstRect.x, picture.dstRect.y, animation, easing, duration);\n      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {\n        this.interpreter.isWaiting = true;\n        this.interpreter.waitCounter = duration;\n      }\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandPlayPictureAnimation\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandPlayPictureAnimation = function() {\n      var animation, bitmap, component, defaults, duration, easing, flags, isLocked, p, picture, record;\n      SceneManager.scene.behavior.changePictureDomain(this.params.numberDomain || \"\");\n      defaults = GameManager.defaults.picture;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      picture = null;\n      easing = !isLocked(flags[\"easing.type\"]) ? gs.Easings.fromValues(this.interpreter.numberValueOf(this.params.easing.type), this.params.easing.inOut) : gs.Easings.fromObject(defaults.appearEasing);\n      duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.appearDuration;\n      animation = !isLocked(flags[\"animation.type\"]) ? this.params.animation : defaults.appearAnimation;\n      if (this.params.animationId != null) {\n        record = RecordManager.animations[this.params.animationId];\n        if (record != null) {\n          picture = this.interpreter.createPicture(record.graphic, this.params);\n          component = picture.findComponent(\"Component_FrameAnimation\");\n          if (component != null) {\n            component.refresh(record);\n            component.start();\n          } else {\n            component = new gs.Component_FrameAnimation(record);\n            picture.addComponent(component);\n          }\n          component.update();\n          if (this.params.positionType === 0) {\n            p = this.interpreter.predefinedObjectPosition(this.params.predefinedPositionId, picture, this.params);\n            picture.dstRect.x = p.x;\n            picture.dstRect.y = p.y;\n          }\n          picture.animator.appear(picture.dstRect.x, picture.dstRect.y, animation, easing, duration);\n        }\n      } else {\n        picture = SceneManager.scene.pictures[this.interpreter.numberValueOf(this.params.number)];\n        animation = picture != null ? picture.findComponent(\"Component_FrameAnimation\") : void 0;\n        if (animation != null) {\n          picture.removeComponent(animation);\n          bitmap = ResourceManager.getBitmap(\"Graphics/Animations/\" + picture.image);\n          if (bitmap != null) {\n            picture.srcRect.set(0, 0, bitmap.width, bitmap.height);\n            picture.dstRect.width = picture.srcRect.width;\n            picture.dstRect.height = picture.srcRect.height;\n          }\n        }\n      }\n      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {\n        this.interpreter.isWaiting = true;\n        this.interpreter.waitCounter = duration;\n      }\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandMovePicturePath\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandMovePicturePath = function() {\n      var number, picture, scene;\n      scene = SceneManager.scene;\n      scene.behavior.changePictureDomain(this.params.numberDomain);\n      number = this.interpreter.numberValueOf(this.params.number);\n      picture = scene.pictures[number];\n      if (picture == null) {\n        return;\n      }\n      this.interpreter.moveObjectPath(picture, this.params.path, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandMovePicture\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandMovePicture = function() {\n      var number, picture, scene;\n      scene = SceneManager.scene;\n      scene.behavior.changePictureDomain(this.params.numberDomain);\n      number = this.interpreter.numberValueOf(this.params.number);\n      picture = scene.pictures[number];\n      if (picture == null) {\n        return;\n      }\n      this.interpreter.moveObject(picture, this.params.picture.position, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandTintPicture\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandTintPicture = function() {\n      var number, picture, scene;\n      scene = SceneManager.scene;\n      scene.behavior.changePictureDomain(this.params.numberDomain || \"\");\n      number = this.interpreter.numberValueOf(this.params.number);\n      picture = scene.pictures[number];\n      if (picture == null) {\n        return;\n      }\n      this.interpreter.tintObject(picture, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandFlashPicture\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandFlashPicture = function() {\n      var number, picture, scene;\n      scene = SceneManager.scene;\n      scene.behavior.changePictureDomain(this.params.numberDomain || \"\");\n      number = this.interpreter.numberValueOf(this.params.number);\n      picture = scene.pictures[number];\n      if (picture == null) {\n        return;\n      }\n      this.interpreter.flashObject(picture, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandCropPicture\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandCropPicture = function() {\n      var number, picture, scene;\n      scene = SceneManager.scene;\n      scene.behavior.changePictureDomain(this.params.numberDomain || \"\");\n      number = this.interpreter.numberValueOf(this.params.number);\n      picture = scene.pictures[number];\n      if (picture == null) {\n        return;\n      }\n      return this.interpreter.cropObject(picture, this.params);\n    };\n\n\n    /**\n    * @method commandRotatePicture\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandRotatePicture = function() {\n      var number, picture, scene;\n      scene = SceneManager.scene;\n      scene.behavior.changePictureDomain(this.params.numberDomain || \"\");\n      number = this.interpreter.numberValueOf(this.params.number);\n      picture = scene.pictures[number];\n      if (picture == null) {\n        return;\n      }\n      this.interpreter.rotateObject(picture, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandZoomPicture\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandZoomPicture = function() {\n      var number, picture, scene;\n      scene = SceneManager.scene;\n      scene.behavior.changePictureDomain(this.params.numberDomain || \"\");\n      number = this.interpreter.numberValueOf(this.params.number);\n      picture = scene.pictures[number];\n      if (picture == null) {\n        return;\n      }\n      this.interpreter.zoomObject(picture, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandBlendPicture\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandBlendPicture = function() {\n      var picture;\n      SceneManager.scene.behavior.changePictureDomain(this.params.numberDomain || \"\");\n      picture = SceneManager.scene.pictures[this.interpreter.numberValueOf(this.params.number)];\n      if (picture == null) {\n        return;\n      }\n      this.interpreter.blendObject(picture, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandShakePicture\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandShakePicture = function() {\n      var picture;\n      picture = SceneManager.scene.pictures[this.interpreter.numberValueOf(this.params.number)];\n      if (picture == null) {\n        return;\n      }\n      this.interpreter.shakeObject(picture, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandMaskPicture\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandMaskPicture = function() {\n      var number, picture, scene;\n      scene = SceneManager.scene;\n      scene.behavior.changePictureDomain(this.params.numberDomain || \"\");\n      number = this.interpreter.numberValueOf(this.params.number);\n      picture = scene.pictures[number];\n      if (picture == null) {\n        return;\n      }\n      this.interpreter.maskObject(picture, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandPictureMotionBlur\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandPictureMotionBlur = function() {\n      var number, picture, scene;\n      scene = SceneManager.scene;\n      scene.behavior.changePictureDomain(this.params.numberDomain || \"\");\n      number = this.interpreter.numberValueOf(this.params.number);\n      picture = scene.pictures[number];\n      if (picture == null) {\n        return;\n      }\n      this.interpreter.objectMotionBlur(picture, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandPictureEffect\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandPictureEffect = function() {\n      var number, picture, scene;\n      scene = SceneManager.scene;\n      scene.behavior.changePictureDomain(this.params.numberDomain || \"\");\n      number = this.interpreter.numberValueOf(this.params.number);\n      picture = scene.pictures[number];\n      if (picture == null) {\n        return;\n      }\n      this.interpreter.objectEffect(picture, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandErasePicture\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandErasePicture = function() {\n      var animation, defaults, duration, easing, flags, isLocked, number, picture, scene;\n      defaults = GameManager.defaults.picture;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      scene = SceneManager.scene;\n      scene.behavior.changePictureDomain(this.params.numberDomain || \"\");\n      number = this.interpreter.numberValueOf(this.params.number);\n      picture = scene.pictures[number];\n      if (picture == null) {\n        return;\n      }\n      easing = !isLocked(flags[\"easing.type\"]) ? gs.Easings.fromValues(this.interpreter.numberValueOf(this.params.easing.type), this.params.easing.inOut) : gs.Easings.fromObject(defaults.disappearEasing);\n      duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.disappearDuration;\n      animation = !isLocked(flags[\"animation.type\"]) ? this.params.animation : defaults.disappearAnimation;\n      picture.animator.disappear(animation, easing, duration, (function(_this) {\n        return function(sender) {\n          sender.dispose();\n          scene.behavior.changePictureDomain(sender.domain);\n          return scene.pictures[number] = null;\n        };\n      })(this));\n      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {\n        this.interpreter.isWaiting = true;\n        this.interpreter.waitCounter = duration;\n      }\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandInputNumber\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandInputNumber = function() {\n      var scene;\n      scene = SceneManager.scene;\n      this.interpreter.isWaiting = true;\n      if (this.interpreter.isProcessingMessageInOtherContext()) {\n        this.interpreter.waitForMessage();\n        return;\n      }\n      if ((GameManager.settings.allowChoiceSkip || this.interpreter.preview) && GameManager.tempSettings.skip) {\n        this.interpreter.isWaiting = false;\n        this.interpreter.messageObject().behavior.clear();\n        this.interpreter.setNumberValueTo(this.params.variable, 0);\n        return;\n      }\n      $tempFields.digits = this.params.digits;\n      scene.behavior.showInputNumber(this.params.digits, gs.CallBack(\"onInputNumberFinish\", this.interpreter, this.params));\n      this.interpreter.waitingFor.inputNumber = this.params;\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandChoiceTimer\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandChoiceTimer = function() {\n      var scene;\n      scene = SceneManager.scene;\n      GameManager.tempFields.choiceTimer = scene.choiceTimer;\n      GameManager.tempFields.choiceTimerVisible = this.params.visible;\n      if (this.params.enabled) {\n        scene.choiceTimer.behavior.seconds = this.interpreter.numberValueOf(this.params.seconds);\n        scene.choiceTimer.behavior.minutes = this.interpreter.numberValueOf(this.params.minutes);\n        scene.choiceTimer.behavior.start();\n        return scene.choiceTimer.events.on(\"finish\", (function(_this) {\n          return function(sender) {\n            var defaultChoice, ref;\n            if (scene.choiceWindow && ((ref = scene.choices) != null ? ref.length : void 0) > 0) {\n              defaultChoice = (scene.choices.first(function(c) {\n                return c.isDefault;\n              })) || scene.choices[0];\n              return scene.choiceWindow.events.emit(\"selectionAccept\", scene.choiceWindow, defaultChoice);\n            }\n          };\n        })(this));\n      } else {\n        return scene.choiceTimer.stop();\n      }\n    };\n\n\n    /**\n    * @method commandShowChoices\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandShowChoices = function() {\n      var choices, defaultChoice, messageObject, pointer, scene;\n      scene = SceneManager.scene;\n      pointer = this.interpreter.pointer;\n      choices = scene.choices || [];\n      if ((GameManager.settings.allowChoiceSkip || this.interpreter.previewData) && GameManager.tempSettings.skip) {\n        messageObject = this.interpreter.messageObject();\n        if (messageObject != null ? messageObject.visible : void 0) {\n          messageObject.behavior.clear();\n        }\n        defaultChoice = (choices.first(function(c) {\n          return c.isDefault;\n        })) || choices[0];\n        if (defaultChoice.action.labelIndex != null) {\n          this.interpreter.pointer = defaultChoice.action.labelIndex;\n        } else {\n          this.interpreter.jumpToLabel(defaultChoice.action.label);\n        }\n        scene.choices = [];\n      } else {\n        if (choices.length > 0) {\n          this.interpreter.isWaiting = true;\n          scene.behavior.showChoices(gs.CallBack(\"onChoiceAccept\", this.interpreter, {\n            pointer: pointer,\n            params: this.params\n          }));\n        }\n      }\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandShowChoice\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandShowChoice = function() {\n      var choices, command, commands, dstRect, index, pointer, scene;\n      scene = SceneManager.scene;\n      commands = this.interpreter.object.commands;\n      command = null;\n      index = 0;\n      pointer = this.interpreter.pointer;\n      choices = null;\n      dstRect = null;\n      switch (this.params.positionType) {\n        case 0:\n          dstRect = null;\n          break;\n        case 1:\n          dstRect = new Rect(this.params.box.x, this.params.box.y, this.params.box.size.width, this.params.box.size.height);\n      }\n      if (!scene.choices) {\n        scene.choices = [];\n      }\n      choices = scene.choices;\n      return choices.push({\n        dstRect: dstRect,\n        text: this.params.text,\n        index: index,\n        action: this.params.action,\n        isSelected: false,\n        isDefault: this.params.defaultChoice,\n        isEnabled: this.interpreter.booleanValueOf(this.params.enabled)\n      });\n    };\n\n\n    /**\n    * @method commandOpenMenu\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandOpenMenu = function() {\n      SceneManager.switchTo(new gs.Object_Layout(\"menuLayout\"), true);\n      this.interpreter.waitCounter = 1;\n      return this.interpreter.isWaiting = true;\n    };\n\n\n    /**\n    * @method commandOpenLoadMenu\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandOpenLoadMenu = function() {\n      SceneManager.switchTo(new gs.Object_Layout(\"loadMenuLayout\"), true);\n      this.interpreter.waitCounter = 1;\n      return this.interpreter.isWaiting = true;\n    };\n\n\n    /**\n    * @method commandOpenSaveMenu\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandOpenSaveMenu = function() {\n      SceneManager.switchTo(new gs.Object_Layout(\"saveMenuLayout\"), true);\n      this.interpreter.waitCounter = 1;\n      return this.interpreter.isWaiting = true;\n    };\n\n\n    /**\n    * @method commandReturnToTitle\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandReturnToTitle = function() {\n      SceneManager.clear();\n      SceneManager.switchTo(new gs.Object_Layout(\"titleLayout\"));\n      this.interpreter.waitCounter = 1;\n      return this.interpreter.isWaiting = true;\n    };\n\n\n    /**\n    * @method commandPlayVideo\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandPlayVideo = function() {\n      var ref, scene;\n      if ((GameManager.inLivePreview || GameManager.settings.allowVideoSkip) && GameManager.tempSettings.skip) {\n        return;\n      }\n      GameManager.tempSettings.skip = false;\n      scene = SceneManager.scene;\n      if (((ref = this.params.video) != null ? ref.name : void 0) != null) {\n        scene.video = ResourceManager.getVideo(\"Movies/\" + this.params.video.name);\n        this.videoSprite = new Sprite(Graphics.viewport);\n        this.videoSprite.srcRect = new Rect(0, 0, scene.video.width, scene.video.height);\n        this.videoSprite.video = scene.video;\n        this.videoSprite.zoomX = Graphics.width / scene.video.width;\n        this.videoSprite.zoomY = Graphics.height / scene.video.height;\n        this.videoSprite.z = 99999999;\n        scene.video.onEnded = (function(_this) {\n          return function() {\n            _this.interpreter.isWaiting = false;\n            _this.videoSprite.dispose();\n            return scene.video = null;\n          };\n        })(this);\n        scene.video.volume = this.params.volume / 100;\n        scene.video.playbackRate = this.params.playbackRate / 100;\n        this.interpreter.isWaiting = true;\n        scene.video.play();\n      }\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandAudioDefaults\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandAudioDefaults = function() {\n      var defaults, flags, isLocked;\n      defaults = GameManager.defaults.audio;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      if (!isLocked(flags.musicFadeInDuration)) {\n        defaults.musicFadeInDuration = this.params.musicFadeInDuration;\n      }\n      if (!isLocked(flags.musicFadeOutDuration)) {\n        defaults.musicFadeOutDuration = this.params.musicFadeOutDuration;\n      }\n      if (!isLocked(flags.musicVolume)) {\n        defaults.musicVolume = this.params.musicVolume;\n      }\n      if (!isLocked(flags.musicPlaybackRate)) {\n        defaults.musicPlaybackRate = this.params.musicPlaybackRate;\n      }\n      if (!isLocked(flags.soundVolume)) {\n        defaults.soundVolume = this.params.soundVolume;\n      }\n      if (!isLocked(flags.soundPlaybackRate)) {\n        defaults.soundPlaybackRate = this.params.soundPlaybackRate;\n      }\n      if (!isLocked(flags.voiceVolume)) {\n        defaults.voiceVolume = this.params.voiceVolume;\n      }\n      if (!isLocked(flags.voicePlaybackRate)) {\n        return defaults.voicePlaybackRate = this.params.voicePlaybackRate;\n      }\n    };\n\n\n    /**\n    * @method commandPlayMusic\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandPlayMusic = function() {\n      var defaults, fadeDuration, flags, isLocked, music, playRange, playTime, playbackRate, volume;\n      if (this.params.music == null) {\n        return;\n      }\n      defaults = GameManager.defaults.audio;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      music = null;\n      if (GameManager.settings.bgmEnabled) {\n        fadeDuration = !isLocked(flags.fadeInDuration) ? this.params.fadeInDuration : defaults.musicFadeInDuration;\n        volume = !isLocked(flags[\"music.volume\"]) ? this.params.music.volume : defaults.musicVolume;\n        playbackRate = !isLocked(flags[\"music.playbackRate\"]) ? this.params.music.playbackRate : defaults.musicPlaybackRate;\n        music = {\n          name: this.params.music.name,\n          volume: volume,\n          playbackRate: playbackRate\n        };\n        if (this.params.playType === 1) {\n          playTime = {\n            min: this.params.playTime.min * 60,\n            max: this.params.playTime.max * 60\n          };\n          playRange = {\n            start: this.params.playRange.start * 60,\n            end: this.params.playRange.end * 60\n          };\n          AudioManager.playMusicRandom(music, fadeDuration, this.params.layer || 0, playTime, playRange);\n        } else {\n          music = AudioManager.playMusic(this.params.music.name, volume, playbackRate, fadeDuration, this.params.layer || 0, this.params.loop);\n        }\n      }\n      if (music && this.params.waitForCompletion && !this.params.loop) {\n        this.interpreter.isWaiting = true;\n        this.interpreter.waitCounter = Math.round(music.duration * Graphics.frameRate);\n      }\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandStopMusic\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandStopMusic = function() {\n      var defaults, fadeDuration, flags, isLocked;\n      defaults = GameManager.defaults.audio;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      fadeDuration = !isLocked(flags.fadeOutDuration) ? this.params.fadeOutDuration : defaults.musicFadeOutDuration;\n      AudioManager.stopMusic(fadeDuration, this.interpreter.numberValueOf(this.params.layer));\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandPauseMusic\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandPauseMusic = function() {\n      var defaults, fadeDuration, flags, isLocked;\n      defaults = GameManager.defaults.audio;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      fadeDuration = !isLocked(flags.fadeOutDuration) ? this.params.fadeOutDuration : defaults.musicFadeOutDuration;\n      return AudioManager.stopMusic(fadeDuration, this.interpreter.numberValueOf(this.params.layer));\n    };\n\n\n    /**\n    * @method commandResumeMusic\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandResumeMusic = function() {\n      var defaults, fadeDuration, flags, isLocked;\n      defaults = GameManager.defaults.audio;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      fadeDuration = !isLocked(flags.fadeInDuration) ? this.params.fadeInDuration : defaults.musicFadeInDuration;\n      AudioManager.resumeMusic(fadeDuration, this.interpreter.numberValueOf(this.params.layer));\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandPlaySound\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandPlaySound = function() {\n      var defaults, flags, isLocked, playbackRate, sound, volume;\n      defaults = GameManager.defaults.audio;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      sound = null;\n      if (GameManager.settings.soundEnabled && !GameManager.tempSettings.skip) {\n        volume = !isLocked(flags[\"sound.volume\"]) ? this.params.sound.volume : defaults.soundVolume;\n        playbackRate = !isLocked(flags[\"sound.playbackRate\"]) ? this.params.sound.playbackRate : defaults.soundPlaybackRate;\n        sound = AudioManager.playSound(this.params.sound.name, volume, playbackRate, this.params.musicEffect, null, this.params.loop);\n      }\n      gs.GameNotifier.postMinorChange();\n      if (sound && this.params.waitForCompletion && !this.params.loop) {\n        this.interpreter.isWaiting = true;\n        return this.interpreter.waitCounter = Math.round(sound.duration * Graphics.frameRate);\n      }\n    };\n\n\n    /**\n    * @method commandStopSound\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandStopSound = function() {\n      AudioManager.stopSound(this.params.sound.name);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandEndCommonEvent\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandEndCommonEvent = function() {\n      var event, eventId;\n      eventId = this.interpreter.stringValueOf(this.params.commonEventId);\n      event = GameManager.commonEvents[eventId];\n      return event != null ? event.behavior.stop() : void 0;\n    };\n\n\n    /**\n    * @method commandResumeCommonEvent\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandResumeCommonEvent = function() {\n      var event, eventId;\n      eventId = this.interpreter.stringValueOf(this.params.commonEventId);\n      event = GameManager.commonEvents[eventId];\n      return event != null ? event.behavior.resume() : void 0;\n    };\n\n\n    /**\n    * @method commandCallCommonEvent\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandCallCommonEvent = function() {\n      var eventId, list, params, scene;\n      scene = SceneManager.scene;\n      eventId = null;\n      if (this.params.commonEventId.index != null) {\n        eventId = this.interpreter.stringValueOf(this.params.commonEventId);\n        list = this.interpreter.listObjectOf(this.params.parameters.values[0]);\n        params = {\n          values: list\n        };\n      } else {\n        params = this.params.parameters;\n        eventId = this.params.commonEventId;\n      }\n      return this.interpreter.callCommonEvent(eventId, params);\n    };\n\n\n    /**\n    * @method commandChangeTextSettings\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandChangeTextSettings = function() {\n      var flags, font, fontName, fontSize, isLocked, number, padding, ref, ref1, ref2, ref3, ref4, scene, textSprite, texts;\n      scene = SceneManager.scene;\n      scene.behavior.changeTextDomain(this.params.numberDomain);\n      number = this.interpreter.numberValueOf(this.params.number);\n      texts = scene.texts;\n      if (texts[number] == null) {\n        texts[number] = new gs.Object_Text();\n        texts[number].visible = false;\n      }\n      textSprite = texts[number];\n      padding = textSprite.behavior.padding;\n      font = textSprite.font;\n      fontName = textSprite.font.name;\n      fontSize = textSprite.font.size;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      if (!isLocked(flags.lineSpacing)) {\n        textSprite.textRenderer.lineSpacing = (ref = this.params.lineSpacing) != null ? ref : textSprite.textRenderer.lineSpacing;\n      }\n      if (!isLocked(flags.font)) {\n        fontName = this.interpreter.stringValueOf(this.params.font);\n      }\n      if (!isLocked(flags.size)) {\n        fontSize = this.interpreter.numberValueOf(this.params.size);\n      }\n      if (!isLocked(flags.font) || !isLocked(flags.size)) {\n        textSprite.font = new Font(fontName, fontSize);\n      }\n      padding.left = !isLocked(flags[\"padding.0\"]) ? (ref1 = this.params.padding) != null ? ref1[0] : void 0 : padding.left;\n      padding.top = !isLocked(flags[\"padding.1\"]) ? (ref2 = this.params.padding) != null ? ref2[1] : void 0 : padding.top;\n      padding.right = !isLocked(flags[\"padding.2\"]) ? (ref3 = this.params.padding) != null ? ref3[2] : void 0 : padding.right;\n      padding.bottom = !isLocked(flags[\"padding.3\"]) ? (ref4 = this.params.padding) != null ? ref4[3] : void 0 : padding.bottom;\n      if (!isLocked(flags.bold)) {\n        textSprite.font.bold = this.params.bold;\n      }\n      if (!isLocked(flags.italic)) {\n        textSprite.font.italic = this.params.italic;\n      }\n      if (!isLocked(flags.smallCaps)) {\n        textSprite.font.smallCaps = this.params.smallCaps;\n      }\n      if (!isLocked(flags.underline)) {\n        textSprite.font.underline = this.params.underline;\n      }\n      if (!isLocked(flags.strikeThrough)) {\n        textSprite.font.strikeThrough = this.params.strikeThrough;\n      }\n      textSprite.font.color = !isLocked(flags.color) ? new Color(this.params.color) : font.color;\n      textSprite.font.border = !isLocked(flags.outline) ? this.params.outline : font.border;\n      textSprite.font.borderColor = !isLocked(flags.outlineColor) ? new Color(this.params.outlineColor) : new Color(font.borderColor);\n      textSprite.font.borderSize = !isLocked(flags.outlineSize) ? this.params.outlineSize : font.borderSize;\n      textSprite.font.shadow = !isLocked(flags.shadow) ? this.params.shadow : font.shadow;\n      textSprite.font.shadowColor = !isLocked(flags.shadowColor) ? new Color(this.params.shadowColor) : new Color(font.shadowColor);\n      textSprite.font.shadowOffsetX = !isLocked(flags.shadowOffsetX) ? this.params.shadowOffsetX : font.shadowOffsetX;\n      textSprite.font.shadowOffsetY = !isLocked(flags.shadowOffsetY) ? this.params.shadowOffsetY : font.shadowOffsetY;\n      textSprite.behavior.refresh();\n      return textSprite.update();\n    };\n\n\n    /**\n    * @method commandChangeTextSettings\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandTextDefaults = function() {\n      var defaults, flags, isLocked;\n      defaults = GameManager.defaults.text;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      if (!isLocked(flags.appearDuration)) {\n        defaults.appearDuration = this.interpreter.durationValueOf(this.params.appearDuration);\n      }\n      if (!isLocked(flags.disappearDuration)) {\n        defaults.disappearDuration = this.interpreter.durationValueOf(this.params.disappearDuration);\n      }\n      if (!isLocked(flags.zOrder)) {\n        defaults.zOrder = this.interpreter.numberValueOf(this.params.zOrder);\n      }\n      if (!isLocked(flags[\"appearEasing.type\"])) {\n        defaults.appearEasing = this.params.appearEasing;\n      }\n      if (!isLocked(flags[\"appearAnimation.type\"])) {\n        defaults.appearAnimation = this.params.appearAnimation;\n      }\n      if (!isLocked(flags[\"disappearEasing.type\"])) {\n        defaults.disappearEasing = this.params.disappearEasing;\n      }\n      if (!isLocked(flags[\"disappearAnimation.type\"])) {\n        defaults.disappearAnimation = this.params.disappearAnimation;\n      }\n      if (!isLocked(flags[\"motionBlur.enabled\"])) {\n        defaults.motionBlur = this.params.motionBlur;\n      }\n      if (!isLocked(flags.origin)) {\n        return defaults.origin = this.params.origin;\n      }\n    };\n\n\n    /**\n    * @method commandShowText\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandShowText = function() {\n      var animation, defaults, duration, easing, flags, isLocked, number, origin, p, positionAnchor, ref, scene, text, textObject, texts, x, y, zIndex;\n      defaults = GameManager.defaults.text;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      scene = SceneManager.scene;\n      scene.behavior.changeTextDomain(this.params.numberDomain);\n      number = this.interpreter.numberValueOf(this.params.number);\n      text = this.params.text;\n      texts = scene.texts;\n      if (texts[number] == null) {\n        texts[number] = new gs.Object_Text();\n      }\n      x = this.interpreter.numberValueOf(this.params.position.x);\n      y = this.interpreter.numberValueOf(this.params.position.y);\n      textObject = texts[number];\n      textObject.domain = this.params.numberDomain;\n      easing = !isLocked(flags[\"easing.type\"]) ? gs.Easings.fromValues(this.interpreter.numberValueOf(this.params.easing.type), this.params.easing.inOut) : gs.Easings.fromObject(defaults.appearEasing);\n      duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.appearDuration;\n      origin = !isLocked(flags.origin) ? this.params.origin : defaults.origin;\n      zIndex = !isLocked(flags.zOrder) ? this.interpreter.numberValueOf(this.params.zOrder) : defaults.zOrder;\n      animation = !isLocked(flags[\"animation.type\"]) ? this.params.animation : defaults.appearAnimation;\n      positionAnchor = !isLocked(flags.positionOrigin) ? this.interpreter.graphicAnchorPointsByConstant[this.params.positionOrigin] || new gs.Point(0, 0) : this.interpreter.graphicAnchorPointsByConstant[defaults.positionOrigin];\n      textObject.text = text;\n      textObject.dstRect.x = x;\n      textObject.dstRect.y = y;\n      textObject.blendMode = this.interpreter.numberValueOf(this.params.blendMode);\n      textObject.anchor.x = origin === 0 ? 0 : 0.5;\n      textObject.anchor.y = origin === 0 ? 0 : 0.5;\n      textObject.positionAnchor.x = positionAnchor.x;\n      textObject.positionAnchor.y = positionAnchor.y;\n      textObject.zIndex = zIndex || (700 + number);\n      textObject.sizeToFit = true;\n      textObject.formatting = true;\n      if (((ref = this.params.viewport) != null ? ref.type : void 0) === \"scene\") {\n        textObject.viewport = SceneManager.scene.behavior.viewport;\n      }\n      textObject.update();\n      if (this.params.positionType === 0) {\n        p = this.interpreter.predefinedObjectPosition(this.params.predefinedPositionId, textObject, this.params);\n        textObject.dstRect.x = p.x;\n        textObject.dstRect.y = p.y;\n      }\n      textObject.animator.appear(x, y, animation, easing, duration);\n      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {\n        this.interpreter.isWaiting = true;\n        this.interpreter.waitCounter = duration;\n      }\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandTextMotionBlur\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandTextMotionBlur = function() {\n      var number, scene, text;\n      scene = SceneManager.scene;\n      scene.behavior.changeTextDomain(this.params.numberDomain);\n      number = this.interpreter.numberValueOf(this.params.number);\n      text = scene.texts[number];\n      if (text == null) {\n        return;\n      }\n      return text.motionBlur.set(this.params.motionBlur);\n    };\n\n\n    /**\n    * @method commandRefreshText\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandRefreshText = function() {\n      var number, scene, texts;\n      scene = SceneManager.scene;\n      scene.behavior.changeTextDomain(this.params.numberDomain);\n      number = this.interpreter.numberValueOf(this.params.number);\n      texts = scene.texts;\n      if (texts[number] == null) {\n        return;\n      }\n      return texts[number].behavior.refresh(true);\n    };\n\n\n    /**\n    * @method commandMoveText\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandMoveText = function() {\n      var number, scene, text;\n      scene = SceneManager.scene;\n      scene.behavior.changeTextDomain(this.params.numberDomain);\n      number = this.interpreter.numberValueOf(this.params.number);\n      text = scene.texts[number];\n      if (text == null) {\n        return;\n      }\n      this.interpreter.moveObject(text, this.params.picture.position, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandMoveTextPath\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandMoveTextPath = function() {\n      var number, scene, text;\n      scene = SceneManager.scene;\n      scene.behavior.changeTextDomain(this.params.numberDomain);\n      number = this.interpreter.numberValueOf(this.params.number);\n      text = scene.texts[number];\n      if (text == null) {\n        return;\n      }\n      this.interpreter.moveObjectPath(text, this.params.path, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandRotateText\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandRotateText = function() {\n      var number, scene, text;\n      scene = SceneManager.scene;\n      scene.behavior.changeTextDomain(this.params.numberDomain);\n      number = this.interpreter.numberValueOf(this.params.number);\n      text = scene.texts[number];\n      if (text == null) {\n        return;\n      }\n      this.interpreter.rotateObject(text, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandZoomText\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandZoomText = function() {\n      var number, scene, text;\n      scene = SceneManager.scene;\n      scene.behavior.changeTextDomain(this.params.numberDomain);\n      number = this.interpreter.numberValueOf(this.params.number);\n      text = scene.texts[number];\n      if (text == null) {\n        return;\n      }\n      this.interpreter.zoomObject(text, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandBlendText\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandBlendText = function() {\n      var text;\n      SceneManager.scene.behavior.changeTextDomain(this.params.numberDomain);\n      text = SceneManager.scene.texts[this.interpreter.numberValueOf(this.params.number)];\n      if (text == null) {\n        return;\n      }\n      this.interpreter.blendObject(text, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandColorText\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandColorText = function() {\n      var duration, easing, number, scene, text;\n      scene = SceneManager.scene;\n      scene.behavior.changeTextDomain(this.params.numberDomain);\n      number = this.interpreter.numberValueOf(this.params.number);\n      text = scene.texts[number];\n      duration = this.interpreter.durationValueOf(this.params.duration);\n      easing = gs.Easings.fromObject(this.params.easing);\n      if (text != null) {\n        text.animator.colorTo(new Color(this.params.color), duration, easing);\n        if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {\n          this.interpreter.isWaiting = true;\n          this.interpreter.waitCounter = duration;\n        }\n      }\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandEraseText\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandEraseText = function() {\n      var animation, defaults, duration, easing, flags, isLocked, number, scene, text;\n      defaults = GameManager.defaults.text;\n      flags = this.params.fieldFlags || {};\n      isLocked = gs.CommandFieldFlags.isLocked;\n      scene = SceneManager.scene;\n      scene.behavior.changeTextDomain(this.params.numberDomain);\n      number = this.interpreter.numberValueOf(this.params.number);\n      text = scene.texts[number];\n      if (text == null) {\n        return;\n      }\n      easing = !isLocked(flags[\"easing.type\"]) ? gs.Easings.fromValues(this.interpreter.numberValueOf(this.params.easing.type), this.params.easing.inOut) : gs.Easings.fromObject(defaults.disappearEasing);\n      duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.disappearDuration;\n      animation = !isLocked(flags[\"animation.type\"]) ? this.params.animation : defaults.disappearAnimation;\n      text.animator.disappear(animation, easing, duration, (function(_this) {\n        return function(sender) {\n          sender.dispose();\n          scene.behavior.changeTextDomain(sender.domain);\n          return scene.texts[number] = null;\n        };\n      })(this));\n      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {\n        this.interpreter.isWaiting = true;\n        this.interpreter.waitCounter = duration;\n      }\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandTextEffect\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandTextEffect = function() {\n      var number, scene, text;\n      scene = SceneManager.scene;\n      scene.behavior.changeTextDomain(this.params.numberDomain);\n      number = this.interpreter.numberValueOf(this.params.number);\n      text = scene.texts[number];\n      if (text == null) {\n        return;\n      }\n      this.interpreter.objectEffect(text, this.params);\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandInputText\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandInputText = function() {\n      var scene;\n      scene = SceneManager.scene;\n      scene.behavior.changeTextDomain(this.params.numberDomain);\n      if ((GameManager.settings.allowChoiceSkip || this.interpreter.preview) && GameManager.tempSettings.skip) {\n        this.interpreter.messageObject().behavior.clear();\n        this.interpreter.setStringValueTo(this.params.variable, \"\");\n        return;\n      }\n      this.interpreter.isWaiting = true;\n      if (this.interpreter.isProcessingMessageInOtherContext()) {\n        this.interpreter.waitForMessage();\n        return;\n      }\n      $tempFields.letters = this.params.letters;\n      scene.behavior.showInputText(this.params.letters, gs.CallBack(\"onInputTextFinish\", this.interpreter, this.interpreter));\n      this.interpreter.waitingFor.inputText = this.params;\n      return gs.GameNotifier.postMinorChange();\n    };\n\n\n    /**\n    * @method commandSavePersistentData\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandSavePersistentData = function() {\n      return GameManager.saveGlobalData();\n    };\n\n\n    /**\n    * @method commandSaveSettings\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandSaveSettings = function() {\n      return GameManager.saveSettings();\n    };\n\n\n    /**\n    * @method commandPrepareSaveGame\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandPrepareSaveGame = function() {\n      if (this.interpreter.previewData != null) {\n        return;\n      }\n      this.interpreter.pointer++;\n      GameManager.prepareSaveGame(this.params.snapshot);\n      return this.interpreter.pointer--;\n    };\n\n\n    /**\n    * @method commandSaveGame\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandSaveGame = function() {\n      var thumbHeight, thumbWidth;\n      if (this.interpreter.previewData != null) {\n        return;\n      }\n      thumbWidth = this.interpreter.numberValueOf(this.params.thumbWidth);\n      thumbHeight = this.interpreter.numberValueOf(this.params.thumbHeight);\n      return GameManager.save(this.interpreter.numberValueOf(this.params.slot) - 1, thumbWidth, thumbHeight);\n    };\n\n\n    /**\n    * @method commandLoadGame\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandLoadGame = function() {\n      if (this.interpreter.previewData != null) {\n        return;\n      }\n      return GameManager.load(this.interpreter.numberValueOf(this.params.slot) - 1);\n    };\n\n\n    /**\n    * @method commandWaitForInput\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandWaitForInput = function() {\n      var f;\n      if (this.interpreter.isInstantSkip()) {\n        return;\n      }\n      gs.GlobalEventManager.offByOwner(\"mouseDown\", this.interpreter.object);\n      gs.GlobalEventManager.offByOwner(\"mouseUp\", this.interpreter.object);\n      gs.GlobalEventManager.offByOwner(\"keyDown\", this.interpreter.object);\n      gs.GlobalEventManager.offByOwner(\"keyUp\", this.interpreter.object);\n      f = (function(_this) {\n        return function() {\n          var executeAction, key;\n          key = _this.interpreter.numberValueOf(_this.params.key);\n          executeAction = false;\n          if (Input.Mouse.isButton(_this.params.key)) {\n            executeAction = Input.Mouse.buttons[_this.params.key] === _this.params.state;\n          } else if (_this.params.key === 100) {\n            if (Input.keyDown && _this.params.state === 1) {\n              executeAction = true;\n            }\n            if (Input.keyUp && _this.params.state === 2) {\n              executeAction = true;\n            }\n          } else if (_this.params.key === 101) {\n            if (Input.Mouse.buttonDown && _this.params.state === 1) {\n              executeAction = true;\n            }\n            if (Input.Mouse.buttonUp && _this.params.state === 2) {\n              executeAction = true;\n            }\n          } else if (_this.params.key === 102) {\n            if ((Input.keyDown || Input.Mouse.buttonDown) && _this.params.state === 1) {\n              executeAction = true;\n            }\n            if ((Input.keyUp || Input.Mouse.buttonUp) && _this.params.state === 2) {\n              executeAction = true;\n            }\n          } else {\n            key = key > 100 ? key - 100 : key;\n            executeAction = Input.keys[key] === _this.params.state;\n          }\n          if (executeAction) {\n            _this.interpreter.isWaiting = false;\n            gs.GlobalEventManager.offByOwner(\"mouseDown\", _this.interpreter.object);\n            gs.GlobalEventManager.offByOwner(\"mouseUp\", _this.interpreter.object);\n            gs.GlobalEventManager.offByOwner(\"keyDown\", _this.interpreter.object);\n            return gs.GlobalEventManager.offByOwner(\"keyUp\", _this.interpreter.object);\n          }\n        };\n      })(this);\n      gs.GlobalEventManager.on(\"mouseDown\", f, null, this.interpreter.object);\n      gs.GlobalEventManager.on(\"mouseUp\", f, null, this.interpreter.object);\n      gs.GlobalEventManager.on(\"keyDown\", f, null, this.interpreter.object);\n      gs.GlobalEventManager.on(\"keyUp\", f, null, this.interpreter.object);\n      return this.interpreter.isWaiting = true;\n    };\n\n\n    /**\n    * @method commandGetInputData\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandGetInputData = function() {\n      var anyButton, anyInput, anyKey, code;\n      switch (this.params.field) {\n        case 0:\n          return this.interpreter.setNumberValueTo(this.params.targetVariable, Input.keys[Input.A]);\n        case 1:\n          return this.interpreter.setNumberValueTo(this.params.targetVariable, Input.keys[Input.B]);\n        case 2:\n          return this.interpreter.setNumberValueTo(this.params.targetVariable, Input.keys[Input.X]);\n        case 3:\n          return this.interpreter.setNumberValueTo(this.params.targetVariable, Input.keys[Input.Y]);\n        case 4:\n          return this.interpreter.setNumberValueTo(this.params.targetVariable, Input.keys[Input.L]);\n        case 5:\n          return this.interpreter.setNumberValueTo(this.params.targetVariable, Input.keys[Input.R]);\n        case 6:\n          return this.interpreter.setNumberValueTo(this.params.targetVariable, Input.keys[Input.START]);\n        case 7:\n          return this.interpreter.setNumberValueTo(this.params.targetVariable, Input.keys[Input.SELECT]);\n        case 8:\n          return this.interpreter.setNumberValueTo(this.params.targetVariable, Input.Mouse.x);\n        case 9:\n          return this.interpreter.setNumberValueTo(this.params.targetVariable, Input.Mouse.y);\n        case 10:\n          return this.interpreter.setNumberValueTo(this.params.targetVariable, Input.Mouse.wheel);\n        case 11:\n          return this.interpreter.setNumberValueTo(this.params.targetVariable, Input.Mouse.buttons[Input.Mouse.LEFT]);\n        case 12:\n          return this.interpreter.setNumberValueTo(this.params.targetVariable, Input.Mouse.buttons[Input.Mouse.RIGHT]);\n        case 13:\n          return this.interpreter.setNumberValueTo(this.params.targetVariable, Input.Mouse.buttons[Input.Mouse.MIDDLE]);\n        case 100:\n          anyKey = 0;\n          if (Input.keyDown) {\n            anyKey = 1;\n          }\n          if (Input.keyUp) {\n            anyKey = 2;\n          }\n          return this.interpreter.setNumberValueTo(this.params.targetVariable, anyKey);\n        case 101:\n          anyButton = 0;\n          if (Input.Mouse.buttonDown) {\n            anyButton = 1;\n          }\n          if (Input.Mouse.buttonUp) {\n            anyButton = 2;\n          }\n          return this.interpreter.setNumberValueTo(this.params.targetVariable, anyButton);\n        case 102:\n          anyInput = 0;\n          if (Input.Mouse.buttonDown || Input.keyDown) {\n            anyInput = 1;\n          }\n          if (Input.Mouse.buttonUp || Input.keyUp) {\n            anyInput = 2;\n          }\n          return this.interpreter.setNumberValueTo(this.params.targetVariable, anyInput);\n        default:\n          code = this.params.field - 100;\n          return this.interpreter.setNumberValueTo(this.params.targetVariable, Input.keys[code]);\n      }\n    };\n\n\n    /**\n    * @method commandGetGameData\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandGetGameData = function() {\n      var ref, ref1, settings, tempSettings;\n      tempSettings = GameManager.tempSettings;\n      settings = GameManager.settings;\n      switch (this.params.field) {\n        case 0:\n          return this.interpreter.setStringValueTo(this.params.targetVariable, SceneManager.scene.sceneDocument.uid);\n        case 1:\n          return this.interpreter.setNumberValueTo(this.params.targetVariable, Math.round(Graphics.frameCount / 60));\n        case 2:\n          return this.interpreter.setNumberValueTo(this.params.targetVariable, Math.round(Graphics.frameCount / 60 / 60));\n        case 3:\n          return this.interpreter.setNumberValueTo(this.params.targetVariable, Math.round(Graphics.frameCount / 60 / 60 / 60));\n        case 4:\n          return this.interpreter.setNumberValueTo(this.params.targetVariable, new Date().getDate());\n        case 5:\n          return this.interpreter.setNumberValueTo(this.params.targetVariable, new Date().getDay());\n        case 6:\n          return this.interpreter.setNumberValueTo(this.params.targetVariable, new Date().getMonth());\n        case 7:\n          return this.interpreter.setNumberValueTo(this.params.targetVariable, new Date().getFullYear());\n        case 8:\n          return this.interpreter.setBooleanValueTo(this.params.targetVariable, settings.allowSkip);\n        case 9:\n          return this.interpreter.setBooleanValueTo(this.params.targetVariable, settings.allowSkipUnreadMessages);\n        case 10:\n          return this.interpreter.setNumberValueTo(this.params.targetVariable, settings.messageSpeed);\n        case 11:\n          return this.interpreter.setBooleanValueTo(this.params.targetVariable, settings.autoMessage.enabled);\n        case 12:\n          return this.interpreter.setNumberValueTo(this.params.targetVariable, settings.autoMessage.time);\n        case 13:\n          return this.interpreter.setBooleanValueTo(this.params.targetVariable, settings.autoMessage.waitForVoice);\n        case 14:\n          return this.interpreter.setBooleanValueTo(this.params.targetVariable, settings.autoMessage.stopOnAction);\n        case 15:\n          return this.interpreter.setBooleanValueTo(this.params.targetVariable, settings.timeMessageToVoice);\n        case 16:\n          return this.interpreter.setBooleanValueTo(this.params.targetVariable, settings.allowVideoSkip);\n        case 17:\n          return this.interpreter.setBooleanValueTo(this.params.targetVariable, settings.allowChoiceSkip);\n        case 18:\n          return this.interpreter.setBooleanValueTo(this.params.targetVariable, settings.skipVoiceOnAction);\n        case 19:\n          return this.interpreter.setBooleanValueTo(this.params.targetVariable, settings.fullScreen);\n        case 20:\n          return this.interpreter.setBooleanValueTo(this.params.targetVariable, settings.adjustAspectRatio);\n        case 21:\n          return this.interpreter.setBooleanValueTo(this.params.targetVariable, settings.confirmation);\n        case 22:\n          return this.interpreter.setNumberValueTo(this.params.targetVariable, settings.bgmVolume);\n        case 23:\n          return this.interpreter.setNumberValueTo(this.params.targetVariable, settings.voiceVolume);\n        case 24:\n          return this.interpreter.setNumberValueTo(this.params.targetVariable, settings.seVolume);\n        case 25:\n          return this.interpreter.setBooleanValueTo(this.params.targetVariable, settings.bgmEnabled);\n        case 26:\n          return this.interpreter.setBooleanValueTo(this.params.targetVariable, settings.voiceEnabled);\n        case 27:\n          return this.interpreter.setBooleanValueTo(this.params.targetVariable, settings.seEnabled);\n        case 28:\n          return this.interpreter.setStringValueTo(this.params.targetVariable, ((ref = LanguageManager.language) != null ? ref.code : void 0) || \"\");\n        case 29:\n          return this.interpreter.setStringValueTo(this.params.targetVariable, ((ref1 = LanguageManager.language) != null ? ref1.name : void 0) || \"\");\n        case 30:\n          return this.interpreter.setBooleanValueTo(this.params.targetVariable, GameManager.tempSettings.skip);\n      }\n    };\n\n\n    /**\n    * @method commandSetGameData\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandSetGameData = function() {\n      var code, language, settings, tempSettings;\n      tempSettings = GameManager.tempSettings;\n      settings = GameManager.settings;\n      switch (this.params.field) {\n        case 0:\n          return settings.allowSkip = this.interpreter.booleanValueOf(this.params.switchValue);\n        case 1:\n          return settings.allowSkipUnreadMessages = this.interpreter.booleanValueOf(this.params.switchValue);\n        case 2:\n          return settings.messageSpeed = this.interpreter.numberValueOf(this.params.decimalValue);\n        case 3:\n          return settings.autoMessage.enabled = this.interpreter.booleanValueOf(this.params.switchValue);\n        case 4:\n          return settings.autoMessage.time = this.interpreter.numberValueOf(this.params.numberValue);\n        case 5:\n          return settings.autoMessage.waitForVoice = this.interpreter.booleanValueOf(this.params.switchValue);\n        case 6:\n          return settings.autoMessage.stopOnAction = this.interpreter.booleanValueOf(this.params.switchValue);\n        case 7:\n          return settings.timeMessageToVoice = this.interpreter.booleanValueOf(this.params.switchValue);\n        case 8:\n          return settings.allowVideoSkip = this.interpreter.booleanValueOf(this.params.switchValue);\n        case 9:\n          return settings.allowChoiceSkip = this.interpreter.booleanValueOf(this.params.switchValue);\n        case 10:\n          return settings.skipVoiceOnAction = this.interpreter.booleanValueOf(this.params.switchValue);\n        case 11:\n          settings.fullScreen = this.interpreter.booleanValueOf(this.params.switchValue);\n          if (settings.fullScreen) {\n            return SceneManager.scene.behavior.enterFullScreen();\n          } else {\n            return SceneManager.scene.behavior.leaveFullScreen();\n          }\n          break;\n        case 12:\n          settings.adjustAspectRatio = this.interpreter.booleanValueOf(this.params.switchValue);\n          Graphics.keepRatio = settings.adjustAspectRatio;\n          return Graphics.onResize();\n        case 13:\n          return settings.confirmation = this.interpreter.booleanValueOf(this.params.switchValue);\n        case 14:\n          return settings.bgmVolume = this.interpreter.numberValueOf(this.params.numberValue);\n        case 15:\n          return settings.voiceVolume = this.interpreter.numberValueOf(this.params.numberValue);\n        case 16:\n          return settings.seVolume = this.interpreter.numberValueOf(this.params.numberValue);\n        case 17:\n          return settings.bgmEnabled = this.interpreter.booleanValueOf(this.params.switchValue);\n        case 18:\n          return settings.voiceEnabled = this.interpreter.booleanValueOf(this.params.switchValue);\n        case 19:\n          return settings.seEnabled = this.interpreter.booleanValueOf(this.params.switchValue);\n        case 20:\n          code = this.interpreter.stringValueOf(this.params.textValue);\n          language = LanguageManager.languages.first((function(_this) {\n            return function(l) {\n              return l.code === code;\n            };\n          })(this));\n          if (language) {\n            return LanguageManager.selectLanguage(language);\n          }\n          break;\n        case 21:\n          return GameManager.tempSettings.skip = this.interpreter.booleanValueOf(this.params.switchValue);\n      }\n    };\n\n\n    /**\n    * @method commandGetObjectData\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandGetObjectData = function() {\n      var area, characterId, field, object, ref, ref1, scene;\n      scene = SceneManager.scene;\n      switch (this.params.objectType) {\n        case 0:\n          scene.behavior.changePictureDomain(this.params.numberDomain);\n          object = SceneManager.scene.pictures[this.interpreter.numberValueOf(this.params.number)];\n          break;\n        case 1:\n          object = SceneManager.scene.backgrounds[this.interpreter.numberValueOf(this.params.layer)];\n          break;\n        case 2:\n          scene.behavior.changeTextDomain(this.params.numberDomain);\n          object = SceneManager.scene.texts[this.interpreter.numberValueOf(this.params.number)];\n          break;\n        case 3:\n          scene.behavior.changeVideoDomain(this.params.numberDomain);\n          object = SceneManager.scene.videos[this.interpreter.numberValueOf(this.params.number)];\n          break;\n        case 4:\n          characterId = this.interpreter.stringValueOf(this.params.characterId);\n          object = SceneManager.scene.characters.first((function(_this) {\n            return function(v) {\n              return !v.disposed && v.rid === characterId;\n            };\n          })(this));\n          break;\n        case 5:\n          object = gs.ObjectManager.current.objectById(\"messageBox\");\n          break;\n        case 6:\n          scene.behavior.changeMessageAreaDomain(this.params.numberDomain);\n          area = SceneManager.scene.messageAreas[this.interpreter.numberValueOf(this.params.number)];\n          object = area != null ? area.layout : void 0;\n          break;\n        case 7:\n          scene.behavior.changeHotspotDomain(this.params.numberDomain);\n          object = SceneManager.scene.hotspots[this.interpreter.numberValueOf(this.params.number)];\n      }\n      field = this.params.field;\n      if (this.params.objectType === 4) {\n        switch (this.params.field) {\n          case 0:\n            this.interpreter.setStringValueTo(this.params.targetVariable, ((ref = RecordManager.characters[characterId]) != null ? ref.index : void 0) || \"\");\n            break;\n          case 1:\n            this.interpreter.setStringValueTo(this.params.targetVariable, lcs((ref1 = RecordManager.characters[characterId]) != null ? ref1.name : void 0) || \"\");\n        }\n        field -= 2;\n      }\n      if (this.params.objectType === 6) {\n        switch (field) {\n          case 0:\n            return this.interpreter.setNumberValueTo(this.params.targetVariable, object.dstRect.x);\n          case 1:\n            return this.interpreter.setNumberValueTo(this.params.targetVariable, object.dstRect.y);\n          case 2:\n            return this.interpreter.setNumberValueTo(this.params.targetVariable, object.zIndex);\n          case 3:\n            return this.interpreter.setNumberValueTo(this.params.targetVariable, object.opacity);\n          case 4:\n            return this.interpreter.setBooleanValueTo(this.params.targetVariable, object.visible);\n        }\n      } else if (object != null) {\n        if (field >= 0) {\n          switch (field) {\n            case 0:\n              switch (this.params.objectType) {\n                case 2:\n                  return this.interpreter.setStringValueTo(this.params.targetVariable, object.text || \"\");\n                case 3:\n                  return this.interpreter.setStringValueTo(this.params.targetVariable, object.video || \"\");\n                default:\n                  return this.interpreter.setStringValueTo(this.params.targetVariable, object.image || \"\");\n              }\n              break;\n            case 1:\n              return this.interpreter.setNumberValueTo(this.params.targetVariable, object.dstRect.x);\n            case 2:\n              return this.interpreter.setNumberValueTo(this.params.targetVariable, object.dstRect.y);\n            case 3:\n              return this.interpreter.setNumberValueTo(this.params.targetVariable, Math.round(object.anchor.x * 100));\n            case 4:\n              return this.interpreter.setNumberValueTo(this.params.targetVariable, Math.round(object.anchor.y * 100));\n            case 5:\n              return this.interpreter.setNumberValueTo(this.params.targetVariable, Math.round(object.zoom.x * 100));\n            case 6:\n              return this.interpreter.setNumberValueTo(this.params.targetVariable, Math.round(object.zoom.y * 100));\n            case 7:\n              return this.interpreter.setNumberValueTo(this.params.targetVariable, object.dstRect.width);\n            case 8:\n              return this.interpreter.setNumberValueTo(this.params.targetVariable, object.dstRect.height);\n            case 9:\n              return this.interpreter.setNumberValueTo(this.params.targetVariable, object.zIndex);\n            case 10:\n              return this.interpreter.setNumberValueTo(this.params.targetVariable, object.opacity);\n            case 11:\n              return this.interpreter.setNumberValueTo(this.params.targetVariable, object.angle);\n            case 12:\n              return this.interpreter.setBooleanValueTo(this.params.targetVariable, object.visible);\n            case 13:\n              return this.interpreter.setNumberValueTo(this.params.targetVariable, object.blendMode);\n            case 14:\n              return this.interpreter.setBooleanValueTo(this.params.targetVariable, object.mirror);\n          }\n        }\n      }\n    };\n\n\n    /**\n    * @method commandSetObjectData\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandSetObjectData = function() {\n      var area, characterId, field, name, object, ref, scene;\n      scene = SceneManager.scene;\n      switch (this.params.objectType) {\n        case 0:\n          scene.behavior.changePictureDomain(this.params.numberDomain);\n          object = SceneManager.scene.pictures[this.interpreter.numberValueOf(this.params.number)];\n          break;\n        case 1:\n          object = SceneManager.scene.backgrounds[this.interpreter.numberValueOf(this.params.layer)];\n          break;\n        case 2:\n          scene.behavior.changeTextDomain(this.params.numberDomain);\n          object = SceneManager.scene.texts[this.interpreter.numberValueOf(this.params.number)];\n          break;\n        case 3:\n          scene.behavior.changeVideoDomain(this.params.numberDomain);\n          object = SceneManager.scene.videos[this.interpreter.numberValueOf(this.params.number)];\n          break;\n        case 4:\n          characterId = this.interpreter.stringValueOf(this.params.characterId);\n          object = SceneManager.scene.characters.first((function(_this) {\n            return function(v) {\n              return !v.disposed && v.rid === characterId;\n            };\n          })(this));\n          break;\n        case 5:\n          object = gs.ObjectManager.current.objectById(\"messageBox\");\n          break;\n        case 6:\n          scene.behavior.changeMessageAreaDomain(this.params.numberDomain);\n          area = SceneManager.scene.messageAreas[this.interpreter.numberValueOf(this.params.number)];\n          object = area != null ? area.layout : void 0;\n          break;\n        case 7:\n          scene.behavior.changeHotspotDomain(this.params.numberDomain);\n          object = SceneManager.scene.hotspots[this.interpreter.numberValueOf(this.params.number)];\n      }\n      field = this.params.field;\n      if (this.params.objectType === 4) {\n        switch (field) {\n          case 0:\n            name = this.interpreter.stringValueOf(this.params.textValue);\n            if (object != null) {\n              object.name = name;\n            }\n            if ((ref = RecordManager.characters[characterId]) != null) {\n              ref.name = name;\n            }\n        }\n        field--;\n      }\n      if (this.params.objectType === 6) {\n        switch (field) {\n          case 0:\n            return object.dstRect.x = this.interpreter.numberValueOf(this.params.numberValue);\n          case 1:\n            return object.dstRect.y = this.interpreter.numberValueOf(this.params.numberValue);\n          case 2:\n            return object.zIndex = this.interpreter.numberValueOf(this.params.numberValue);\n          case 3:\n            return object.opacity = this.interpreter.numberValueOf(this.params.numberValue);\n          case 4:\n            return object.visible = this.interpreter.booleanValueOf(this.params.switchValue);\n        }\n      } else if (object != null) {\n        if (field >= 0) {\n          switch (field) {\n            case 0:\n              switch (this.params.objectType) {\n                case 2:\n                  return object.text = this.interpreter.stringValueOf(this.params.textValue);\n                case 3:\n                  return object.video = this.interpreter.stringValueOf(this.params.textValue);\n                default:\n                  return object.image = this.interpreter.stringValueOf(this.params.textValue);\n              }\n              break;\n            case 1:\n              return object.dstRect.x = this.interpreter.numberValueOf(this.params.numberValue);\n            case 2:\n              return object.dstRect.y = this.interpreter.numberValueOf(this.params.numberValue);\n            case 3:\n              return object.anchor.x = this.interpreter.numberValueOf(this.params.numberValue) / 100;\n            case 4:\n              return object.anchor.y = this.interpreter.numberValueOf(this.params.numberValue) / 100;\n            case 5:\n              return object.zoom.x = this.interpreter.numberValueOf(this.params.numberValue) / 100;\n            case 6:\n              return object.zoom.y = this.interpreter.numberValueOf(this.params.numberValue) / 100;\n            case 7:\n              return object.zIndex = this.interpreter.numberValueOf(this.params.numberValue);\n            case 8:\n              return object.opacity = this.interpreter.numberValueOf(this.params.numberValue);\n            case 9:\n              return object.angle = this.interpreter.numberValueOf(this.params.numberValue);\n            case 10:\n              return object.visible = this.interpreter.booleanValueOf(this.params.switchValue);\n            case 11:\n              return object.blendMode = this.interpreter.numberValueOf(this.params.numberValue);\n            case 12:\n              return object.mirror = this.interpreter.booleanValueOf(this.params.switchValue);\n          }\n        }\n      }\n    };\n\n\n    /**\n    * @method commandChangeSounds\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandChangeSounds = function() {\n      var fieldFlags, i, k, len, ref, results, sound, sounds;\n      sounds = RecordManager.system.sounds;\n      fieldFlags = this.params.fieldFlags || {};\n      ref = this.params.sounds;\n      results = [];\n      for (i = k = 0, len = ref.length; k < len; i = ++k) {\n        sound = ref[i];\n        if (!gs.CommandFieldFlags.isLocked(fieldFlags[\"sounds.\" + i])) {\n          results.push(sounds[i] = this.params.sounds[i]);\n        } else {\n          results.push(void 0);\n        }\n      }\n      return results;\n    };\n\n\n    /**\n    * @method commandChangeColors\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandChangeColors = function() {\n      var color, colors, fieldFlags, i, k, len, ref, results;\n      colors = RecordManager.system.colors;\n      fieldFlags = this.params.fieldFlags || {};\n      ref = this.params.colors;\n      results = [];\n      for (i = k = 0, len = ref.length; k < len; i = ++k) {\n        color = ref[i];\n        if (!gs.CommandFieldFlags.isLocked(fieldFlags[\"colors.\" + i])) {\n          results.push(colors[i] = new gs.Color(this.params.colors[i]));\n        } else {\n          results.push(void 0);\n        }\n      }\n      return results;\n    };\n\n\n    /**\n    * @method commandChangeScreenCursor\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandChangeScreenCursor = function() {\n      var bitmap, ref;\n      if (((ref = this.params.graphic) != null ? ref.name : void 0) != null) {\n        bitmap = ResourceManager.getBitmap(\"Graphics/Pictures/\" + this.params.graphic.name);\n        return Graphics.setCursorBitmap(bitmap, this.params.hx, this.params.hy);\n      } else {\n        return Graphics.setCursorBitmap(null, 0, 0);\n      }\n    };\n\n\n    /**\n    * @method commandResetGlobalData\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandResetGlobalData = function() {\n      return GameManager.resetGlobalData();\n    };\n\n\n    /**\n    * @method commandScript\n    * @protected\n     */\n\n    Component_CommandInterpreter.prototype.commandScript = function() {\n      var ex;\n      try {\n        if (!this.params.scriptFunc) {\n          this.params.scriptFunc = eval(\"(function(){\" + this.params.script + \"})\");\n        }\n        return this.params.scriptFunc();\n      } catch (error) {\n        ex = error;\n        return console.log(ex);\n      }\n    };\n\n    return Component_CommandInterpreter;\n\n  })(gs.Component);\n\n  window.CommandInterpreter = Component_CommandInterpreter;\n\n  gs.Component_CommandInterpreter = Component_CommandInterpreter;\n\n}).call(this);\n"
    },
    "summary": [
        "name",
        "type",
        "order"
    ],
    "externalItems": []
}