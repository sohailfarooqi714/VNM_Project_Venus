{
    "uid": "87BE6898K0E78A48FCSB889E1DAAB10BF84B",
    "isLoaded": true,
    "lastModificationTime": 0,
    "items": {
        "name": "Component_HotspotBehavior",
        "type": "game_script",
        "order": 1,
        "parentId": "01A95DA3K01E8A4CB4SBE17E790BCE1FC035",
        "folder": false,
        "content": "# ===================================================================\n#\n#   Script: Component_HotspotBehavior\n#\n#   $$COPYRIGHT$$\n#\n# ===================================================================\n\nclass HotspotShape\n    @RECTANGLE = \"rect\"\n    @PIXEL = \"pixel\"\ngs.HotspotShape = HotspotShape\n\nclass Component_HotspotBehavior extends gs.Component\n    ###*\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    *\n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n    ###\n    onDataBundleRestore: (data, context) ->\n        @setupEventHandlers()\n\n    ###*\n    * Adds a hotspot-behavior to a game object. That allows a game object\n    * to respond to mouse/touch actions by firing an action-event or changing\n    * the game object's image.\n    *\n    * @module gs\n    * @class Component_HotspotBehavior\n    * @extends gs.Component\n    * @memberof gs\n    * @constructor\n    ###\n    constructor: (params) ->\n        ###*\n        * The shape used to detect if a hotspot is clicked, hovered, etc.\n        * @property shape\n        * @type boolean\n        ###\n        @shape = gs.HotspotShape.RECTANGLE\n\n        ###*\n        * Indicates if the hotspot is selected.\n        * @property selected\n        * @type boolean\n        ###\n        @selected = no\n\n        ###*\n        * Indicates if the hotspot is enabled.\n        * @property enabled\n        * @type boolean\n        ###\n        @enabled = yes\n\n        ###*\n        * @property imageHandling\n        * @type number\n        * @protected\n        ###\n        @imageHandling = 0\n\n        ###*\n        * Indicates if the mouse/touch pointer is inside the hotspot bounds.\n        * @property contains\n        * @type boolean\n        * @protected\n        ###\n        @containsPointer = no\n\n        ###*\n        * Indicates if the action-button was pressed before.\n        * @property buttonUp\n        * @type boolean\n        * @protected\n        ###\n        @buttonUp = no\n\n        ###*\n        * Indicates if the action-button is pressed.\n        * @property buttonDown\n        * @type boolean\n        * @protected\n        ###\n        @buttonDown = no\n\n        ###*\n        * @property actionButtons\n        * @type Object\n        * @protected\n        ###\n        @actionButtons = { \"left\": Input.Mouse.BUTTON_LEFT, \"right\": Input.Mouse.BUTTON_RIGHT, \"middle\": Input.Mouse.BUTTON_MIDDLE }\n\n        ###*\n        * The default action-button. By default the left-button is used.\n        *\n        * @property actionButton\n        * @type number\n        ###\n        @actionButton = @actionButtons[params?.actionButton ? \"left\"]\n\n        ###*\n        * The sound played if the hotspot action is executed.\n        * @property sound\n        * @type Object\n        ###\n        @sound = params?.sound\n\n        ###*\n        * <p>The sounds played depending on the hotspot state.</p>\n        * <ul>\n        * <li>0 = Select Sound</li>\n        * <li>1 = Unselect Sound</li>\n        * </ul>\n        * @property sounds\n        * @type Object[]\n        ###\n        @sounds = params?.sounds || []\n\n\n    ###*\n    * Gets the render-index of the object associated with the hotspot component. This\n    * implementation is necessary to be able to act as an owner for gs.EventEmitter.on\n    * event registration.\n    *\n    * @property rIndex\n    * @type number\n    ###\n    @accessors \"rIndex\",\n        get: -> @object.rIndex\n\n    ###*\n    * Sets up event handlers.\n    *\n    * @method setupEventHandlers\n    ###\n    setupEventHandlers: ->\n        gs.GlobalEventManager.offByOwner(\"mouseUp\", this)\n        gs.GlobalEventManager.offByOwner(\"mouseMoved\", this)\n\n        gs.GlobalEventManager.on \"hotspotDrop\", ((e) =>\n            scene = SceneManager.scene\n            for hotspot in scene.hotspots\n                rect = e.sender.dstRect\n                if hotspot? and hotspot != e.sender and hotspot.dstRect.intersect(rect.x, rect.y, rect.width, rect.height)\n                    hotspot.events.emit(\"dropReceived\", hotspot)\n                    #@executeAction(hotspot.data.params.actions.onDropReceive, yes, hotspot.data.bindValue)\n        ), null, this\n\n        gs.GlobalEventManager.on \"mouseUp\", ((e) =>\n            return if not @object.visible\n            mx = Input.Mouse.x - @object.origin.x\n            my = Input.Mouse.y - @object.origin.y\n            contains = Rect.contains(@object.dstRect.x, @object.dstRect.y,\n                         @object.dstRect.width, @object.dstRect.height,\n                         mx, my)\n            if contains\n                contains = @checkShape(mx - @object.dstRect.x, my - @object.dstRect.y)\n                if contains\n                    @containsPointer = contains\n                    @updateInput()\n                    @updateEvents()\n                    @object.needsUpdate = yes\n                    e.breakChain = yes\n            ),\n            null, this\n\n        if @object.images or yes\n            gs.GlobalEventManager.on \"mouseMoved\", ((e) =>\n                return if not @object.visible\n\n                contains = Rect.contains(@object.dstRect.x, @object.dstRect.y,\n                         @object.dstRect.width, @object.dstRect.height,\n                         Input.Mouse.x - @object.origin.x, Input.Mouse.y - @object.origin.y)\n\n                if contains\n                    mx = Input.Mouse.x - @object.origin.x\n                    my = Input.Mouse.y - @object.origin.y\n                    contains = @checkShape(mx - @object.dstRect.x, my - @object.dstRect.y)\n\n                if @containsPointer != contains\n                    @containsPointer = contains\n                    @object.needsUpdate = yes\n\n                    if contains\n                        @object.events.emit(\"enter\", this)\n                    else\n                        @object.events.emit(\"leave\", this)\n\n                @updateInput()\n            ),\n            null, this\n\n    ###*\n    * Initializes the hotspot component.\n    *\n    * @method setup\n    ###\n    setup: ->\n        super\n\n        @sound = ui.Component_FormulaHandler.fieldValue(@object, @sound)\n\n        if @sounds?\n            for sound, i in @sounds\n                @sounds[i] = ui.Component_FormulaHandler.fieldValue(@object, sound)\n        else\n           @sounds = []\n\n\n        @setupEventHandlers()\n\n\n\n    ###*\n    * Disposes the component.\n    *\n    * @method dispose\n    ###\n    dispose: ->\n        super\n\n        gs.GlobalEventManager.offByOwner(\"mouseUp\", this)\n        gs.GlobalEventManager.offByOwner(\"mouseMoved\", this)\n\n\n    ###*\n    * Checks if the specified point is inside of the hotspot's shape.\n    *\n    * @method checkShape\n    * @param x - The x-coordinate of the point.\n    * @param y - The y-coordinate of the point.\n    * @return If <b>true</b> the point is inside of the hotspot's shape. Otherwise <b>false</b>.\n    ###\n    checkShape: (x, y) ->\n        result = yes\n\n        switch @shape\n            when gs.HotspotShape.PIXEL\n                if @object.bitmap\n                    result = @object.bitmap.isPixelSet(x, y)\n                else\n                    result = @object.target?.bitmap.isPixelSet(x, y)\n\n        return result\n\n    ###*\n    * Updates the image depending on the hotspot state.\n    *\n    * @method updateImage\n    * @protected\n    ###\n    updateImage: ->\n        object = @object.target || @object\n        if @object.images?\n            baseImage = if @enabled then @object.images[4] || @object.images[0] else @object.images[0]\n            if @containsPointer\n                if @object.selected or @selected\n                    object.image = @object.images[3] || @object.images[2] || baseImage\n                else\n                    object.image = @object.images[1] || baseImage\n            else\n                if @object.selected or @selected\n                    object.image = @object.images[2] || @object.images[4] || baseImage\n                else\n                    object.image = baseImage\n\n            if !object.image\n                object.bitmap = null\n\n\n    ###*\n    * Updates the hotspot position and size from an other target game object. For example,\n    * that is useful for adding a hotspot to an other moving game object.\n    *\n    * @method updateFromTarget\n    * @protected\n    ###\n    updateFromTarget: ->\n        if @object.target?\n            @object.dstRect.x = @object.target.dstRect.x\n            @object.dstRect.y = @object.target.dstRect.y\n            @object.dstRect.width = @object.target.dstRect.width\n            @object.dstRect.height = @object.target.dstRect.height\n            @object.offset.x = @object.target.offset.x\n            @object.offset.y = @object.target.offset.y\n            @object.origin.x = @object.target.origin.x\n            @object.origin.y = @object.target.origin.y\n\n    ###*\n    * Updates the event-handling and fires necessary events.\n    *\n    * @method updateEvents\n    * @protected\n    ###\n    updateEvents: ->\n        if @buttonUp and @object.enabled and @enabled and @object.visible\n            if @object.selectable\n                group = gs.ObjectManager.current.objectsByGroup(@object.group)\n                for object in group\n                    if object != @object\n                        object.selected = no\n                if @object.group\n                    @selected = yes\n                else\n                    @selected = !@selected\n\n                if @selected\n                    AudioManager.playSound(@sounds[0] || @sound)\n                else\n                    AudioManager.playSound(@sounds[1] || @sound)\n                @object.events.emit(\"click\", this)\n                @object.events.emit(\"stateChanged\", @object)\n            else\n                AudioManager.playSound(@sounds[0] || @sound)\n                @object.events.emit(\"click\", this)\n                @object.events.emit(\"action\", this)\n\n    ###*\n    * Updates the game object's color depending on the state of the hotspot.\n    *\n    * @method updateColor\n    * @protected\n    ###\n    updateColor: ->\n        if !@object.enabled\n            @object.color.set(0, 0, 0, 100)\n        else\n            @object.color.set(0, 0, 0, 0)\n\n    ###*\n    * Stores current states of mouse/touch pointer and buttons.\n    *\n    * @method updateInput\n    * @protected\n    ###\n    updateInput: ->\n        @buttonUp = Input.Mouse.buttons[@actionButton] == 2 and @containsPointer\n        @buttonDown = Input.Mouse.buttons[@actionButton] == 1 and @containsPointer\n\n    ###*\n    * Updates the hotspot component.\n    *\n    * @method update\n    ###\n    update: ->\n        if not @object.visible then return\n\n        @updateColor()\n        @updateFromTarget()\n        @updateImage()\n\ngs.Component_HotspotBehavior = Component_HotspotBehavior",
        "compiledContent": "// Generated by CoffeeScript 1.12.7\n(function() {\n  var Component_HotspotBehavior, HotspotShape,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  HotspotShape = (function() {\n    function HotspotShape() {}\n\n    HotspotShape.RECTANGLE = \"rect\";\n\n    HotspotShape.PIXEL = \"pixel\";\n\n    return HotspotShape;\n\n  })();\n\n  gs.HotspotShape = HotspotShape;\n\n  Component_HotspotBehavior = (function(superClass) {\n    extend(Component_HotspotBehavior, superClass);\n\n\n    /**\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    *\n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n     */\n\n    Component_HotspotBehavior.prototype.onDataBundleRestore = function(data, context) {\n      return this.setupEventHandlers();\n    };\n\n\n    /**\n    * Adds a hotspot-behavior to a game object. That allows a game object\n    * to respond to mouse/touch actions by firing an action-event or changing\n    * the game object's image.\n    *\n    * @module gs\n    * @class Component_HotspotBehavior\n    * @extends gs.Component\n    * @memberof gs\n    * @constructor\n     */\n\n    function Component_HotspotBehavior(params) {\n\n      /**\n      * The shape used to detect if a hotspot is clicked, hovered, etc.\n      * @property shape\n      * @type boolean\n       */\n      var ref;\n      this.shape = gs.HotspotShape.RECTANGLE;\n\n      /**\n      * Indicates if the hotspot is selected.\n      * @property selected\n      * @type boolean\n       */\n      this.selected = false;\n\n      /**\n      * Indicates if the hotspot is enabled.\n      * @property enabled\n      * @type boolean\n       */\n      this.enabled = true;\n\n      /**\n      * @property imageHandling\n      * @type number\n      * @protected\n       */\n      this.imageHandling = 0;\n\n      /**\n      * Indicates if the mouse/touch pointer is inside the hotspot bounds.\n      * @property contains\n      * @type boolean\n      * @protected\n       */\n      this.containsPointer = false;\n\n      /**\n      * Indicates if the action-button was pressed before.\n      * @property buttonUp\n      * @type boolean\n      * @protected\n       */\n      this.buttonUp = false;\n\n      /**\n      * Indicates if the action-button is pressed.\n      * @property buttonDown\n      * @type boolean\n      * @protected\n       */\n      this.buttonDown = false;\n\n      /**\n      * @property actionButtons\n      * @type Object\n      * @protected\n       */\n      this.actionButtons = {\n        \"left\": Input.Mouse.BUTTON_LEFT,\n        \"right\": Input.Mouse.BUTTON_RIGHT,\n        \"middle\": Input.Mouse.BUTTON_MIDDLE\n      };\n\n      /**\n      * The default action-button. By default the left-button is used.\n      *\n      * @property actionButton\n      * @type number\n       */\n      this.actionButton = this.actionButtons[(ref = params != null ? params.actionButton : void 0) != null ? ref : \"left\"];\n\n      /**\n      * The sound played if the hotspot action is executed.\n      * @property sound\n      * @type Object\n       */\n      this.sound = params != null ? params.sound : void 0;\n\n      /**\n      * <p>The sounds played depending on the hotspot state.</p>\n      * <ul>\n      * <li>0 = Select Sound</li>\n      * <li>1 = Unselect Sound</li>\n      * </ul>\n      * @property sounds\n      * @type Object[]\n       */\n      this.sounds = (params != null ? params.sounds : void 0) || [];\n    }\n\n\n    /**\n    * Gets the render-index of the object associated with the hotspot component. This\n    * implementation is necessary to be able to act as an owner for gs.EventEmitter.on\n    * event registration.\n    *\n    * @property rIndex\n    * @type number\n     */\n\n    Component_HotspotBehavior.accessors(\"rIndex\", {\n      get: function() {\n        return this.object.rIndex;\n      }\n    });\n\n\n    /**\n    * Sets up event handlers.\n    *\n    * @method setupEventHandlers\n     */\n\n    Component_HotspotBehavior.prototype.setupEventHandlers = function() {\n      gs.GlobalEventManager.offByOwner(\"mouseUp\", this);\n      gs.GlobalEventManager.offByOwner(\"mouseMoved\", this);\n      gs.GlobalEventManager.on(\"hotspotDrop\", ((function(_this) {\n        return function(e) {\n          var hotspot, j, len, rect, ref, results, scene;\n          scene = SceneManager.scene;\n          ref = scene.hotspots;\n          results = [];\n          for (j = 0, len = ref.length; j < len; j++) {\n            hotspot = ref[j];\n            rect = e.sender.dstRect;\n            if ((hotspot != null) && hotspot !== e.sender && hotspot.dstRect.intersect(rect.x, rect.y, rect.width, rect.height)) {\n              results.push(hotspot.events.emit(\"dropReceived\", hotspot));\n            } else {\n              results.push(void 0);\n            }\n          }\n          return results;\n        };\n      })(this)), null, this);\n      gs.GlobalEventManager.on(\"mouseUp\", ((function(_this) {\n        return function(e) {\n          var contains, mx, my;\n          if (!_this.object.visible) {\n            return;\n          }\n          mx = Input.Mouse.x - _this.object.origin.x;\n          my = Input.Mouse.y - _this.object.origin.y;\n          contains = Rect.contains(_this.object.dstRect.x, _this.object.dstRect.y, _this.object.dstRect.width, _this.object.dstRect.height, mx, my);\n          if (contains) {\n            contains = _this.checkShape(mx - _this.object.dstRect.x, my - _this.object.dstRect.y);\n            if (contains) {\n              _this.containsPointer = contains;\n              _this.updateInput();\n              _this.updateEvents();\n              _this.object.needsUpdate = true;\n              return e.breakChain = true;\n            }\n          }\n        };\n      })(this)), null, this);\n      if (this.object.images || true) {\n        return gs.GlobalEventManager.on(\"mouseMoved\", ((function(_this) {\n          return function(e) {\n            var contains, mx, my;\n            if (!_this.object.visible) {\n              return;\n            }\n            contains = Rect.contains(_this.object.dstRect.x, _this.object.dstRect.y, _this.object.dstRect.width, _this.object.dstRect.height, Input.Mouse.x - _this.object.origin.x, Input.Mouse.y - _this.object.origin.y);\n            if (contains) {\n              mx = Input.Mouse.x - _this.object.origin.x;\n              my = Input.Mouse.y - _this.object.origin.y;\n              contains = _this.checkShape(mx - _this.object.dstRect.x, my - _this.object.dstRect.y);\n            }\n            if (_this.containsPointer !== contains) {\n              _this.containsPointer = contains;\n              _this.object.needsUpdate = true;\n              if (contains) {\n                _this.object.events.emit(\"enter\", _this);\n              } else {\n                _this.object.events.emit(\"leave\", _this);\n              }\n            }\n            return _this.updateInput();\n          };\n        })(this)), null, this);\n      }\n    };\n\n\n    /**\n    * Initializes the hotspot component.\n    *\n    * @method setup\n     */\n\n    Component_HotspotBehavior.prototype.setup = function() {\n      var i, j, len, ref, sound;\n      Component_HotspotBehavior.__super__.setup.apply(this, arguments);\n      this.sound = ui.Component_FormulaHandler.fieldValue(this.object, this.sound);\n      if (this.sounds != null) {\n        ref = this.sounds;\n        for (i = j = 0, len = ref.length; j < len; i = ++j) {\n          sound = ref[i];\n          this.sounds[i] = ui.Component_FormulaHandler.fieldValue(this.object, sound);\n        }\n      } else {\n        this.sounds = [];\n      }\n      return this.setupEventHandlers();\n    };\n\n\n    /**\n    * Disposes the component.\n    *\n    * @method dispose\n     */\n\n    Component_HotspotBehavior.prototype.dispose = function() {\n      Component_HotspotBehavior.__super__.dispose.apply(this, arguments);\n      gs.GlobalEventManager.offByOwner(\"mouseUp\", this);\n      return gs.GlobalEventManager.offByOwner(\"mouseMoved\", this);\n    };\n\n\n    /**\n    * Checks if the specified point is inside of the hotspot's shape.\n    *\n    * @method checkShape\n    * @param x - The x-coordinate of the point.\n    * @param y - The y-coordinate of the point.\n    * @return If <b>true</b> the point is inside of the hotspot's shape. Otherwise <b>false</b>.\n     */\n\n    Component_HotspotBehavior.prototype.checkShape = function(x, y) {\n      var ref, result;\n      result = true;\n      switch (this.shape) {\n        case gs.HotspotShape.PIXEL:\n          if (this.object.bitmap) {\n            result = this.object.bitmap.isPixelSet(x, y);\n          } else {\n            result = (ref = this.object.target) != null ? ref.bitmap.isPixelSet(x, y) : void 0;\n          }\n      }\n      return result;\n    };\n\n\n    /**\n    * Updates the image depending on the hotspot state.\n    *\n    * @method updateImage\n    * @protected\n     */\n\n    Component_HotspotBehavior.prototype.updateImage = function() {\n      var baseImage, object;\n      object = this.object.target || this.object;\n      if (this.object.images != null) {\n        baseImage = this.enabled ? this.object.images[4] || this.object.images[0] : this.object.images[0];\n        if (this.containsPointer) {\n          if (this.object.selected || this.selected) {\n            object.image = this.object.images[3] || this.object.images[2] || baseImage;\n          } else {\n            object.image = this.object.images[1] || baseImage;\n          }\n        } else {\n          if (this.object.selected || this.selected) {\n            object.image = this.object.images[2] || this.object.images[4] || baseImage;\n          } else {\n            object.image = baseImage;\n          }\n        }\n        if (!object.image) {\n          return object.bitmap = null;\n        }\n      }\n    };\n\n\n    /**\n    * Updates the hotspot position and size from an other target game object. For example,\n    * that is useful for adding a hotspot to an other moving game object.\n    *\n    * @method updateFromTarget\n    * @protected\n     */\n\n    Component_HotspotBehavior.prototype.updateFromTarget = function() {\n      if (this.object.target != null) {\n        this.object.dstRect.x = this.object.target.dstRect.x;\n        this.object.dstRect.y = this.object.target.dstRect.y;\n        this.object.dstRect.width = this.object.target.dstRect.width;\n        this.object.dstRect.height = this.object.target.dstRect.height;\n        this.object.offset.x = this.object.target.offset.x;\n        this.object.offset.y = this.object.target.offset.y;\n        this.object.origin.x = this.object.target.origin.x;\n        return this.object.origin.y = this.object.target.origin.y;\n      }\n    };\n\n\n    /**\n    * Updates the event-handling and fires necessary events.\n    *\n    * @method updateEvents\n    * @protected\n     */\n\n    Component_HotspotBehavior.prototype.updateEvents = function() {\n      var group, j, len, object;\n      if (this.buttonUp && this.object.enabled && this.enabled && this.object.visible) {\n        if (this.object.selectable) {\n          group = gs.ObjectManager.current.objectsByGroup(this.object.group);\n          for (j = 0, len = group.length; j < len; j++) {\n            object = group[j];\n            if (object !== this.object) {\n              object.selected = false;\n            }\n          }\n          if (this.object.group) {\n            this.selected = true;\n          } else {\n            this.selected = !this.selected;\n          }\n          if (this.selected) {\n            AudioManager.playSound(this.sounds[0] || this.sound);\n          } else {\n            AudioManager.playSound(this.sounds[1] || this.sound);\n          }\n          this.object.events.emit(\"click\", this);\n          return this.object.events.emit(\"stateChanged\", this.object);\n        } else {\n          AudioManager.playSound(this.sounds[0] || this.sound);\n          this.object.events.emit(\"click\", this);\n          return this.object.events.emit(\"action\", this);\n        }\n      }\n    };\n\n\n    /**\n    * Updates the game object's color depending on the state of the hotspot.\n    *\n    * @method updateColor\n    * @protected\n     */\n\n    Component_HotspotBehavior.prototype.updateColor = function() {\n      if (!this.object.enabled) {\n        return this.object.color.set(0, 0, 0, 100);\n      } else {\n        return this.object.color.set(0, 0, 0, 0);\n      }\n    };\n\n\n    /**\n    * Stores current states of mouse/touch pointer and buttons.\n    *\n    * @method updateInput\n    * @protected\n     */\n\n    Component_HotspotBehavior.prototype.updateInput = function() {\n      this.buttonUp = Input.Mouse.buttons[this.actionButton] === 2 && this.containsPointer;\n      return this.buttonDown = Input.Mouse.buttons[this.actionButton] === 1 && this.containsPointer;\n    };\n\n\n    /**\n    * Updates the hotspot component.\n    *\n    * @method update\n     */\n\n    Component_HotspotBehavior.prototype.update = function() {\n      if (!this.object.visible) {\n        return;\n      }\n      this.updateColor();\n      this.updateFromTarget();\n      return this.updateImage();\n    };\n\n    return Component_HotspotBehavior;\n\n  })(gs.Component);\n\n  gs.Component_HotspotBehavior = Component_HotspotBehavior;\n\n}).call(this);\n"
    },
    "summary": [
        "name",
        "type",
        "order"
    ],
    "externalItems": []
}