{
    "uid": "564F8E31K64F3A4823S8E83E87FB6B24717C",
    "isLoaded": true,
    "lastModificationTime": 1426867424531,
    "items": {
        "name": "AudioManager",
        "type": "game_script",
        "order": 5,
        "parentId": "C0268943K60B3A42B7SA6F1EDDCF2F642FD7",
        "content": "# ===================================================================\n#\n#   Script: AudioManager\n#\n#   $$COPYRIGHT$$\n#\n# ===================================================================\nclass AudioManager\n    ###*\n    * Manages the audio playback of the game. \n    *\n    * @module gs\n    * @class AudioManager\n    * @memberof gs\n    * @constructor\n    ###\n    constructor: ->\n        ###*\n        * Stores all audio buffers.\n        * @property buffers\n        * @type gs.AudioBuffer[]\n        * @protected\n        ###  \n        @audioBuffers = []\n        \n        ###*\n        * Stores all audio buffers by layer.\n        * @property buffers\n        * @type gs.AudioBuffer[]\n        * @protected\n        ###  \n        @audioBuffersByLayer = []\n        \n        ###*\n        * Stores all audio buffer references for sounds.\n        * @property soundReferences\n        * @type gs.AudioBufferReference[]\n        * @protected\n        ###  \n        @soundReferences = {}\n        \n        ###*\n        * Current Music (Layer 0)\n        * @property music\n        * @type Object\n        * @protected\n        ### \n        @music = null\n        \n        ###*\n        * Current music volume.\n        * @property musicVolume\n        * @type number\n        * @protected\n        ### \n        @musicVolume = 100\n        \n        ###*\n        * Current sound volume.\n        * @property soundVolume\n        * @type number\n        * @protected\n        ### \n        @soundVolume = 100\n        \n        ###*\n        * Current voice volume.\n        * @property voiceVolume\n        * @type number\n        * @protected\n        ### \n        @voiceVolume = 100\n        \n        ###*\n        * General music volume\n        * @property generalMusicVolume\n        * @type number\n        * @protected\n        ### \n        @generalMusicVolume = 100\n        \n        ###*\n        * General sound volume\n        * @property generalSoundVolume\n        * @type number\n        * @protected\n        ### \n        @generalSoundVolume = 100\n        \n        ###*\n        * General voice volume\n        * @property generalVoiceVolume\n        * @type number\n        * @protected\n        ### \n        @generalVoiceVolume = 100\n        \n        ###*\n        * Stores audio layer info-data for each layer.\n        * @property audioLayers\n        * @type gs.AudioLayerInfo[]\n        * @protected\n        ### \n        @audioLayers = []\n      \n    ###*\n    * Restores audio-playback from a specified array of audio layers.\n    *\n    * @method restore\n    * @param {gs.AudioLayerInfo[]} layers - An array of audio layer info objects.\n    ###  \n    restore: (layers) ->\n        @audioLayers = layers\n        \n        for layer, i in layers\n            if layer and layer.playing\n                if layer.customData\n                    @playMusicRandom(layer, layer.customData.fadeTime, i, layer.customData.playTime, layer.customData.playRange)\n                else\n                    @playMusic(layer, layer.fadeInTime, i)\n     \n    ###*\n    * Loads the specified music.\n    *\n    * @method loadMusic\n    * @param {String} name - The name of the music to load.\n    ###    \n    loadMusic: (name) -> \n        name = if name? then (name.name || name) else name\n        if name and name.length > 0\n            ResourceManager.getAudioStream(\"Audio/Music/#{name}\")\n     \n    ###*\n    * Loads the specified sound.\n    *\n    * @method loadSound\n    * @param {String} name - The name of the sound to load.\n    ###           \n    loadSound: (name) -> \n        name = if name? then name.name || name else name\n        if name and name.length > 0\n            ResourceManager.getAudioBuffer(\"Audio/Sounds/#{name}\")\n    \n    ###*\n    * Updates a randomly played audio buffer.\n    *\n    * @method updateRandomAudio\n    * @param {gs.AudioBuffer} buffer - The audio buffer to update.\n    * @protected\n    ###    \n    # FIXME: Refactoring necessary.      \n    updateRandomAudio: (buffer) ->\n        if buffer.customData.startTimer > 0\n            buffer.customData.startTimer--\n            if buffer.customData.startTimer <= 0\n                buffer.fadeInVolume = 1.0 / (buffer.customData.fadeTime||1)\n                buffer.fadeInTime = buffer.customData.fadeTime||1\n                buffer.fadeOutTime = buffer.customData.fadeTime||1\n                buffer.playTime = buffer.customData.playTime.min + Math.random() * (buffer.customData.playTime.max - buffer.customData.playTime.min)\n                currentTime = buffer.currentTime # - buffer.startTime\n                timeLeft = buffer.duration - currentTime\n                buffer.playTime = Math.min(timeLeft * 1000 / 16.6, buffer.playTime)\n    \n                buffer.customData.startTimer = buffer.playTime + buffer.customData.playRange.start + Math.random() * (buffer.customData.playRange.end - buffer.customData.playRange.start)\n    \n    ###*\n    * Updates all audio-buffers depending on the play-type.\n    *\n    * @method updateAudioBuffers\n    * @protected\n    ###   \n    updateAudioBuffers: ->\n        for buffer in @audioBuffers\n            if buffer?\n                if buffer.customData.playType == 1\n                    @updateRandomAudio(buffer)\n                    \n                if GameManager.settings.bgmVolume != @generalMusicVolume\n                    buffer.volume = (@musicVolume * GameManager.settings.bgmVolume / 100) / 100\n                    \n                buffer.update()\n        if GameManager.settings.bgmVolume != @generalMusicVolume\n            @generalMusicVolume = GameManager.settings.bgmVolume\n    \n    \n    ###*\n    * Updates all audio-buffers depending on the play-type.\n    *\n    * @method updateAudioBuffers\n    * @protected\n    ###             \n    updateGeneralVolume: ->\n        if GameManager.settings.seVolume != @generalSoundVolume or GameManager.settings.voiceVolume != @generalVoiceVolume\n            @generalSoundVolume = GameManager.settings.seVolume\n            @generalVoiceVolume = GameManager.settings.voiceVolume\n            for k of @soundReferences\n                for reference in @soundReferences[k]\n                    if reference.voice\n                        reference.volume = (@voiceVolume * GameManager.settings.voiceVolume / 100) / 100\n                    else\n                        reference.volume = (@soundVolume * GameManager.settings.seVolume / 100) / 100\n    ###*\n    * Updates the audio-playback.\n    *\n    * @method update\n    ###                \n    update: ->\n        @updateAudioBuffers()\n        @updateGeneralVolume()\n     \n    ###*\n    * Changes the current music to the specified one.\n    *\n    * @method changeMusic\n    * @param {Object} music - The music to play. If <b>null</b> the current music will stop playing.\n    ###           \n    changeMusic: (music) ->\n        if music? and music.name?\n            if @music? and @music.name != music.name\n                @playMusic(music)\n            else if not @music?\n                @playMusic(music)\n        else\n            @stopMusic()\n     \n    # FIXME: Is this still used?\n    ###*\n    * Prepares. \n    *\n    * @method prepare\n    * @param {Object} music - The music to play. If <b>null</b> the current music will stop playing.\n    ###            \n    prepare: (path, volume, rate) -> \n        buffer = ResourceManager.getAudioBuffer(path)\n        \n        if buffer.decoded\n            buffer.volume = if volume? then volume / 100 else 1.0\n            buffer.playbackRate = if rate? then rate / 100 else 1.0\n        else\n           buffer.onFinishDecode = (source) => \n               source.volume = if volume? then volume / 100 else 1.0\n               source.playbackRate = if rate? then rate / 100 else 1.0\n           buffer.decode()\n           \n        return buffer\n        \n    ###*\n    * Plays an audio resource.\n    *\n    * @method play\n    * @param {String} path - The path to the audio resource.\n    * @param {number} volume - The volume.\n    * @param {number} rate - The playback rate.\n    * @param {number} fadeInTime - The fade-in time in frames.\n    ###     \n    play: (path, volume, rate, fadeInTime) ->\n        buffer = ResourceManager.getAudioStream(path)\n    \n        if buffer.decoded\n            buffer.volume = if volume? then volume / 100 else 1.0\n            buffer.playbackRate = if rate? then rate / 100 else 1.0\n            buffer.play(fadeInTime) if GameManager.settings.bgmEnabled\n        else\n           buffer.onFinishDecode = (source) => \n               source.volume = if volume? then volume / 100 else 1.0\n               source.playbackRate = if rate? then rate / 100 else 1.0\n               source.play(fadeInTime) if GameManager.settings.bgmEnabled\n           buffer.decode()\n           \n        return buffer\n     \n    ###*\n    * Stops all sounds.\n    *\n    * @method stopAllSounds\n    ###    \n    stopAllSounds: ->\n        for k of @soundReferences\n            for reference in @soundReferences[k]\n                reference?.stop()\n    \n    ###*\n    * Stops a sound and all references of it.\n    *\n    * @method stopSound\n    * @param {String} name - The name of the sound to stop.\n    ###             \n    stopSound: (name) ->\n        if @soundReferences[name]?\n            for reference in @soundReferences[name]\n                reference.stop()\n    \n    \n    ###*\n    * Stops a voice.\n    *\n    * @method stopVoice\n    * @param {String} name - The name of the voice to stop.\n    ###             \n    stopVoice: (name) ->\n        @stopSound(name)\n    \n    ###*\n    * Stops all voices.\n    *\n    * @method stopAllVoices\n    ###     \n    stopAllVoices: ->\n        for k of @soundReferences\n            for reference in @soundReferences[k]\n                reference.stop() if reference.voice\n    \n    ###*\n    * Plays a voice.\n    *\n    * @method playVoice\n    * @param {String} name - The name of the voice to play.\n    * @param {number} volume - The voice volume.\n    * @param {number} rate - The voice playback rate.\n    ###     \n    playVoice: (name, volume, rate) ->\n        voice = null\n        if GameManager.settings.voiceEnabled and not $PARAMS.preview?.settings.voiceDisabled\n            voice = @playSound(name?.name, volume || GameManager.defaults.audio.voiceVolume, rate || GameManager.defaults.audio.voicePlaybackRate, no, yes)\n        \n        return voice    \n    \n    ###*\n    * Plays a sound.\n    *\n    * @method playSound\n    * @param {String} name - The name of the sound to play.\n    * @param {number} volume - The sound's volume.\n    * @param {number} rate - The sound's playback rate.\n    * @param {boolean} musicEffect - Indicates if the sound should be played as a music effect. In that case, the current music\n    * at audio-layer will be paused until the sound finishes playing.\n    * @param {boolean} voice - Indicates if the sound should be handled as a voice.\n    ###          \n    playSound: (name, volume, rate, musicEffect, voice, loopSound) ->\n        if $PARAMS.preview?.settings.soundDisabled then return\n        if not name? or (!voice and !GameManager.settings.soundEnabled) then return\n        if name.name?\n            volume = name.volume\n            rate = name.playbackRate\n            name = name.name\n         \n        if name.length == 0 then return\n        \n        if musicEffect\n            @stopMusic()\n        \n        if not @soundReferences[name]?\n            @soundReferences[name] = []\n        \n        volume = volume ? 100\n        volume *= if voice then @generalVoiceVolume / 100 else @generalSoundVolume / 100\n        \n        reference = null\n        for r in @soundReferences[name]\n            if not r.isPlaying\n                reference = r\n                if musicEffect then reference.onEnd = => @resumeMusic(40)\n                reference.voice = voice\n                reference.volume = volume / 100\n                reference.playbackRate = rate / 100\n                reference.loop = loopSound\n                @voice = reference if voice\n                reference.play()\n                break\n         \n        if not reference?\n            buffer = ResourceManager.getAudioBuffer(\"Audio/Sounds/#{name}\")\n            if buffer and buffer.loaded\n                if buffer.decoded\n                    reference = new GS.AudioBufferReference(buffer, voice)\n                    if musicEffect then reference.onEnd = => @resumeMusic(40)\n                    reference.volume = volume / 100\n                    reference.playbackRate = rate / 100\n                    reference.voice = voice\n                    reference.loop = loopSound\n                    reference.play()\n                    @voice = reference if voice\n                    @soundReferences[name].push(reference)\n                else\n                    buffer.name = name\n                    buffer.onDecodeFinish = (source) =>\n                        reference = new GS.AudioBufferReference(source, voice)\n                        if musicEffect then reference.onEnd = => @resumeMusic(40)\n                        reference.voice = voice\n                        reference.volume = volume / 100\n                        reference.playbackRate = rate / 100\n                        reference.loop = loopSound\n                        @voice = reference if voice\n                        reference.play()\n                        @soundReferences[source.name].push(reference)\n                    buffer.decode()\n        \n        return reference            \n    \n    ###*\n    * Plays a music as a random music. A random music will fade-in and fade-out\n    * at random times. That can be combined with other audio-layers to create a\n    * much better looping of an audio track.\n    *\n    * @method playMusicRandom\n    * @param {Object} music - The music to play.\n    * @param {number} fadeTime - The time for a single fade-in/out in frames.\n    * @param {number} layer - The audio layer to use.\n    * @param {gs.Range} playTime - Play-Time range like 10s to 30s.\n    * @param {gs.Range} playRange - Play-Range.\n    ###     \n    playMusicRandom: (music, fadeTime, layer, playTime, playRange) ->\n        return if $PARAMS.preview?.settings.musicDisabled\n        layer = layer ? 0\n\n        volume = if music.volume? then music.volume else 100\n        volume = volume * (@generalMusicVolume / 100)\n        @musicVolume = volume\n        @disposeMusic(layer)\n        \n        if music.name? and music.name.length > 0\n            musicBuffer = @play(\"Audio/Music/#{music.name}\", volume, music.rate)\n            musicBuffer.loop = yes\n            musicBuffer.volume = 0\n            musicBuffer.duration = Math.round(musicBuffer.duration * 1000 / 16.6)\n            musicBuffer.customData.playType = 1\n            musicBuffer.customData.playTime = playTime\n            if playRange.end == 0\n                musicBuffer.customData.playRange = { start: playRange.start, end: musicBuffer.duration }\n            else\n                musicBuffer.customData.playRange = playRange\n            musicBuffer.customData.fadeTime = fadeTime\n            \n            musicBuffer.customData.startTimer = Math.round(musicBuffer.customData.playRange.start + Math.random() * (musicBuffer.customData.playRange.end - musicBuffer.customData.playRange.start))\n            \n            @audioBuffers.push(musicBuffer) if not @audioBuffers.contains(musicBuffer)\n            @audioBuffersByLayer[layer] = musicBuffer\n            @audioLayers[layer] = name: music.name, time: music.currentTime, volume: music.volume, rate: music.playbackRate, fadeInTime: fadeTime, customData: musicBuffer.customData\n     \n    ###*\n    * Plays a music.\n    *\n    * @method playMusic\n    * @param {string|Object} name - The music to play. Can be just a name or a music data-object.\n    * @param {number} volume - The music's volume in percent.\n    * @param {number} rate - The music's playback rate in percent.\n    * @param {number} fadeInTime - The fade-in time.\n    * @param {number} layer - The layer to play the music on.\n    * @param {boolean} loop - Indicates if the music should be looped\n    ###          \n    playMusic: (name, volume, rate, fadeInTime, layer, loopMusic) ->\n        return if $PARAMS.preview?.settings.musicDisabled\n        loopMusic ?= yes\n        if name? and name.name?\n            layer = if layer? then layer else rate || 0\n            fadeInTime = volume\n            volume = name.volume\n            rate = name.playbackRate\n            name = name.name\n        else\n            layer = layer ? 0\n            \n        @disposeMusic(layer)\n        @audioLayers[layer] = name: name, volume: volume, rate: rate, fadeInTime: fadeInTime, playing: true\n           \n        volume = if volume? then volume else 100\n        volume = volume * (@generalMusicVolume / 100)\n        @musicVolume = volume\n        \n        \n        if name? and name.length > 0\n            @music = name: name\n            musicBuffer = @play(\"Audio/Music/#{name}\", volume, rate, fadeInTime)\n            musicBuffer.loop = loopMusic\n            @audioBuffers.push(musicBuffer) if not @audioBuffers.contains(musicBuffer)\n            @audioBuffersByLayer[layer] = musicBuffer\n            \n        return musicBuffer\n            \n    ###*\n    * Resumes a paused music.\n    *\n    * @method resumeMusic\n    * @param {number} fadeInTime - The fade-in time in frames.\n    * @param {number} layer - The audio layer to resume.\n    ###   \n    resumeMusic: (fadeInTime, layer) ->\n        layer = layer ? 0\n        if @audioBuffersByLayer[layer]? and not @audioBuffersByLayer[layer].isPlaying\n            @audioBuffersByLayer[layer].resume(fadeInTime)\n            @audioLayers[layer]?.playing = true\n    \n    ###*\n    * Stops a music.\n    *\n    * @method stopMusic\n    * @param {number} fadeOutTime - The fade-out time in frames.\n    * @param {number} layer - The audio layer to stop.\n    ###         \n    stopMusic: (fadeOutTime, layer) -> \n        layer = layer ? 0\n        @audioBuffersByLayer[layer]?.stop(fadeOutTime)\n        @audioBuffersByLayer[layer]?.customData = {}\n        @audioLayers[layer]?.playing = false\n        @music = null\n        \n    ###*\n    * Stops all music/audio layers.\n    *\n    * @method stopAllMusic\n    * @param {number} fadeOutTime - The fade-out time in frames.\n    ###         \n    stopAllMusic: (fadeOutTime) -> \n        for buffer in @audioBuffers\n            if buffer?\n                buffer.stop(fadeOutTime)\n                buffer.customData = {}\n        @music = null\n\n\n    dispose: (context) ->\n        data = context.resources.select (r) -> r.data\n        for buffer, layer in @audioBuffersByLayer\n            if buffer and data.indexOf(buffer) != -1\n                buffer.dispose()\n                \n                @audioBuffers.remove(buffer)\n                @audioBuffersByLayer[layer] = null\n                @audioLayers[layer] = null\n                \n    ###*\n    * Disposes a music.\n    *\n    * @method disposeMusic\n    * @param {number} layer - The audio layer of the music to dispose.\n    ### \n    disposeMusic: (layer) ->\n        layer = layer ? 0\n        \n        @stopMusic(0, layer)\n        #@audioBuffers[layer]?.dispose()\n        @audioBuffers.remove(@audioBuffersByLayer[layer])\n        @audioBuffersByLayer[layer] = null\n        @audioLayers[layer] = null\n    \nwindow.AudioManager = new AudioManager()\ngs.AudioManager = AudioManager",
        "compiledContent": "// Generated by CoffeeScript 1.12.7\n(function() {\n  var AudioManager;\n\n  AudioManager = (function() {\n\n    /**\n    * Manages the audio playback of the game. \n    *\n    * @module gs\n    * @class AudioManager\n    * @memberof gs\n    * @constructor\n     */\n    function AudioManager() {\n\n      /**\n      * Stores all audio buffers.\n      * @property buffers\n      * @type gs.AudioBuffer[]\n      * @protected\n       */\n      this.audioBuffers = [];\n\n      /**\n      * Stores all audio buffers by layer.\n      * @property buffers\n      * @type gs.AudioBuffer[]\n      * @protected\n       */\n      this.audioBuffersByLayer = [];\n\n      /**\n      * Stores all audio buffer references for sounds.\n      * @property soundReferences\n      * @type gs.AudioBufferReference[]\n      * @protected\n       */\n      this.soundReferences = {};\n\n      /**\n      * Current Music (Layer 0)\n      * @property music\n      * @type Object\n      * @protected\n       */\n      this.music = null;\n\n      /**\n      * Current music volume.\n      * @property musicVolume\n      * @type number\n      * @protected\n       */\n      this.musicVolume = 100;\n\n      /**\n      * Current sound volume.\n      * @property soundVolume\n      * @type number\n      * @protected\n       */\n      this.soundVolume = 100;\n\n      /**\n      * Current voice volume.\n      * @property voiceVolume\n      * @type number\n      * @protected\n       */\n      this.voiceVolume = 100;\n\n      /**\n      * General music volume\n      * @property generalMusicVolume\n      * @type number\n      * @protected\n       */\n      this.generalMusicVolume = 100;\n\n      /**\n      * General sound volume\n      * @property generalSoundVolume\n      * @type number\n      * @protected\n       */\n      this.generalSoundVolume = 100;\n\n      /**\n      * General voice volume\n      * @property generalVoiceVolume\n      * @type number\n      * @protected\n       */\n      this.generalVoiceVolume = 100;\n\n      /**\n      * Stores audio layer info-data for each layer.\n      * @property audioLayers\n      * @type gs.AudioLayerInfo[]\n      * @protected\n       */\n      this.audioLayers = [];\n    }\n\n\n    /**\n    * Restores audio-playback from a specified array of audio layers.\n    *\n    * @method restore\n    * @param {gs.AudioLayerInfo[]} layers - An array of audio layer info objects.\n     */\n\n    AudioManager.prototype.restore = function(layers) {\n      var i, j, layer, len, results;\n      this.audioLayers = layers;\n      results = [];\n      for (i = j = 0, len = layers.length; j < len; i = ++j) {\n        layer = layers[i];\n        if (layer && layer.playing) {\n          if (layer.customData) {\n            results.push(this.playMusicRandom(layer, layer.customData.fadeTime, i, layer.customData.playTime, layer.customData.playRange));\n          } else {\n            results.push(this.playMusic(layer, layer.fadeInTime, i));\n          }\n        } else {\n          results.push(void 0);\n        }\n      }\n      return results;\n    };\n\n\n    /**\n    * Loads the specified music.\n    *\n    * @method loadMusic\n    * @param {String} name - The name of the music to load.\n     */\n\n    AudioManager.prototype.loadMusic = function(name) {\n      name = name != null ? name.name || name : name;\n      if (name && name.length > 0) {\n        return ResourceManager.getAudioStream(\"Audio/Music/\" + name);\n      }\n    };\n\n\n    /**\n    * Loads the specified sound.\n    *\n    * @method loadSound\n    * @param {String} name - The name of the sound to load.\n     */\n\n    AudioManager.prototype.loadSound = function(name) {\n      name = name != null ? name.name || name : name;\n      if (name && name.length > 0) {\n        return ResourceManager.getAudioBuffer(\"Audio/Sounds/\" + name);\n      }\n    };\n\n\n    /**\n    * Updates a randomly played audio buffer.\n    *\n    * @method updateRandomAudio\n    * @param {gs.AudioBuffer} buffer - The audio buffer to update.\n    * @protected\n     */\n\n    AudioManager.prototype.updateRandomAudio = function(buffer) {\n      var currentTime, timeLeft;\n      if (buffer.customData.startTimer > 0) {\n        buffer.customData.startTimer--;\n        if (buffer.customData.startTimer <= 0) {\n          buffer.fadeInVolume = 1.0 / (buffer.customData.fadeTime || 1);\n          buffer.fadeInTime = buffer.customData.fadeTime || 1;\n          buffer.fadeOutTime = buffer.customData.fadeTime || 1;\n          buffer.playTime = buffer.customData.playTime.min + Math.random() * (buffer.customData.playTime.max - buffer.customData.playTime.min);\n          currentTime = buffer.currentTime;\n          timeLeft = buffer.duration - currentTime;\n          buffer.playTime = Math.min(timeLeft * 1000 / 16.6, buffer.playTime);\n          return buffer.customData.startTimer = buffer.playTime + buffer.customData.playRange.start + Math.random() * (buffer.customData.playRange.end - buffer.customData.playRange.start);\n        }\n      }\n    };\n\n\n    /**\n    * Updates all audio-buffers depending on the play-type.\n    *\n    * @method updateAudioBuffers\n    * @protected\n     */\n\n    AudioManager.prototype.updateAudioBuffers = function() {\n      var buffer, j, len, ref;\n      ref = this.audioBuffers;\n      for (j = 0, len = ref.length; j < len; j++) {\n        buffer = ref[j];\n        if (buffer != null) {\n          if (buffer.customData.playType === 1) {\n            this.updateRandomAudio(buffer);\n          }\n          if (GameManager.settings.bgmVolume !== this.generalMusicVolume) {\n            buffer.volume = (this.musicVolume * GameManager.settings.bgmVolume / 100) / 100;\n          }\n          buffer.update();\n        }\n      }\n      if (GameManager.settings.bgmVolume !== this.generalMusicVolume) {\n        return this.generalMusicVolume = GameManager.settings.bgmVolume;\n      }\n    };\n\n\n    /**\n    * Updates all audio-buffers depending on the play-type.\n    *\n    * @method updateAudioBuffers\n    * @protected\n     */\n\n    AudioManager.prototype.updateGeneralVolume = function() {\n      var k, reference, results;\n      if (GameManager.settings.seVolume !== this.generalSoundVolume || GameManager.settings.voiceVolume !== this.generalVoiceVolume) {\n        this.generalSoundVolume = GameManager.settings.seVolume;\n        this.generalVoiceVolume = GameManager.settings.voiceVolume;\n        results = [];\n        for (k in this.soundReferences) {\n          results.push((function() {\n            var j, len, ref, results1;\n            ref = this.soundReferences[k];\n            results1 = [];\n            for (j = 0, len = ref.length; j < len; j++) {\n              reference = ref[j];\n              if (reference.voice) {\n                results1.push(reference.volume = (this.voiceVolume * GameManager.settings.voiceVolume / 100) / 100);\n              } else {\n                results1.push(reference.volume = (this.soundVolume * GameManager.settings.seVolume / 100) / 100);\n              }\n            }\n            return results1;\n          }).call(this));\n        }\n        return results;\n      }\n    };\n\n\n    /**\n    * Updates the audio-playback.\n    *\n    * @method update\n     */\n\n    AudioManager.prototype.update = function() {\n      this.updateAudioBuffers();\n      return this.updateGeneralVolume();\n    };\n\n\n    /**\n    * Changes the current music to the specified one.\n    *\n    * @method changeMusic\n    * @param {Object} music - The music to play. If <b>null</b> the current music will stop playing.\n     */\n\n    AudioManager.prototype.changeMusic = function(music) {\n      if ((music != null) && (music.name != null)) {\n        if ((this.music != null) && this.music.name !== music.name) {\n          return this.playMusic(music);\n        } else if (this.music == null) {\n          return this.playMusic(music);\n        }\n      } else {\n        return this.stopMusic();\n      }\n    };\n\n\n    /**\n    * Prepares. \n    *\n    * @method prepare\n    * @param {Object} music - The music to play. If <b>null</b> the current music will stop playing.\n     */\n\n    AudioManager.prototype.prepare = function(path, volume, rate) {\n      var buffer;\n      buffer = ResourceManager.getAudioBuffer(path);\n      if (buffer.decoded) {\n        buffer.volume = volume != null ? volume / 100 : 1.0;\n        buffer.playbackRate = rate != null ? rate / 100 : 1.0;\n      } else {\n        buffer.onFinishDecode = (function(_this) {\n          return function(source) {\n            source.volume = volume != null ? volume / 100 : 1.0;\n            return source.playbackRate = rate != null ? rate / 100 : 1.0;\n          };\n        })(this);\n        buffer.decode();\n      }\n      return buffer;\n    };\n\n\n    /**\n    * Plays an audio resource.\n    *\n    * @method play\n    * @param {String} path - The path to the audio resource.\n    * @param {number} volume - The volume.\n    * @param {number} rate - The playback rate.\n    * @param {number} fadeInTime - The fade-in time in frames.\n     */\n\n    AudioManager.prototype.play = function(path, volume, rate, fadeInTime) {\n      var buffer;\n      buffer = ResourceManager.getAudioStream(path);\n      if (buffer.decoded) {\n        buffer.volume = volume != null ? volume / 100 : 1.0;\n        buffer.playbackRate = rate != null ? rate / 100 : 1.0;\n        if (GameManager.settings.bgmEnabled) {\n          buffer.play(fadeInTime);\n        }\n      } else {\n        buffer.onFinishDecode = (function(_this) {\n          return function(source) {\n            source.volume = volume != null ? volume / 100 : 1.0;\n            source.playbackRate = rate != null ? rate / 100 : 1.0;\n            if (GameManager.settings.bgmEnabled) {\n              return source.play(fadeInTime);\n            }\n          };\n        })(this);\n        buffer.decode();\n      }\n      return buffer;\n    };\n\n\n    /**\n    * Stops all sounds.\n    *\n    * @method stopAllSounds\n     */\n\n    AudioManager.prototype.stopAllSounds = function() {\n      var k, reference, results;\n      results = [];\n      for (k in this.soundReferences) {\n        results.push((function() {\n          var j, len, ref, results1;\n          ref = this.soundReferences[k];\n          results1 = [];\n          for (j = 0, len = ref.length; j < len; j++) {\n            reference = ref[j];\n            results1.push(reference != null ? reference.stop() : void 0);\n          }\n          return results1;\n        }).call(this));\n      }\n      return results;\n    };\n\n\n    /**\n    * Stops a sound and all references of it.\n    *\n    * @method stopSound\n    * @param {String} name - The name of the sound to stop.\n     */\n\n    AudioManager.prototype.stopSound = function(name) {\n      var j, len, ref, reference, results;\n      if (this.soundReferences[name] != null) {\n        ref = this.soundReferences[name];\n        results = [];\n        for (j = 0, len = ref.length; j < len; j++) {\n          reference = ref[j];\n          results.push(reference.stop());\n        }\n        return results;\n      }\n    };\n\n\n    /**\n    * Stops a voice.\n    *\n    * @method stopVoice\n    * @param {String} name - The name of the voice to stop.\n     */\n\n    AudioManager.prototype.stopVoice = function(name) {\n      return this.stopSound(name);\n    };\n\n\n    /**\n    * Stops all voices.\n    *\n    * @method stopAllVoices\n     */\n\n    AudioManager.prototype.stopAllVoices = function() {\n      var k, reference, results;\n      results = [];\n      for (k in this.soundReferences) {\n        results.push((function() {\n          var j, len, ref, results1;\n          ref = this.soundReferences[k];\n          results1 = [];\n          for (j = 0, len = ref.length; j < len; j++) {\n            reference = ref[j];\n            if (reference.voice) {\n              results1.push(reference.stop());\n            } else {\n              results1.push(void 0);\n            }\n          }\n          return results1;\n        }).call(this));\n      }\n      return results;\n    };\n\n\n    /**\n    * Plays a voice.\n    *\n    * @method playVoice\n    * @param {String} name - The name of the voice to play.\n    * @param {number} volume - The voice volume.\n    * @param {number} rate - The voice playback rate.\n     */\n\n    AudioManager.prototype.playVoice = function(name, volume, rate) {\n      var ref, voice;\n      voice = null;\n      if (GameManager.settings.voiceEnabled && !((ref = $PARAMS.preview) != null ? ref.settings.voiceDisabled : void 0)) {\n        voice = this.playSound(name != null ? name.name : void 0, volume || GameManager.defaults.audio.voiceVolume, rate || GameManager.defaults.audio.voicePlaybackRate, false, true);\n      }\n      return voice;\n    };\n\n\n    /**\n    * Plays a sound.\n    *\n    * @method playSound\n    * @param {String} name - The name of the sound to play.\n    * @param {number} volume - The sound's volume.\n    * @param {number} rate - The sound's playback rate.\n    * @param {boolean} musicEffect - Indicates if the sound should be played as a music effect. In that case, the current music\n    * at audio-layer will be paused until the sound finishes playing.\n    * @param {boolean} voice - Indicates if the sound should be handled as a voice.\n     */\n\n    AudioManager.prototype.playSound = function(name, volume, rate, musicEffect, voice, loopSound) {\n      var buffer, j, len, r, ref, ref1, reference;\n      if ((ref = $PARAMS.preview) != null ? ref.settings.soundDisabled : void 0) {\n        return;\n      }\n      if ((name == null) || (!voice && !GameManager.settings.soundEnabled)) {\n        return;\n      }\n      if (name.name != null) {\n        volume = name.volume;\n        rate = name.playbackRate;\n        name = name.name;\n      }\n      if (name.length === 0) {\n        return;\n      }\n      if (musicEffect) {\n        this.stopMusic();\n      }\n      if (this.soundReferences[name] == null) {\n        this.soundReferences[name] = [];\n      }\n      volume = volume != null ? volume : 100;\n      volume *= voice ? this.generalVoiceVolume / 100 : this.generalSoundVolume / 100;\n      reference = null;\n      ref1 = this.soundReferences[name];\n      for (j = 0, len = ref1.length; j < len; j++) {\n        r = ref1[j];\n        if (!r.isPlaying) {\n          reference = r;\n          if (musicEffect) {\n            reference.onEnd = (function(_this) {\n              return function() {\n                return _this.resumeMusic(40);\n              };\n            })(this);\n          }\n          reference.voice = voice;\n          reference.volume = volume / 100;\n          reference.playbackRate = rate / 100;\n          reference.loop = loopSound;\n          if (voice) {\n            this.voice = reference;\n          }\n          reference.play();\n          break;\n        }\n      }\n      if (reference == null) {\n        buffer = ResourceManager.getAudioBuffer(\"Audio/Sounds/\" + name);\n        if (buffer && buffer.loaded) {\n          if (buffer.decoded) {\n            reference = new GS.AudioBufferReference(buffer, voice);\n            if (musicEffect) {\n              reference.onEnd = (function(_this) {\n                return function() {\n                  return _this.resumeMusic(40);\n                };\n              })(this);\n            }\n            reference.volume = volume / 100;\n            reference.playbackRate = rate / 100;\n            reference.voice = voice;\n            reference.loop = loopSound;\n            reference.play();\n            if (voice) {\n              this.voice = reference;\n            }\n            this.soundReferences[name].push(reference);\n          } else {\n            buffer.name = name;\n            buffer.onDecodeFinish = (function(_this) {\n              return function(source) {\n                reference = new GS.AudioBufferReference(source, voice);\n                if (musicEffect) {\n                  reference.onEnd = function() {\n                    return _this.resumeMusic(40);\n                  };\n                }\n                reference.voice = voice;\n                reference.volume = volume / 100;\n                reference.playbackRate = rate / 100;\n                reference.loop = loopSound;\n                if (voice) {\n                  _this.voice = reference;\n                }\n                reference.play();\n                return _this.soundReferences[source.name].push(reference);\n              };\n            })(this);\n            buffer.decode();\n          }\n        }\n      }\n      return reference;\n    };\n\n\n    /**\n    * Plays a music as a random music. A random music will fade-in and fade-out\n    * at random times. That can be combined with other audio-layers to create a\n    * much better looping of an audio track.\n    *\n    * @method playMusicRandom\n    * @param {Object} music - The music to play.\n    * @param {number} fadeTime - The time for a single fade-in/out in frames.\n    * @param {number} layer - The audio layer to use.\n    * @param {gs.Range} playTime - Play-Time range like 10s to 30s.\n    * @param {gs.Range} playRange - Play-Range.\n     */\n\n    AudioManager.prototype.playMusicRandom = function(music, fadeTime, layer, playTime, playRange) {\n      var musicBuffer, ref, volume;\n      if ((ref = $PARAMS.preview) != null ? ref.settings.musicDisabled : void 0) {\n        return;\n      }\n      layer = layer != null ? layer : 0;\n      volume = music.volume != null ? music.volume : 100;\n      volume = volume * (this.generalMusicVolume / 100);\n      this.musicVolume = volume;\n      this.disposeMusic(layer);\n      if ((music.name != null) && music.name.length > 0) {\n        musicBuffer = this.play(\"Audio/Music/\" + music.name, volume, music.rate);\n        musicBuffer.loop = true;\n        musicBuffer.volume = 0;\n        musicBuffer.duration = Math.round(musicBuffer.duration * 1000 / 16.6);\n        musicBuffer.customData.playType = 1;\n        musicBuffer.customData.playTime = playTime;\n        if (playRange.end === 0) {\n          musicBuffer.customData.playRange = {\n            start: playRange.start,\n            end: musicBuffer.duration\n          };\n        } else {\n          musicBuffer.customData.playRange = playRange;\n        }\n        musicBuffer.customData.fadeTime = fadeTime;\n        musicBuffer.customData.startTimer = Math.round(musicBuffer.customData.playRange.start + Math.random() * (musicBuffer.customData.playRange.end - musicBuffer.customData.playRange.start));\n        if (!this.audioBuffers.contains(musicBuffer)) {\n          this.audioBuffers.push(musicBuffer);\n        }\n        this.audioBuffersByLayer[layer] = musicBuffer;\n        return this.audioLayers[layer] = {\n          name: music.name,\n          time: music.currentTime,\n          volume: music.volume,\n          rate: music.playbackRate,\n          fadeInTime: fadeTime,\n          customData: musicBuffer.customData\n        };\n      }\n    };\n\n\n    /**\n    * Plays a music.\n    *\n    * @method playMusic\n    * @param {string|Object} name - The music to play. Can be just a name or a music data-object.\n    * @param {number} volume - The music's volume in percent.\n    * @param {number} rate - The music's playback rate in percent.\n    * @param {number} fadeInTime - The fade-in time.\n    * @param {number} layer - The layer to play the music on.\n    * @param {boolean} loop - Indicates if the music should be looped\n     */\n\n    AudioManager.prototype.playMusic = function(name, volume, rate, fadeInTime, layer, loopMusic) {\n      var musicBuffer, ref;\n      if ((ref = $PARAMS.preview) != null ? ref.settings.musicDisabled : void 0) {\n        return;\n      }\n      if (loopMusic == null) {\n        loopMusic = true;\n      }\n      if ((name != null) && (name.name != null)) {\n        layer = layer != null ? layer : rate || 0;\n        fadeInTime = volume;\n        volume = name.volume;\n        rate = name.playbackRate;\n        name = name.name;\n      } else {\n        layer = layer != null ? layer : 0;\n      }\n      this.disposeMusic(layer);\n      this.audioLayers[layer] = {\n        name: name,\n        volume: volume,\n        rate: rate,\n        fadeInTime: fadeInTime,\n        playing: true\n      };\n      volume = volume != null ? volume : 100;\n      volume = volume * (this.generalMusicVolume / 100);\n      this.musicVolume = volume;\n      if ((name != null) && name.length > 0) {\n        this.music = {\n          name: name\n        };\n        musicBuffer = this.play(\"Audio/Music/\" + name, volume, rate, fadeInTime);\n        musicBuffer.loop = loopMusic;\n        if (!this.audioBuffers.contains(musicBuffer)) {\n          this.audioBuffers.push(musicBuffer);\n        }\n        this.audioBuffersByLayer[layer] = musicBuffer;\n      }\n      return musicBuffer;\n    };\n\n\n    /**\n    * Resumes a paused music.\n    *\n    * @method resumeMusic\n    * @param {number} fadeInTime - The fade-in time in frames.\n    * @param {number} layer - The audio layer to resume.\n     */\n\n    AudioManager.prototype.resumeMusic = function(fadeInTime, layer) {\n      var ref;\n      layer = layer != null ? layer : 0;\n      if ((this.audioBuffersByLayer[layer] != null) && !this.audioBuffersByLayer[layer].isPlaying) {\n        this.audioBuffersByLayer[layer].resume(fadeInTime);\n        return (ref = this.audioLayers[layer]) != null ? ref.playing = true : void 0;\n      }\n    };\n\n\n    /**\n    * Stops a music.\n    *\n    * @method stopMusic\n    * @param {number} fadeOutTime - The fade-out time in frames.\n    * @param {number} layer - The audio layer to stop.\n     */\n\n    AudioManager.prototype.stopMusic = function(fadeOutTime, layer) {\n      var ref, ref1, ref2;\n      layer = layer != null ? layer : 0;\n      if ((ref = this.audioBuffersByLayer[layer]) != null) {\n        ref.stop(fadeOutTime);\n      }\n      if ((ref1 = this.audioBuffersByLayer[layer]) != null) {\n        ref1.customData = {};\n      }\n      if ((ref2 = this.audioLayers[layer]) != null) {\n        ref2.playing = false;\n      }\n      return this.music = null;\n    };\n\n\n    /**\n    * Stops all music/audio layers.\n    *\n    * @method stopAllMusic\n    * @param {number} fadeOutTime - The fade-out time in frames.\n     */\n\n    AudioManager.prototype.stopAllMusic = function(fadeOutTime) {\n      var buffer, j, len, ref;\n      ref = this.audioBuffers;\n      for (j = 0, len = ref.length; j < len; j++) {\n        buffer = ref[j];\n        if (buffer != null) {\n          buffer.stop(fadeOutTime);\n          buffer.customData = {};\n        }\n      }\n      return this.music = null;\n    };\n\n    AudioManager.prototype.dispose = function(context) {\n      var buffer, data, j, layer, len, ref, results;\n      data = context.resources.select(function(r) {\n        return r.data;\n      });\n      ref = this.audioBuffersByLayer;\n      results = [];\n      for (layer = j = 0, len = ref.length; j < len; layer = ++j) {\n        buffer = ref[layer];\n        if (buffer && data.indexOf(buffer) !== -1) {\n          buffer.dispose();\n          this.audioBuffers.remove(buffer);\n          this.audioBuffersByLayer[layer] = null;\n          results.push(this.audioLayers[layer] = null);\n        } else {\n          results.push(void 0);\n        }\n      }\n      return results;\n    };\n\n\n    /**\n    * Disposes a music.\n    *\n    * @method disposeMusic\n    * @param {number} layer - The audio layer of the music to dispose.\n     */\n\n    AudioManager.prototype.disposeMusic = function(layer) {\n      layer = layer != null ? layer : 0;\n      this.stopMusic(0, layer);\n      this.audioBuffers.remove(this.audioBuffersByLayer[layer]);\n      this.audioBuffersByLayer[layer] = null;\n      return this.audioLayers[layer] = null;\n    };\n\n    return AudioManager;\n\n  })();\n\n  window.AudioManager = new AudioManager();\n\n  gs.AudioManager = AudioManager;\n\n}).call(this);\n"
    },
    "summary": [
        "name",
        "type",
        "order"
    ],
    "externalItems": []
}