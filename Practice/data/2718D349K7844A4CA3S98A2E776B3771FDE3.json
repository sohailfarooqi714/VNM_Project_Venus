{
    "uid": "2718D349K7844A4CA3S98A2E776B3771FDE3",
    "isLoaded": true,
    "lastModificationTime": 0,
    "items": {
        "name": "Component_PathAnimation",
        "type": "game_script",
        "order": 4,
        "parentId": "A8E9945CKEE5CA4855SAC81E480CB8098E0E",
        "folder": false,
        "content": "# ===================================================================\n#\n#   Script: Component_PathAnimation\n#\n#   $$COPYRIGHT$$\n#\n# ===================================================================\n\n###*\n* Different types of animation looping.\n*\n* @module gs\n* @class AnimationLoopType\n* @memberof gs\n* @static\n* @final\n###\nclass AnimationLoopType\n    @initialize: ->\n        ###*\n        * No looping.\n        * @property NONE\n        * @static\n        * @final\n        ###\n        @NONE = 0\n        \n        ###*\n        * Regular looping. If the end of an animation is reached it will start\n        * from the beginning.\n        * @property NORMAL\n        * @static\n        * @final\n        ###\n        @NORMAL = 1\n        \n        ###*\n        * Reverse looping. If the end of an animation is reached it will be\n        * reversed an goes now from end to start.\n        * @property REVERSE\n        * @static\n        * @final\n        ###\n        @REVERSE = 2\n        \nAnimationLoopType.initialize()\ngs.AnimationLoopType = AnimationLoopType\n\nclass Component_PathAnimation extends gs.Component_Animation\n    ###*\n    * Executes a path-animation on a game-object. A path-animation moves the\n    * game-object along a path of quadratic bezier-curves.\n    *\n    * @module gs\n    * @class Component_PathAnimation\n    * @extends gs.Component_Animation\n    * @memberof gs\n    * @constructor\n    ###\n    constructor: (data) ->\n        super\n        \n        @path = data?.path || null\n        @easing = new gs.Easing(null, data?.easing)\n        @startPosition = data?.startPosition || null\n        @loopType = data?.loopType || 0\n        @animationType = 0\n        @effects = data?.effects || []\n        @effect = null\n    ###*\n    * Serializes the path-animation into a data-bundle.\n    *\n    * @method toDataBundle\n    ###\n    toDataBundle: ->\n        path: @path,\n        easing: @easing,\n        startPosition: @startPosition,\n        loopType: @loopType\n     \n    ###*\n    * Skips the animation. That is used to skip an animation if the user\n    * wants to skip very fast through a visual novel scene.\n    *\n    * @method skip\n    ###      \n    skip: ->\n        if @loopType == 0 and @easing.duration > 1\n            @easing.duration = 1\n            @easing.time = 0\n     \n    ###*\n    * Calculates a certain point on a specified bezier-curve.\n    *\n    * @method quadraticBezierPoint\n    * @protected\n    * @param {number} startPt - The start-point of the bezier-curve.\n    * @param {number} controlPt - The control-point of the bezier-curve.\n    * @param {number} endPt - The end-point of the bezier-curve.\n    * @param {number} percent - The percentage (0.0 - 1.0). A percentage of\n    * 0.0 returns the <b>startPt</b> and 1.0 returns the <b>endPt</b> while\n    * 0.5 return the point at the middle of the bezier-curve.\n    ###   \n    quadraticBezierPoint: (startPt, controlPt, endPt, percent) ->\n        x = Math.pow(1-percent,2) * startPt.x + 2 * (1-percent) * percent * controlPt.x + Math.pow(percent,2) * endPt.x\n        y = Math.pow(1-percent,2) * startPt.y + 2 * (1-percent) * percent * controlPt.y + Math.pow(percent,2) * endPt.y\n        \n        return x: x, y: y \n    ###*\n    * Updates the path-animation.\n    *\n    * @method update\n    ###   \n    update: ->\n        super\n        if not @easing.isRunning then return\n        \n        @easing.updateValue()\n        value = @easing.value\n        \n        point = @path.curveLength / 100 * value\n        for len, i in @path.curveLengths\n            if point <= len.len + len.offset\n                current = { percent: (point - len.offset) / len.len, path: @path.data[i] }\n                break\n                \n        curve = current.path\n        point = @quadraticBezierPoint(curve.pt1, curve.cpt, curve.pt2, current.percent)\n\n        switch @animationType\n            when 0\n                @object.dstRect.x = Math.round(point.x - @path.data[0].pt1.x + @startPosition.x)\n                @object.dstRect.y = Math.round(point.y - @path.data[0].pt1.y + @startPosition.y)\n            when 2\n                @object.visual.scroll.x = Math.round(point.x - @path.data[0].pt1.x + @startPosition.x)\n                @object.visual.scroll.y = Math.round(point.y - @path.data[0].pt1.y + @startPosition.y)\n                \n        for effect in @effects\n            if (!@effect or (@effect != effect and @effect?.time <= effect.time)) and @easing.time >= effect.time\n                @effect = effect\n                AudioManager.playSound(@effect.sound)\n        \n        if not @easing.isRunning\n            switch @loopType\n                when 0\n                    @callback?(@object, this)\n                when 1 # Normal\n                    @easing.startValue(0, 100, @easing.duration)\n                    @startPosition.x = @object.dstRect.x\n                    @startPosition.y = @object.dstRect.y\n                when 2 # Reverse\n                    @effect = null\n                    @easing.startValue(@easing.value, 100 - @easing.value*2, @easing.duration)\n    \n    ###*\n    * Starts the path-animation. Scrolls the game object along the path.\n    *\n    * @method scrollPath\n    * @param {Object} path The path to follow.\n    * @param {gs.AnimationLoopType} loopType The loop-Type.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    * @param {function} [callback] An optional callback called if blending is finished. \n    ###                \n    scroll: (path, loopType, duration, easingType, effects, callback) ->\n        @start(path, loopType, duration, easingType, callback)\n        @animationType = 2\n        \n    ###*\n    * Starts the path-animation.\n    *\n    * @method movePath\n    * @param {Object} path The path to follow.\n    * @param {gs.AnimationLoopType} loopType The loop-Type.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    * @param {function} [callback] An optional callback called if blending is finished. \n    ###                \n    start: (path, loopType, duration, easingType, effects, callback) ->\n        @effects = effects || []\n        @effect = null\n        @callback = callback\n        @loopType = loopType\n        @path = data: path||[], curveLength: null, curveLengths: null\n        @easing.type = easingType || gs.Easings.EASE_LINEAR[gs.EasingTypes.EASE_IN]\n        @easing.startValue(0, 100, duration)\n        @startPosition = x: @object.dstRect.x, y: @object.dstRect.y\n        \n        if @path.data.length == 0\n            @callback?(@object, this)\n        else if duration == 0 or @isInstantSkip()\n            point = @path.data.last().pt2\n            @object.dstRect.x = Math.round(point.x - @path.data[0].pt1.x + @startPosition.x)\n            @object.dstRect.y = Math.round(point.y - @path.data[0].pt1.y + @startPosition.y)\n            @callback?(@object, this)\n        else if not @path.curveLength?\n            length = 0\n            lengths = []\n\n            for curve in @path.data\n                x = (curve.cpt.x - curve.pt1.x) + (curve.pt2.x - curve.cpt.x)\n                y = (curve.cpt.y - curve.pt1.y) + (curve.pt2.y - curve.cpt.y)\n                l = Math.round(Math.sqrt(x*x + y*y))\n                \n                lengths.push({ len: l, offset: length })\n                length += l\n                \n            @path.curveLength = length\n            @path.curveLengths = lengths\n            \ngs.Component_PathAnimation = Component_PathAnimation",
        "compiledContent": "// Generated by CoffeeScript 1.12.7\n\n/**\n* Different types of animation looping.\n*\n* @module gs\n* @class AnimationLoopType\n* @memberof gs\n* @static\n* @final\n */\n\n(function() {\n  var AnimationLoopType, Component_PathAnimation,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  AnimationLoopType = (function() {\n    function AnimationLoopType() {}\n\n    AnimationLoopType.initialize = function() {\n\n      /**\n      * No looping.\n      * @property NONE\n      * @static\n      * @final\n       */\n      this.NONE = 0;\n\n      /**\n      * Regular looping. If the end of an animation is reached it will start\n      * from the beginning.\n      * @property NORMAL\n      * @static\n      * @final\n       */\n      this.NORMAL = 1;\n\n      /**\n      * Reverse looping. If the end of an animation is reached it will be\n      * reversed an goes now from end to start.\n      * @property REVERSE\n      * @static\n      * @final\n       */\n      return this.REVERSE = 2;\n    };\n\n    return AnimationLoopType;\n\n  })();\n\n  AnimationLoopType.initialize();\n\n  gs.AnimationLoopType = AnimationLoopType;\n\n  Component_PathAnimation = (function(superClass) {\n    extend(Component_PathAnimation, superClass);\n\n\n    /**\n    * Executes a path-animation on a game-object. A path-animation moves the\n    * game-object along a path of quadratic bezier-curves.\n    *\n    * @module gs\n    * @class Component_PathAnimation\n    * @extends gs.Component_Animation\n    * @memberof gs\n    * @constructor\n     */\n\n    function Component_PathAnimation(data) {\n      Component_PathAnimation.__super__.constructor.apply(this, arguments);\n      this.path = (data != null ? data.path : void 0) || null;\n      this.easing = new gs.Easing(null, data != null ? data.easing : void 0);\n      this.startPosition = (data != null ? data.startPosition : void 0) || null;\n      this.loopType = (data != null ? data.loopType : void 0) || 0;\n      this.animationType = 0;\n      this.effects = (data != null ? data.effects : void 0) || [];\n      this.effect = null;\n    }\n\n\n    /**\n    * Serializes the path-animation into a data-bundle.\n    *\n    * @method toDataBundle\n     */\n\n    Component_PathAnimation.prototype.toDataBundle = function() {\n      return {\n        path: this.path,\n        easing: this.easing,\n        startPosition: this.startPosition,\n        loopType: this.loopType\n      };\n    };\n\n\n    /**\n    * Skips the animation. That is used to skip an animation if the user\n    * wants to skip very fast through a visual novel scene.\n    *\n    * @method skip\n     */\n\n    Component_PathAnimation.prototype.skip = function() {\n      if (this.loopType === 0 && this.easing.duration > 1) {\n        this.easing.duration = 1;\n        return this.easing.time = 0;\n      }\n    };\n\n\n    /**\n    * Calculates a certain point on a specified bezier-curve.\n    *\n    * @method quadraticBezierPoint\n    * @protected\n    * @param {number} startPt - The start-point of the bezier-curve.\n    * @param {number} controlPt - The control-point of the bezier-curve.\n    * @param {number} endPt - The end-point of the bezier-curve.\n    * @param {number} percent - The percentage (0.0 - 1.0). A percentage of\n    * 0.0 returns the <b>startPt</b> and 1.0 returns the <b>endPt</b> while\n    * 0.5 return the point at the middle of the bezier-curve.\n     */\n\n    Component_PathAnimation.prototype.quadraticBezierPoint = function(startPt, controlPt, endPt, percent) {\n      var x, y;\n      x = Math.pow(1 - percent, 2) * startPt.x + 2 * (1 - percent) * percent * controlPt.x + Math.pow(percent, 2) * endPt.x;\n      y = Math.pow(1 - percent, 2) * startPt.y + 2 * (1 - percent) * percent * controlPt.y + Math.pow(percent, 2) * endPt.y;\n      return {\n        x: x,\n        y: y\n      };\n    };\n\n\n    /**\n    * Updates the path-animation.\n    *\n    * @method update\n     */\n\n    Component_PathAnimation.prototype.update = function() {\n      var current, curve, effect, i, j, k, len, len1, len2, point, ref, ref1, ref2, value;\n      Component_PathAnimation.__super__.update.apply(this, arguments);\n      if (!this.easing.isRunning) {\n        return;\n      }\n      this.easing.updateValue();\n      value = this.easing.value;\n      point = this.path.curveLength / 100 * value;\n      ref = this.path.curveLengths;\n      for (i = j = 0, len1 = ref.length; j < len1; i = ++j) {\n        len = ref[i];\n        if (point <= len.len + len.offset) {\n          current = {\n            percent: (point - len.offset) / len.len,\n            path: this.path.data[i]\n          };\n          break;\n        }\n      }\n      curve = current.path;\n      point = this.quadraticBezierPoint(curve.pt1, curve.cpt, curve.pt2, current.percent);\n      switch (this.animationType) {\n        case 0:\n          this.object.dstRect.x = Math.round(point.x - this.path.data[0].pt1.x + this.startPosition.x);\n          this.object.dstRect.y = Math.round(point.y - this.path.data[0].pt1.y + this.startPosition.y);\n          break;\n        case 2:\n          this.object.visual.scroll.x = Math.round(point.x - this.path.data[0].pt1.x + this.startPosition.x);\n          this.object.visual.scroll.y = Math.round(point.y - this.path.data[0].pt1.y + this.startPosition.y);\n      }\n      ref1 = this.effects;\n      for (k = 0, len2 = ref1.length; k < len2; k++) {\n        effect = ref1[k];\n        if ((!this.effect || (this.effect !== effect && ((ref2 = this.effect) != null ? ref2.time : void 0) <= effect.time)) && this.easing.time >= effect.time) {\n          this.effect = effect;\n          AudioManager.playSound(this.effect.sound);\n        }\n      }\n      if (!this.easing.isRunning) {\n        switch (this.loopType) {\n          case 0:\n            return typeof this.callback === \"function\" ? this.callback(this.object, this) : void 0;\n          case 1:\n            this.easing.startValue(0, 100, this.easing.duration);\n            this.startPosition.x = this.object.dstRect.x;\n            return this.startPosition.y = this.object.dstRect.y;\n          case 2:\n            this.effect = null;\n            return this.easing.startValue(this.easing.value, 100 - this.easing.value * 2, this.easing.duration);\n        }\n      }\n    };\n\n\n    /**\n    * Starts the path-animation. Scrolls the game object along the path.\n    *\n    * @method scrollPath\n    * @param {Object} path The path to follow.\n    * @param {gs.AnimationLoopType} loopType The loop-Type.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    * @param {function} [callback] An optional callback called if blending is finished.\n     */\n\n    Component_PathAnimation.prototype.scroll = function(path, loopType, duration, easingType, effects, callback) {\n      this.start(path, loopType, duration, easingType, callback);\n      return this.animationType = 2;\n    };\n\n\n    /**\n    * Starts the path-animation.\n    *\n    * @method movePath\n    * @param {Object} path The path to follow.\n    * @param {gs.AnimationLoopType} loopType The loop-Type.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    * @param {function} [callback] An optional callback called if blending is finished.\n     */\n\n    Component_PathAnimation.prototype.start = function(path, loopType, duration, easingType, effects, callback) {\n      var curve, j, l, len1, length, lengths, point, ref, x, y;\n      this.effects = effects || [];\n      this.effect = null;\n      this.callback = callback;\n      this.loopType = loopType;\n      this.path = {\n        data: path || [],\n        curveLength: null,\n        curveLengths: null\n      };\n      this.easing.type = easingType || gs.Easings.EASE_LINEAR[gs.EasingTypes.EASE_IN];\n      this.easing.startValue(0, 100, duration);\n      this.startPosition = {\n        x: this.object.dstRect.x,\n        y: this.object.dstRect.y\n      };\n      if (this.path.data.length === 0) {\n        return typeof this.callback === \"function\" ? this.callback(this.object, this) : void 0;\n      } else if (duration === 0 || this.isInstantSkip()) {\n        point = this.path.data.last().pt2;\n        this.object.dstRect.x = Math.round(point.x - this.path.data[0].pt1.x + this.startPosition.x);\n        this.object.dstRect.y = Math.round(point.y - this.path.data[0].pt1.y + this.startPosition.y);\n        return typeof this.callback === \"function\" ? this.callback(this.object, this) : void 0;\n      } else if (this.path.curveLength == null) {\n        length = 0;\n        lengths = [];\n        ref = this.path.data;\n        for (j = 0, len1 = ref.length; j < len1; j++) {\n          curve = ref[j];\n          x = (curve.cpt.x - curve.pt1.x) + (curve.pt2.x - curve.cpt.x);\n          y = (curve.cpt.y - curve.pt1.y) + (curve.pt2.y - curve.cpt.y);\n          l = Math.round(Math.sqrt(x * x + y * y));\n          lengths.push({\n            len: l,\n            offset: length\n          });\n          length += l;\n        }\n        this.path.curveLength = length;\n        return this.path.curveLengths = lengths;\n      }\n    };\n\n    return Component_PathAnimation;\n\n  })(gs.Component_Animation);\n\n  gs.Component_PathAnimation = Component_PathAnimation;\n\n}).call(this);\n"
    },
    "summary": [
        "name",
        "type",
        "order"
    ],
    "externalItems": []
}