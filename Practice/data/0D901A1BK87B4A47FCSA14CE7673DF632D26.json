{
    "uid": "0D901A1BK87B4A47FCSA14CE7673DF632D26",
    "isLoaded": true,
    "lastModificationTime": 0,
    "items": {
        "name": "Component_Draggable",
        "type": "game_script",
        "order": 2,
        "parentId": "01A95DA3K01E8A4CB4SBE17E790BCE1FC035",
        "folder": false,
        "content": "# ===================================================================\n#\n#   Script: Component_Draggable\n#\n#   $$COPYRIGHT$$\n#\n# ===================================================================\nclass Component_Draggable extends gs.Component\n    ###*\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    *\n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n    ###\n    onDataBundleRestore: (data, context) ->\n        @setupEventHandlers()\n\n    ###*\n    * Makes a game object draggable using mouse/touch. The dragging can be\n    * vertical, horizontal or both. It can be configured as pixel-wise or\n    * step-wise dragging. For example: To create a slider for UI with\n    * fixed steps, step-wise is useful while a pixel-wise dragging could\n    * be used for a volume-slider.\n    *\n    * @module gs\n    * @class Component_Draggable\n    * @extends gs.Component\n    * @memberof gs\n    * @constructor\n    ###\n    constructor: ->\n        ###*\n        * Mouse/Pointer x coordinate\n        * @property mx\n        * @type number\n        ###\n        @mx = 0\n\n        ###*\n        * Mouse/Pointer y coordinate\n        * @property my\n        * @type number\n        ###\n        @my = 0\n\n        ###*\n        * Stepping in pixels.\n        * @property stepSize\n        * @type gs.Point\n        ###\n        @stepSize = { x: 0, y: 0 }\n\n        ###*\n        * Drag Area\n        * @property rect\n        * @type gs.Rect\n        ###\n        @rect = null\n\n    ###*\n    * Adds event-handler for mouse/touch events to update the component only if\n    * a user-action happened.\n    *\n    * @method setupEventHandlers\n    ###\n    setupEventHandlers: ->\n        gs.GlobalEventManager.on \"mouseMoved\", ( (e) =>\n            rect = @object.draggable?.rect\n            x = Input.Mouse.x - @object.origin.x\n            y = Input.Mouse.y - @object.origin.y\n            if @object.dragging or rect.contains(x, y)\n                @object.needsUpdate = yes\n                e.breakChain = yes\n\n        ), null, @object\n\n        gs.GlobalEventManager.on \"mouseDown\",( (e) =>\n            rect = @object.dstRect\n            x = Input.Mouse.x - @object.origin.x\n            y = Input.Mouse.y - @object.origin.y\n            if rect.contains(x, y)\n                @object.dragging = yes\n                @object.needsUpdate = yes\n                @object.events?.emit(\"dragStart\", @object)\n                e.breakChain = yes\n\n\n        ), null, @object\n\n        gs.GlobalEventManager.on \"mouseUp\",( (e) =>\n            if @object.dragging\n                @object.needsUpdate = yes\n                e.breakChain = yes\n\n        ), null, @object\n\n    ###*\n    * Initializes the component. Adds event-handler for mouse/touch events to\n    * update the component only if a user-action happened.\n    *\n    * @method setup\n    ###\n    setup: ->\n        @setupEventHandlers()\n\n    ###*\n    * Disposes the component.\n    *\n    * @method dispose\n    ###\n    dispose: ->\n        super\n\n        gs.GlobalEventManager.offByOwner(\"mouseDown\", @object)\n        gs.GlobalEventManager.offByOwner(\"mouseMoved\", @object)\n\n    ###*\n    * Updates the dragging-process on x-axis if configured.\n    *\n    * @method updateAxisX\n    * @protected\n    ###\n    updateAxisX: ->\n        if (@object.draggable.axisX ? yes)\n            if @object.dragging\n                @object.draggable.step = Math.round(Math.max(@rect.x, Math.min((@mx - @object.dstRect.width / 2), @rect.x+@rect.width-@object.dstRect.width)) / @stepSize.x)\n                @object.dstRect.x = @object.draggable.step * @stepSize.x\n            else if @object.draggable.steps?\n                @object.dstRect.x = @object.draggable.step * @stepSize.x\n\n    ###*\n    * Updates the dragging-process on y-axis if configured.\n    *\n    * @method updateAxisY\n    * @protected\n    ###\n    updateAxisY: ->\n        if (@object.draggable.axisY ? yes)\n            if @object.dragging\n                @object.draggable.step = Math.round(Math.max(@rect.y, Math.min((@my - @object.dstRect.height / 2), @rect.y+@rect.height-@object.dstRect.height)) / @stepSize.y)\n                @object.dstRect.y = @object.draggable.step * @stepSize.y\n            else if @object.draggable.steps?\n                @object.dstRect.y = @object.draggable.step * @stepSize.y\n\n    ###*\n    * Calculates the size of a single step if steps are configured for this\n    * component. Otherwise the step-size 1-pixel.\n    *\n    * @method updateDragging\n    * @protected\n    ###\n    updateStepSize: ->\n        if @object.draggable.steps?\n            @stepSize.x = (@rect.width-@object.dstRect.width) / (@object.draggable.steps-1)\n            @stepSize.y = (@rect.height-@object.dstRect.height) / (@object.draggable.steps-1)\n        else\n            @stepSize.x = 1\n            @stepSize.y = 1\n\n    ###*\n    * Updates the game object's dragging-state and fires a dragged-event\n    * if necessary.\n    *\n    * @method updateDragging\n    * @protected\n    ###\n    updateDragging: ->\n        if @object.focusable and !@object.ui.focused then return\n\n        x = Input.Mouse.x - @object.origin.x\n        y = Input.Mouse.y - @object.origin.y\n\n        if @object.dragging\n            if (@mx != x or @my != y)\n                @object.events.emit(\"drag\", @object)\n            if Input.Mouse.buttons[Input.Mouse.LEFT] == 2 or Input.Mouse.buttons[Input.Mouse.LEFT] == 0\n                @object.dragging = no\n                @object.events?.emit(\"dragEnd\", @object)\n\n        @mx = x\n        @my = y\n\n    ###*\n    * Updates the dragging-logic.\n    *\n    * @method update\n    ###\n    update: ->\n        @rect = @object.draggable?.rect || @object.dstRect\n        @updateStepSize()\n        @updateDragging()\n        @updateAxisX()\n        @updateAxisY()\n\n\n\n\n\n\nui.Draggable = Component_Draggable\nui.Component_Draggable = Component_Draggable",
        "compiledContent": "// Generated by CoffeeScript 1.12.7\n(function() {\n  var Component_Draggable,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  Component_Draggable = (function(superClass) {\n    extend(Component_Draggable, superClass);\n\n\n    /**\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    *\n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n     */\n\n    Component_Draggable.prototype.onDataBundleRestore = function(data, context) {\n      return this.setupEventHandlers();\n    };\n\n\n    /**\n    * Makes a game object draggable using mouse/touch. The dragging can be\n    * vertical, horizontal or both. It can be configured as pixel-wise or\n    * step-wise dragging. For example: To create a slider for UI with\n    * fixed steps, step-wise is useful while a pixel-wise dragging could\n    * be used for a volume-slider.\n    *\n    * @module gs\n    * @class Component_Draggable\n    * @extends gs.Component\n    * @memberof gs\n    * @constructor\n     */\n\n    function Component_Draggable() {\n\n      /**\n      * Mouse/Pointer x coordinate\n      * @property mx\n      * @type number\n       */\n      this.mx = 0;\n\n      /**\n      * Mouse/Pointer y coordinate\n      * @property my\n      * @type number\n       */\n      this.my = 0;\n\n      /**\n      * Stepping in pixels.\n      * @property stepSize\n      * @type gs.Point\n       */\n      this.stepSize = {\n        x: 0,\n        y: 0\n      };\n\n      /**\n      * Drag Area\n      * @property rect\n      * @type gs.Rect\n       */\n      this.rect = null;\n    }\n\n\n    /**\n    * Adds event-handler for mouse/touch events to update the component only if\n    * a user-action happened.\n    *\n    * @method setupEventHandlers\n     */\n\n    Component_Draggable.prototype.setupEventHandlers = function() {\n      gs.GlobalEventManager.on(\"mouseMoved\", ((function(_this) {\n        return function(e) {\n          var rect, ref, x, y;\n          rect = (ref = _this.object.draggable) != null ? ref.rect : void 0;\n          x = Input.Mouse.x - _this.object.origin.x;\n          y = Input.Mouse.y - _this.object.origin.y;\n          if (_this.object.dragging || rect.contains(x, y)) {\n            _this.object.needsUpdate = true;\n            return e.breakChain = true;\n          }\n        };\n      })(this)), null, this.object);\n      gs.GlobalEventManager.on(\"mouseDown\", ((function(_this) {\n        return function(e) {\n          var rect, ref, x, y;\n          rect = _this.object.dstRect;\n          x = Input.Mouse.x - _this.object.origin.x;\n          y = Input.Mouse.y - _this.object.origin.y;\n          if (rect.contains(x, y)) {\n            _this.object.dragging = true;\n            _this.object.needsUpdate = true;\n            if ((ref = _this.object.events) != null) {\n              ref.emit(\"dragStart\", _this.object);\n            }\n            return e.breakChain = true;\n          }\n        };\n      })(this)), null, this.object);\n      return gs.GlobalEventManager.on(\"mouseUp\", ((function(_this) {\n        return function(e) {\n          if (_this.object.dragging) {\n            _this.object.needsUpdate = true;\n            return e.breakChain = true;\n          }\n        };\n      })(this)), null, this.object);\n    };\n\n\n    /**\n    * Initializes the component. Adds event-handler for mouse/touch events to\n    * update the component only if a user-action happened.\n    *\n    * @method setup\n     */\n\n    Component_Draggable.prototype.setup = function() {\n      return this.setupEventHandlers();\n    };\n\n\n    /**\n    * Disposes the component.\n    *\n    * @method dispose\n     */\n\n    Component_Draggable.prototype.dispose = function() {\n      Component_Draggable.__super__.dispose.apply(this, arguments);\n      gs.GlobalEventManager.offByOwner(\"mouseDown\", this.object);\n      return gs.GlobalEventManager.offByOwner(\"mouseMoved\", this.object);\n    };\n\n\n    /**\n    * Updates the dragging-process on x-axis if configured.\n    *\n    * @method updateAxisX\n    * @protected\n     */\n\n    Component_Draggable.prototype.updateAxisX = function() {\n      var ref;\n      if ((ref = this.object.draggable.axisX) != null ? ref : true) {\n        if (this.object.dragging) {\n          this.object.draggable.step = Math.round(Math.max(this.rect.x, Math.min(this.mx - this.object.dstRect.width / 2, this.rect.x + this.rect.width - this.object.dstRect.width)) / this.stepSize.x);\n          return this.object.dstRect.x = this.object.draggable.step * this.stepSize.x;\n        } else if (this.object.draggable.steps != null) {\n          return this.object.dstRect.x = this.object.draggable.step * this.stepSize.x;\n        }\n      }\n    };\n\n\n    /**\n    * Updates the dragging-process on y-axis if configured.\n    *\n    * @method updateAxisY\n    * @protected\n     */\n\n    Component_Draggable.prototype.updateAxisY = function() {\n      var ref;\n      if ((ref = this.object.draggable.axisY) != null ? ref : true) {\n        if (this.object.dragging) {\n          this.object.draggable.step = Math.round(Math.max(this.rect.y, Math.min(this.my - this.object.dstRect.height / 2, this.rect.y + this.rect.height - this.object.dstRect.height)) / this.stepSize.y);\n          return this.object.dstRect.y = this.object.draggable.step * this.stepSize.y;\n        } else if (this.object.draggable.steps != null) {\n          return this.object.dstRect.y = this.object.draggable.step * this.stepSize.y;\n        }\n      }\n    };\n\n\n    /**\n    * Calculates the size of a single step if steps are configured for this\n    * component. Otherwise the step-size 1-pixel.\n    *\n    * @method updateDragging\n    * @protected\n     */\n\n    Component_Draggable.prototype.updateStepSize = function() {\n      if (this.object.draggable.steps != null) {\n        this.stepSize.x = (this.rect.width - this.object.dstRect.width) / (this.object.draggable.steps - 1);\n        return this.stepSize.y = (this.rect.height - this.object.dstRect.height) / (this.object.draggable.steps - 1);\n      } else {\n        this.stepSize.x = 1;\n        return this.stepSize.y = 1;\n      }\n    };\n\n\n    /**\n    * Updates the game object's dragging-state and fires a dragged-event\n    * if necessary.\n    *\n    * @method updateDragging\n    * @protected\n     */\n\n    Component_Draggable.prototype.updateDragging = function() {\n      var ref, x, y;\n      if (this.object.focusable && !this.object.ui.focused) {\n        return;\n      }\n      x = Input.Mouse.x - this.object.origin.x;\n      y = Input.Mouse.y - this.object.origin.y;\n      if (this.object.dragging) {\n        if (this.mx !== x || this.my !== y) {\n          this.object.events.emit(\"drag\", this.object);\n        }\n        if (Input.Mouse.buttons[Input.Mouse.LEFT] === 2 || Input.Mouse.buttons[Input.Mouse.LEFT] === 0) {\n          this.object.dragging = false;\n          if ((ref = this.object.events) != null) {\n            ref.emit(\"dragEnd\", this.object);\n          }\n        }\n      }\n      this.mx = x;\n      return this.my = y;\n    };\n\n\n    /**\n    * Updates the dragging-logic.\n    *\n    * @method update\n     */\n\n    Component_Draggable.prototype.update = function() {\n      var ref;\n      this.rect = ((ref = this.object.draggable) != null ? ref.rect : void 0) || this.object.dstRect;\n      this.updateStepSize();\n      this.updateDragging();\n      this.updateAxisX();\n      return this.updateAxisY();\n    };\n\n    return Component_Draggable;\n\n  })(gs.Component);\n\n  ui.Draggable = Component_Draggable;\n\n  ui.Component_Draggable = Component_Draggable;\n\n}).call(this);\n"
    },
    "summary": [
        "name",
        "type",
        "order"
    ],
    "externalItems": []
}