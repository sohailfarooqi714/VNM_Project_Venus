{
    "uid": "AB1D7471K9AA5A4790SA69CEB8BEC017E46A",
    "isLoaded": true,
    "lastModificationTime": 0,
    "items": {
        "name": "Component_EventEmitter",
        "type": "game_script",
        "order": 15,
        "parentId": "D3325122KACDEA4515SB731E37A42B9D779F",
        "folder": false,
        "content": "# ===================================================================\n#\n#   Script: Component_EventEmitter\n#\n#   $$COPYRIGHT$$\n#\n# ===================================================================\nclass Component_EventEmitter extends gs.Component\n    #@objectCodecBlackList = [\"handlers\"]\n    ###*\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    *\n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n    ###\n    onDataBundleRestore: (data, context) ->\n        for k of @handlers\n            list = @handlers[k]\n            for i in [0...list.length]\n                handlers = list[i]\n                j = 0\n                while j < handlers.length\n                    handler = handlers[j]\n\n                    if !handler.handler or !handler.handler.$vnm_cb\n                        handlers.splice(j, 1)\n                    else\n                        j++\n\n        #@handlers = {}\n        return null\n    ###*\n    * A component which allow a game object to fire events and manage a list\n    * of observers.\n    *\n    * @module gs\n    * @class Component_EventEmitter\n    * @extends gs.Component\n    * @memberof gs\n    ###\n    constructor: ->\n        super\n\n        ###*\n        * List of registered observers.\n        *\n        * @property handlers\n        * @type Object\n        * @private\n        ###\n        @handlers = {}\n\n        ###*\n        * @property defaultData\n        * @type Object\n        * @private\n        ###\n        @defaultData = {}\n\n        ###*\n        * @property chainInfo\n        * @type Object\n        * @private\n        ###\n        @chainInfo = {}\n\n        ###*\n        * @property needsSort\n        * @type boolean\n        * @private\n        ###\n        @needsSort = {}\n\n        ###*\n        * @property markedForRemove\n        * @type Object[]\n        * @private\n        ###\n        @markedForRemove = []\n\n        ###*\n        * @property isEmitting\n        * @type number\n        * @private\n        ###\n        @isEmitting = 0\n\n    ###*\n    * Clears the event emitter by removing all handlers/listeners.\n    *\n    * @method clear\n    ###\n    clear: ->\n        @needsSort = {}\n        @handlers = {}\n        @defaultData = {}\n\n    ###*\n    * Clears the event emitter by removing all handlers/listeners except those\n    * which are associated with an owner in the specified owners array.\n    *\n    * @method clearExcept\n    * @param {Object[]} owners - An array of owner objects. Only handlers/listeners which are not\n    * associated with that owners are removed.\n    ###\n    clearExcept: (owners) ->\n        @needsSort = {}\n        @defaultData = {}\n\n        events = Object.keys(@handlers)\n        for event in events\n            handlers = @handlers[event]\n            for handlerList, i in handlers\n                handlerList = handlerList.filter (h) -> owners.indexOf(h.owner) != 1\n                handlers[i] = handlerList\n\n    ###*\n    * Adds a new observer/listener for a specified event.\n    *\n    * @method on\n    * @param {string} eventName - The event name.\n    * @param {function} handler - The handler-function called when the event is fired.\n    * @param {Object} [data={}] - An optional info-object passed to the handler-function.\n    * @param {Object} [owner=null] - An optional owner-object associated with the observer/listener.\n    * @param {number} priority - An optional priority level. An observer/listener with a higher level will receive the event before observers/listeners with a lower level.\n    * @return {gs.EventObserver} - The added observer-object.\n    ###\n    on: (eventName, handler, data, owner, priority) ->\n        priority = priority || 0\n        @needsSort[eventName] = true\n        if not @handlers[eventName]?\n            @handlers[eventName] = []\n        if not @handlers[eventName][priority]\n            @handlers[eventName][priority] = []\n\n        handlerObject = { handler: handler, once: no, data: data, owner: owner, eventName: eventName, priority: priority }\n        @handlers[eventName][priority].push(handlerObject)\n\n        return handlerObject\n\n    ###*\n    * Adds a new observer/listener for a specified event and removes it\n    * after the even has been emitted once.\n    *\n    * @method once\n    * @param {string} eventName - The event name.\n    * @param {function} handler - The handler-function called when the event is fired.\n    * @param {Object} [data={}] - An optional info-object passed to the handler-function.\n    * @param {Object} [owner=null] - An optional owner-object associated with the observer/listener.\n    * @param {number} priority - An optional priority level. An observer/listener with a higher level will receive the event before observers/listeners with a lower level.\n    * @return {gs.EventObserver} - The added observer-object.\n    ###\n    once: (eventName, handler, data, owner, priority) ->\n        handlerObject = @on(eventName, handler, data, owner, priority)\n        handlerObject.once = yes\n\n        return handlerObject\n\n    ###*\n    * Removes an observer/listener from a specified event. If handler parameter\n    * is null, all observers for the specified event are removed.\n    *\n    * @method off\n    * @param {string} eventName - The event name.\n    * @param {gs.EventObserver} [handler=null] - The observer-object to remove.\n    * If null, all observers for the specified event are removed.\n    ###\n    off: (eventName, handler) ->\n        if @isEmitting > 0 and handler\n            @markedForRemove.push(handler)\n        else if handler?\n            @handlers[eventName]?[handler.priority]?.remove(handler)\n        else\n            @handlers[eventName] = []\n\n    ###*\n    * Removes all observers/listeners from an event which are belonging to the specified\n    * owner.\n    *\n    * @method offByOwner\n    * @param {string} eventName - The event name.\n    * @param {Object} owner - The owner.\n    * @return {number} Count of removed observers/listeners.\n    ###\n    offByOwner: (eventName, owner) ->\n        if @handlers[eventName]\n            if @isEmitting > 0\n                for handlerList in @handlers[eventName]\n                    handlers = handlerList?.where (x) -> x.owner == owner\n                    for handler in handlers\n                        @markedForRemove.push(handler)\n            else\n                for handlerList in @handlers[eventName]\n                    handlerList.removeAll((x) -> x.owner == owner)\n\n    ###*\n    * Emits the specified event. All observers/listeners registered for the\n    * specified event are informed.\n    *\n    * @method emit\n    * @param {string} eventName - The name of the event to fire.\n    * @param {Object} [sender=null] - The sender of the event.\n    * @param {Object} [data={}] - An optional object passed to each handler-function.\n    ###\n    emit: (eventName, sender, data) ->\n        handlerLists = @handlers[eventName]\n        data = data ? {} #@defaultData\n\n        if handlerLists and @needsSort[eventName]\n            @needsSort[eventName] = no\n            for handlerList in handlerLists\n                handlerList.sort (a, b) ->\n                    if a.owner and b.owner\n                        if a.owner.rIndex > b.owner.rIndex\n                          return -1\n                        else if a.owner.rIndex < b.owner.rIndex\n                          return 1\n                        else\n                          return 0\n                    else\n                        return -1\n\n        if handlerLists?\n            breakOwner = null\n            for handlerList in handlerLists by -1\n                if !handlerList then continue\n                i = 0\n                count = handlerList.length\n                @isEmitting++\n                while i < count\n                    handler = handlerList[i]\n\n                    data.handler = handler\n                    data.sender = sender\n                    data.data = handler.data\n\n                    if (!breakOwner and (!handler.owner or !handler.owner.visible? or handler.owner.visible)) or breakOwner == handler.owner\n                        handler.handler(data)\n\n                    if handler.once\n                        @markedForRemove.push(handler)\n\n                    if data.breakChain\n                        breakOwner = handler.owner\n                        #break\n\n                    i++\n                @isEmitting--\n                if data.breakChain\n                    data.breakChain = no\n                    break\n\n            if !@isEmitting and @markedForRemove.length > 0\n                for handler in @markedForRemove\n                    @handlers[handler.eventName][handler.priority].remove(handler)\n                @markedForRemove = []\n\n\n        return null\n\n\n\n    ###*\n    * Checks if an event-handler with a specified owner exists for the\n    * given event.\n    *\n    * @method checkForOwner\n    * @param {string} eventName - The event name.\n    * @param {function} owner - The owner to search for.\n    * @return {boolean} If <b>true</b>, an event-handler with the specified owner\n    * exists for the given event. Otherwise <b>false</b>.\n    ###\n    checkForOwner: (eventName, owner) ->\n        result = no\n\n        for handler in @handlers[eventName]\n            if handler.owner == owner\n                result = yes\n                break\n\n        return result\n\n    ###*\n    * Checks if an event-handler with a specified handler-function exists for the\n    * given event.\n    *\n    * @method checkForHandlerFunction\n    * @param {string} eventName - The event name.\n    * @param {function} handlerFunction - The handler-function to search for.\n    * @return {boolean} If true, an observer witht he specified handler-function\n    * exists for the given event. Otherwise false.\n    ###\n    checkForHandlerFunction: (eventName, handlerFunction) ->\n        result = no\n\n        if handlerFunction?\n            for handler in @handlers[eventName]\n                if handler.handler == handlerFunction\n                    result = yes\n                    break\n\n        return result\n\n    ###*\n    * Not implemented yet.\n    * @method update\n    ###\n    # FIXME: Why should event-emitter influence the active-property?\n    update: ->\n        @object.active = @object.active and (!@object.parent or @object.parent.active)\n\ngs.Component_EventEmitter = Component_EventEmitter\ngs.EventEmitter = Component_EventEmitter\ngs.GlobalEventManager = new Component_EventEmitter()",
        "compiledContent": "// Generated by CoffeeScript 1.12.7\n(function() {\n  var Component_EventEmitter,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  Component_EventEmitter = (function(superClass) {\n    extend(Component_EventEmitter, superClass);\n\n\n    /**\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    *\n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n     */\n\n    Component_EventEmitter.prototype.onDataBundleRestore = function(data, context) {\n      var handler, handlers, i, j, k, l, list, ref;\n      for (k in this.handlers) {\n        list = this.handlers[k];\n        for (i = l = 0, ref = list.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {\n          handlers = list[i];\n          j = 0;\n          while (j < handlers.length) {\n            handler = handlers[j];\n            if (!handler.handler || !handler.handler.$vnm_cb) {\n              handlers.splice(j, 1);\n            } else {\n              j++;\n            }\n          }\n        }\n      }\n      return null;\n    };\n\n\n    /**\n    * A component which allow a game object to fire events and manage a list\n    * of observers.\n    *\n    * @module gs\n    * @class Component_EventEmitter\n    * @extends gs.Component\n    * @memberof gs\n     */\n\n    function Component_EventEmitter() {\n      Component_EventEmitter.__super__.constructor.apply(this, arguments);\n\n      /**\n      * List of registered observers.\n      *\n      * @property handlers\n      * @type Object\n      * @private\n       */\n      this.handlers = {};\n\n      /**\n      * @property defaultData\n      * @type Object\n      * @private\n       */\n      this.defaultData = {};\n\n      /**\n      * @property chainInfo\n      * @type Object\n      * @private\n       */\n      this.chainInfo = {};\n\n      /**\n      * @property needsSort\n      * @type boolean\n      * @private\n       */\n      this.needsSort = {};\n\n      /**\n      * @property markedForRemove\n      * @type Object[]\n      * @private\n       */\n      this.markedForRemove = [];\n\n      /**\n      * @property isEmitting\n      * @type number\n      * @private\n       */\n      this.isEmitting = 0;\n    }\n\n\n    /**\n    * Clears the event emitter by removing all handlers/listeners.\n    *\n    * @method clear\n     */\n\n    Component_EventEmitter.prototype.clear = function() {\n      this.needsSort = {};\n      this.handlers = {};\n      return this.defaultData = {};\n    };\n\n\n    /**\n    * Clears the event emitter by removing all handlers/listeners except those\n    * which are associated with an owner in the specified owners array.\n    *\n    * @method clearExcept\n    * @param {Object[]} owners - An array of owner objects. Only handlers/listeners which are not\n    * associated with that owners are removed.\n     */\n\n    Component_EventEmitter.prototype.clearExcept = function(owners) {\n      var event, events, handlerList, handlers, i, l, len, results;\n      this.needsSort = {};\n      this.defaultData = {};\n      events = Object.keys(this.handlers);\n      results = [];\n      for (l = 0, len = events.length; l < len; l++) {\n        event = events[l];\n        handlers = this.handlers[event];\n        results.push((function() {\n          var len1, m, results1;\n          results1 = [];\n          for (i = m = 0, len1 = handlers.length; m < len1; i = ++m) {\n            handlerList = handlers[i];\n            handlerList = handlerList.filter(function(h) {\n              return owners.indexOf(h.owner) !== 1;\n            });\n            results1.push(handlers[i] = handlerList);\n          }\n          return results1;\n        })());\n      }\n      return results;\n    };\n\n\n    /**\n    * Adds a new observer/listener for a specified event.\n    *\n    * @method on\n    * @param {string} eventName - The event name.\n    * @param {function} handler - The handler-function called when the event is fired.\n    * @param {Object} [data={}] - An optional info-object passed to the handler-function.\n    * @param {Object} [owner=null] - An optional owner-object associated with the observer/listener.\n    * @param {number} priority - An optional priority level. An observer/listener with a higher level will receive the event before observers/listeners with a lower level.\n    * @return {gs.EventObserver} - The added observer-object.\n     */\n\n    Component_EventEmitter.prototype.on = function(eventName, handler, data, owner, priority) {\n      var handlerObject;\n      priority = priority || 0;\n      this.needsSort[eventName] = true;\n      if (this.handlers[eventName] == null) {\n        this.handlers[eventName] = [];\n      }\n      if (!this.handlers[eventName][priority]) {\n        this.handlers[eventName][priority] = [];\n      }\n      handlerObject = {\n        handler: handler,\n        once: false,\n        data: data,\n        owner: owner,\n        eventName: eventName,\n        priority: priority\n      };\n      this.handlers[eventName][priority].push(handlerObject);\n      return handlerObject;\n    };\n\n\n    /**\n    * Adds a new observer/listener for a specified event and removes it\n    * after the even has been emitted once.\n    *\n    * @method once\n    * @param {string} eventName - The event name.\n    * @param {function} handler - The handler-function called when the event is fired.\n    * @param {Object} [data={}] - An optional info-object passed to the handler-function.\n    * @param {Object} [owner=null] - An optional owner-object associated with the observer/listener.\n    * @param {number} priority - An optional priority level. An observer/listener with a higher level will receive the event before observers/listeners with a lower level.\n    * @return {gs.EventObserver} - The added observer-object.\n     */\n\n    Component_EventEmitter.prototype.once = function(eventName, handler, data, owner, priority) {\n      var handlerObject;\n      handlerObject = this.on(eventName, handler, data, owner, priority);\n      handlerObject.once = true;\n      return handlerObject;\n    };\n\n\n    /**\n    * Removes an observer/listener from a specified event. If handler parameter\n    * is null, all observers for the specified event are removed.\n    *\n    * @method off\n    * @param {string} eventName - The event name.\n    * @param {gs.EventObserver} [handler=null] - The observer-object to remove.\n    * If null, all observers for the specified event are removed.\n     */\n\n    Component_EventEmitter.prototype.off = function(eventName, handler) {\n      var ref, ref1;\n      if (this.isEmitting > 0 && handler) {\n        return this.markedForRemove.push(handler);\n      } else if (handler != null) {\n        return (ref = this.handlers[eventName]) != null ? (ref1 = ref[handler.priority]) != null ? ref1.remove(handler) : void 0 : void 0;\n      } else {\n        return this.handlers[eventName] = [];\n      }\n    };\n\n\n    /**\n    * Removes all observers/listeners from an event which are belonging to the specified\n    * owner.\n    *\n    * @method offByOwner\n    * @param {string} eventName - The event name.\n    * @param {Object} owner - The owner.\n    * @return {number} Count of removed observers/listeners.\n     */\n\n    Component_EventEmitter.prototype.offByOwner = function(eventName, owner) {\n      var handler, handlerList, handlers, l, len, len1, m, ref, ref1, results, results1;\n      if (this.handlers[eventName]) {\n        if (this.isEmitting > 0) {\n          ref = this.handlers[eventName];\n          results = [];\n          for (l = 0, len = ref.length; l < len; l++) {\n            handlerList = ref[l];\n            handlers = handlerList != null ? handlerList.where(function(x) {\n              return x.owner === owner;\n            }) : void 0;\n            results.push((function() {\n              var len1, m, results1;\n              results1 = [];\n              for (m = 0, len1 = handlers.length; m < len1; m++) {\n                handler = handlers[m];\n                results1.push(this.markedForRemove.push(handler));\n              }\n              return results1;\n            }).call(this));\n          }\n          return results;\n        } else {\n          ref1 = this.handlers[eventName];\n          results1 = [];\n          for (m = 0, len1 = ref1.length; m < len1; m++) {\n            handlerList = ref1[m];\n            results1.push(handlerList.removeAll(function(x) {\n              return x.owner === owner;\n            }));\n          }\n          return results1;\n        }\n      }\n    };\n\n\n    /**\n    * Emits the specified event. All observers/listeners registered for the\n    * specified event are informed.\n    *\n    * @method emit\n    * @param {string} eventName - The name of the event to fire.\n    * @param {Object} [sender=null] - The sender of the event.\n    * @param {Object} [data={}] - An optional object passed to each handler-function.\n     */\n\n    Component_EventEmitter.prototype.emit = function(eventName, sender, data) {\n      var breakOwner, count, handler, handlerList, handlerLists, i, l, len, len1, m, n, ref;\n      handlerLists = this.handlers[eventName];\n      data = data != null ? data : {};\n      if (handlerLists && this.needsSort[eventName]) {\n        this.needsSort[eventName] = false;\n        for (l = 0, len = handlerLists.length; l < len; l++) {\n          handlerList = handlerLists[l];\n          handlerList.sort(function(a, b) {\n            if (a.owner && b.owner) {\n              if (a.owner.rIndex > b.owner.rIndex) {\n                return -1;\n              } else if (a.owner.rIndex < b.owner.rIndex) {\n                return 1;\n              } else {\n                return 0;\n              }\n            } else {\n              return -1;\n            }\n          });\n        }\n      }\n      if (handlerLists != null) {\n        breakOwner = null;\n        for (m = handlerLists.length - 1; m >= 0; m += -1) {\n          handlerList = handlerLists[m];\n          if (!handlerList) {\n            continue;\n          }\n          i = 0;\n          count = handlerList.length;\n          this.isEmitting++;\n          while (i < count) {\n            handler = handlerList[i];\n            data.handler = handler;\n            data.sender = sender;\n            data.data = handler.data;\n            if ((!breakOwner && (!handler.owner || (handler.owner.visible == null) || handler.owner.visible)) || breakOwner === handler.owner) {\n              handler.handler(data);\n            }\n            if (handler.once) {\n              this.markedForRemove.push(handler);\n            }\n            if (data.breakChain) {\n              breakOwner = handler.owner;\n            }\n            i++;\n          }\n          this.isEmitting--;\n          if (data.breakChain) {\n            data.breakChain = false;\n            break;\n          }\n        }\n        if (!this.isEmitting && this.markedForRemove.length > 0) {\n          ref = this.markedForRemove;\n          for (n = 0, len1 = ref.length; n < len1; n++) {\n            handler = ref[n];\n            this.handlers[handler.eventName][handler.priority].remove(handler);\n          }\n          this.markedForRemove = [];\n        }\n      }\n      return null;\n    };\n\n\n    /**\n    * Checks if an event-handler with a specified owner exists for the\n    * given event.\n    *\n    * @method checkForOwner\n    * @param {string} eventName - The event name.\n    * @param {function} owner - The owner to search for.\n    * @return {boolean} If <b>true</b>, an event-handler with the specified owner\n    * exists for the given event. Otherwise <b>false</b>.\n     */\n\n    Component_EventEmitter.prototype.checkForOwner = function(eventName, owner) {\n      var handler, l, len, ref, result;\n      result = false;\n      ref = this.handlers[eventName];\n      for (l = 0, len = ref.length; l < len; l++) {\n        handler = ref[l];\n        if (handler.owner === owner) {\n          result = true;\n          break;\n        }\n      }\n      return result;\n    };\n\n\n    /**\n    * Checks if an event-handler with a specified handler-function exists for the\n    * given event.\n    *\n    * @method checkForHandlerFunction\n    * @param {string} eventName - The event name.\n    * @param {function} handlerFunction - The handler-function to search for.\n    * @return {boolean} If true, an observer witht he specified handler-function\n    * exists for the given event. Otherwise false.\n     */\n\n    Component_EventEmitter.prototype.checkForHandlerFunction = function(eventName, handlerFunction) {\n      var handler, l, len, ref, result;\n      result = false;\n      if (handlerFunction != null) {\n        ref = this.handlers[eventName];\n        for (l = 0, len = ref.length; l < len; l++) {\n          handler = ref[l];\n          if (handler.handler === handlerFunction) {\n            result = true;\n            break;\n          }\n        }\n      }\n      return result;\n    };\n\n\n    /**\n    * Not implemented yet.\n    * @method update\n     */\n\n    Component_EventEmitter.prototype.update = function() {\n      return this.object.active = this.object.active && (!this.object.parent || this.object.parent.active);\n    };\n\n    return Component_EventEmitter;\n\n  })(gs.Component);\n\n  gs.Component_EventEmitter = Component_EventEmitter;\n\n  gs.EventEmitter = Component_EventEmitter;\n\n  gs.GlobalEventManager = new Component_EventEmitter();\n\n}).call(this);\n"
    },
    "summary": [
        "name",
        "type",
        "order"
    ],
    "externalItems": []
}