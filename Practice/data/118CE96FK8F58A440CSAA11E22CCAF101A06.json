{
    "uid": "118CE96FK8F58A440CSAA11E22CCAF101A06",
    "isLoaded": true,
    "lastModificationTime": 0,
    "items": {
        "name": "Component_MessageTextRenderer",
        "type": "game_script",
        "order": 11,
        "parentId": "D3325122KACDEA4515SB731E37A42B9D779F",
        "folder": false,
        "content": "# ===================================================================\n#\n#   Script: Component_MessageTextRenderer\n#\n#   $$COPYRIGHT$$\n#\n# ===================================================================\nclass Component_MessageTextRenderer extends gs.Component_TextRenderer\n    @objectCodecBlackList = [\"onLinkClick\", \"onBatchDisappear\"]\n    ###*\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    *\n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n    ###\n    onDataBundleRestore: (data, context) ->\n        @setupEventHandlers()\n        l = 0\n        lastLine = null\n\n        for message in @object.messages\n            if @object.settings.useCharacterColor\n                @object.font.color = new gs.Color(message.character.textColor)\n\n            lineWidth = if @isRunningInMultiPartMode() then lastLine?.width || 0 else 0\n            @lines = @calculateLines(lcsm(message.text), yes, lineWidth)\n            for line in @lines\n                bitmap = @createBitmap(line)\n                if line == @line\n                    @drawLineContent(line, bitmap, @charIndex+1)\n                else\n                    @drawLineContent(line, bitmap, -1)\n                @allSprites[l].bitmap = bitmap\n                lastLine = line\n                l++\n\n        for customObject in @customObjects\n            SceneManager.scene.addObject(customObject)\n\n        return null\n\n    ###*\n    *  A text-renderer component to render an animated and interactive message text using\n    *  dimensions of the game object's destination-rectangle. The message is displayed\n    *  using a sprite for each line instead of drawing to the game object's bitmap object.\n    *\n    *  @module gs\n    *  @class Component_MessageTextRenderer\n    *  @extends gs.Component_TextRenderer\n    *  @memberof gs\n    *  @constructor\n    ###\n    constructor: ->\n        super\n\n        ###*\n        * An array containing all sprites of the current message.\n        * @property sprites\n        * @type gs.Sprite[]\n        * @protected\n        ###\n        @sprites = []\n\n        ###*\n        * An array containing all sprites of all messages. In NVL mode\n        * a page can contain multiple messages.\n        * @property allSprites\n        * @type gs.Sprite[]\n        * @protected\n        ###\n        @allSprites = []\n        ###*\n        * An array containing all line-objects of the current message.\n        * @property lines\n        * @type gs.TextRendererLine[]\n        * @readOnly\n        ###\n        @lines = null\n\n        ###*\n        * The line currently rendered.\n        * @property line\n        * @type number\n        * @readOnly\n        ###\n        @line = 0\n\n        ###*\n        * The left and right padding per line.\n        * @property padding\n        * @type number\n        ###\n        @padding = 6\n\n        ###*\n        * The minimum height of the line currently rendered. If 0, the measured\n        * height of the line will be used.\n        * @property minLineHeight\n        * @type number\n        ###\n        @minLineHeight = 0\n\n        ###*\n        * The spacing between text lines in pixels.\n        * @property lineSpacing\n        * @type number\n        ###\n        @lineSpacing = 2\n\n        ###*\n        * The line currently rendered.\n        * @property currentLine\n        * @type number\n        * @protected\n        ###\n        @currentLine = 0\n\n        ###*\n        * The height of the line currently rendered.\n        * @property currentLineHeight\n        * @type number\n        * @protected\n        ###\n        @currentLineHeight = 0\n\n        ###*\n        * Index of the current character to draw.\n        * @property charIndex\n        * @type number\n        * @readOnly\n        ###\n        @charIndex = 0\n\n        ###*\n        * Position of the message caret. The caret is like an invisible\n        * cursor pointing to the x/y coordinates of the last rendered character of\n        * the message. That position can be used to display a waiting- or processing-animation for example.\n        * @property caretPosition\n        * @type gs.Point\n        * @readOnly\n        ###\n        @caretPosition = new gs.Point()\n\n        ###*\n        * Indicates that the a message is currently in progress.\n        * @property isRunning\n        * @type boolean\n        * @readOnly\n        ###\n        @isRunning = no\n\n        ###*\n        * The current x-coordinate of the caret/cursor.\n        * @property currentX\n        * @type number\n        * @readOnly\n        ###\n        @currentX = 0\n\n        ###*\n        * The current y-coordinate of the caret/cursor.\n        * @property currentY\n        * @type number\n        * @readOnly\n        ###\n        @currentY = 0\n\n        ###*\n        * The current sprites used to display the current text-line/part.\n        * @property currentSprite\n        * @type gs.Sprite\n        * @readOnly\n        ###\n        @currentSprite = null\n\n        ###*\n        * Indicates if the message-renderer is currently waiting like for a user-action.\n        * @property isWaiting\n        * @type boolean\n        * @readOnly\n        ###\n        @isWaiting = no\n\n        ###*\n        * Indicates if the message-renderer is currently waiting for a key-press or mouse/touch action.\n        * @property waitForKey\n        * @type boolean\n        * @readOnly\n        ###\n        @waitForKey = no\n\n        ###*\n        * Number of frames the message-renderer should wait before continue.\n        * @property waitCounter\n        * @type number\n        ###\n        @waitCounter = 0\n\n        ###*\n        * Speed of the message-drawing. The smaller the value, the faster the message is displayed.\n        * @property speed\n        * @type number\n        ###\n        @speed = 1\n\n        ###*\n        * Indicates if the message should be rendered immedialtely without any animation or delay.\n        * @property drawImmediately\n        * @type boolean\n        ###\n        @drawImmediately = no\n\n        ###*\n        * Indicates if the message should wait for a user-action or a certain amount of time\n        * before finishing.\n        * @property waitAtEnd\n        * @type boolean\n        ###\n        @waitAtEnd = yes\n\n        ###*\n        * The number of frames to wait before finishing a message.\n        * before finishing.\n        * @property waitAtEndTime\n        * @type number\n        ###\n        @waitAtEndTime = 0\n\n        ###*\n        * Indicates if auto word-wrap should be used. Default is <b>true</b>\n        * @property wordWrap\n        * @type boolean\n        ###\n        @wordWrap = yes\n\n        ###*\n        * Custom game objects which are alive until the current message is erased. Can be used to display\n        * animated icons, etc.\n        * @property customObjects\n        * @type gs.Object_Base[]\n        ###\n        @customObjects = []\n\n        ###*\n        * A hashtable/dictionary object to store custom-data useful like for token-processing. The data must be\n        * serializable.\n        * @property customObjects\n        * @type Object\n        ###\n        @customData = {}\n\n        ###*\n        * A callback function called if the player clicks on a non-stylable link (LK text-code) to trigger\n        * the specified common event.\n        * @property onLinkClick\n        * @type Function\n        ###\n        @onLinkClick = (e) ->\n            eventId = e.data.linkData.commonEventId\n            event = RecordManager.commonEvents[eventId]\n            if !event\n                event = RecordManager.commonEvents.first (x) => x.name == eventId\n                eventId = event.index if event\n            if !event\n                SceneManager.scene.interpreter.jumpToLabel(eventId)\n            else\n                SceneManager.scene.interpreter.callCommonEvent(eventId, null, yes)\n\n        ###*\n        * A callback function called if a batched messsage has been faded out. It triggers the execution of\n        * the next message.\n        * @property onBatchDisappear\n        * @type Function\n        ###\n        @onBatchDisappear = (e) =>\n            @drawImmediately = no\n            @isWaiting = no\n            @object.opacity = 255\n            @executeBatch()\n\n\n    ###*\n    * Serializes the message text-renderer into a data-bundle.\n    * @method toDataBundle\n    * @return {Object} A data-bundle.\n    ###\n    toDataBundle: ->\n        ignore = [\"object\", \"font\", \"sprites\", \"allSprites\", \"currentSprite\", \"currentX\"]\n        bundle = { currentSpriteIndex: @sprites.indexOf(@currentSprite) }\n\n        for k of this\n            if ignore.indexOf(k) == -1\n                bundle[k] = this[k]\n\n        return bundle\n\n\n\n    ###*\n    * Disposes the message text-renderer and all sprites used to display\n    * the message.\n    * @method dispose\n    ###\n    dispose: ->\n        super\n\n        @disposeEventHandlers()\n\n        for sprite in @allSprites\n            sprite.bitmap?.dispose()\n            sprite.dispose()\n\n    ###*\n    * Removes all attached event handlers\n    * the message.\n    * @method disposeEventHandlers\n    ###\n    disposeEventHandlers: ->\n        gs.GlobalEventManager.offByOwner(\"mouseUp\", @object)\n        gs.GlobalEventManager.offByOwner(\"keyUp\", @object)\n\n    ###*\n    * Adds event-handlers for mouse/touch events\n    *\n    * @method setupEventHandlers\n    ###\n    setupEventHandlers: ->\n        gs.GlobalEventManager.offByOwner(\"mouseUp\", @object)\n        gs.GlobalEventManager.offByOwner(\"keyUp\", @object)\n\n        gs.GlobalEventManager.on \"mouseUp\", ((e) =>\n            return if @object.findComponentByName(\"animation\") or (GameManager.settings.autoMessage.enabled and !GameManager.settings.autoMessage.stopOnAction)\n\n            #if @object.dstRect.contains(Input.Mouse.x - @object.origin.x, Input.Mouse.y - @object.origin.y)\n            if @isWaiting and not (@waitCounter > 0 or @waitForKey)\n                e.breakChain = yes\n                @continue()\n            else\n                e.breakChain = @isRunning\n                @drawImmediately = !@waitForKey\n                @waitCounter = 0\n                @waitForKey = no\n                @isWaiting = no\n\n            if @waitForKey\n                if Input.Mouse.buttons[Input.Mouse.LEFT] == 2\n                    e.breakChain = yes\n                    Input.clear()\n                    @waitForKey = no\n                    @isWaiting = no\n\n\n\n\n        ), null, @object\n\n        gs.GlobalEventManager.on \"keyUp\", ((e) =>\n            if Input.keys[Input.C] and (!@isWaiting or (@waitCounter > 0 or @waitForKey))\n                @drawImmediately = !@waitForKey\n                @waitCounter = 0\n                @waitForKey = no\n                @isWaiting = no\n\n            if @isWaiting and !@waitForKey and !@waitCounter and Input.keys[Input.C]\n                @continue()\n\n            if @waitForKey\n                if Input.keys[Input.C]\n                    Input.clear()\n                    @waitForKey = no\n                    @isWaiting = no\n\n        ), null, @object\n\n    ###*\n    * Sets up the renderer. Registers necessary event handlers.\n    * @method setup\n    ###\n    setup: ->\n        @setupEventHandlers()\n\n    ###*\n    * Restores the message text-renderer's state from a data-bundle.\n    * @method restore\n    * @param {Object} bundle - A data-bundle containing message text-renderer state.\n    ###\n    restore: (bundle) ->\n        for k of bundle\n            if k == \"currentSpriteIndex\"\n                @currentSprite = @sprites[bundle.currentSpriteIndex]\n            else\n                this[k] = bundle[k]\n\n        if @sprites.length > 0\n            @currentY = @sprites.last().y - @object.origin.y - @object.dstRect.y\n            @line = @maxLines\n            @isWaiting = @isWaiting || @isRunning\n\n        return null\n\n\n    ###*\n    * Continues message-processing if currently waiting.\n    * @method continue\n    ###\n    continue: ->\n        @isWaiting = no\n\n        if @line >= @lines.length\n            @isRunning = no\n            @object.events?.emit(\"messageFinish\", this)\n        else\n            @object.events?.emit(\"messageBatch\", this)\n            fading = GameManager.tempSettings.messageFading\n            duration = if GameManager.tempSettings.skip then 0 else fading.duration\n            @object.animator.disappear(fading.animation, fading.easing, duration, gs.CallBack(\"onBatchDisappear\", this))\n\n    ###*\n    * Updates the text-renderer.\n    * @method update\n    ###\n    update: ->\n        for sprite in @allSprites\n            sprite.opacity = @object.opacity\n            sprite.visible = @object.visible\n            sprite.ox = -@object.offset.x\n            sprite.oy = -@object.offset.y\n            sprite.mask.value = @object.mask.value\n            sprite.mask.vague = @object.mask.vague\n            sprite.mask.source = @object.mask.source\n            sprite.mask.type = @object.mask.type\n\n        for object in @customObjects\n            object.opacity = @object.opacity\n            object.visible = @object.visible\n\n        if not @isRunning and @waitCounter > 0\n            @waitCounter--\n            if @waitCounter == 0\n                @continue()\n            return\n\n        if @object.visible and @lines?.length > 0\n            @updateLineWriting()\n            @updateWaitForKey()\n            @updateWaitCounter()\n            @updateCaretPosition()\n\n\n    ###*\n    * Indicates if its a batched messages.\n    *\n    * @method isBatched\n    * @return If <b>true</b> it is a batched message. Otherwise <b>false</b>.\n    ###\n    isBatched: -> @lines.length > @maxLines\n\n    ###*\n    * Indicates if the batch is still in progress and not done.\n    *\n    * @method isBatchInProgress\n    * @return If <b>true</b> the batched message is still not done. Otherwise <b>false</b>\n    ###\n    isBatchInProgress: -> @lines.length - @line > @maxLines\n\n    ###*\n    * Indicates if the renderer runs in multi-part message mode which\n    * means that a single message might be constructed from multiple drawFormattedText\n    * calls.\n    *\n    * @method isRunningInMultiPartMode\n    * @return If <b>true</b> the renderer runs in multi-part mode. Otherwise <b>false</b>.\n    ###\n    isRunningInMultiPartMode: -> !@object.settings.autoErase and @object.settings.paragraphSpacing <= 0\n\n    ###*\n    * Starts displaying the next page of text if a message is too long to fit\n    * into one message box.\n    *\n    * @method executeBatch\n    ###\n    executeBatch: ->\n        @clearAllSprites()\n        @lines = @lines.slice(@line)\n        @line = 0\n        @currentX = 0\n        @currentY = 0\n        @currentLineHeight = 0\n        @tokenIndex = 0\n        @charIndex = 0\n        @token = @lines[@line].content[@tokenIndex] || new gs.RendererToken(null, \"\");\n        @maxLines = @calculateMaxLines(@lines)\n        @lineAnimationCount = @speed\n        @sprites = @createSprites(@lines)\n        @allSprites = @allSprites.concat(@sprites)\n        @currentSprite = @sprites[@line]\n        @currentSprite.x = @currentX + @object.origin.x + @object.dstRect.x\n        @drawNext()\n\n    ###*\n    * Calculates the duration(in frames) the message-renderer needs to display\n    * the message.\n    *\n    * @method calculateDuration\n    * @return {number} The duration in frames.\n    ###\n    calculateDuration: ->\n        duration = 0\n\n        if @lines?\n            for line in @lines\n                for token in line.content\n                    if token?\n                        duration += @calculateDurationForToken(token)\n        return duration\n\n    ###*\n    * Calculates the duration(in frames) the message-renderer needs to display\n    * the specified line.\n    *\n    * @method calculateDurationForLine\n    * @param {gs.RendererTextLine} line The line to calculate the duration for.\n    * @return {number} The duration in frames.\n    ###\n    calculateDurationForLine: (line) ->\n        duration = 0\n\n        if line\n            for token in line.content\n                if token?\n                    duration += @calculateDurationForToken(token)\n\n        return duration\n\n    ###*\n    * Calculates the duration(in frames) the message-renderer needs to process\n    * the specified token.\n    *\n    * @method calculateDurationForToken\n    * @param {string|Object} token - The token.\n    * @return {number} The duration in frames.\n    ###\n    calculateDurationForToken: (token) ->\n        duration = 0\n\n        if token.code?\n            switch token.code\n                when \"W\"\n                    if token.value != \"A\"\n                        duration = token.value / 1000 * Graphics.frameRate\n        else\n            duration = token.value.length * @speed\n\n        return duration\n\n    ###*\n    * Calculates the maximum of lines which can be displayed in one message.\n    *\n    * @method calculateMaxLines\n    * @param {Array} lines - An array of line-objects.\n    * @return {number} The number of displayable lines.\n    ###\n    calculateMaxLines: (lines) ->\n        height = 0\n        result = 0\n\n        for line in lines\n                height += line.height + @lineSpacing\n                if @currentY+height > (@object.dstRect.height)\n                    break\n                result++\n\n        return Math.min(lines.length, result || 1)\n\n    ###*\n    * Displays the character or processes the next control-token.\n    *\n    * @method drawNext\n    ###\n    drawNext: ->\n        token = @processToken()\n\n        if token?.value.length > 0\n            @char = @token.value.charAt(@charIndex)\n\n            size = @font.measureTextPlain(@char)\n            lineSpacing = @lineSpacing\n\n            if @currentLine != @line\n                @currentLine = @line\n               # @currentY += @currentLineHeight + lineSpacing * Graphics.scale\n                @currentLineHeight = 0\n\n            @currentSprite.y = @object.origin.y + @object.dstRect.y + @currentY\n            @currentSprite.visible = yes\n            @drawLineContent(@lines[@line], @currentSprite.bitmap, @charIndex+1)\n            @currentSprite.srcRect.width = @currentSprite.bitmap.width #Math.min(@currentSprite.srcRect.width + size.width, @currentSprite.bitmap.width)\n\n            @currentLineHeight = @lines[@line].height\n            @currentX = Math.min(@lines[@line].width, @currentX + size.width)\n\n    ###*\n    * Processes the next character/token of the message.\n    * @method nextChar\n    * @private\n    ###\n    nextChar: ->\n        loop\n            @charIndex++\n            @lineAnimationCount = @speed\n\n            if @token.code? or @charIndex >= @token.value.length\n                @token.onEnd?()\n                @tokenIndex++\n                if @tokenIndex >= @lines[@line].content.length\n                    @tokenIndex = 0\n                    @line++\n                    @currentSprite.srcRect.width = @currentSprite.bitmap.width\n                    @currentSprite = @sprites[@line]\n                    if @currentSprite?\n                        @currentSprite.x = @object.origin.x + @object.dstRect.x\n                    if @line < @maxLines\n                        @currentY += (@currentLineHeight || @font.lineHeight) + @lineSpacing * Graphics.scale\n                        @charIndex = 0\n                        @currentX = 0\n                        @token = @lines[@line].content[@tokenIndex] || new gs.RendererToken(null, \"\")\n                else\n                    @charIndex = 0\n                    @token = @lines[@line].content[@tokenIndex] || new gs.RendererToken(null, \"\")\n                @token.onStart?()\n\n\n            if !@token or @token.value != \"\\n\" or !@lines[@line]\n                break\n    ###*\n    * Finishes the message. Depending on the message configuration, the\n    * message text-renderer will now wait for a user-action or a certain amount\n    * of time.\n    *\n    * @method finish\n    ###\n    finish: ->\n        if @waitAtEnd\n            @isWaiting = yes\n            @object.events?.emit(\"messageWaiting\", this)\n        else if @waitAtEndTime > 0\n            @waitCounter = @waitAtEndTime\n            @isWaiting = no\n\n            @object.events?.emit(\"messageWaiting\", this)\n        else\n            @object.events?.emit(\"messageWaiting\", this)\n            @continue()\n\n    ###*\n    * Returns the position of the caret in pixels. The caret is like an invisible\n    * cursor pointing to the x/y coordinates of the last rendered character of\n    * the message. That position can be used to display a waiting- or processing-animation for example.\n    *\n    * @method updateCaretPosition\n    ###\n    updateCaretPosition: ->\n        @caretPosition.x = @currentX + @padding\n        @caretPosition.y = @currentY + @currentLineHeight/2\n\n    ###*\n    * Updates the line writing.\n    *\n    * @method updateLineWriting\n    * @private\n    ###\n    updateLineWriting: ->\n        if @isRunning and !@isWaiting and !@waitForKey and @waitCounter <= 0\n            if @lineAnimationCount <= 0\n                loop\n                    if @line < @maxLines\n                        @nextChar()\n\n                    if @line >= @maxLines\n                        @finish()\n                    else\n                        @drawNext()\n\n                    break unless (@token.code or @lineAnimationCount <= 0 or @drawImmediately) and !@waitForKey and @waitCounter <= 0 and @isRunning and @line < @maxLines\n\n            if GameManager.tempSettings.skip\n                @lineAnimationCount = 0\n            else\n                @lineAnimationCount--\n\n    ###*\n    * Updates wait-for-key state. If skipping is enabled, the text renderer will\n    * not wait for key press.\n    *\n    * @method updateWaitForKey\n    * @private\n    ###\n    updateWaitForKey: ->\n        if @waitForKey\n            @isWaiting = !GameManager.tempSettings.skip\n            @waitForKey = @isWaiting\n\n    ###*\n    * Updates wait counter if the text renderer is waiting for a certain amount of time to pass. If skipping is enabled, the text renderer will\n    * not wait for the actual amount of time and sets the wait-counter to 1 frame instead.\n    *\n    * @method updateWaitForKey\n    * @private\n    ###\n    updateWaitCounter: ->\n        if @waitCounter > 0\n            if GameManager.tempSettings.skip\n                @waitCounter = 1\n            @isWaiting = yes\n            @waitCounter--\n            if @waitCounter <= 0\n                @isWaiting = no\n                @continue() if @line >= @maxLines\n\n    ###*\n    * Creates a token-object for a specified text-code.\n    *\n    * @method createToken\n    * @param {string} code - The code/type of the text-code.\n    * @param {string} value - The value of the text-code.\n    * @return {Object} The token-object.\n    ###\n    createToken: (code, value) ->\n        tokenObject = null\n\n        switch code\n            when \"CE\"\n                data = value.split(\"/\")\n                value = data.shift()\n                value = if isNaN(value) then value else parseInt(value)\n                for i in [0...data]\n                    if data[i].startsWith('\"') and data[i].endsWith('\"')\n                        data[i] = data[i].substring(1, data[i].length-1)\n                    else\n                        data[i] = if isNaN(data[i]) then data[i] else parseFloat(data[i])\n                tokenObject = { code: code, value: value, values: data  }\n            else\n                tokenObject = super(code, value)\n\n\n        return tokenObject\n    ###*\n    * <p>Measures a control-token. If a token produces a visual result like displaying an icon then it must return the size taken by\n    * the visual result. If the token has no visual result, <b>null</b> must be returned. This method is called for every token when the message is initialized.</p>\n    *\n    * <p>This method is not called while the message is running. For that case, see <i>processControlToken</i> method which is called\n    * for every token while the message is running.</p>\n    *\n    * @param {Object} token - A control-token.\n    * @return {gs.Size} The size of the area taken by the visual result of the token or <b>null</b> if the token has no visual result.\n    * @method analyzeControlToken\n    * @protected\n    ###\n    measureControlToken: (token) -> return super(token)\n\n    ###*\n    * <p>Draws the visual result of a token, like an icon for example, to the specified bitmap. This method is called for every token when the message is initialized and the sprites for each\n    * text-line are created.</p>\n    *\n    * <p>This method is not called while the message is running. For that case, see <i>processControlToken</i> method which is called\n    * for every token while the message is running.</p>\n    *\n    * @param {Object} token - A control-token.\n    * @param {gs.Bitmap} bitmap - The bitmap used for the current text-line. Can be used to draw something on it like an icon, etc.\n    * @param {number} offset - An x-offset for the draw-routine.\n    * @param {number} length - Determines how many characters of the token should be drawn. Can be ignored for tokens\n    * not drawing any characters.\n    * @method drawControlToken\n    * @protected\n    ###\n    drawControlToken: (token, bitmap, offset, length) ->\n        switch token.code\n            when \"RT\" # Ruby Text\n                super(token, bitmap, offset, length)\n            when \"SLK\" # Stylable Link\n                if !token.customData.offsetX?\n                    token.customData.offsetX = offset\n                if @customData.linkData\n                    linkData = @customData.linkData[@line]\n                    if linkData then for data in linkData\n                        @sprites[@line].bitmap.clearRect(data.cx,\n                                                        0,\n                                                        data.width,\n                                                        data.height)\n\n\n    ###*\n    * Processes a control-token. A control-token is a token which influences\n    * the text-rendering like changing the fonts color, size or style. Changes\n    * will be automatically applied to the game object's font.\n    *\n    * For message text-renderer, a few additional control-tokens like\n    * speed-change, waiting, etc. needs to be processed here.\n    *\n    * This method is called for each token while the message is initialized and\n    * also while the message is running. See <i>formattingOnly</i> parameter.\n    *\n    * @param {Object} token - A control-token.\n    * @param {boolean} formattingOnly - If <b>true</b> the message is initializing right now and only\n    * format-tokens should be processed which is necessary for the message to calculated sizes correctly.\n    * @return {Object} A new token which is processed next or <b>null</b>.\n    * @method processControlToken\n    * @protected\n    ###\n    processControlToken: (token, formattingOnly) ->\n        return super(token) if formattingOnly\n        result = null\n\n        switch token.code\n            when \"CR\" # Change Current Character\n                character = RecordManager.charactersArray.first (c) -> (c.name.defaultText ? c.name) == token.value\n                if character\n                    SceneManager.scene.currentCharacter = character\n            when \"CE\" # Call Common Event\n                params = { \"values\": token.values }\n                @object.events?.emit(\"callCommonEvent\", @object, { commonEventId: token.value, params: params, finish: no, waiting: yes })\n            when \"X\" # Script\n                token.value?(@object)\n            when \"A\" # Play Animation\n                animation = RecordManager.animationsArray.first (a) -> a.name == token.value\n                if !animation\n                    animation = RecordManager.animations[token.value]\n                if animation?.graphic.name?\n                    bitmap = ResourceManager.getBitmap(\"Graphics/Pictures/#{animation.graphic.name}\")\n                    object = new gs.Object_Animation(animation)\n\n                    @addCustomObject(object)\n                    @currentX += Math.round(bitmap.width / animation.framesX)\n                    @currentSprite.srcRect.width += Math.round(bitmap.width / animation.framesX)\n\n            when \"RT\" # Ruby Text\n                if token.rtSize.width > token.rbSize.width\n                    @currentX += token.rtSize.width\n                    @font.set(@getRubyTextFont(token))\n                else\n                    @currentX += token.rbSize.width\n\n            when \"LK\" # Link\n                if token.value == 'E' # End Link\n                    object = new ui.Object_Hotspot()\n                    object.enabled = yes\n                    object.setup()\n\n                    @addCustomObject(object)\n\n                    object.dstRect.x = @object.dstRect.x + @object.origin.x + @customData.linkData.cx\n                    object.dstRect.y = @object.dstRect.y + @object.origin.y + @customData.linkData.cy\n                    object.dstRect.width = @currentX - @customData.linkData.cx\n                    object.dstRect.height = @currentLineHeight\n\n                    object.events.on(\"click\", gs.CallBack(\"onLinkClick\", this), linkData: @customData.linkData, this)\n                else # Begin Link\n                    @customData.linkData = { cx: @currentX, cy: @currentY, commonEventId: token.value, tokenIndex: @tokenIndex }\n            when \"SLK\" # Styleable Link\n                if token.value == 'E' # End Link\n                    linkData = @customData.linkData[@line].last()\n                    line = @lines[@line].content\n                    linkStart = @findToken(@tokenIndex-1, \"SLK\", -1, line)\n                    textTokens = @findTokensBetween(linkData.tokenIndex, @tokenIndex, null, line)\n\n                    linkData.cx = linkStart.customData.offsetX\n                    linkData.width = @currentX - linkData.cx + @padding\n                    linkData.height = @currentSprite.bitmap.height\n\n                    object = new ui.Object_Text()\n                    object.text = textTokens.select((x) => x.value).join(\"\")\n                    #object.sizeToFit = yes\n                    object.formatting = no\n                    object.wordWrap = no\n                    object.ui = new ui.Component_UIBehavior()\n                    object.enabled = yes\n                    object.addComponent(object.ui)\n                    object.addComponent(new gs.Component_HotspotBehavior())\n                    object.behavior.padding.left = 0\n                    object.behavior.padding.right = 0\n                    object.dstRect.width = linkData.width\n                    object.dstRect.height = linkData.height\n\n                    if linkData.styleIndex == -1\n                        ui.UIManager.addControlStyles(object, [\"hyperlink\"])\n                    else\n                        ui.UIManager.addControlStyles(object, [\"hyperlink-\"+linkData.styleIndex])\n\n                    object.setup()\n\n                    @addCustomObject(object)\n\n                    object.dstRect.x = @currentSprite.x + linkData.cx\n                    object.dstRect.y = @object.dstRect.y + @object.origin.y + linkData.cy\n\n                    object.events.on(\"click\", gs.CallBack(\"onLinkClick\", this), linkData: linkData, this)\n                else # Begin Link\n                    if !@customData.linkData\n                        @customData.linkData = []\n                    if !@customData.linkData[@line]\n                        @customData.linkData[@line] = []\n                    if token.value?.contains(\",\")\n                        values = token.value.split(\",\")\n                        @customData.linkData[@line].push({ cx: @currentX, cy: @currentY, commonEventId: values[0], styleIndex: parseInt(values[1]), tokenIndex: @tokenIndex })\n                    else\n                        @customData.linkData[@line].push({ cx: @currentY, cy: @currentY, commonEventId: token.value, tokenIndex: @tokenIndex, styleIndex: -1 })\n\n            when \"E\" # Change Expression\n                expression = RecordManager.characterExpressionsArray.first (c) -> (c.name.defaultText ? c.name) == token.value\n                if !expression\n                    expression = RecordManager.characterExpressions[token.value]\n\n                character = SceneManager.scene.currentCharacter\n                if expression? and character?.index?\n                    duration = GameManager.defaults.character.expressionDuration\n                    easing = gs.Easings.fromObject(GameManager.defaults.character.changeEasing)\n                    animation = GameManager.defaults.character.changeAnimation\n                    object = SceneManager.scene.characters.first (c) -> c.rid == character.index\n                    object?.behavior.changeExpression(expression, animation, easing, duration)\n\n            when \"SP\" # Play Sound\n                sound = RecordManager.system.sounds[token.value-1]\n                AudioManager.playSound(sound)\n            when \"S\" # Change Speed\n                GameManager.settings.messageSpeed = token.value\n            when \"W\" # Wait\n                @drawImmediately = no\n                if !GameManager.tempSettings.skip\n                    if token.value == \"A\"\n                        @waitForKey = yes\n                    else\n                        @waitCounter = Math.round(token.value / 1000 * Graphics.frameRate)\n            when \"WE\" # Wait at End\n                @waitAtEnd = token.value == \"Y\"\n            when \"DI\" # Draw Immedialty\n                @drawImmediately = token.value == 1 or token.value == \"Y\" # Draw immediately\n            else\n                result = super(token)\n\n        return result\n    ###*\n    * Clears/Resets the text-renderer.\n    *\n    * @method clear\n    ###\n    clear: ->\n        @charIndex = 0\n        @currentX = 0\n        @currentY = 0\n        @line = 0\n        @lines = []\n        @clearCustomObjects()\n        @object.bitmap?.clear()\n\n        for sprite in @allSprites\n            sprite.dispose()\n            sprite.bitmap?.dispose()\n        @allSprites = []\n        return null\n\n    ###*\n    * Clears/Disposes all sprites used to display the text-lines/parts.\n    *\n    * @method clearAllSprites\n    ###\n    clearAllSprites: ->\n        for sprite in @allSprites\n            sprite.dispose()\n            sprite.bitmap?.dispose()\n\n        return null\n\n    ###*\n    * Clears/Disposes the sprites used to display the text-lines/parts of the current/last message.\n    *\n    * @method clearSprites\n    ###\n    clearSprites: ->\n        for sprite in @sprites\n            sprite.dispose()\n            sprite.bitmap?.dispose()\n\n        return null\n\n\n    ###*\n    * Removes a game object from the message.\n    *\n    * @method removeCustomObject\n    * @param object {gs.Object_Base} The game object to remove.\n    ###\n    removeCustomObject: (object) ->\n        SceneManager.scene.removeObject(object)\n        object.dispose()\n        @customObjects.remove(object)\n\n    ###*\n    * Adds a game object to the message which is alive until the message is\n    * erased. Can be used to display animationed-icons, etc. in a message.\n    *\n    * @method addCustomObject\n    * @param object {gs.Object_Base} The game object to add.\n    ###\n    addCustomObject: (object) ->\n        object.dstRect.x = @object.dstRect.x + @object.origin.x + @currentX\n        object.dstRect.y = @object.dstRect.y + @object.origin.y + @currentY\n        object.zIndex = @object.zIndex + 1\n        object.update()\n\n        SceneManager.scene.addObject(object)\n        @customObjects.push(object)\n\n    ###*\n    * Clears the list of custom game objects. All game objects are disposed and removed\n    * from the scene.\n    *\n    * @method clearCustomObjects\n    * @param object {Object} The game object to add.\n    ###\n    clearCustomObjects: ->\n        for object in @customObjects\n            object.dispose()\n            SceneManager.scene.removeObject(object)\n\n        @customObjects = []\n\n    ###*\n    * Creates the bitmap for a specified line-object.\n    *\n    * @method createBitmap\n    * @private\n    * @param {Object} line - A line-object.\n    * @return {Bitmap} A newly created bitmap containing the line-text.\n    ###\n    createBitmap: (line) ->\n        @font = @object.font\n        bitmap = new Bitmap(@object.dstRect.width, Math.max(@minLineHeight, line.height))\n        bitmap.font = @font\n\n        return bitmap\n\n    ###*\n    * Draws the line's content on the specified bitmap.\n    *\n    * @method drawLineContent\n    * @protected\n    * @param {Object} line - A line-object which should be drawn on the bitmap.\n    * @param {gs.Bitmap} bitmap - The bitmap to draw the line's content on.\n    * @param {number} length - Determines how many characters of the specified line should be drawn. You can\n    * specify -1 to draw all characters.\n    ###\n    drawLineContent: (line, bitmap, length) ->\n        bitmap.clear()\n        currentX = @padding\n        drawAll = length == -1\n\n        for token, i in line.content\n            break if i > @tokenIndex and !drawAll\n            if token.code?\n                size = @measureControlToken(token, bitmap)\n                @drawControlToken(token, bitmap, currentX)\n                if size then currentX += size.width\n                @processControlToken(token, yes, line)\n            else if token.value.length > 0\n                token.applyFormat(@font)\n                value = token.value\n                if !drawAll and @tokenIndex == i and value.length > length\n                    value = value.substring(0, length)\n                if value != \"\\n\"\n                    size = @font.measureTextPlain(value)\n                    bitmap.drawText(currentX, line.height - (size.height - @font.descent) - line.descent, size.width, bitmap.height, value, 0, 0)\n                    currentX += size.width\n\n        line.contentWidth = currentX + @font.measureTextPlain(\" \").width\n\n    ###*\n    * Creates the sprite for a specified line-object.\n    *\n    * @method createSprite\n    * @private\n    * @param {Object} line - A line-object.\n    * @return {Sprite} A newly created sprite object containing the line-text as bitmap.\n    ###\n    createSprite: (line) ->\n        bitmap = @createBitmap(line)\n\n        @currentX = 0\n        @waitCounter = 0\n        @waitForKey = no\n\n        sprite = new Sprite(Graphics.viewport)\n        sprite.bitmap = bitmap\n        sprite.visible = yes\n        sprite.z = @object.zIndex + 1\n\n        sprite.srcRect = new Rect(0, 0, 0, bitmap.height)\n\n        return sprite\n\n    ###*\n    * Creates the sprites for a specified array of line-objects.\n    *\n    * @method createSprites\n    * @private\n    * @see gs.Component_MessageTextRenderer.createSprite.\n    * @param {Array} lines - An array of line-objects.\n    * @return {Array} An array of sprites.\n    ###\n    createSprites: (lines) ->\n        @fontSize = @object.font.size\n        result = []\n        for line, i in lines\n            sprite = @createSprite(line)\n            result.push(sprite)\n        return result\n\n    ###*\n    * Starts a new line.\n    *\n    * @method newLine\n    ###\n    newLine: ->\n        @currentX = 0\n        @currentY += @currentLineHeight + @lineSpacing\n\n    ###*\n    * Displays a formatted text immediately without any delays or animations. The\n    * Component_TextRenderer.drawFormattedText method from the base-class cannot\n    * be used here because it would render to the game object's bitmap object while\n    * this method is rendering to the sprites.\n    *\n    * @method drawFormattedTextImmediately\n    * @param {number} x - The x-coordinate of the text's position.\n    * @param {number} y - The y-coordinate of the text's position.\n    * @param {number} width - Deprecated. Can be null.\n    * @param {number} height - Deprecated. Can be null.\n    * @param {string} text - The text to draw.\n    * @param {boolean} wordWrap - If wordWrap is set to true, line-breaks are automatically created.\n    ###\n    drawFormattedTextImmediately: (x, y, width, height, text, wordWrap) ->\n        @drawFormattedText(x, y, width, height, text, wordWrap)\n\n        loop\n            @nextChar()\n\n            if @line >= @maxLines\n                @isRunning = no\n            else\n                @drawNext()\n\n            break unless @isRunning\n\n        @currentY += @currentLineHeight + @lineSpacing\n\n        return null\n\n\n    ###*\n    * Starts the rendering-process for the message.\n    *\n    * @method drawFormattedText\n    * @param {number} x - The x-coordinate of the text's position.\n    * @param {number} y - The y-coordinate of the text's position.\n    * @param {number} width - Deprecated. Can be null.\n    * @param {number} height - Deprecated. Can be null.\n    * @param {string} text - The text to draw.\n    * @param {boolean} wordWrap - If wordWrap is set to true, line-breaks are automatically created.\n    ###\n    drawFormattedText: (x, y, width, height, text, wordWrap) ->\n        text = text || \" \" # Use a space character if no text is specified.\n        @font.set(@object.font)\n        @speed = 11 - Math.round(GameManager.settings.messageSpeed * 2.5)\n        @isRunning = yes\n        @drawImmediately = no\n        @lineAnimationCount = @speed\n        @currentLineHeight = 0\n        @isWaiting = no\n        @waitForKey = no\n        @charIndex = 0\n        @token = null\n        @tokenIndex = 0\n        @message = text\n        @line = 0\n        @currentLine = @line\n        currentX = @currentX #Math.max(@currentX, @padding)\n        @lines = @calculateLines(lcsm(@message), wordWrap, @currentX)\n        @sprites = @createSprites(@lines)\n        @allSprites = @allSprites.concat(@sprites)\n        @currentX = currentX\n        @currentSprite = @sprites[@line]\n        @currentSprite.x = @currentX + @object.origin.x + @object.dstRect.x\n        @maxLines = @calculateMaxLines(@lines)\n        @token = @lines[@line]?.content[@tokenIndex] || new gs.RendererToken(null, \"\")\n\n\n        @start()\n\n    ###*\n    * Starts the message-rendering process.\n    *\n    * @method start\n    * @protected\n    ###\n    start: ->\n        if GameManager.tempSettings.skip and GameManager.tempSettings.skipTime == 0\n            @instantSkip()\n        else if @maxLines == 0\n            # If first line is empty then it doesn't fit into current line, so finish.\n            if @lines[0]?.content == \"\"\n                @finish()\n            else\n                @maxLines = 1\n                @drawNext()\n        else\n            @drawNext()\n\n    ###*\n    * Skips the current message and finishes the message-processing immediately. The message\n    * tokens are processed but not rendered.\n    *\n    * @method instantSkip\n    ###\n    instantSkip: ->\n        loop\n            if @line < @maxLines\n                @nextChar()\n\n            if @line >= @maxLines\n                break\n            else\n                @processToken()\n\n            break unless @isRunning and @line < @maxLines\n\n        @object.events?.emit(\"messageWaiting\", this)\n        @continue()\n\n    ###*\n    * Processes the current token.\n    *\n    * @method processToken\n    ###\n    processToken: ->\n        token = null\n\n        if @token.code?\n            token = @processControlToken(@token, no)\n            if token?\n                @token = token\n                @token.onStart?()\n        else\n            token = @token\n\n        return token\n\n\n\ngs.Component_MessageTextRenderer = Component_MessageTextRenderer",
        "compiledContent": "// Generated by CoffeeScript 1.12.7\n(function() {\n  var Component_MessageTextRenderer,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  Component_MessageTextRenderer = (function(superClass) {\n    extend(Component_MessageTextRenderer, superClass);\n\n    Component_MessageTextRenderer.objectCodecBlackList = [\"onLinkClick\", \"onBatchDisappear\"];\n\n\n    /**\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    *\n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n     */\n\n    Component_MessageTextRenderer.prototype.onDataBundleRestore = function(data, context) {\n      var bitmap, customObject, j, l, lastLine, len, len1, len2, line, lineWidth, m, message, n, ref, ref1, ref2;\n      this.setupEventHandlers();\n      l = 0;\n      lastLine = null;\n      ref = this.object.messages;\n      for (j = 0, len = ref.length; j < len; j++) {\n        message = ref[j];\n        if (this.object.settings.useCharacterColor) {\n          this.object.font.color = new gs.Color(message.character.textColor);\n        }\n        lineWidth = this.isRunningInMultiPartMode() ? (lastLine != null ? lastLine.width : void 0) || 0 : 0;\n        this.lines = this.calculateLines(lcsm(message.text), true, lineWidth);\n        ref1 = this.lines;\n        for (m = 0, len1 = ref1.length; m < len1; m++) {\n          line = ref1[m];\n          bitmap = this.createBitmap(line);\n          if (line === this.line) {\n            this.drawLineContent(line, bitmap, this.charIndex + 1);\n          } else {\n            this.drawLineContent(line, bitmap, -1);\n          }\n          this.allSprites[l].bitmap = bitmap;\n          lastLine = line;\n          l++;\n        }\n      }\n      ref2 = this.customObjects;\n      for (n = 0, len2 = ref2.length; n < len2; n++) {\n        customObject = ref2[n];\n        SceneManager.scene.addObject(customObject);\n      }\n      return null;\n    };\n\n\n    /**\n    *  A text-renderer component to render an animated and interactive message text using\n    *  dimensions of the game object's destination-rectangle. The message is displayed\n    *  using a sprite for each line instead of drawing to the game object's bitmap object.\n    *\n    *  @module gs\n    *  @class Component_MessageTextRenderer\n    *  @extends gs.Component_TextRenderer\n    *  @memberof gs\n    *  @constructor\n     */\n\n    function Component_MessageTextRenderer() {\n      Component_MessageTextRenderer.__super__.constructor.apply(this, arguments);\n\n      /**\n      * An array containing all sprites of the current message.\n      * @property sprites\n      * @type gs.Sprite[]\n      * @protected\n       */\n      this.sprites = [];\n\n      /**\n      * An array containing all sprites of all messages. In NVL mode\n      * a page can contain multiple messages.\n      * @property allSprites\n      * @type gs.Sprite[]\n      * @protected\n       */\n      this.allSprites = [];\n\n      /**\n      * An array containing all line-objects of the current message.\n      * @property lines\n      * @type gs.TextRendererLine[]\n      * @readOnly\n       */\n      this.lines = null;\n\n      /**\n      * The line currently rendered.\n      * @property line\n      * @type number\n      * @readOnly\n       */\n      this.line = 0;\n\n      /**\n      * The left and right padding per line.\n      * @property padding\n      * @type number\n       */\n      this.padding = 6;\n\n      /**\n      * The minimum height of the line currently rendered. If 0, the measured\n      * height of the line will be used.\n      * @property minLineHeight\n      * @type number\n       */\n      this.minLineHeight = 0;\n\n      /**\n      * The spacing between text lines in pixels.\n      * @property lineSpacing\n      * @type number\n       */\n      this.lineSpacing = 2;\n\n      /**\n      * The line currently rendered.\n      * @property currentLine\n      * @type number\n      * @protected\n       */\n      this.currentLine = 0;\n\n      /**\n      * The height of the line currently rendered.\n      * @property currentLineHeight\n      * @type number\n      * @protected\n       */\n      this.currentLineHeight = 0;\n\n      /**\n      * Index of the current character to draw.\n      * @property charIndex\n      * @type number\n      * @readOnly\n       */\n      this.charIndex = 0;\n\n      /**\n      * Position of the message caret. The caret is like an invisible\n      * cursor pointing to the x/y coordinates of the last rendered character of\n      * the message. That position can be used to display a waiting- or processing-animation for example.\n      * @property caretPosition\n      * @type gs.Point\n      * @readOnly\n       */\n      this.caretPosition = new gs.Point();\n\n      /**\n      * Indicates that the a message is currently in progress.\n      * @property isRunning\n      * @type boolean\n      * @readOnly\n       */\n      this.isRunning = false;\n\n      /**\n      * The current x-coordinate of the caret/cursor.\n      * @property currentX\n      * @type number\n      * @readOnly\n       */\n      this.currentX = 0;\n\n      /**\n      * The current y-coordinate of the caret/cursor.\n      * @property currentY\n      * @type number\n      * @readOnly\n       */\n      this.currentY = 0;\n\n      /**\n      * The current sprites used to display the current text-line/part.\n      * @property currentSprite\n      * @type gs.Sprite\n      * @readOnly\n       */\n      this.currentSprite = null;\n\n      /**\n      * Indicates if the message-renderer is currently waiting like for a user-action.\n      * @property isWaiting\n      * @type boolean\n      * @readOnly\n       */\n      this.isWaiting = false;\n\n      /**\n      * Indicates if the message-renderer is currently waiting for a key-press or mouse/touch action.\n      * @property waitForKey\n      * @type boolean\n      * @readOnly\n       */\n      this.waitForKey = false;\n\n      /**\n      * Number of frames the message-renderer should wait before continue.\n      * @property waitCounter\n      * @type number\n       */\n      this.waitCounter = 0;\n\n      /**\n      * Speed of the message-drawing. The smaller the value, the faster the message is displayed.\n      * @property speed\n      * @type number\n       */\n      this.speed = 1;\n\n      /**\n      * Indicates if the message should be rendered immedialtely without any animation or delay.\n      * @property drawImmediately\n      * @type boolean\n       */\n      this.drawImmediately = false;\n\n      /**\n      * Indicates if the message should wait for a user-action or a certain amount of time\n      * before finishing.\n      * @property waitAtEnd\n      * @type boolean\n       */\n      this.waitAtEnd = true;\n\n      /**\n      * The number of frames to wait before finishing a message.\n      * before finishing.\n      * @property waitAtEndTime\n      * @type number\n       */\n      this.waitAtEndTime = 0;\n\n      /**\n      * Indicates if auto word-wrap should be used. Default is <b>true</b>\n      * @property wordWrap\n      * @type boolean\n       */\n      this.wordWrap = true;\n\n      /**\n      * Custom game objects which are alive until the current message is erased. Can be used to display\n      * animated icons, etc.\n      * @property customObjects\n      * @type gs.Object_Base[]\n       */\n      this.customObjects = [];\n\n      /**\n      * A hashtable/dictionary object to store custom-data useful like for token-processing. The data must be\n      * serializable.\n      * @property customObjects\n      * @type Object\n       */\n      this.customData = {};\n\n      /**\n      * A callback function called if the player clicks on a non-stylable link (LK text-code) to trigger\n      * the specified common event.\n      * @property onLinkClick\n      * @type Function\n       */\n      this.onLinkClick = function(e) {\n        var event, eventId;\n        eventId = e.data.linkData.commonEventId;\n        event = RecordManager.commonEvents[eventId];\n        if (!event) {\n          event = RecordManager.commonEvents.first((function(_this) {\n            return function(x) {\n              return x.name === eventId;\n            };\n          })(this));\n          if (event) {\n            eventId = event.index;\n          }\n        }\n        if (!event) {\n          return SceneManager.scene.interpreter.jumpToLabel(eventId);\n        } else {\n          return SceneManager.scene.interpreter.callCommonEvent(eventId, null, true);\n        }\n      };\n\n      /**\n      * A callback function called if a batched messsage has been faded out. It triggers the execution of\n      * the next message.\n      * @property onBatchDisappear\n      * @type Function\n       */\n      this.onBatchDisappear = (function(_this) {\n        return function(e) {\n          _this.drawImmediately = false;\n          _this.isWaiting = false;\n          _this.object.opacity = 255;\n          return _this.executeBatch();\n        };\n      })(this);\n    }\n\n\n    /**\n    * Serializes the message text-renderer into a data-bundle.\n    * @method toDataBundle\n    * @return {Object} A data-bundle.\n     */\n\n    Component_MessageTextRenderer.prototype.toDataBundle = function() {\n      var bundle, ignore, k;\n      ignore = [\"object\", \"font\", \"sprites\", \"allSprites\", \"currentSprite\", \"currentX\"];\n      bundle = {\n        currentSpriteIndex: this.sprites.indexOf(this.currentSprite)\n      };\n      for (k in this) {\n        if (ignore.indexOf(k) === -1) {\n          bundle[k] = this[k];\n        }\n      }\n      return bundle;\n    };\n\n\n    /**\n    * Disposes the message text-renderer and all sprites used to display\n    * the message.\n    * @method dispose\n     */\n\n    Component_MessageTextRenderer.prototype.dispose = function() {\n      var j, len, ref, ref1, results, sprite;\n      Component_MessageTextRenderer.__super__.dispose.apply(this, arguments);\n      this.disposeEventHandlers();\n      ref = this.allSprites;\n      results = [];\n      for (j = 0, len = ref.length; j < len; j++) {\n        sprite = ref[j];\n        if ((ref1 = sprite.bitmap) != null) {\n          ref1.dispose();\n        }\n        results.push(sprite.dispose());\n      }\n      return results;\n    };\n\n\n    /**\n    * Removes all attached event handlers\n    * the message.\n    * @method disposeEventHandlers\n     */\n\n    Component_MessageTextRenderer.prototype.disposeEventHandlers = function() {\n      gs.GlobalEventManager.offByOwner(\"mouseUp\", this.object);\n      return gs.GlobalEventManager.offByOwner(\"keyUp\", this.object);\n    };\n\n\n    /**\n    * Adds event-handlers for mouse/touch events\n    *\n    * @method setupEventHandlers\n     */\n\n    Component_MessageTextRenderer.prototype.setupEventHandlers = function() {\n      gs.GlobalEventManager.offByOwner(\"mouseUp\", this.object);\n      gs.GlobalEventManager.offByOwner(\"keyUp\", this.object);\n      gs.GlobalEventManager.on(\"mouseUp\", ((function(_this) {\n        return function(e) {\n          if (_this.object.findComponentByName(\"animation\") || (GameManager.settings.autoMessage.enabled && !GameManager.settings.autoMessage.stopOnAction)) {\n            return;\n          }\n          if (_this.isWaiting && !(_this.waitCounter > 0 || _this.waitForKey)) {\n            e.breakChain = true;\n            _this[\"continue\"]();\n          } else {\n            e.breakChain = _this.isRunning;\n            _this.drawImmediately = !_this.waitForKey;\n            _this.waitCounter = 0;\n            _this.waitForKey = false;\n            _this.isWaiting = false;\n          }\n          if (_this.waitForKey) {\n            if (Input.Mouse.buttons[Input.Mouse.LEFT] === 2) {\n              e.breakChain = true;\n              Input.clear();\n              _this.waitForKey = false;\n              return _this.isWaiting = false;\n            }\n          }\n        };\n      })(this)), null, this.object);\n      return gs.GlobalEventManager.on(\"keyUp\", ((function(_this) {\n        return function(e) {\n          if (Input.keys[Input.C] && (!_this.isWaiting || (_this.waitCounter > 0 || _this.waitForKey))) {\n            _this.drawImmediately = !_this.waitForKey;\n            _this.waitCounter = 0;\n            _this.waitForKey = false;\n            _this.isWaiting = false;\n          }\n          if (_this.isWaiting && !_this.waitForKey && !_this.waitCounter && Input.keys[Input.C]) {\n            _this[\"continue\"]();\n          }\n          if (_this.waitForKey) {\n            if (Input.keys[Input.C]) {\n              Input.clear();\n              _this.waitForKey = false;\n              return _this.isWaiting = false;\n            }\n          }\n        };\n      })(this)), null, this.object);\n    };\n\n\n    /**\n    * Sets up the renderer. Registers necessary event handlers.\n    * @method setup\n     */\n\n    Component_MessageTextRenderer.prototype.setup = function() {\n      return this.setupEventHandlers();\n    };\n\n\n    /**\n    * Restores the message text-renderer's state from a data-bundle.\n    * @method restore\n    * @param {Object} bundle - A data-bundle containing message text-renderer state.\n     */\n\n    Component_MessageTextRenderer.prototype.restore = function(bundle) {\n      var k;\n      for (k in bundle) {\n        if (k === \"currentSpriteIndex\") {\n          this.currentSprite = this.sprites[bundle.currentSpriteIndex];\n        } else {\n          this[k] = bundle[k];\n        }\n      }\n      if (this.sprites.length > 0) {\n        this.currentY = this.sprites.last().y - this.object.origin.y - this.object.dstRect.y;\n        this.line = this.maxLines;\n        this.isWaiting = this.isWaiting || this.isRunning;\n      }\n      return null;\n    };\n\n\n    /**\n    * Continues message-processing if currently waiting.\n    * @method continue\n     */\n\n    Component_MessageTextRenderer.prototype[\"continue\"] = function() {\n      var duration, fading, ref, ref1;\n      this.isWaiting = false;\n      if (this.line >= this.lines.length) {\n        this.isRunning = false;\n        return (ref = this.object.events) != null ? ref.emit(\"messageFinish\", this) : void 0;\n      } else {\n        if ((ref1 = this.object.events) != null) {\n          ref1.emit(\"messageBatch\", this);\n        }\n        fading = GameManager.tempSettings.messageFading;\n        duration = GameManager.tempSettings.skip ? 0 : fading.duration;\n        return this.object.animator.disappear(fading.animation, fading.easing, duration, gs.CallBack(\"onBatchDisappear\", this));\n      }\n    };\n\n\n    /**\n    * Updates the text-renderer.\n    * @method update\n     */\n\n    Component_MessageTextRenderer.prototype.update = function() {\n      var j, len, len1, m, object, ref, ref1, ref2, sprite;\n      ref = this.allSprites;\n      for (j = 0, len = ref.length; j < len; j++) {\n        sprite = ref[j];\n        sprite.opacity = this.object.opacity;\n        sprite.visible = this.object.visible;\n        sprite.ox = -this.object.offset.x;\n        sprite.oy = -this.object.offset.y;\n        sprite.mask.value = this.object.mask.value;\n        sprite.mask.vague = this.object.mask.vague;\n        sprite.mask.source = this.object.mask.source;\n        sprite.mask.type = this.object.mask.type;\n      }\n      ref1 = this.customObjects;\n      for (m = 0, len1 = ref1.length; m < len1; m++) {\n        object = ref1[m];\n        object.opacity = this.object.opacity;\n        object.visible = this.object.visible;\n      }\n      if (!this.isRunning && this.waitCounter > 0) {\n        this.waitCounter--;\n        if (this.waitCounter === 0) {\n          this[\"continue\"]();\n        }\n        return;\n      }\n      if (this.object.visible && ((ref2 = this.lines) != null ? ref2.length : void 0) > 0) {\n        this.updateLineWriting();\n        this.updateWaitForKey();\n        this.updateWaitCounter();\n        return this.updateCaretPosition();\n      }\n    };\n\n\n    /**\n    * Indicates if its a batched messages.\n    *\n    * @method isBatched\n    * @return If <b>true</b> it is a batched message. Otherwise <b>false</b>.\n     */\n\n    Component_MessageTextRenderer.prototype.isBatched = function() {\n      return this.lines.length > this.maxLines;\n    };\n\n\n    /**\n    * Indicates if the batch is still in progress and not done.\n    *\n    * @method isBatchInProgress\n    * @return If <b>true</b> the batched message is still not done. Otherwise <b>false</b>\n     */\n\n    Component_MessageTextRenderer.prototype.isBatchInProgress = function() {\n      return this.lines.length - this.line > this.maxLines;\n    };\n\n\n    /**\n    * Indicates if the renderer runs in multi-part message mode which\n    * means that a single message might be constructed from multiple drawFormattedText\n    * calls.\n    *\n    * @method isRunningInMultiPartMode\n    * @return If <b>true</b> the renderer runs in multi-part mode. Otherwise <b>false</b>.\n     */\n\n    Component_MessageTextRenderer.prototype.isRunningInMultiPartMode = function() {\n      return !this.object.settings.autoErase && this.object.settings.paragraphSpacing <= 0;\n    };\n\n\n    /**\n    * Starts displaying the next page of text if a message is too long to fit\n    * into one message box.\n    *\n    * @method executeBatch\n     */\n\n    Component_MessageTextRenderer.prototype.executeBatch = function() {\n      this.clearAllSprites();\n      this.lines = this.lines.slice(this.line);\n      this.line = 0;\n      this.currentX = 0;\n      this.currentY = 0;\n      this.currentLineHeight = 0;\n      this.tokenIndex = 0;\n      this.charIndex = 0;\n      this.token = this.lines[this.line].content[this.tokenIndex] || new gs.RendererToken(null, \"\");\n      this.maxLines = this.calculateMaxLines(this.lines);\n      this.lineAnimationCount = this.speed;\n      this.sprites = this.createSprites(this.lines);\n      this.allSprites = this.allSprites.concat(this.sprites);\n      this.currentSprite = this.sprites[this.line];\n      this.currentSprite.x = this.currentX + this.object.origin.x + this.object.dstRect.x;\n      return this.drawNext();\n    };\n\n\n    /**\n    * Calculates the duration(in frames) the message-renderer needs to display\n    * the message.\n    *\n    * @method calculateDuration\n    * @return {number} The duration in frames.\n     */\n\n    Component_MessageTextRenderer.prototype.calculateDuration = function() {\n      var duration, j, len, len1, line, m, ref, ref1, token;\n      duration = 0;\n      if (this.lines != null) {\n        ref = this.lines;\n        for (j = 0, len = ref.length; j < len; j++) {\n          line = ref[j];\n          ref1 = line.content;\n          for (m = 0, len1 = ref1.length; m < len1; m++) {\n            token = ref1[m];\n            if (token != null) {\n              duration += this.calculateDurationForToken(token);\n            }\n          }\n        }\n      }\n      return duration;\n    };\n\n\n    /**\n    * Calculates the duration(in frames) the message-renderer needs to display\n    * the specified line.\n    *\n    * @method calculateDurationForLine\n    * @param {gs.RendererTextLine} line The line to calculate the duration for.\n    * @return {number} The duration in frames.\n     */\n\n    Component_MessageTextRenderer.prototype.calculateDurationForLine = function(line) {\n      var duration, j, len, ref, token;\n      duration = 0;\n      if (line) {\n        ref = line.content;\n        for (j = 0, len = ref.length; j < len; j++) {\n          token = ref[j];\n          if (token != null) {\n            duration += this.calculateDurationForToken(token);\n          }\n        }\n      }\n      return duration;\n    };\n\n\n    /**\n    * Calculates the duration(in frames) the message-renderer needs to process\n    * the specified token.\n    *\n    * @method calculateDurationForToken\n    * @param {string|Object} token - The token.\n    * @return {number} The duration in frames.\n     */\n\n    Component_MessageTextRenderer.prototype.calculateDurationForToken = function(token) {\n      var duration;\n      duration = 0;\n      if (token.code != null) {\n        switch (token.code) {\n          case \"W\":\n            if (token.value !== \"A\") {\n              duration = token.value / 1000 * Graphics.frameRate;\n            }\n        }\n      } else {\n        duration = token.value.length * this.speed;\n      }\n      return duration;\n    };\n\n\n    /**\n    * Calculates the maximum of lines which can be displayed in one message.\n    *\n    * @method calculateMaxLines\n    * @param {Array} lines - An array of line-objects.\n    * @return {number} The number of displayable lines.\n     */\n\n    Component_MessageTextRenderer.prototype.calculateMaxLines = function(lines) {\n      var height, j, len, line, result;\n      height = 0;\n      result = 0;\n      for (j = 0, len = lines.length; j < len; j++) {\n        line = lines[j];\n        height += line.height + this.lineSpacing;\n        if (this.currentY + height > this.object.dstRect.height) {\n          break;\n        }\n        result++;\n      }\n      return Math.min(lines.length, result || 1);\n    };\n\n\n    /**\n    * Displays the character or processes the next control-token.\n    *\n    * @method drawNext\n     */\n\n    Component_MessageTextRenderer.prototype.drawNext = function() {\n      var lineSpacing, size, token;\n      token = this.processToken();\n      if ((token != null ? token.value.length : void 0) > 0) {\n        this.char = this.token.value.charAt(this.charIndex);\n        size = this.font.measureTextPlain(this.char);\n        lineSpacing = this.lineSpacing;\n        if (this.currentLine !== this.line) {\n          this.currentLine = this.line;\n          this.currentLineHeight = 0;\n        }\n        this.currentSprite.y = this.object.origin.y + this.object.dstRect.y + this.currentY;\n        this.currentSprite.visible = true;\n        this.drawLineContent(this.lines[this.line], this.currentSprite.bitmap, this.charIndex + 1);\n        this.currentSprite.srcRect.width = this.currentSprite.bitmap.width;\n        this.currentLineHeight = this.lines[this.line].height;\n        return this.currentX = Math.min(this.lines[this.line].width, this.currentX + size.width);\n      }\n    };\n\n\n    /**\n    * Processes the next character/token of the message.\n    * @method nextChar\n    * @private\n     */\n\n    Component_MessageTextRenderer.prototype.nextChar = function() {\n      var base, base1, results;\n      results = [];\n      while (true) {\n        this.charIndex++;\n        this.lineAnimationCount = this.speed;\n        if ((this.token.code != null) || this.charIndex >= this.token.value.length) {\n          if (typeof (base = this.token).onEnd === \"function\") {\n            base.onEnd();\n          }\n          this.tokenIndex++;\n          if (this.tokenIndex >= this.lines[this.line].content.length) {\n            this.tokenIndex = 0;\n            this.line++;\n            this.currentSprite.srcRect.width = this.currentSprite.bitmap.width;\n            this.currentSprite = this.sprites[this.line];\n            if (this.currentSprite != null) {\n              this.currentSprite.x = this.object.origin.x + this.object.dstRect.x;\n            }\n            if (this.line < this.maxLines) {\n              this.currentY += (this.currentLineHeight || this.font.lineHeight) + this.lineSpacing * Graphics.scale;\n              this.charIndex = 0;\n              this.currentX = 0;\n              this.token = this.lines[this.line].content[this.tokenIndex] || new gs.RendererToken(null, \"\");\n            }\n          } else {\n            this.charIndex = 0;\n            this.token = this.lines[this.line].content[this.tokenIndex] || new gs.RendererToken(null, \"\");\n          }\n          if (typeof (base1 = this.token).onStart === \"function\") {\n            base1.onStart();\n          }\n        }\n        if (!this.token || this.token.value !== \"\\n\" || !this.lines[this.line]) {\n          break;\n        } else {\n          results.push(void 0);\n        }\n      }\n      return results;\n    };\n\n\n    /**\n    * Finishes the message. Depending on the message configuration, the\n    * message text-renderer will now wait for a user-action or a certain amount\n    * of time.\n    *\n    * @method finish\n     */\n\n    Component_MessageTextRenderer.prototype.finish = function() {\n      var ref, ref1, ref2;\n      if (this.waitAtEnd) {\n        this.isWaiting = true;\n        return (ref = this.object.events) != null ? ref.emit(\"messageWaiting\", this) : void 0;\n      } else if (this.waitAtEndTime > 0) {\n        this.waitCounter = this.waitAtEndTime;\n        this.isWaiting = false;\n        return (ref1 = this.object.events) != null ? ref1.emit(\"messageWaiting\", this) : void 0;\n      } else {\n        if ((ref2 = this.object.events) != null) {\n          ref2.emit(\"messageWaiting\", this);\n        }\n        return this[\"continue\"]();\n      }\n    };\n\n\n    /**\n    * Returns the position of the caret in pixels. The caret is like an invisible\n    * cursor pointing to the x/y coordinates of the last rendered character of\n    * the message. That position can be used to display a waiting- or processing-animation for example.\n    *\n    * @method updateCaretPosition\n     */\n\n    Component_MessageTextRenderer.prototype.updateCaretPosition = function() {\n      this.caretPosition.x = this.currentX + this.padding;\n      return this.caretPosition.y = this.currentY + this.currentLineHeight / 2;\n    };\n\n\n    /**\n    * Updates the line writing.\n    *\n    * @method updateLineWriting\n    * @private\n     */\n\n    Component_MessageTextRenderer.prototype.updateLineWriting = function() {\n      if (this.isRunning && !this.isWaiting && !this.waitForKey && this.waitCounter <= 0) {\n        if (this.lineAnimationCount <= 0) {\n          while (true) {\n            if (this.line < this.maxLines) {\n              this.nextChar();\n            }\n            if (this.line >= this.maxLines) {\n              this.finish();\n            } else {\n              this.drawNext();\n            }\n            if (!((this.token.code || this.lineAnimationCount <= 0 || this.drawImmediately) && !this.waitForKey && this.waitCounter <= 0 && this.isRunning && this.line < this.maxLines)) {\n              break;\n            }\n          }\n        }\n        if (GameManager.tempSettings.skip) {\n          return this.lineAnimationCount = 0;\n        } else {\n          return this.lineAnimationCount--;\n        }\n      }\n    };\n\n\n    /**\n    * Updates wait-for-key state. If skipping is enabled, the text renderer will\n    * not wait for key press.\n    *\n    * @method updateWaitForKey\n    * @private\n     */\n\n    Component_MessageTextRenderer.prototype.updateWaitForKey = function() {\n      if (this.waitForKey) {\n        this.isWaiting = !GameManager.tempSettings.skip;\n        return this.waitForKey = this.isWaiting;\n      }\n    };\n\n\n    /**\n    * Updates wait counter if the text renderer is waiting for a certain amount of time to pass. If skipping is enabled, the text renderer will\n    * not wait for the actual amount of time and sets the wait-counter to 1 frame instead.\n    *\n    * @method updateWaitForKey\n    * @private\n     */\n\n    Component_MessageTextRenderer.prototype.updateWaitCounter = function() {\n      if (this.waitCounter > 0) {\n        if (GameManager.tempSettings.skip) {\n          this.waitCounter = 1;\n        }\n        this.isWaiting = true;\n        this.waitCounter--;\n        if (this.waitCounter <= 0) {\n          this.isWaiting = false;\n          if (this.line >= this.maxLines) {\n            return this[\"continue\"]();\n          }\n        }\n      }\n    };\n\n\n    /**\n    * Creates a token-object for a specified text-code.\n    *\n    * @method createToken\n    * @param {string} code - The code/type of the text-code.\n    * @param {string} value - The value of the text-code.\n    * @return {Object} The token-object.\n     */\n\n    Component_MessageTextRenderer.prototype.createToken = function(code, value) {\n      var data, i, j, ref, tokenObject;\n      tokenObject = null;\n      switch (code) {\n        case \"CE\":\n          data = value.split(\"/\");\n          value = data.shift();\n          value = isNaN(value) ? value : parseInt(value);\n          for (i = j = 0, ref = data; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            if (data[i].startsWith('\"') && data[i].endsWith('\"')) {\n              data[i] = data[i].substring(1, data[i].length - 1);\n            } else {\n              data[i] = isNaN(data[i]) ? data[i] : parseFloat(data[i]);\n            }\n          }\n          tokenObject = {\n            code: code,\n            value: value,\n            values: data\n          };\n          break;\n        default:\n          tokenObject = Component_MessageTextRenderer.__super__.createToken.call(this, code, value);\n      }\n      return tokenObject;\n    };\n\n\n    /**\n    * <p>Measures a control-token. If a token produces a visual result like displaying an icon then it must return the size taken by\n    * the visual result. If the token has no visual result, <b>null</b> must be returned. This method is called for every token when the message is initialized.</p>\n    *\n    * <p>This method is not called while the message is running. For that case, see <i>processControlToken</i> method which is called\n    * for every token while the message is running.</p>\n    *\n    * @param {Object} token - A control-token.\n    * @return {gs.Size} The size of the area taken by the visual result of the token or <b>null</b> if the token has no visual result.\n    * @method analyzeControlToken\n    * @protected\n     */\n\n    Component_MessageTextRenderer.prototype.measureControlToken = function(token) {\n      return Component_MessageTextRenderer.__super__.measureControlToken.call(this, token);\n    };\n\n\n    /**\n    * <p>Draws the visual result of a token, like an icon for example, to the specified bitmap. This method is called for every token when the message is initialized and the sprites for each\n    * text-line are created.</p>\n    *\n    * <p>This method is not called while the message is running. For that case, see <i>processControlToken</i> method which is called\n    * for every token while the message is running.</p>\n    *\n    * @param {Object} token - A control-token.\n    * @param {gs.Bitmap} bitmap - The bitmap used for the current text-line. Can be used to draw something on it like an icon, etc.\n    * @param {number} offset - An x-offset for the draw-routine.\n    * @param {number} length - Determines how many characters of the token should be drawn. Can be ignored for tokens\n    * not drawing any characters.\n    * @method drawControlToken\n    * @protected\n     */\n\n    Component_MessageTextRenderer.prototype.drawControlToken = function(token, bitmap, offset, length) {\n      var data, j, len, linkData, results;\n      switch (token.code) {\n        case \"RT\":\n          return Component_MessageTextRenderer.__super__.drawControlToken.call(this, token, bitmap, offset, length);\n        case \"SLK\":\n          if (token.customData.offsetX == null) {\n            token.customData.offsetX = offset;\n          }\n          if (this.customData.linkData) {\n            linkData = this.customData.linkData[this.line];\n            if (linkData) {\n              results = [];\n              for (j = 0, len = linkData.length; j < len; j++) {\n                data = linkData[j];\n                results.push(this.sprites[this.line].bitmap.clearRect(data.cx, 0, data.width, data.height));\n              }\n              return results;\n            }\n          }\n      }\n    };\n\n\n    /**\n    * Processes a control-token. A control-token is a token which influences\n    * the text-rendering like changing the fonts color, size or style. Changes\n    * will be automatically applied to the game object's font.\n    *\n    * For message text-renderer, a few additional control-tokens like\n    * speed-change, waiting, etc. needs to be processed here.\n    *\n    * This method is called for each token while the message is initialized and\n    * also while the message is running. See <i>formattingOnly</i> parameter.\n    *\n    * @param {Object} token - A control-token.\n    * @param {boolean} formattingOnly - If <b>true</b> the message is initializing right now and only\n    * format-tokens should be processed which is necessary for the message to calculated sizes correctly.\n    * @return {Object} A new token which is processed next or <b>null</b>.\n    * @method processControlToken\n    * @protected\n     */\n\n    Component_MessageTextRenderer.prototype.processControlToken = function(token, formattingOnly) {\n      var animation, bitmap, character, duration, easing, expression, line, linkData, linkStart, object, params, ref, ref1, result, sound, textTokens, values;\n      if (formattingOnly) {\n        return Component_MessageTextRenderer.__super__.processControlToken.call(this, token);\n      }\n      result = null;\n      switch (token.code) {\n        case \"CR\":\n          character = RecordManager.charactersArray.first(function(c) {\n            var ref;\n            return ((ref = c.name.defaultText) != null ? ref : c.name) === token.value;\n          });\n          if (character) {\n            SceneManager.scene.currentCharacter = character;\n          }\n          break;\n        case \"CE\":\n          params = {\n            \"values\": token.values\n          };\n          if ((ref = this.object.events) != null) {\n            ref.emit(\"callCommonEvent\", this.object, {\n              commonEventId: token.value,\n              params: params,\n              finish: false,\n              waiting: true\n            });\n          }\n          break;\n        case \"X\":\n          if (typeof token.value === \"function\") {\n            token.value(this.object);\n          }\n          break;\n        case \"A\":\n          animation = RecordManager.animationsArray.first(function(a) {\n            return a.name === token.value;\n          });\n          if (!animation) {\n            animation = RecordManager.animations[token.value];\n          }\n          if ((animation != null ? animation.graphic.name : void 0) != null) {\n            bitmap = ResourceManager.getBitmap(\"Graphics/Pictures/\" + animation.graphic.name);\n            object = new gs.Object_Animation(animation);\n            this.addCustomObject(object);\n            this.currentX += Math.round(bitmap.width / animation.framesX);\n            this.currentSprite.srcRect.width += Math.round(bitmap.width / animation.framesX);\n          }\n          break;\n        case \"RT\":\n          if (token.rtSize.width > token.rbSize.width) {\n            this.currentX += token.rtSize.width;\n            this.font.set(this.getRubyTextFont(token));\n          } else {\n            this.currentX += token.rbSize.width;\n          }\n          break;\n        case \"LK\":\n          if (token.value === 'E') {\n            object = new ui.Object_Hotspot();\n            object.enabled = true;\n            object.setup();\n            this.addCustomObject(object);\n            object.dstRect.x = this.object.dstRect.x + this.object.origin.x + this.customData.linkData.cx;\n            object.dstRect.y = this.object.dstRect.y + this.object.origin.y + this.customData.linkData.cy;\n            object.dstRect.width = this.currentX - this.customData.linkData.cx;\n            object.dstRect.height = this.currentLineHeight;\n            object.events.on(\"click\", gs.CallBack(\"onLinkClick\", this), {\n              linkData: this.customData.linkData\n            }, this);\n          } else {\n            this.customData.linkData = {\n              cx: this.currentX,\n              cy: this.currentY,\n              commonEventId: token.value,\n              tokenIndex: this.tokenIndex\n            };\n          }\n          break;\n        case \"SLK\":\n          if (token.value === 'E') {\n            linkData = this.customData.linkData[this.line].last();\n            line = this.lines[this.line].content;\n            linkStart = this.findToken(this.tokenIndex - 1, \"SLK\", -1, line);\n            textTokens = this.findTokensBetween(linkData.tokenIndex, this.tokenIndex, null, line);\n            linkData.cx = linkStart.customData.offsetX;\n            linkData.width = this.currentX - linkData.cx + this.padding;\n            linkData.height = this.currentSprite.bitmap.height;\n            object = new ui.Object_Text();\n            object.text = textTokens.select((function(_this) {\n              return function(x) {\n                return x.value;\n              };\n            })(this)).join(\"\");\n            object.formatting = false;\n            object.wordWrap = false;\n            object.ui = new ui.Component_UIBehavior();\n            object.enabled = true;\n            object.addComponent(object.ui);\n            object.addComponent(new gs.Component_HotspotBehavior());\n            object.behavior.padding.left = 0;\n            object.behavior.padding.right = 0;\n            object.dstRect.width = linkData.width;\n            object.dstRect.height = linkData.height;\n            if (linkData.styleIndex === -1) {\n              ui.UIManager.addControlStyles(object, [\"hyperlink\"]);\n            } else {\n              ui.UIManager.addControlStyles(object, [\"hyperlink-\" + linkData.styleIndex]);\n            }\n            object.setup();\n            this.addCustomObject(object);\n            object.dstRect.x = this.currentSprite.x + linkData.cx;\n            object.dstRect.y = this.object.dstRect.y + this.object.origin.y + linkData.cy;\n            object.events.on(\"click\", gs.CallBack(\"onLinkClick\", this), {\n              linkData: linkData\n            }, this);\n          } else {\n            if (!this.customData.linkData) {\n              this.customData.linkData = [];\n            }\n            if (!this.customData.linkData[this.line]) {\n              this.customData.linkData[this.line] = [];\n            }\n            if ((ref1 = token.value) != null ? ref1.contains(\",\") : void 0) {\n              values = token.value.split(\",\");\n              this.customData.linkData[this.line].push({\n                cx: this.currentX,\n                cy: this.currentY,\n                commonEventId: values[0],\n                styleIndex: parseInt(values[1]),\n                tokenIndex: this.tokenIndex\n              });\n            } else {\n              this.customData.linkData[this.line].push({\n                cx: this.currentY,\n                cy: this.currentY,\n                commonEventId: token.value,\n                tokenIndex: this.tokenIndex,\n                styleIndex: -1\n              });\n            }\n          }\n          break;\n        case \"E\":\n          expression = RecordManager.characterExpressionsArray.first(function(c) {\n            var ref2;\n            return ((ref2 = c.name.defaultText) != null ? ref2 : c.name) === token.value;\n          });\n          if (!expression) {\n            expression = RecordManager.characterExpressions[token.value];\n          }\n          character = SceneManager.scene.currentCharacter;\n          if ((expression != null) && ((character != null ? character.index : void 0) != null)) {\n            duration = GameManager.defaults.character.expressionDuration;\n            easing = gs.Easings.fromObject(GameManager.defaults.character.changeEasing);\n            animation = GameManager.defaults.character.changeAnimation;\n            object = SceneManager.scene.characters.first(function(c) {\n              return c.rid === character.index;\n            });\n            if (object != null) {\n              object.behavior.changeExpression(expression, animation, easing, duration);\n            }\n          }\n          break;\n        case \"SP\":\n          sound = RecordManager.system.sounds[token.value - 1];\n          AudioManager.playSound(sound);\n          break;\n        case \"S\":\n          GameManager.settings.messageSpeed = token.value;\n          break;\n        case \"W\":\n          this.drawImmediately = false;\n          if (!GameManager.tempSettings.skip) {\n            if (token.value === \"A\") {\n              this.waitForKey = true;\n            } else {\n              this.waitCounter = Math.round(token.value / 1000 * Graphics.frameRate);\n            }\n          }\n          break;\n        case \"WE\":\n          this.waitAtEnd = token.value === \"Y\";\n          break;\n        case \"DI\":\n          this.drawImmediately = token.value === 1 || token.value === \"Y\";\n          break;\n        default:\n          result = Component_MessageTextRenderer.__super__.processControlToken.call(this, token);\n      }\n      return result;\n    };\n\n\n    /**\n    * Clears/Resets the text-renderer.\n    *\n    * @method clear\n     */\n\n    Component_MessageTextRenderer.prototype.clear = function() {\n      var j, len, ref, ref1, ref2, sprite;\n      this.charIndex = 0;\n      this.currentX = 0;\n      this.currentY = 0;\n      this.line = 0;\n      this.lines = [];\n      this.clearCustomObjects();\n      if ((ref = this.object.bitmap) != null) {\n        ref.clear();\n      }\n      ref1 = this.allSprites;\n      for (j = 0, len = ref1.length; j < len; j++) {\n        sprite = ref1[j];\n        sprite.dispose();\n        if ((ref2 = sprite.bitmap) != null) {\n          ref2.dispose();\n        }\n      }\n      this.allSprites = [];\n      return null;\n    };\n\n\n    /**\n    * Clears/Disposes all sprites used to display the text-lines/parts.\n    *\n    * @method clearAllSprites\n     */\n\n    Component_MessageTextRenderer.prototype.clearAllSprites = function() {\n      var j, len, ref, ref1, sprite;\n      ref = this.allSprites;\n      for (j = 0, len = ref.length; j < len; j++) {\n        sprite = ref[j];\n        sprite.dispose();\n        if ((ref1 = sprite.bitmap) != null) {\n          ref1.dispose();\n        }\n      }\n      return null;\n    };\n\n\n    /**\n    * Clears/Disposes the sprites used to display the text-lines/parts of the current/last message.\n    *\n    * @method clearSprites\n     */\n\n    Component_MessageTextRenderer.prototype.clearSprites = function() {\n      var j, len, ref, ref1, sprite;\n      ref = this.sprites;\n      for (j = 0, len = ref.length; j < len; j++) {\n        sprite = ref[j];\n        sprite.dispose();\n        if ((ref1 = sprite.bitmap) != null) {\n          ref1.dispose();\n        }\n      }\n      return null;\n    };\n\n\n    /**\n    * Removes a game object from the message.\n    *\n    * @method removeCustomObject\n    * @param object {gs.Object_Base} The game object to remove.\n     */\n\n    Component_MessageTextRenderer.prototype.removeCustomObject = function(object) {\n      SceneManager.scene.removeObject(object);\n      object.dispose();\n      return this.customObjects.remove(object);\n    };\n\n\n    /**\n    * Adds a game object to the message which is alive until the message is\n    * erased. Can be used to display animationed-icons, etc. in a message.\n    *\n    * @method addCustomObject\n    * @param object {gs.Object_Base} The game object to add.\n     */\n\n    Component_MessageTextRenderer.prototype.addCustomObject = function(object) {\n      object.dstRect.x = this.object.dstRect.x + this.object.origin.x + this.currentX;\n      object.dstRect.y = this.object.dstRect.y + this.object.origin.y + this.currentY;\n      object.zIndex = this.object.zIndex + 1;\n      object.update();\n      SceneManager.scene.addObject(object);\n      return this.customObjects.push(object);\n    };\n\n\n    /**\n    * Clears the list of custom game objects. All game objects are disposed and removed\n    * from the scene.\n    *\n    * @method clearCustomObjects\n    * @param object {Object} The game object to add.\n     */\n\n    Component_MessageTextRenderer.prototype.clearCustomObjects = function() {\n      var j, len, object, ref;\n      ref = this.customObjects;\n      for (j = 0, len = ref.length; j < len; j++) {\n        object = ref[j];\n        object.dispose();\n        SceneManager.scene.removeObject(object);\n      }\n      return this.customObjects = [];\n    };\n\n\n    /**\n    * Creates the bitmap for a specified line-object.\n    *\n    * @method createBitmap\n    * @private\n    * @param {Object} line - A line-object.\n    * @return {Bitmap} A newly created bitmap containing the line-text.\n     */\n\n    Component_MessageTextRenderer.prototype.createBitmap = function(line) {\n      var bitmap;\n      this.font = this.object.font;\n      bitmap = new Bitmap(this.object.dstRect.width, Math.max(this.minLineHeight, line.height));\n      bitmap.font = this.font;\n      return bitmap;\n    };\n\n\n    /**\n    * Draws the line's content on the specified bitmap.\n    *\n    * @method drawLineContent\n    * @protected\n    * @param {Object} line - A line-object which should be drawn on the bitmap.\n    * @param {gs.Bitmap} bitmap - The bitmap to draw the line's content on.\n    * @param {number} length - Determines how many characters of the specified line should be drawn. You can\n    * specify -1 to draw all characters.\n     */\n\n    Component_MessageTextRenderer.prototype.drawLineContent = function(line, bitmap, length) {\n      var currentX, drawAll, i, j, len, ref, size, token, value;\n      bitmap.clear();\n      currentX = this.padding;\n      drawAll = length === -1;\n      ref = line.content;\n      for (i = j = 0, len = ref.length; j < len; i = ++j) {\n        token = ref[i];\n        if (i > this.tokenIndex && !drawAll) {\n          break;\n        }\n        if (token.code != null) {\n          size = this.measureControlToken(token, bitmap);\n          this.drawControlToken(token, bitmap, currentX);\n          if (size) {\n            currentX += size.width;\n          }\n          this.processControlToken(token, true, line);\n        } else if (token.value.length > 0) {\n          token.applyFormat(this.font);\n          value = token.value;\n          if (!drawAll && this.tokenIndex === i && value.length > length) {\n            value = value.substring(0, length);\n          }\n          if (value !== \"\\n\") {\n            size = this.font.measureTextPlain(value);\n            bitmap.drawText(currentX, line.height - (size.height - this.font.descent) - line.descent, size.width, bitmap.height, value, 0, 0);\n            currentX += size.width;\n          }\n        }\n      }\n      return line.contentWidth = currentX + this.font.measureTextPlain(\" \").width;\n    };\n\n\n    /**\n    * Creates the sprite for a specified line-object.\n    *\n    * @method createSprite\n    * @private\n    * @param {Object} line - A line-object.\n    * @return {Sprite} A newly created sprite object containing the line-text as bitmap.\n     */\n\n    Component_MessageTextRenderer.prototype.createSprite = function(line) {\n      var bitmap, sprite;\n      bitmap = this.createBitmap(line);\n      this.currentX = 0;\n      this.waitCounter = 0;\n      this.waitForKey = false;\n      sprite = new Sprite(Graphics.viewport);\n      sprite.bitmap = bitmap;\n      sprite.visible = true;\n      sprite.z = this.object.zIndex + 1;\n      sprite.srcRect = new Rect(0, 0, 0, bitmap.height);\n      return sprite;\n    };\n\n\n    /**\n    * Creates the sprites for a specified array of line-objects.\n    *\n    * @method createSprites\n    * @private\n    * @see gs.Component_MessageTextRenderer.createSprite.\n    * @param {Array} lines - An array of line-objects.\n    * @return {Array} An array of sprites.\n     */\n\n    Component_MessageTextRenderer.prototype.createSprites = function(lines) {\n      var i, j, len, line, result, sprite;\n      this.fontSize = this.object.font.size;\n      result = [];\n      for (i = j = 0, len = lines.length; j < len; i = ++j) {\n        line = lines[i];\n        sprite = this.createSprite(line);\n        result.push(sprite);\n      }\n      return result;\n    };\n\n\n    /**\n    * Starts a new line.\n    *\n    * @method newLine\n     */\n\n    Component_MessageTextRenderer.prototype.newLine = function() {\n      this.currentX = 0;\n      return this.currentY += this.currentLineHeight + this.lineSpacing;\n    };\n\n\n    /**\n    * Displays a formatted text immediately without any delays or animations. The\n    * Component_TextRenderer.drawFormattedText method from the base-class cannot\n    * be used here because it would render to the game object's bitmap object while\n    * this method is rendering to the sprites.\n    *\n    * @method drawFormattedTextImmediately\n    * @param {number} x - The x-coordinate of the text's position.\n    * @param {number} y - The y-coordinate of the text's position.\n    * @param {number} width - Deprecated. Can be null.\n    * @param {number} height - Deprecated. Can be null.\n    * @param {string} text - The text to draw.\n    * @param {boolean} wordWrap - If wordWrap is set to true, line-breaks are automatically created.\n     */\n\n    Component_MessageTextRenderer.prototype.drawFormattedTextImmediately = function(x, y, width, height, text, wordWrap) {\n      this.drawFormattedText(x, y, width, height, text, wordWrap);\n      while (true) {\n        this.nextChar();\n        if (this.line >= this.maxLines) {\n          this.isRunning = false;\n        } else {\n          this.drawNext();\n        }\n        if (!this.isRunning) {\n          break;\n        }\n      }\n      this.currentY += this.currentLineHeight + this.lineSpacing;\n      return null;\n    };\n\n\n    /**\n    * Starts the rendering-process for the message.\n    *\n    * @method drawFormattedText\n    * @param {number} x - The x-coordinate of the text's position.\n    * @param {number} y - The y-coordinate of the text's position.\n    * @param {number} width - Deprecated. Can be null.\n    * @param {number} height - Deprecated. Can be null.\n    * @param {string} text - The text to draw.\n    * @param {boolean} wordWrap - If wordWrap is set to true, line-breaks are automatically created.\n     */\n\n    Component_MessageTextRenderer.prototype.drawFormattedText = function(x, y, width, height, text, wordWrap) {\n      var currentX, ref;\n      text = text || \" \";\n      this.font.set(this.object.font);\n      this.speed = 11 - Math.round(GameManager.settings.messageSpeed * 2.5);\n      this.isRunning = true;\n      this.drawImmediately = false;\n      this.lineAnimationCount = this.speed;\n      this.currentLineHeight = 0;\n      this.isWaiting = false;\n      this.waitForKey = false;\n      this.charIndex = 0;\n      this.token = null;\n      this.tokenIndex = 0;\n      this.message = text;\n      this.line = 0;\n      this.currentLine = this.line;\n      currentX = this.currentX;\n      this.lines = this.calculateLines(lcsm(this.message), wordWrap, this.currentX);\n      this.sprites = this.createSprites(this.lines);\n      this.allSprites = this.allSprites.concat(this.sprites);\n      this.currentX = currentX;\n      this.currentSprite = this.sprites[this.line];\n      this.currentSprite.x = this.currentX + this.object.origin.x + this.object.dstRect.x;\n      this.maxLines = this.calculateMaxLines(this.lines);\n      this.token = ((ref = this.lines[this.line]) != null ? ref.content[this.tokenIndex] : void 0) || new gs.RendererToken(null, \"\");\n      return this.start();\n    };\n\n\n    /**\n    * Starts the message-rendering process.\n    *\n    * @method start\n    * @protected\n     */\n\n    Component_MessageTextRenderer.prototype.start = function() {\n      var ref;\n      if (GameManager.tempSettings.skip && GameManager.tempSettings.skipTime === 0) {\n        return this.instantSkip();\n      } else if (this.maxLines === 0) {\n        if (((ref = this.lines[0]) != null ? ref.content : void 0) === \"\") {\n          return this.finish();\n        } else {\n          this.maxLines = 1;\n          return this.drawNext();\n        }\n      } else {\n        return this.drawNext();\n      }\n    };\n\n\n    /**\n    * Skips the current message and finishes the message-processing immediately. The message\n    * tokens are processed but not rendered.\n    *\n    * @method instantSkip\n     */\n\n    Component_MessageTextRenderer.prototype.instantSkip = function() {\n      var ref;\n      while (true) {\n        if (this.line < this.maxLines) {\n          this.nextChar();\n        }\n        if (this.line >= this.maxLines) {\n          break;\n        } else {\n          this.processToken();\n        }\n        if (!(this.isRunning && this.line < this.maxLines)) {\n          break;\n        }\n      }\n      if ((ref = this.object.events) != null) {\n        ref.emit(\"messageWaiting\", this);\n      }\n      return this[\"continue\"]();\n    };\n\n\n    /**\n    * Processes the current token.\n    *\n    * @method processToken\n     */\n\n    Component_MessageTextRenderer.prototype.processToken = function() {\n      var base, token;\n      token = null;\n      if (this.token.code != null) {\n        token = this.processControlToken(this.token, false);\n        if (token != null) {\n          this.token = token;\n          if (typeof (base = this.token).onStart === \"function\") {\n            base.onStart();\n          }\n        }\n      } else {\n        token = this.token;\n      }\n      return token;\n    };\n\n    return Component_MessageTextRenderer;\n\n  })(gs.Component_TextRenderer);\n\n  gs.Component_MessageTextRenderer = Component_MessageTextRenderer;\n\n}).call(this);\n"
    },
    "summary": [
        "name",
        "type",
        "order"
    ],
    "externalItems": []
}