{
    "uid": "960AB145K44D2A495DS9C83E4AECD84B7EDD",
    "isLoaded": true,
    "lastModificationTime": 0,
    "items": {
        "name": "Component_TilingPlane",
        "type": "game_script",
        "order": 7,
        "parentId": "D3325122KACDEA4515SB731E37A42B9D779F",
        "folder": false,
        "content": "# ===================================================================\n#\n#   Script: Component_TilingPlane\n#\n#   $$COPYRIGHT$$\n#\n# ===================================================================\nclass Component_TilingPlane extends gs.Component_Sprite\n    ###*\n    * A tiling plane component tiles the image of the game object endless over the screen. The\n    * tiling can be vertical, horizontal or both. The sprite can be managed or\n    * unmanaged. A managed sprite is automatically added to the graphics-system\n    * and processed every frame until it gets disposed. An unmanaged sprite needs\n    * to be added and removed manually.\n    *\n    * @module gs\n    * @class Component_TilingPlane\n    * @extends gs.Component_Sprite\n    * @memberof gs\n    * @constructor\n    * @param {boolean} managed - Indicates if the sprite is managed by the graphics system.\n    ###\n    constructor: (managed) ->\n        @sprite = null\n        @tilingPlane = null\n        @tilingSprite = @sprite\n        @image = null\n        @video = null\n        @imageFolder = \"Graphics/Pictures\"\n        @visible = yes\n        @looping = vertical: no, horizontal: no\n    \n    ###*\n    * Creates sprite object.\n    *\n    * @method setupSprite\n    ###\n    setupSprite: ->\n        if !@sprite\n            @sprite = new gs.Sprite(Graphics.viewport, managed ? yes)\n            @tilingSprite = @sprite\n        \n    ###*\n    * Updates the padding.\n    *\n    * @method updatePadding\n    ###\n    updatePadding: ->\n        if @object.padding?\n            @sprite.rect.x += @object.padding.left\n            @sprite.rect.y += @object.padding.top\n            @sprite.rect.width -= @object.padding.left+@object.padding.right\n            @sprite.rect.height -= @object.padding.bottom+@object.padding.bottom\n            \n    ###*\n    * Updates the source- and destination-rectangle of the game object so that\n    * the associated bitmap fits in. \n    *\n    * @method updateRect\n    ###\n    updateRect: ->\n        if @sprite.bitmap?\n            @object.srcRect = new Rect(0, 0, @sprite.bitmap.width, @sprite.bitmap.height)\n            @object.dstRect.width = @object.srcRect.width\n            @object.dstRect.height = @object.srcRect.height\n            \n    ###*\n    * Updates the sprite properties from the game object properties.\n    *\n    * @method updateProperties\n    ###\n    updateProperties: ->\n        super()\n        \n        @sprite.vertical = @looping.vertical\n        @sprite.horizontal = @looping.horizontal\n        @sprite.x = @object.dstRect.x\n        @sprite.y = @object.dstRect.y\n    \n    ###*\n    * Updates the optional sprite properties from the game object properties.\n    * @method updateOptionalProperties\n    ###    \n    updateOptionalProperties: ->\n        super()\n        \n        @sprite.zoomX = @object.zoom.x\n        @sprite.zoomY = @object.zoom.y\n        \n    ###*\n    * Updates the tiling-plane component by updating its visibility, image, padding and\n    * properties. To save performance, a gs.TilingPlane is only used if looping is enabled. Otherwise\n    * a regular sprite is used.\n    * @method update\n    ###    \n    update: ->\n        if @tilingSprite and (@looping.vertical or @looping.horizontal)\n            @tilingSprite.dispose()\n            @tilingPlane = new gs.TilingPlane(null, @tilingSprite.managed)\n            @tilingSprite = null\n            @sprite = @tilingPlane\n            @image = null\n            \n        if @tilingPlane and not (@looping.vertical or @looping.horizontal)\n            @tilingPlane.dispose()\n            @tilingSprite = new gs.Sprite(null, @tilingPlane.managed)\n            @tilingPlane = null\n            @sprite = @tilingSprite\n            @image = null\n            \n        super\n        \n        \ngs.Component_TilingPlane = Component_TilingPlane\n",
        "compiledContent": "// Generated by CoffeeScript 1.12.7\n(function() {\n  var Component_TilingPlane,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  Component_TilingPlane = (function(superClass) {\n    extend(Component_TilingPlane, superClass);\n\n\n    /**\n    * A tiling plane component tiles the image of the game object endless over the screen. The\n    * tiling can be vertical, horizontal or both. The sprite can be managed or\n    * unmanaged. A managed sprite is automatically added to the graphics-system\n    * and processed every frame until it gets disposed. An unmanaged sprite needs\n    * to be added and removed manually.\n    *\n    * @module gs\n    * @class Component_TilingPlane\n    * @extends gs.Component_Sprite\n    * @memberof gs\n    * @constructor\n    * @param {boolean} managed - Indicates if the sprite is managed by the graphics system.\n     */\n\n    function Component_TilingPlane(managed) {\n      this.sprite = null;\n      this.tilingPlane = null;\n      this.tilingSprite = this.sprite;\n      this.image = null;\n      this.video = null;\n      this.imageFolder = \"Graphics/Pictures\";\n      this.visible = true;\n      this.looping = {\n        vertical: false,\n        horizontal: false\n      };\n    }\n\n\n    /**\n    * Creates sprite object.\n    *\n    * @method setupSprite\n     */\n\n    Component_TilingPlane.prototype.setupSprite = function() {\n      if (!this.sprite) {\n        this.sprite = new gs.Sprite(Graphics.viewport, typeof managed !== \"undefined\" && managed !== null ? managed : true);\n        return this.tilingSprite = this.sprite;\n      }\n    };\n\n\n    /**\n    * Updates the padding.\n    *\n    * @method updatePadding\n     */\n\n    Component_TilingPlane.prototype.updatePadding = function() {\n      if (this.object.padding != null) {\n        this.sprite.rect.x += this.object.padding.left;\n        this.sprite.rect.y += this.object.padding.top;\n        this.sprite.rect.width -= this.object.padding.left + this.object.padding.right;\n        return this.sprite.rect.height -= this.object.padding.bottom + this.object.padding.bottom;\n      }\n    };\n\n\n    /**\n    * Updates the source- and destination-rectangle of the game object so that\n    * the associated bitmap fits in. \n    *\n    * @method updateRect\n     */\n\n    Component_TilingPlane.prototype.updateRect = function() {\n      if (this.sprite.bitmap != null) {\n        this.object.srcRect = new Rect(0, 0, this.sprite.bitmap.width, this.sprite.bitmap.height);\n        this.object.dstRect.width = this.object.srcRect.width;\n        return this.object.dstRect.height = this.object.srcRect.height;\n      }\n    };\n\n\n    /**\n    * Updates the sprite properties from the game object properties.\n    *\n    * @method updateProperties\n     */\n\n    Component_TilingPlane.prototype.updateProperties = function() {\n      Component_TilingPlane.__super__.updateProperties.call(this);\n      this.sprite.vertical = this.looping.vertical;\n      this.sprite.horizontal = this.looping.horizontal;\n      this.sprite.x = this.object.dstRect.x;\n      return this.sprite.y = this.object.dstRect.y;\n    };\n\n\n    /**\n    * Updates the optional sprite properties from the game object properties.\n    * @method updateOptionalProperties\n     */\n\n    Component_TilingPlane.prototype.updateOptionalProperties = function() {\n      Component_TilingPlane.__super__.updateOptionalProperties.call(this);\n      this.sprite.zoomX = this.object.zoom.x;\n      return this.sprite.zoomY = this.object.zoom.y;\n    };\n\n\n    /**\n    * Updates the tiling-plane component by updating its visibility, image, padding and\n    * properties. To save performance, a gs.TilingPlane is only used if looping is enabled. Otherwise\n    * a regular sprite is used.\n    * @method update\n     */\n\n    Component_TilingPlane.prototype.update = function() {\n      if (this.tilingSprite && (this.looping.vertical || this.looping.horizontal)) {\n        this.tilingSprite.dispose();\n        this.tilingPlane = new gs.TilingPlane(null, this.tilingSprite.managed);\n        this.tilingSprite = null;\n        this.sprite = this.tilingPlane;\n        this.image = null;\n      }\n      if (this.tilingPlane && !(this.looping.vertical || this.looping.horizontal)) {\n        this.tilingPlane.dispose();\n        this.tilingSprite = new gs.Sprite(null, this.tilingPlane.managed);\n        this.tilingPlane = null;\n        this.sprite = this.tilingSprite;\n        this.image = null;\n      }\n      return Component_TilingPlane.__super__.update.apply(this, arguments);\n    };\n\n    return Component_TilingPlane;\n\n  })(gs.Component_Sprite);\n\n  gs.Component_TilingPlane = Component_TilingPlane;\n\n}).call(this);\n"
    },
    "summary": [
        "name",
        "type",
        "order"
    ],
    "externalItems": []
}