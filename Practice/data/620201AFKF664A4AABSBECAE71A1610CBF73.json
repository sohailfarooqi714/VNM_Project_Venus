{
    "uid": "620201AFKF664A4AABSBECAE71A1610CBF73",
    "isLoaded": true,
    "lastModificationTime": 0,
    "items": {
        "name": "Component_TextBehavior",
        "type": "game_script",
        "order": 0,
        "parentId": "01A95DA3K01E8A4CB4SBE17E790BCE1FC035",
        "folder": false,
        "content": "# ===================================================================\n#\n#   Script: Component_TextBehavior\n#\n#   $$COPYRIGHT$$\n#\n# ===================================================================\nclass Component_TextBehavior extends gs.Component\n    @memoryUsage: 0\n    \n    ###*\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    * \n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n    ###\n    onDataBundleRestore: (data, context) ->\n        if @renderedLines\n            size = @object.textRenderer.measureFormattedLines(@renderedLines, @object.wordWrap ? yes)\n            @refreshWithSize(size)\n            @refreshBitmap()\n            @object.textRenderer.drawFormattedLines(@padding.left, @padding.top, @padding.right, @padding.bottom, @renderedLines, @object.wordWrap ? yes)\n        else\n            @refresh(true)\n        \n    ###*\n    * \n    *\n    * @module gs\n    * @class Component_TextBehavior\n    * @extends gs.Component\n    * @memberof gs\n    * @constructor\n    ###\n    constructor: () ->\n        super()\n\n        ###*\n        * The current text displayed.\n        * @property text\n        * @type string\n        * @protected\n        ###\n        @text = \"\"\n        \n        @renderedLines = null\n        \n        ###*\n        * The space around the text.\n        * @property padding\n        * @type string\n        * @protected\n        ###\n        @padding = new ui.Space(6, 0, 6, 0);\n        \n        ###*\n        * The font used for text-rendering.\n        * @property font\n        * @type string\n        * @protected\n        ###\n        @font = new Font(gs.Fonts.TEXT)\n        \n        ###*\n        * Standard Format String which can be used if the text represents a number value.\n        * Example: If the text is \"3\" and format is \"%0d3\" then 003 is the displayed text.\n        * @property format\n        * @type string\n        * @protected\n        ###\n        @format = null\n        \n    ###*\n    * Disposes the component and bitmap.\n    *\n    * @method dispose\n    ###\n    dispose: ->\n        if @object.bitmap?\n            @object.bitmap.dispose()\n            @object.bitmap = null\n    \n    ###*\n    * Redraws the texts on game object's bitmap.\n    *\n    * @method redraw\n    ###\n    redraw: ->\n        if @text?\n            @object.bitmap.clear()\n            @object.bitmap.font = @object.font\n            text = lcs(@text)\n            if @format?\n                text = sprintf(@format, text)\n                \n            if @object.formatting\n                @renderedLines = @object.textRenderer.drawFormattedText(@padding.left, @padding.top, @padding.right, @padding.bottom, text, @object.wordWrap ? yes)\n            else\n                @object.textRenderer.drawText(@padding.left, @padding.top, @padding.right, @padding.bottom, text)\n\n    ###*\n    * Updates the game object's <b>dstRect</b> so that the text fits in. That only works\n    * if the game object's <b>sizeToFit</b> property is set.\n    *\n    * @method refreshSize\n    ###\n    refreshSize: ->\n        if not @object.text?  then return\n        \n        @text = @object.text\n        text = lcs(@object.text).toString()\n        \n        if @format?\n            text = sprintf(@format, text)\n            \n        if @object.sizeToFit\n            @object.font = @object.font || @font\n            if @object.formatting\n                size = @object.textRenderer.measureFormattedText(text, @object.wordWrap ? yes)\n            else\n                size = @object.textRenderer.measureText(text)\n            @refreshWithSize(size)\n    \n    ###*\n    * Updates the game object's <b>dstRect</b> with the specified text size.\n    *\n    * @param {gs.Size} size - The text size to resize the game object for.\n    * @method refreshWithSize\n    ###\n    refreshWithSize: (size) ->\n        if !(@object.sizeToFit.horizontal?) or @object.sizeToFit.horizontal\n                @object.dstRect.width = size.width + @padding.right + @padding.left\n        if !(@object.sizeToFit.vertical?) or @object.sizeToFit.vertical\n            @object.dstRect.height = size.height + @padding.bottom + @padding.top\n     \n    ###*\n    * Recreates and clears the game object's bitmap if necessary.\n    *\n    * @method refreshBitmap\n    ###\n    refreshBitmap: ->\n        width = @object.bitmap?.width || 0\n        height = @object.bitmap?.height || 0\n        \n        if(!@object.bitmap or width != @object.dstRect.width or height != @object.dstRect.height)\n            @object.bitmap?.dispose()\n            @object.bitmap = new Bitmap(@object.dstRect.width , @object.dstRect.height)\n        else\n            @object.bitmap.clear()\n            \n        @object.bitmap.font = @object.font\n            \n    ###*\n    * Refreshes the texts on game object's bitmap. If the text or font has not been\n    * changed, no refresh will happen.\n    *\n    * @method refresh\n    * @param {boolean} force - If set to <b>true</b> it will force redrawing the text even if the\n    * text and font has not been changed.\n    ###            \n    refresh: (force) ->\n        fontChange = !@font.compare(@object.font)\n        if !@object.text? or (!force and @object.text == @text and !fontChange) then return\n        \n        @font.set(@object.font) if fontChange\n        @refreshSize()\n        @refreshBitmap()\n        \n        @srcRect = new Rect(0, 0, @object.dstRect.width , @object.dstRect.height)\n        @object.srcRect = @srcRect\n        @redraw()\n    \n    ###*\n    * Action to append a specified text.\n    *\n    * @method addText\n    * @param {Object} sender - The sender of the action.\n    * @param {Object} params - The action's parameters.\n    ###  \n    addText: (sender, params) ->\n        @object.text += ui.Component_FormulaHandler.fieldValue(sender, params.text)\n     \n    ###*\n    * Updates the component. Checks if the game object's bitmap needs a refresh\n    * and maybe disposes the bitmap if the game object's is out of the\n    * screen and memory usage is too high.\n    *\n    * @method update\n    ###     \n    update: ->\n        super\n        visible = @object.visual.visible\n            \n        if (!@object.bitmap or @object.bitmap.width != @object.dstRect.width or @object.bitmap.height != @object.dstRect.height or lcs(@object.text)?.toString() != lcs(@text))\n            @refresh()\n    \ngs.Component_TextBehavior = Component_TextBehavior",
        "compiledContent": "// Generated by CoffeeScript 1.12.7\n(function() {\n  var Component_TextBehavior,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  Component_TextBehavior = (function(superClass) {\n    extend(Component_TextBehavior, superClass);\n\n    Component_TextBehavior.memoryUsage = 0;\n\n\n    /**\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    * \n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n     */\n\n    Component_TextBehavior.prototype.onDataBundleRestore = function(data, context) {\n      var ref, ref1, size;\n      if (this.renderedLines) {\n        size = this.object.textRenderer.measureFormattedLines(this.renderedLines, (ref = this.object.wordWrap) != null ? ref : true);\n        this.refreshWithSize(size);\n        this.refreshBitmap();\n        return this.object.textRenderer.drawFormattedLines(this.padding.left, this.padding.top, this.padding.right, this.padding.bottom, this.renderedLines, (ref1 = this.object.wordWrap) != null ? ref1 : true);\n      } else {\n        return this.refresh(true);\n      }\n    };\n\n\n    /**\n    * \n    *\n    * @module gs\n    * @class Component_TextBehavior\n    * @extends gs.Component\n    * @memberof gs\n    * @constructor\n     */\n\n    function Component_TextBehavior() {\n      Component_TextBehavior.__super__.constructor.call(this);\n\n      /**\n      * The current text displayed.\n      * @property text\n      * @type string\n      * @protected\n       */\n      this.text = \"\";\n      this.renderedLines = null;\n\n      /**\n      * The space around the text.\n      * @property padding\n      * @type string\n      * @protected\n       */\n      this.padding = new ui.Space(6, 0, 6, 0);\n\n      /**\n      * The font used for text-rendering.\n      * @property font\n      * @type string\n      * @protected\n       */\n      this.font = new Font(gs.Fonts.TEXT);\n\n      /**\n      * Standard Format String which can be used if the text represents a number value.\n      * Example: If the text is \"3\" and format is \"%0d3\" then 003 is the displayed text.\n      * @property format\n      * @type string\n      * @protected\n       */\n      this.format = null;\n    }\n\n\n    /**\n    * Disposes the component and bitmap.\n    *\n    * @method dispose\n     */\n\n    Component_TextBehavior.prototype.dispose = function() {\n      if (this.object.bitmap != null) {\n        this.object.bitmap.dispose();\n        return this.object.bitmap = null;\n      }\n    };\n\n\n    /**\n    * Redraws the texts on game object's bitmap.\n    *\n    * @method redraw\n     */\n\n    Component_TextBehavior.prototype.redraw = function() {\n      var ref, text;\n      if (this.text != null) {\n        this.object.bitmap.clear();\n        this.object.bitmap.font = this.object.font;\n        text = lcs(this.text);\n        if (this.format != null) {\n          text = sprintf(this.format, text);\n        }\n        if (this.object.formatting) {\n          return this.renderedLines = this.object.textRenderer.drawFormattedText(this.padding.left, this.padding.top, this.padding.right, this.padding.bottom, text, (ref = this.object.wordWrap) != null ? ref : true);\n        } else {\n          return this.object.textRenderer.drawText(this.padding.left, this.padding.top, this.padding.right, this.padding.bottom, text);\n        }\n      }\n    };\n\n\n    /**\n    * Updates the game object's <b>dstRect</b> so that the text fits in. That only works\n    * if the game object's <b>sizeToFit</b> property is set.\n    *\n    * @method refreshSize\n     */\n\n    Component_TextBehavior.prototype.refreshSize = function() {\n      var ref, size, text;\n      if (this.object.text == null) {\n        return;\n      }\n      this.text = this.object.text;\n      text = lcs(this.object.text).toString();\n      if (this.format != null) {\n        text = sprintf(this.format, text);\n      }\n      if (this.object.sizeToFit) {\n        this.object.font = this.object.font || this.font;\n        if (this.object.formatting) {\n          size = this.object.textRenderer.measureFormattedText(text, (ref = this.object.wordWrap) != null ? ref : true);\n        } else {\n          size = this.object.textRenderer.measureText(text);\n        }\n        return this.refreshWithSize(size);\n      }\n    };\n\n\n    /**\n    * Updates the game object's <b>dstRect</b> with the specified text size.\n    *\n    * @param {gs.Size} size - The text size to resize the game object for.\n    * @method refreshWithSize\n     */\n\n    Component_TextBehavior.prototype.refreshWithSize = function(size) {\n      if (!(this.object.sizeToFit.horizontal != null) || this.object.sizeToFit.horizontal) {\n        this.object.dstRect.width = size.width + this.padding.right + this.padding.left;\n      }\n      if (!(this.object.sizeToFit.vertical != null) || this.object.sizeToFit.vertical) {\n        return this.object.dstRect.height = size.height + this.padding.bottom + this.padding.top;\n      }\n    };\n\n\n    /**\n    * Recreates and clears the game object's bitmap if necessary.\n    *\n    * @method refreshBitmap\n     */\n\n    Component_TextBehavior.prototype.refreshBitmap = function() {\n      var height, ref, ref1, ref2, width;\n      width = ((ref = this.object.bitmap) != null ? ref.width : void 0) || 0;\n      height = ((ref1 = this.object.bitmap) != null ? ref1.height : void 0) || 0;\n      if (!this.object.bitmap || width !== this.object.dstRect.width || height !== this.object.dstRect.height) {\n        if ((ref2 = this.object.bitmap) != null) {\n          ref2.dispose();\n        }\n        this.object.bitmap = new Bitmap(this.object.dstRect.width, this.object.dstRect.height);\n      } else {\n        this.object.bitmap.clear();\n      }\n      return this.object.bitmap.font = this.object.font;\n    };\n\n\n    /**\n    * Refreshes the texts on game object's bitmap. If the text or font has not been\n    * changed, no refresh will happen.\n    *\n    * @method refresh\n    * @param {boolean} force - If set to <b>true</b> it will force redrawing the text even if the\n    * text and font has not been changed.\n     */\n\n    Component_TextBehavior.prototype.refresh = function(force) {\n      var fontChange;\n      fontChange = !this.font.compare(this.object.font);\n      if ((this.object.text == null) || (!force && this.object.text === this.text && !fontChange)) {\n        return;\n      }\n      if (fontChange) {\n        this.font.set(this.object.font);\n      }\n      this.refreshSize();\n      this.refreshBitmap();\n      this.srcRect = new Rect(0, 0, this.object.dstRect.width, this.object.dstRect.height);\n      this.object.srcRect = this.srcRect;\n      return this.redraw();\n    };\n\n\n    /**\n    * Action to append a specified text.\n    *\n    * @method addText\n    * @param {Object} sender - The sender of the action.\n    * @param {Object} params - The action's parameters.\n     */\n\n    Component_TextBehavior.prototype.addText = function(sender, params) {\n      return this.object.text += ui.Component_FormulaHandler.fieldValue(sender, params.text);\n    };\n\n\n    /**\n    * Updates the component. Checks if the game object's bitmap needs a refresh\n    * and maybe disposes the bitmap if the game object's is out of the\n    * screen and memory usage is too high.\n    *\n    * @method update\n     */\n\n    Component_TextBehavior.prototype.update = function() {\n      var ref, visible;\n      Component_TextBehavior.__super__.update.apply(this, arguments);\n      visible = this.object.visual.visible;\n      if (!this.object.bitmap || this.object.bitmap.width !== this.object.dstRect.width || this.object.bitmap.height !== this.object.dstRect.height || ((ref = lcs(this.object.text)) != null ? ref.toString() : void 0) !== lcs(this.text)) {\n        return this.refresh();\n      }\n    };\n\n    return Component_TextBehavior;\n\n  })(gs.Component);\n\n  gs.Component_TextBehavior = Component_TextBehavior;\n\n}).call(this);\n"
    },
    "summary": [
        "name",
        "type",
        "order"
    ],
    "externalItems": []
}