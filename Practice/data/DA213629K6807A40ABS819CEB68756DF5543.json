{
    "uid": "DA213629K6807A40ABS819CEB68756DF5543",
    "isLoaded": true,
    "lastModificationTime": 0,
    "items": {
        "name": "Component_ImageMap",
        "type": "game_script",
        "order": 9,
        "parentId": "D3325122KACDEA4515SB731E37A42B9D779F",
        "folder": false,
        "content": "# ===================================================================\n#\n#   Script: Component_ImageMap\n#\n#   $$COPYRIGHT$$\n#\n# ===================================================================\nclass Component_ImageMap extends gs.Component_Visual\n    ###*\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    *\n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n    ###\n    onDataBundleRestore: (data, context) ->\n        @setupEventHandlers()\n        @object.addObject(@ground)\n\n        bitmap = ResourceManager.getBitmap(\"Graphics/Pictures/#{@object.images[0]}\")\n        ground = new gs.Bitmap(bitmap.width, bitmap.height)\n        ground.blt(0, 0, bitmap, new Rect(0, 0, bitmap.width, bitmap.height))\n        @ground.bitmap = ground\n\n        @setupHotspots(@hotspots)\n\n    ###*\n    * A component which turns a game object into an interactive image-map.\n    *\n    * @module gs\n    * @class Component_ImageMap\n    * @extends gs.Component_Visual\n    * @memberof gs\n    ###\n    constructor: ->\n        super\n\n        ###*\n        * The ground/base image.\n        * @property ground\n        * @type gs.Object_Picture\n        * @default null\n        ###\n        @ground = null\n\n        ###*\n        * An array of different hotspots.\n        * @property hotspots\n        * @type gs.Object_Picture[]\n        * @default null\n        ###\n        @hotspots = null\n\n        ###*\n        * The variable context used if a hotspot needs to deal with local variables.\n        * @property variableContext\n        * @type Object\n        * @default null\n        ###\n        @variableContext = null\n\n        ###*\n        * Indicates if the image-map is active. An in-active image-map doesn't respond\n        * to any input-event. Hover effects are still working.\n        * @property active\n        * @type boolean\n        * @default yes\n        ###\n        @active = yes\n\n    ###*\n    * Adds event-handler for mouse/touch events to update the component only if\n    * a user-action happened.\n    *\n    * @method setupEventHandlers\n    ###\n    setupEventHandlers: ->\n        gs.GlobalEventManager.offByOwner(\"mouseUp\", @object)\n        gs.GlobalEventManager.on \"mouseUp\", ((e) =>\n            contains = Rect.contains(@object.dstRect.x, @object.dstRect.y,\n                         @object.dstRect.width, @object.dstRect.height,\n                         Input.Mouse.x - @object.origin.x, Input.Mouse.y - @object.origin.y)\n\n            if contains and @active\n                for hotspot in @hotspots\n                    if @checkHotspotAction(hotspot)\n                        e.breakChain = yes\n                        if hotspot.data.bindToSwitch\n                            hotspot.selected = !hotspot.selected\n                        @executeHotspotAction(hotspot)\n\n        ), null, @object\n\n\n    ###*\n    * Initializes the image-map. Creates the background and hotspots.\n    *\n    * @method setup\n    ###\n    setup: ->\n        @setupEventHandlers()\n        @object.rIndex = 11000 # Receive Input Events first\n\n        if @object.images[0]\n            bitmap = ResourceManager.getBitmap(\"Graphics/Pictures/#{@object.images[0]}\")\n            if bitmap.loaded\n                bitmap.makeMutable()\n                ground = new gs.Bitmap(bitmap.width, bitmap.height)\n                ground.blt(0, 0, bitmap, new Rect(0, 0, bitmap.width, bitmap.height))\n\n        @ground = new gs.Object_Picture()\n        @ground.bitmap = ground\n        @ground.image = null\n        @ground.zIndex = @object.zIndex\n        @ground.imageHandling = gs.ImageHandling.CUSTOM_SIZE\n        @object.addObject(@ground)\n\n        @setupHotspots()\n\n        if ground?\n            @ground.srcRect.set(0, 0, ground.width, ground.height)\n            @ground.dstRect.width = ground.width\n            @ground.dstRect.height = ground.height\n        @ground.update()\n\n        @object.dstRect.width = @ground.dstRect.width\n        @object.dstRect.height = @ground.dstRect.height\n\n    ###*\n    * Sets up the hotspots on the image-map. Each hotspot is a gs.Object_ImageMapHotspot\n    * object.\n    *\n    * @method setupHotspots\n    ###\n    setupHotspots: (hotspots) ->\n        @hotspots = @object.hotspots.select (v, i) =>\n            @ground.bitmap?.clearRect(v.x, v.y, v.size.width, v.size.height)\n            picture = new gs.Object_ImageMapHotspot()\n            picture.fixedSize = true\n            picture.srcRect = new Rect(v.x, v.y, v.size.width, v.size.height)\n            picture.dstRect = new Rect(v.x, v.y, v.size.width, v.size.height)\n            picture.imageHandling = gs.ImageHandling.CUSTOM_SIZE\n            picture.zIndex = @object.zIndex + 1\n            picture.selected = hotspots?[i]?.selected ? no\n            picture.hovered = no\n            picture.enabled = hotspots?[i]?.enabled ? yes\n            picture.actions = v.data.actions\n            picture.data = v.data\n            picture.commonEventId = v.commonEventId\n            picture.anchor.set(0.5, 0.5)\n            @object.addObject(picture)\n\n            return picture\n\n    ###*\n    * Initializes the image-map. Frees ground image.\n    *\n    * @method dispose\n    ###\n    dispose: ->\n        super\n        gs.GlobalEventManager.offByOwner(\"mouseUp\", @object)\n        @ground.bitmap?.dispose()\n\n    ###*\n    * Executes a hotspot's associated action. Depending on the configuration a hotspot\n    * can trigger a common-event or turn on a switch for example.\n    *\n    * @method executeHotspotAction\n    * @param {gs.Object_Picture} hotspot - The hotspot where the image should be updated.\n    * @protected\n    ###\n    executeHotspotAction: (hotspot) ->\n        GameManager.variableStore.setupTempVariables(@variableContext)\n        if hotspot.data.bindToSwitch\n            domain = GameManager.variableStore.domain\n            GameManager.variableStore.setBooleanValueTo(hotspot.data.switch, hotspot.selected)\n        if hotspot.data.bindValueTo\n            domain = GameManager.variableStore.domain\n            GameManager.variableStore.setNumberValueTo(hotspot.data.bindValueVariable, hotspot.data.bindValue)\n\n        AudioManager.playSound(hotspot.data.onClickSound)\n        switch hotspot.data.action\n            when 1 # Jump To\n                @object.events?.emit(\"jumpTo\", @object, { label: hotspot.data.label })\n            when 2 # Call Common Event\n                @object.events?.emit(\"callCommonEvent\", @object, { commonEventId: hotspot.data.commonEventId, finish: hotspot.data.finish })\n            when 3 # UI Action\n                @object.events?.emit(\"action\", @object, { actions: hotspot.data.actions })\n\n        if hotspot.data.finish\n            @object.events?.emit(\"finish\", @object)\n\n\n    ###*\n    * Checks if a hotspot's associated action needs to be executed. Depending on the configuration a hotspot\n    * can trigger a common-event or turn on a switch for example.\n    *\n    * @method updateHotspotAction\n    * @param {gs.Object_Picture} hotspot - The hotspot where the image should be updated.\n    * @return {boolean} If <b>true</b> the hotspot's action needs to be executed. Otherwise <b>false</b>.\n    * @protected\n    ###\n    checkHotspotAction: (hotspot) ->\n        result = no\n        hovered = hotspot.dstRect.contains(Input.Mouse.x - hotspot.origin.x, Input.Mouse.y - hotspot.origin.y)\n\n        if hovered and hotspot.enabled and Input.Mouse.buttons[Input.Mouse.LEFT] == 2\n            result = yes\n\n        return result\n\n    ###*\n    * Updates a hotspot's image. Depending on the state the image of a hotspot can\n    * change for example if the mouse hovers over a hotspot.\n    *\n    * @method updateHotspotImage\n    * @param {gs.Object_Picture} hotspot - The hotspot where the image should be updated.\n    * @param {boolean} hovered - Indicates if the hotspot is hovered by mouse/touch cursor.\n    * @protected\n    ###\n    updateHotspotImage: (hotspot, hovered) ->\n        baseImage = if hotspot.enabled then @object.images[2] || @object.images[0] else @object.images[0]\n        if hovered and hotspot.enabled\n            if hotspot.selected\n                hotspot.image = @object.images[4] || @object.images[1] || baseImage\n            else\n                hotspot.image = @object.images[1] || baseImage\n        else\n            if hotspot.selected\n                hotspot.image = @object.images[3] || baseImage\n            else\n                hotspot.image = baseImage\n\n\n    ###*\n    * Updates a hotspot.\n    *\n    * @method updateHotspot\n    * @param {gs.Object_Picture} hotspot - The hotspot to update.\n    * @protected\n    ###\n    updateHotspot: (hotspot) ->\n        hotspot.visible = @object.visible\n        hotspot.opacity = @object.opacity\n        hotspot.tone.setFromObject(@object.tone)\n        hotspot.color.setFromObject(@object.color)\n        if hotspot.data.bindEnabledState\n            GameManager.variableStore.setupTempVariables(@variableContext)\n            hotspot.enabled = GameManager.variableStore.booleanValueOf(hotspot.data.enabledSwitch)\n        if hotspot.data.bindToSwitch\n            GameManager.variableStore.setupTempVariables(@variableContext)\n            hotspot.selected = GameManager.variableStore.booleanValueOf(hotspot.data.switch)\n        hovered = hotspot.dstRect.contains(Input.Mouse.x - hotspot.origin.x, Input.Mouse.y - hotspot.origin.y)\n        if hovered != hotspot.hovered\n            hotspot.hovered = hovered\n            AudioManager.playSound(hotspot.data.onHoverSound) if hovered\n        @updateHotspotImage(hotspot, hovered)\n        hotspot.update()\n\n    ###*\n    * Updates the ground-image.\n    *\n    * @method updateGround\n    * @protected\n    ###\n    updateGround: ->\n        @ground.visible = @object.visible\n        @ground.opacity = @object.opacity\n        @ground.anchor.x = 0.5\n        @ground.anchor.y = 0.5\n        @ground.tone.setFromObject(@object.tone)\n        @ground.color.setFromObject(@object.color)\n        @ground.update()\n\n    ###*\n    * Updates the image-map's ground and all hotspots.\n    *\n    * @method update\n    ###\n    update: ->\n        super()\n\n        @updateGround()\n\n        for hotspot in @hotspots\n            @updateHotspot(hotspot)\n\n        return null\n\ngs.Component_ImageMap = Component_ImageMap",
        "compiledContent": "// Generated by CoffeeScript 1.12.7\n(function() {\n  var Component_ImageMap,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  Component_ImageMap = (function(superClass) {\n    extend(Component_ImageMap, superClass);\n\n\n    /**\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    *\n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n     */\n\n    Component_ImageMap.prototype.onDataBundleRestore = function(data, context) {\n      var bitmap, ground;\n      this.setupEventHandlers();\n      this.object.addObject(this.ground);\n      bitmap = ResourceManager.getBitmap(\"Graphics/Pictures/\" + this.object.images[0]);\n      ground = new gs.Bitmap(bitmap.width, bitmap.height);\n      ground.blt(0, 0, bitmap, new Rect(0, 0, bitmap.width, bitmap.height));\n      this.ground.bitmap = ground;\n      return this.setupHotspots(this.hotspots);\n    };\n\n\n    /**\n    * A component which turns a game object into an interactive image-map.\n    *\n    * @module gs\n    * @class Component_ImageMap\n    * @extends gs.Component_Visual\n    * @memberof gs\n     */\n\n    function Component_ImageMap() {\n      Component_ImageMap.__super__.constructor.apply(this, arguments);\n\n      /**\n      * The ground/base image.\n      * @property ground\n      * @type gs.Object_Picture\n      * @default null\n       */\n      this.ground = null;\n\n      /**\n      * An array of different hotspots.\n      * @property hotspots\n      * @type gs.Object_Picture[]\n      * @default null\n       */\n      this.hotspots = null;\n\n      /**\n      * The variable context used if a hotspot needs to deal with local variables.\n      * @property variableContext\n      * @type Object\n      * @default null\n       */\n      this.variableContext = null;\n\n      /**\n      * Indicates if the image-map is active. An in-active image-map doesn't respond\n      * to any input-event. Hover effects are still working.\n      * @property active\n      * @type boolean\n      * @default yes\n       */\n      this.active = true;\n    }\n\n\n    /**\n    * Adds event-handler for mouse/touch events to update the component only if\n    * a user-action happened.\n    *\n    * @method setupEventHandlers\n     */\n\n    Component_ImageMap.prototype.setupEventHandlers = function() {\n      gs.GlobalEventManager.offByOwner(\"mouseUp\", this.object);\n      return gs.GlobalEventManager.on(\"mouseUp\", ((function(_this) {\n        return function(e) {\n          var contains, hotspot, j, len, ref, results;\n          contains = Rect.contains(_this.object.dstRect.x, _this.object.dstRect.y, _this.object.dstRect.width, _this.object.dstRect.height, Input.Mouse.x - _this.object.origin.x, Input.Mouse.y - _this.object.origin.y);\n          if (contains && _this.active) {\n            ref = _this.hotspots;\n            results = [];\n            for (j = 0, len = ref.length; j < len; j++) {\n              hotspot = ref[j];\n              if (_this.checkHotspotAction(hotspot)) {\n                e.breakChain = true;\n                if (hotspot.data.bindToSwitch) {\n                  hotspot.selected = !hotspot.selected;\n                }\n                results.push(_this.executeHotspotAction(hotspot));\n              } else {\n                results.push(void 0);\n              }\n            }\n            return results;\n          }\n        };\n      })(this)), null, this.object);\n    };\n\n\n    /**\n    * Initializes the image-map. Creates the background and hotspots.\n    *\n    * @method setup\n     */\n\n    Component_ImageMap.prototype.setup = function() {\n      var bitmap, ground;\n      this.setupEventHandlers();\n      this.object.rIndex = 11000;\n      if (this.object.images[0]) {\n        bitmap = ResourceManager.getBitmap(\"Graphics/Pictures/\" + this.object.images[0]);\n        if (bitmap.loaded) {\n          bitmap.makeMutable();\n          ground = new gs.Bitmap(bitmap.width, bitmap.height);\n          ground.blt(0, 0, bitmap, new Rect(0, 0, bitmap.width, bitmap.height));\n        }\n      }\n      this.ground = new gs.Object_Picture();\n      this.ground.bitmap = ground;\n      this.ground.image = null;\n      this.ground.zIndex = this.object.zIndex;\n      this.ground.imageHandling = gs.ImageHandling.CUSTOM_SIZE;\n      this.object.addObject(this.ground);\n      this.setupHotspots();\n      if (ground != null) {\n        this.ground.srcRect.set(0, 0, ground.width, ground.height);\n        this.ground.dstRect.width = ground.width;\n        this.ground.dstRect.height = ground.height;\n      }\n      this.ground.update();\n      this.object.dstRect.width = this.ground.dstRect.width;\n      return this.object.dstRect.height = this.ground.dstRect.height;\n    };\n\n\n    /**\n    * Sets up the hotspots on the image-map. Each hotspot is a gs.Object_ImageMapHotspot\n    * object.\n    *\n    * @method setupHotspots\n     */\n\n    Component_ImageMap.prototype.setupHotspots = function(hotspots) {\n      return this.hotspots = this.object.hotspots.select((function(_this) {\n        return function(v, i) {\n          var picture, ref, ref1, ref2, ref3, ref4;\n          if ((ref = _this.ground.bitmap) != null) {\n            ref.clearRect(v.x, v.y, v.size.width, v.size.height);\n          }\n          picture = new gs.Object_ImageMapHotspot();\n          picture.fixedSize = true;\n          picture.srcRect = new Rect(v.x, v.y, v.size.width, v.size.height);\n          picture.dstRect = new Rect(v.x, v.y, v.size.width, v.size.height);\n          picture.imageHandling = gs.ImageHandling.CUSTOM_SIZE;\n          picture.zIndex = _this.object.zIndex + 1;\n          picture.selected = (ref1 = hotspots != null ? (ref2 = hotspots[i]) != null ? ref2.selected : void 0 : void 0) != null ? ref1 : false;\n          picture.hovered = false;\n          picture.enabled = (ref3 = hotspots != null ? (ref4 = hotspots[i]) != null ? ref4.enabled : void 0 : void 0) != null ? ref3 : true;\n          picture.actions = v.data.actions;\n          picture.data = v.data;\n          picture.commonEventId = v.commonEventId;\n          picture.anchor.set(0.5, 0.5);\n          _this.object.addObject(picture);\n          return picture;\n        };\n      })(this));\n    };\n\n\n    /**\n    * Initializes the image-map. Frees ground image.\n    *\n    * @method dispose\n     */\n\n    Component_ImageMap.prototype.dispose = function() {\n      var ref;\n      Component_ImageMap.__super__.dispose.apply(this, arguments);\n      gs.GlobalEventManager.offByOwner(\"mouseUp\", this.object);\n      return (ref = this.ground.bitmap) != null ? ref.dispose() : void 0;\n    };\n\n\n    /**\n    * Executes a hotspot's associated action. Depending on the configuration a hotspot\n    * can trigger a common-event or turn on a switch for example.\n    *\n    * @method executeHotspotAction\n    * @param {gs.Object_Picture} hotspot - The hotspot where the image should be updated.\n    * @protected\n     */\n\n    Component_ImageMap.prototype.executeHotspotAction = function(hotspot) {\n      var domain, ref, ref1, ref2, ref3;\n      GameManager.variableStore.setupTempVariables(this.variableContext);\n      if (hotspot.data.bindToSwitch) {\n        domain = GameManager.variableStore.domain;\n        GameManager.variableStore.setBooleanValueTo(hotspot.data[\"switch\"], hotspot.selected);\n      }\n      if (hotspot.data.bindValueTo) {\n        domain = GameManager.variableStore.domain;\n        GameManager.variableStore.setNumberValueTo(hotspot.data.bindValueVariable, hotspot.data.bindValue);\n      }\n      AudioManager.playSound(hotspot.data.onClickSound);\n      switch (hotspot.data.action) {\n        case 1:\n          if ((ref = this.object.events) != null) {\n            ref.emit(\"jumpTo\", this.object, {\n              label: hotspot.data.label\n            });\n          }\n          break;\n        case 2:\n          if ((ref1 = this.object.events) != null) {\n            ref1.emit(\"callCommonEvent\", this.object, {\n              commonEventId: hotspot.data.commonEventId,\n              finish: hotspot.data.finish\n            });\n          }\n          break;\n        case 3:\n          if ((ref2 = this.object.events) != null) {\n            ref2.emit(\"action\", this.object, {\n              actions: hotspot.data.actions\n            });\n          }\n      }\n      if (hotspot.data.finish) {\n        return (ref3 = this.object.events) != null ? ref3.emit(\"finish\", this.object) : void 0;\n      }\n    };\n\n\n    /**\n    * Checks if a hotspot's associated action needs to be executed. Depending on the configuration a hotspot\n    * can trigger a common-event or turn on a switch for example.\n    *\n    * @method updateHotspotAction\n    * @param {gs.Object_Picture} hotspot - The hotspot where the image should be updated.\n    * @return {boolean} If <b>true</b> the hotspot's action needs to be executed. Otherwise <b>false</b>.\n    * @protected\n     */\n\n    Component_ImageMap.prototype.checkHotspotAction = function(hotspot) {\n      var hovered, result;\n      result = false;\n      hovered = hotspot.dstRect.contains(Input.Mouse.x - hotspot.origin.x, Input.Mouse.y - hotspot.origin.y);\n      if (hovered && hotspot.enabled && Input.Mouse.buttons[Input.Mouse.LEFT] === 2) {\n        result = true;\n      }\n      return result;\n    };\n\n\n    /**\n    * Updates a hotspot's image. Depending on the state the image of a hotspot can\n    * change for example if the mouse hovers over a hotspot.\n    *\n    * @method updateHotspotImage\n    * @param {gs.Object_Picture} hotspot - The hotspot where the image should be updated.\n    * @param {boolean} hovered - Indicates if the hotspot is hovered by mouse/touch cursor.\n    * @protected\n     */\n\n    Component_ImageMap.prototype.updateHotspotImage = function(hotspot, hovered) {\n      var baseImage;\n      baseImage = hotspot.enabled ? this.object.images[2] || this.object.images[0] : this.object.images[0];\n      if (hovered && hotspot.enabled) {\n        if (hotspot.selected) {\n          return hotspot.image = this.object.images[4] || this.object.images[1] || baseImage;\n        } else {\n          return hotspot.image = this.object.images[1] || baseImage;\n        }\n      } else {\n        if (hotspot.selected) {\n          return hotspot.image = this.object.images[3] || baseImage;\n        } else {\n          return hotspot.image = baseImage;\n        }\n      }\n    };\n\n\n    /**\n    * Updates a hotspot.\n    *\n    * @method updateHotspot\n    * @param {gs.Object_Picture} hotspot - The hotspot to update.\n    * @protected\n     */\n\n    Component_ImageMap.prototype.updateHotspot = function(hotspot) {\n      var hovered;\n      hotspot.visible = this.object.visible;\n      hotspot.opacity = this.object.opacity;\n      hotspot.tone.setFromObject(this.object.tone);\n      hotspot.color.setFromObject(this.object.color);\n      if (hotspot.data.bindEnabledState) {\n        GameManager.variableStore.setupTempVariables(this.variableContext);\n        hotspot.enabled = GameManager.variableStore.booleanValueOf(hotspot.data.enabledSwitch);\n      }\n      if (hotspot.data.bindToSwitch) {\n        GameManager.variableStore.setupTempVariables(this.variableContext);\n        hotspot.selected = GameManager.variableStore.booleanValueOf(hotspot.data[\"switch\"]);\n      }\n      hovered = hotspot.dstRect.contains(Input.Mouse.x - hotspot.origin.x, Input.Mouse.y - hotspot.origin.y);\n      if (hovered !== hotspot.hovered) {\n        hotspot.hovered = hovered;\n        if (hovered) {\n          AudioManager.playSound(hotspot.data.onHoverSound);\n        }\n      }\n      this.updateHotspotImage(hotspot, hovered);\n      return hotspot.update();\n    };\n\n\n    /**\n    * Updates the ground-image.\n    *\n    * @method updateGround\n    * @protected\n     */\n\n    Component_ImageMap.prototype.updateGround = function() {\n      this.ground.visible = this.object.visible;\n      this.ground.opacity = this.object.opacity;\n      this.ground.anchor.x = 0.5;\n      this.ground.anchor.y = 0.5;\n      this.ground.tone.setFromObject(this.object.tone);\n      this.ground.color.setFromObject(this.object.color);\n      return this.ground.update();\n    };\n\n\n    /**\n    * Updates the image-map's ground and all hotspots.\n    *\n    * @method update\n     */\n\n    Component_ImageMap.prototype.update = function() {\n      var hotspot, j, len, ref;\n      Component_ImageMap.__super__.update.call(this);\n      this.updateGround();\n      ref = this.hotspots;\n      for (j = 0, len = ref.length; j < len; j++) {\n        hotspot = ref[j];\n        this.updateHotspot(hotspot);\n      }\n      return null;\n    };\n\n    return Component_ImageMap;\n\n  })(gs.Component_Visual);\n\n  gs.Component_ImageMap = Component_ImageMap;\n\n}).call(this);\n"
    },
    "summary": [
        "name",
        "type",
        "order"
    ],
    "externalItems": []
}