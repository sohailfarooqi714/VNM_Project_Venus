{
    "uid": "FA7A4820K975AA4196S8E5DEEFF71858030C",
    "isLoaded": true,
    "lastModificationTime": 0,
    "items": {
        "name": "Component_GameSceneBehavior",
        "type": "game_script",
        "order": 2,
        "parentId": "0C1D8BE8KDB63A469AS9782EB90E63254DB3",
        "folder": false,
        "content": "# ===================================================================\n#\n#   Script: Component_GameSceneBehavior\n#\n#   $$COPYRIGHT$$\n#\n# ===================================================================\nclass Component_GameSceneBehavior extends gs.Component_LayoutSceneBehavior\n #   @objectCodecBlackList = [\"objectManager\"]\n    ###*\n    * Defines the behavior of visual novel game scene.\n    *\n    * @module vn\n    * @class Component_GameSceneBehavior\n    * @extends gs.Component_LayoutSceneBehavior\n    * @memberof vn\n    ###\n    constructor: ->\n        super()\n\n        @onAutoCommonEventStart = =>\n            @object.removeComponent(@object.interpreter)\n            @object.interpreter.stop()\n        @onAutoCommonEventFinish = =>\n            if !@object.components.contains(@object.interpreter)\n                @object.addComponent(@object.interpreter)\n            @object.interpreter.resume()\n\n        @resourceContext = null\n        @objectDomain = \"\"\n\n    ###*\n    * Initializes the scene.\n    *\n    * @method initialize\n    ###\n    initialize: ->\n        if SceneManager.previousScenes.length == 0\n            gs.GlobalEventManager.clearExcept(@object.commonEventContainer.subObjects)\n\n        @resourceContext = ResourceManager.createContext()\n        ResourceManager.context = @resourceContext\n\n        Graphics.freeze()\n        saveGame = GameManager.loadedSaveGame\n        sceneUid = null\n\n        if saveGame\n            sceneUid = saveGame.sceneUid\n            @object.sceneData = saveGame.data\n        else\n            sceneUid = $PARAMS.preview?.scene.uid || @object.sceneData.uid || RecordManager.system.startInfo.scene.uid\n\n        @object.sceneDocument = DataManager.getDocument(sceneUid)\n\n        if @object.sceneDocument and @object.sceneDocument.items.type == \"vn.scene\"\n            @object.chapter = DataManager.getDocument(@object.sceneDocument.items.chapterUid)\n            @object.currentCharacter = { \"name\": \"\" } #RecordManager.characters[0]\n\n            if not GameManager.initialized\n                GameManager.initialize()\n            GameManager.preloadCommonEvents()\n\n            LanguageManager.loadBundles()\n        else\n            sprite = new gs.Sprite()\n            sprite.bitmap = new gs.Bitmap(Graphics.width, 50)\n            sprite.bitmap.drawText(0, 0, Graphics.width, 50, \"No Start Scene selected\", 1, 0)\n            sprite.srcRect = new gs.Rect(0, 0, Graphics.width, 50)\n            sprite.y = (Graphics.height - 50) / 2\n            sprite.z = 10000\n\n        @setupScreen()\n\n    ###*\n    * Disposes the scene.\n    *\n    * @method dispose\n    ###\n    dispose: ->\n        ResourceManager.context = @resourceContext\n        @object.removeObject(@object.commonEventContainer)\n        @show(no)\n\n        for event in GameManager.commonEvents\n            if event\n                event.events.offByOwner(\"start\", @object)\n                event.events.offByOwner(\"finish\", @object)\n\n        if @object.video\n            @object.video.dispose()\n            @object.video.onEnded()\n\n        super()\n\n    changePictureDomain: (domain) ->\n        @object.pictureContainer.behavior.changeDomain(domain)\n        @object.pictures = @object.pictureContainer.subObjects\n    changeTextDomain: (domain) ->\n        @object.textContainer.behavior.changeDomain(domain)\n        @object.texts = @object.textContainer.subObjects\n    changeVideoDomain: (domain) ->\n        @object.videoContainer.behavior.changeDomain(domain)\n        @object.videos = @object.videoContainer.subObjects\n    changeHotspotDomain: (domain) ->\n        @object.hotspotContainer.behavior.changeDomain(domain)\n        @object.hotspots = @object.hotspotContainer.subObjects\n    changeMessageAreaDomain: (domain) ->\n        @object.messageAreaContainer.behavior.changeDomain(domain)\n        @object.messageAreas = @object.messageAreaContainer.subObjects\n\n    ###*\n    * Shows/Hides the current scene. A hidden scene is no longer shown and executed\n    * but all objects and data is still there and be shown again anytime.\n    *\n    * @method show\n    * @param {boolean} visible - Indicates if the scene should be shown or hidden.\n    ###\n    show: (visible) ->\n        if visible\n            @object.viewport = GameManager.sceneViewport\n\n        window.$dataFields = @dataFields\n        @object.visible = visible\n\n        @object.layout?.update()\n\n        @object.pictureContainer.behavior.setVisible(visible)\n        @object.hotspotContainer.behavior.setVisible(visible)\n        @object.textContainer.behavior.setVisible(visible)\n        @object.videoContainer.behavior.setVisible(visible)\n        @object.messageAreaContainer.behavior.setVisible(visible)\n        @object.viewportContainer.behavior.setVisible(visible)\n        @object.characterContainer.behavior.setVisible(visible)\n        @object.backgroundContainer.behavior.setVisible(visible)\n\n        @viewport?.visible = visible\n        @object.choiceWindow?.visible = visible\n        @object.inputNumberBox?.visible = visible\n        @object.inputTextBox?.visible = visible\n        @object.inputTextBox?.update()\n        @object.inputNumberBox?.update()\n        @object.choiceWindow?.update()\n\n        GameManager.tempSettings.skip = no\n\n        #if visible and @object.commonEventContainer.subObjects.length == 0\n        @setupCommonEvents()\n\n    ###*\n    * Sets up common event handling.\n    *\n    * @method setupCommonEvents\n    ###\n    setupCommonEvents: ->\n        commonEvents = @object.sceneData?.commonEvents\n\n        if commonEvents\n            for event, i in commonEvents\n                if event and @object.commonEventContainer.subObjects.indexOf(event) == -1\n                    @object.commonEventContainer.setObject(event, i)\n                    event.behavior.setupEventHandlers()\n\n                    if event.interpreter?.isRunning\n                        event.events.emit(\"start\", event)\n        else\n            for event, i in GameManager.commonEvents\n                if event and (event.record.startCondition == 1 or event.record.parallel) and @object.commonEventContainer.subObjects.indexOf(event) == -1\n                    @object.commonEventContainer.setObject(event, i)\n\n                    event.events.offByOwner(\"start\", @object)\n                    event.events.offByOwner(\"finish\", @object)\n\n                    if not event.record.parallel\n                        event.events.on \"start\", gs.CallBack(\"onAutoCommonEventStart\", this), null, @object\n                        event.events.on \"finish\", gs.CallBack(\"onAutoCommonEventFinish\", this), null, @object\n\n                    if event.interpreter?.isRunning\n                        event.events.emit(\"start\", event)\n\n        return null\n\n    ###*\n    * Sets up main interpreter.\n    *\n    * @method setupInterpreter\n    * @protected\n    ###\n    setupInterpreter: ->\n        @object.commands = @object.sceneDocument.items.commands\n\n        if @object.sceneData.interpreter\n            @object.removeComponent(@object.interpreter)\n            @object.interpreter = @object.sceneData.interpreter\n            @object.addComponent(@object.interpreter)\n            #Object.mixin(@object.interpreter, @object.sceneData.interpreter, gs.Component_CommandInterpreter.objectCodecBlackList)\n            @object.interpreter.context.set(@object.sceneDocument.uid, @object)\n            @object.interpreter.object = @object\n        else\n            @object.interpreter.setup()\n            @object.interpreter.context.set(@object.sceneDocument.uid, @object)\n            @object.interpreter.start()\n\n\n    ###*\n    * Sets up characters and restores them from loaded save game if necessary.\n    *\n    * @method setupCharacters\n    * @protected\n    ###\n    setupCharacters: ->\n        if @object.sceneData.characters?\n            for c, i in @object.sceneData.characters\n                @object.characterContainer.setObject(c, i)\n\n        @object.currentCharacter = @object.sceneData.currentCharacter || { name: \"\" }#RecordManager.characters[0]\n\n\n    ###*\n    * Sets up viewports and restores them from loaded save game if necessary.\n    *\n    * @method setupViewports\n    * @protected\n    ###\n    setupViewports: ->\n        viewports = @object.sceneData?.viewports ? []\n        for viewport, i in viewports\n            if viewport\n                @object.viewportContainer.setObject(viewport, i)\n    ###*\n    * Sets up backgrounds and restores them from loaded save game if necessary.\n    *\n    * @method setupBackgrounds\n    * @protected\n    ###\n    setupBackgrounds: ->\n        backgrounds = @object.sceneData?.backgrounds ? []\n        for b, i in backgrounds\n            @object.backgroundContainer.setObject(b, i)\n\n    ###*\n    * Sets up pictures and restores them from loaded save game if necessary.\n    *\n    * @method setupPictures\n    * @protected\n    ###\n    setupPictures: ->\n        pictures = @object.sceneData?.pictures ? {}\n        for domain of pictures\n            @object.pictureContainer.behavior.changeDomain(domain)\n            if pictures[domain] then for picture, i in pictures[domain]\n                @object.pictureContainer.setObject(picture, i)\n                if picture?.image\n                    path = \"Graphics/Pictures/#{picture.image}\"\n                    @resourceContext.add(path, ResourceManager.resourcesByPath[path])\n\n    ###*\n    * Sets up texts and restores them from loaded save game if necessary.\n    *\n    * @method setupTexts\n    * @protected\n    ###\n    setupTexts: ->\n        texts = @object.sceneData?.texts ? {}\n        for domain of texts\n            @object.textContainer.behavior.changeDomain(domain)\n            if texts[domain] then for text, i in texts[domain]\n                @object.textContainer.setObject(text, i)\n\n    ###*\n    * Sets up videos and restores them from loaded save game if necessary.\n    *\n    * @method setupVideos\n    * @protected\n    ###\n    setupVideos: ->\n        videos = @object.sceneData?.videos ? {}\n        for domain of videos\n            @object.videoContainer.behavior.changeDomain(domain)\n            if videos[domain] then for video, i in videos[domain]\n                if video\n                    path = \"Movies/#{video.video}\"\n                    @resourceContext.add(path, ResourceManager.resourcesByPath[path])\n                    video.visible = yes\n                    video.update()\n\n                @object.videoContainer.setObject(video, i)\n\n    ###*\n    * Sets up hotspots and restores them from loaded save game if necessary.\n    *\n    * @method setupHotspots\n    * @protected\n    ###\n    setupHotspots: ->\n        hotspots = @object.sceneData?.hotspots ? {}\n        for domain of hotspots\n            @object.hotspotContainer.behavior.changeDomain(domain)\n            if hotspots[domain] then for hotspot, i in hotspots[domain]\n                @object.hotspotContainer.setObject(hotspot, i)\n\n    ###*\n    * Sets up layout.\n    *\n    * @method setupLayout\n    * @protected\n    ###\n    setupLayout: ->\n        @dataFields = ui.UIManager.dataSources[ui.UiFactory.layouts.gameLayout.dataSource || \"default\"]()\n        @dataFields.scene = @object\n        window.$dataFields = @dataFields\n        advVisible = @object.messageMode == vn.MessageMode.ADV\n\n        @object.layout = ui.UiFactory.createFromDescriptor(ui.UiFactory.layouts.gameLayout, @object)\n        @object.layout.visible = advVisible\n        $gameMessage_message.visible = advVisible\n        @object.layout.ui.prepare()\n\n        @object.choices = @object.sceneData?.choices || @object.choices\n        if @object.choices?.length > 0\n            @showChoices(gs.CallBack(\"onChoiceAccept\", @object.interpreter, { pointer: @object.interpreter.pointer, params: @params }))\n\n        if @object.interpreter.waitingFor.inputNumber\n            @showInputNumber(GameManager.tempFields.digits, gs.CallBack(\"onInputNumberFinish\", @object.interpreter, @object.interpreter))\n\n        if @object.interpreter.waitingFor.inputText\n            @showInputText(GameManager.tempFields.letters, gs.CallBack(\"onInputTextFinish\", @object.interpreter, @object.interpreter))\n\n    ###*\n    * Sets up the main viewport / screen viewport.\n    *\n    * @method setupMainViewport\n    * @protected\n    ###\n    setupMainViewport: ->\n        if !@object.sceneData.viewport\n            GameManager.sceneViewport.removeComponent(GameManager.sceneViewport.visual)\n            GameManager.sceneViewport.dispose()\n            GameManager.sceneViewport = new gs.Object_Viewport(GameManager.sceneViewport.visual.viewport)\n            @viewport = GameManager.sceneViewport.visual.viewport\n            @object.viewport = GameManager.sceneViewport\n        else\n            GameManager.sceneViewport.dispose()\n            GameManager.sceneViewport = @object.sceneData.viewport\n            @object.viewport = @object.sceneData.viewport\n            @viewport = @object.viewport.visual.viewport\n            @viewport.viewport = Graphics.viewport\n\n    ###*\n    * Sets up screen.\n    *\n    * @method setupScreen\n    * @protected\n    ###\n    setupScreen: ->\n        if @object.sceneData.screen\n            @object.viewport.restore(@object.sceneData.screen)\n\n    ###*\n    * Restores main interpreter from loaded save game.\n    *\n    * @method restoreInterpreter\n    * @protected\n    ###\n    restoreInterpreter: ->\n        if @object.sceneData.interpreter\n            @object.interpreter.restore()\n\n    ###*\n    * Restores message box from loaded save game.\n    *\n    * @method restoreMessageBox\n    * @protected\n    ###\n    restoreMessageBox: ->\n        messageBoxes = @object.sceneData?.messageBoxes\n        if messageBoxes\n            for messageBox in messageBoxes\n                messageObject = gs.ObjectManager.current.objectById(messageBox.id)\n                messageObject.visible = messageBox.visible\n                if messageBox.message\n                    messageBox.message.textRenderer.disposeEventHandlers()\n                    message = gs.ObjectManager.current.objectById(messageBox.message.id)\n                    message.textRenderer.dispose()\n\n                    Object.mixin(message, messageBox.message, ui.Object_Message.objectCodecBlackList.concat([\"origin\"]))\n\n                    for c in message.components\n                        c.object = message\n                    message.textRenderer.setupEventHandlers()\n\n    ###*\n    * Restores message from loaded save game.\n    *\n    * @method restoreMessages\n    * @protected\n    ###\n    restoreMessages: ->\n        if @object.sceneData?.messageAreas\n            for domain of @object.sceneData.messageAreas\n                @object.messageAreaContainer.behavior.changeDomain(domain)\n                messageAreas = @object.sceneData.messageAreas\n                if messageAreas[domain] then for area, i in messageAreas[domain]\n                    if area\n                        messageArea = new gs.Object_MessageArea()\n                        messageLayout = ui.UIManager.createControlFromDescriptor(type: \"ui.CustomGameMessage\", id: \"customGameMessage_\"+i, params: { id: \"customGameMessage_\"+i }, messageArea)\n                        message = gs.ObjectManager.current.objectById(\"customGameMessage_\"+i+\"_message\")\n                        area.message.textRenderer.disposeEventHandlers();\n                        message.textRenderer.dispose()\n                        Object.mixin(message, area.message)\n                        for c in message.components\n                            c.object = message\n                        #message.restore(f.message)\n\n                        messageLayout.dstRect.x = area.layout.dstRect.x\n                        messageLayout.dstRect.y = area.layout.dstRect.y\n                        messageLayout.dstRect.width = area.layout.dstRect.width\n                        messageLayout.dstRect.height = area.layout.dstRect.height\n                        messageLayout.needsUpdate = yes\n                        message.textRenderer.setupEventHandlers()\n                        messageLayout.update()\n\n                        #message.message.restoreMessages(f.messages)\n                        #message.textRenderer.restore(f.textRenderer)\n                        #message.visible = yes\n                        messageArea.message = message\n                        messageArea.layout = messageLayout\n                        messageArea.addObject(messageLayout)\n                        @object.messageAreaContainer.setObject(messageArea, i)\n\n\n\n\n\n    ###*\n    * Restores audio-playback from loaded save game.\n    *\n    * @method restoreAudioPlayback\n    * @protected\n    ###\n    restoreAudioPlayback: ->\n        if @object.sceneData.audio\n            AudioManager.audioBuffers.push(b) for b in @object.sceneData.audio.audioBuffers\n            AudioManager.audioBuffersByLayer = @object.sceneData.audio.audioBuffersByLayer\n            AudioManager.audioLayers = @object.sceneData.audio.audioLayers\n            AudioManager.soundReferences = @object.sceneData.audio.soundReferences\n\n\n    ###*\n    * Restores the scene objects from the current loaded save-game. If no save-game is\n    * present in GameManager.loadedSaveGame, nothing will happen.\n    *\n    * @method restoreScene\n    * @protected\n    ###\n    restoreScene: ->\n        saveGame = GameManager.loadedSaveGame\n        if saveGame\n            context = new gs.ObjectCodecContext([Graphics.viewport, @object, this], saveGame.encodedObjectStore, null)\n            saveGame.data = gs.ObjectCodec.decode(saveGame.data, context)\n            for c in saveGame.data.characterNames\n                if c then RecordManager.characters[c.index]?.name = c.name\n            GameManager.restore(saveGame)\n            gs.ObjectCodec.onRestore(saveGame.data, context)\n            @resourceContext.fromDataBundle(saveGame.data.resourceContext, ResourceManager.resourcesByPath)\n\n            @object.sceneData = saveGame.data\n            Graphics.frameCount = saveGame.data.frameCount\n\n    ###*\n    * Prepares all data for the scene and loads the necessary graphic and audio resources.\n    *\n    * @method prepareData\n    * @abstract\n    ###\n    prepareData: ->\n        #RecordManager.translate()\n\n        GameManager.scene = @object\n\n        gs.ObjectManager.current = @objectManager\n\n        @object.sceneData.uid = @object.sceneDocument.uid\n\n        if !ResourceLoader.loadEventCommandsData(@object.sceneDocument.items.commands)\n            ResourceLoader.loadEventCommandsGraphics(@object.sceneDocument.items.commands)\n            GameManager.backlog = @object.sceneData.backlog || GameManager.sceneData.backlog || []\n\n            ResourceLoader.loadSystemSounds()\n            ResourceLoader.loadSystemGraphics()\n            ResourceLoader.loadUiTypesGraphics(ui.UiFactory.customTypes)\n            ResourceLoader.loadUiLayoutGraphics(ui.UiFactory.layouts.gameLayout)\n\n            if @dataFields?\n                ResourceLoader.loadUiDataFieldsGraphics(@dataFields)\n\n            $tempFields.choiceTimer = @object.choiceTimer\n\n            GameManager.variableStore.setup({ id: @object.sceneDocument.uid})\n\n    ###*\n    * Prepares all visual game object for the scene.\n    *\n    * @method prepareVisual\n    ###\n    prepareVisual: ->\n        if @object.layout then return\n\n        if GameManager.tempFields.isExitingGame\n            GameManager.tempFields.isExitingGame = no\n            gs.GameNotifier.postResetSceneChange(@object.sceneDocument.items.name)\n        else\n            gs.GameNotifier.postSceneChange(@object.sceneDocument.items.name)\n\n        @restoreScene()\n        @object.messageMode = @object.sceneData.messageMode ? vn.MessageMode.ADV\n        @setupMainViewport()\n        @setupViewports()\n        @setupCharacters()\n        @setupBackgrounds()\n        @setupPictures()\n        @setupTexts()\n        @setupVideos()\n        @setupHotspots()\n        @setupInterpreter()\n        @setupLayout()\n        @setupCommonEvents()\n\n        @restoreMessageBox()\n        @restoreInterpreter()\n        @restoreMessages()\n        @restoreAudioPlayback()\n\n        @show(true)\n\n        @object.sceneData = {}\n        GameManager.sceneData = {}\n\n        Graphics.update()\n        @transition({ duration: 0 })\n\n\n    ###*\n    * Adds a new character to the scene.\n    *\n    * @method addCharacter\n    * @param {vn.Object_Character} character - The character to add.\n    * @param {boolean} noAnimation - Indicates if the character should be added immediately witout any appear-animation.\n    * @param {Object} animationData - Contains the appear-animation data -> { animation, easing, duration }.\n    ###\n    addCharacter: (character, noAnimation, animationData) ->\n        unless noAnimation\n            character.motionBlur.set(animationData.motionBlur)\n\n            if animationData.duration > 0\n                character.animator.appear(character.dstRect.x, character.dstRect.y, animationData.animation, animationData.easing, animationData.duration) unless noAnimation\n\n        character.viewport = @viewport\n        character.visible = yes\n\n        @object.characterContainer.addObject(character)\n\n    ###*\n    * Removes a character from the scene.\n    *\n    * @method removeCharacter\n    * @param {vn.Object_Character} character - The character to remove.\n    * @param {boolean} noAnimation - Indicates if the character should be disposed immediately witout any disapear-animation.\n    * @param {Object} animationData - Contains the disappear-animation data -> { animation, easing, duration }.\n    ###\n    removeCharacter: (character, noAnimation, animationData) ->\n        unless noAnimation\n            character?.animator.disappear(animationData.animation, animationData.easing, animationData.duration, (sender) -> sender.dispose())\n        else\n            character?.dispose()\n\n    ###*\n    * Resumes the current scene if it has been paused.\n    *\n    * @method resumeScene\n    ###\n    resumeScene: ->\n        @object.pictureContainer.active = yes\n        @object.characterContainer.active = yes\n        @object.backgroundContainer.active = yes\n        @object.textContainer.active = yes\n        @object.hotspotContainer.active = yes\n        @object.videoContainer.active = yes\n\n        message = gs.ObjectManager.current.objectById(\"gameMessage_message\")\n        message.active = yes\n\n    ###*\n    * Pauses the current scene. A paused scene will not continue, messages, pictures, etc. will\n    * stop until the scene resumes.\n    *\n    * @method pauseScene\n    ###\n    pauseScene: ->\n        @object.pictureContainer.active = no\n        @object.characterContainer.active = no\n        @object.backgroundContainer.active = no\n        @object.textContainer.active = no\n        @object.hotspotContainer.active = no\n        @object.videoContainer.active = no\n\n        message = gs.ObjectManager.current.objectById(\"gameMessage_message\")\n        message.active = no\n\n    ###*\n    * Changes the visibility of the entire game UI like the message boxes, etc. to allows\n    * the player to see the entire scene. Useful for CGs, etc.\n    *\n    * @param {boolean} visible - If <b>true</b>, the game UI will be visible. Otherwise it will be hidden.\n    * @method changeUIVisibility\n    ###\n    changeUIVisibility: (visible) ->\n        @uiVisible = visible\n        @object.layout.visible = visible\n\n    ###*\n    * Shows input-text box to let the user enter a text.\n    *\n    * @param {number} letters - The max. number of letters the user can enter.\n    * @param {gs.Callback} callback - A callback function called if the input-text box has been accepted by the user.\n    * @method showInputText\n    ###\n    showInputText: (letters, callback) ->\n        @object.inputTextBox?.dispose()\n        @object.inputTextBox = ui.UiFactory.createControlFromDescriptor(ui.UiFactory.customTypes[\"ui.InputTextBox\"], @object.layout)\n        @object.inputTextBox.ui.prepare()\n        @object.inputTextBox.events.on(\"accept\", callback)\n\n    ###*\n    * Shows input-number box to let the user enter a number.\n    *\n    * @param {number} digits - The max. number of digits the user can enter.\n    * @param {gs.Callback} callback - A callback function called if the input-number box has been accepted by the user.\n    * @method showInputNumber\n    ###\n    showInputNumber: (digits, callback) ->\n        @object.inputNumberBox?.dispose()\n        @object.inputNumberBox = ui.UiFactory.createControlFromDescriptor(ui.UiFactory.customTypes[\"ui.InputNumberBox\"], @object.layout)\n        @object.inputNumberBox.ui.prepare()\n        @object.inputNumberBox.events.on(\"accept\", callback)\n\n    ###*\n    * Shows choices to let the user pick a choice.\n    *\n    * @param {Object[]} choices - An array of choices\n    * @param {gs.Callback} callback - A callback function called if a choice has been picked by the user.\n    * @method showChoices\n    ###\n    showChoices: (callback) ->\n        useFreeLayout = @object.choices.where((x) -> x.dstRect?).length > 0\n\n        @object.choiceWindow?.dispose()\n\n        if useFreeLayout\n            @object.choiceWindow = ui.UiFactory.createControlFromDescriptor(ui.UiFactory.customTypes[\"ui.FreeChoiceBox\"], @object.layout)\n        else\n            @object.choiceWindow = ui.UiFactory.createControlFromDescriptor(ui.UiFactory.customTypes[\"ui.ChoiceBox\"], @object.layout)\n\n        @object.choiceWindow.events.on(\"selectionAccept\", callback)\n        @object.choiceWindow.ui.prepare()\n\n    ###*\n    * Changes the background of the scene.\n    *\n    * @method changeBackground\n    * @param {Object} background - The background graphic object -> { name }\n    * @param {boolean} noAnimation - Indicates if the background should be changed immediately witout any change-animation.\n    * @param {Object} animation - The appear/disappear animation to use.\n    * @param {Object} easing - The easing of the change animation.\n    * @param {number} duration - The duration of the change in frames.\n    * @param {number} ox - The x-origin of the background.\n    * @param {number} oy - The y-origin of the background.\n    * @param {number} layer - The background-layer to change.\n    * @param {boolean} loopHorizontal - Indicates if the background should be looped horizontally.\n    * @param {boolean} loopVertical - Indicates if the background should be looped vertically.\n    ###\n    changeBackground: (background, noAnimation, animation, easing, duration, ox, oy, layer, loopHorizontal, loopVertical) ->\n        if background?\n            otherObject = @object.backgrounds[layer]\n            object = new vn.Object_Background()\n            object.image = background.name\n            object.origin.x = ox\n            object.origin.y = oy\n            object.viewport = @viewport\n            object.visual.looping.vertical = no\n            object.visual.looping.horizontal = no\n            object.update()\n\n            @object.backgroundContainer.setObject(object, layer)\n\n            duration = duration ? 30\n\n            otherObject?.zIndex = layer\n            otherObject?.animator.otherObject?.dispose()\n\n            if duration == 0\n                otherObject?.dispose()\n                object.visual.looping.vertical = loopVertical\n                object.visual.looping.horizontal = loopHorizontal\n            else\n                if noAnimation\n                    object.visual.looping.vertical = loopVertical\n                    object.visual.looping.horizontal = loopHorizontal\n                else\n                    object.animator.otherObject = otherObject\n                    object.animator.appear(0, 0, animation, easing, duration, (sender) =>\n                        sender.update()\n                        sender.animator.otherObject?.dispose()\n                        sender.animator.otherObject = null\n                        sender.visual.looping.vertical = loopVertical\n                        sender.visual.looping.horizontal = loopHorizontal\n                    )\n        else\n            @object.backgrounds[layer]?.animator.hide duration, easing,  =>\n               @object.backgrounds[layer].dispose()\n               @object.backgrounds[layer] = null\n\n\n    ###*\n    * Skips all viewport animations except the main viewport animation.\n    *\n    * @method skipViewports\n    * @protected\n    ###\n    skipViewports: ->\n        viewports = @object.viewportContainer.subObjects\n        for viewport in viewports\n            if viewport\n                for component in viewport.components\n                    component.skip?()\n        return null\n\n    ###*\n    * Skips all picture animations.\n    *\n    * @method skipPictures\n    * @protected\n    ###\n    skipPictures: ->\n        for picture in @object.pictures\n            if picture\n                for component in picture.components\n                    component.skip?()\n        return null\n\n    ###*\n    * Skips all text animations.\n    *\n    * @method skipTexts\n    * @protected\n    ###\n    skipTexts: ->\n       for text in @object.texts\n            if text\n                for component in text.components\n                    component.skip?()\n        return null\n\n    ###*\n    * Skips all video animations but not the video-playback itself.\n    *\n    * @method skipVideos\n    * @protected\n    ###\n    skipVideos: ->\n        for video in @object.videos\n            if video\n                for component in video.components\n                    component.skip?()\n        return null\n\n    ###*\n    * Skips all background animations.\n    *\n    * @method skipBackgrounds\n    * @protected\n    ###\n    skipBackgrounds: ->\n        for background in @object.backgrounds\n            if background\n                for component in background.components\n                    component.skip?()\n        return null\n\n    ###*\n    * Skips all character animations\n    *\n    * @method skipCharacters\n    * @protected\n    ###\n    skipCharacters: ->\n        for character in @object.characters\n            if character\n                for component in character.components\n                    component.skip?()\n        return null\n\n    ###*\n    * Skips the main viewport animation.\n    *\n    * @method skipMainViewport\n    * @protected\n    ###\n    skipMainViewport: ->\n        for component in @object.viewport.components\n            component.skip?()\n        return null\n\n    ###*\n    * Skips all animations of all message boxes defined in MESSAGE_BOX_IDS ui constant.\n    *\n    * @method skipMessageBoxes\n    * @protected\n    ###\n    skipMessageBoxes: ->\n        for messageBoxId in gs.UIConstants.MESSAGE_BOX_IDS || [\"messageBox\", \"nvlMessageBox\"]\n            messageBox = gs.ObjectManager.current.objectById(messageBoxId)\n            if messageBox.components\n                for component in messageBox.components\n                    component.skip?()\n        return null\n\n    ###*\n    * Skips all animations of all message areas.\n    *\n    * @method skipMessageAreas\n    * @protected\n    ###\n    skipMessageAreas: ->\n        for messageArea in @object.messageAreas\n            if messageArea?.message\n                for component in messageArea.message.components\n                    component.skip?()\n\n        msg = gs.ObjectManager.current.objectById(\"gameMessage_message\")\n        if msg\n            for component in msg.components\n                component.skip?()\n        msg = gs.ObjectManager.current.objectById(\"nvlGameMessage_message\")\n        if msg\n            for component in msg.components\n                component.skip?()\n\n        return null\n\n    ###*\n    * Skips the scene interpreter timer.\n    *\n    * @method skipInterpreter\n    * @protected\n    ###\n    skipInterpreter: ->\n        if @object.interpreter.waitCounter > GameManager.tempSettings.skipTime\n            @object.interpreter.waitCounter = GameManager.tempSettings.skipTime\n            if @object.interpreter.waitCounter == 0\n                @object.interpreter.isWaiting = no\n\n    ###*\n    * Skips the interpreter timer of all common events.\n    *\n    * @method skipCommonEvents\n    * @protected\n    ###\n    skipCommonEvents: ->\n        events = @object.commonEventContainer.subObjects\n        for event in events\n            if event?.interpreter and event.interpreter.waitCounter > GameManager.tempSettings.skipTime\n                event.interpreter.waitCounter = GameManager.tempSettings.skipTime\n                if event.interpreter.waitCounter == 0\n                    event.interpreter.isWaiting = no\n\n    ###*\n    * Skips the scene's content.\n    *\n    * @method skipContent\n    * @protected\n    ###\n    skipContent: ->\n        @skipPictures()\n        @skipTexts()\n        @skipVideos()\n        @skipBackgrounds()\n        @skipCharacters()\n        @skipMainViewport()\n        @skipViewports()\n        @skipMessageBoxes()\n        @skipMessageAreas()\n        @skipInterpreter()\n        @skipCommonEvents()\n\n\n    ###*\n    * Checks for the shortcut to hide/show the game UI. By default, this is the space-key. You\n    * can override this method to change the shortcut.\n    *\n    * @method updateUIVisibilityShortcut\n    * @protected\n    ###\n    updateUIVisibilityShortcut: ->\n        if !@uiVisible and (Input.trigger(Input.C) or Input.Mouse.buttonDown)\n            @changeUIVisibility(!@uiVisible)\n        if Input.trigger(Input.KEY_SPACE)\n            @changeUIVisibility(!@uiVisible)\n\n    ###*\n    * Checks for the shortcut to exit the game. By default, this is the escape-key. You\n    * can override this method to change the shortcut.\n    *\n    * @method updateQuitShortcut\n    * @protected\n    ###\n    updateQuitShortcut: ->\n        if Input.trigger(Input.KEY_ESCAPE)\n            gs.Application.exit()\n\n\n    ###*\n    * Checks for the shortcut to open the settings menu. By default, this is the s-key. You\n    * can override this method to change the shortcut.\n    *\n    * @method updateSettingsShortcut\n    * @protected\n    ###\n    updateSettingsShortcut: ->\n        if GameManager.tempSettings.menuAccess and Input.trigger(Input.X)\n            SceneManager.switchTo(new gs.Object_Layout(\"settingsMenuLayout\"), true)\n\n    ###*\n    * Checks for the shortcut to open the settings menu. By default, this is the control-key. You\n    * can override this method to change the shortcut.\n    *\n    * @method updateSkipShortcut\n    * @protected\n    ###\n    updateSkipShortcut: ->\n        if @object.settings.allowSkip\n            if Input.keys[Input.KEY_CONTROL] == 1\n                GameManager.tempSettings.skip = yes\n            else if Input.keys[Input.KEY_CONTROL] == 2\n                GameManager.tempSettings.skip = no\n\n    ###*\n    * Checks for default keyboard shortcuts e.g space-key to hide the UI, etc.\n    *\n    * @method updateShortcuts\n    * @protected\n    ###\n    updateShortcuts: ->\n        @updateSettingsShortcut()\n        @updateQuitShortcut()\n        @updateUIVisibilityShortcut()\n        @updateSkipShortcut()\n\n    ###*\n    * Updates the full screen video played via Play Movie command.\n    *\n    * @method updateVideo\n    ###\n    updateVideo: ->\n        if @object.video?\n            @object.video.update()\n            if @object.settings.allowVideoSkip and (Input.trigger(Input.C) or Input.Mouse.buttons[Input.Mouse.LEFT] == 2)\n                @object.video.stop()\n            Input.clear()\n\n    ###*\n    * Updates skipping if enabled.\n    *\n    * @method updateSkipping\n    ###\n    updateSkipping: ->\n        if !@object.settings.allowSkip\n            @object.tempSettings.skip = no\n\n        if GameManager.tempSettings.skip\n            @skipContent()\n\n    ###*\n    * Updates the scene's content.\n    *\n    * @method updateContent\n    ###\n    updateContent: ->\n        #if !@object.interpreter.isRunning and !Graphics.frozen\n        #    @setupInterpreter()\n        GameManager.scene = @object\n        Graphics.viewport.update()\n        @object.viewport.update()\n\n        @updateSkipping()\n        @updateVideo()\n        @updateShortcuts()\n\n        super()\n\nvn.Component_GameSceneBehavior = Component_GameSceneBehavior",
        "compiledContent": "// Generated by CoffeeScript 1.12.7\n(function() {\n  var Component_GameSceneBehavior,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  Component_GameSceneBehavior = (function(superClass) {\n    extend(Component_GameSceneBehavior, superClass);\n\n\n    /**\n    * Defines the behavior of visual novel game scene.\n    *\n    * @module vn\n    * @class Component_GameSceneBehavior\n    * @extends gs.Component_LayoutSceneBehavior\n    * @memberof vn\n     */\n\n    function Component_GameSceneBehavior() {\n      Component_GameSceneBehavior.__super__.constructor.call(this);\n      this.onAutoCommonEventStart = (function(_this) {\n        return function() {\n          _this.object.removeComponent(_this.object.interpreter);\n          return _this.object.interpreter.stop();\n        };\n      })(this);\n      this.onAutoCommonEventFinish = (function(_this) {\n        return function() {\n          if (!_this.object.components.contains(_this.object.interpreter)) {\n            _this.object.addComponent(_this.object.interpreter);\n          }\n          return _this.object.interpreter.resume();\n        };\n      })(this);\n      this.resourceContext = null;\n      this.objectDomain = \"\";\n    }\n\n\n    /**\n    * Initializes the scene.\n    *\n    * @method initialize\n     */\n\n    Component_GameSceneBehavior.prototype.initialize = function() {\n      var ref, saveGame, sceneUid, sprite;\n      if (SceneManager.previousScenes.length === 0) {\n        gs.GlobalEventManager.clearExcept(this.object.commonEventContainer.subObjects);\n      }\n      this.resourceContext = ResourceManager.createContext();\n      ResourceManager.context = this.resourceContext;\n      Graphics.freeze();\n      saveGame = GameManager.loadedSaveGame;\n      sceneUid = null;\n      if (saveGame) {\n        sceneUid = saveGame.sceneUid;\n        this.object.sceneData = saveGame.data;\n      } else {\n        sceneUid = ((ref = $PARAMS.preview) != null ? ref.scene.uid : void 0) || this.object.sceneData.uid || RecordManager.system.startInfo.scene.uid;\n      }\n      this.object.sceneDocument = DataManager.getDocument(sceneUid);\n      if (this.object.sceneDocument && this.object.sceneDocument.items.type === \"vn.scene\") {\n        this.object.chapter = DataManager.getDocument(this.object.sceneDocument.items.chapterUid);\n        this.object.currentCharacter = {\n          \"name\": \"\"\n        };\n        if (!GameManager.initialized) {\n          GameManager.initialize();\n        }\n        GameManager.preloadCommonEvents();\n        LanguageManager.loadBundles();\n      } else {\n        sprite = new gs.Sprite();\n        sprite.bitmap = new gs.Bitmap(Graphics.width, 50);\n        sprite.bitmap.drawText(0, 0, Graphics.width, 50, \"No Start Scene selected\", 1, 0);\n        sprite.srcRect = new gs.Rect(0, 0, Graphics.width, 50);\n        sprite.y = (Graphics.height - 50) / 2;\n        sprite.z = 10000;\n      }\n      return this.setupScreen();\n    };\n\n\n    /**\n    * Disposes the scene.\n    *\n    * @method dispose\n     */\n\n    Component_GameSceneBehavior.prototype.dispose = function() {\n      var event, j, len, ref;\n      ResourceManager.context = this.resourceContext;\n      this.object.removeObject(this.object.commonEventContainer);\n      this.show(false);\n      ref = GameManager.commonEvents;\n      for (j = 0, len = ref.length; j < len; j++) {\n        event = ref[j];\n        if (event) {\n          event.events.offByOwner(\"start\", this.object);\n          event.events.offByOwner(\"finish\", this.object);\n        }\n      }\n      if (this.object.video) {\n        this.object.video.dispose();\n        this.object.video.onEnded();\n      }\n      return Component_GameSceneBehavior.__super__.dispose.call(this);\n    };\n\n    Component_GameSceneBehavior.prototype.changePictureDomain = function(domain) {\n      this.object.pictureContainer.behavior.changeDomain(domain);\n      return this.object.pictures = this.object.pictureContainer.subObjects;\n    };\n\n    Component_GameSceneBehavior.prototype.changeTextDomain = function(domain) {\n      this.object.textContainer.behavior.changeDomain(domain);\n      return this.object.texts = this.object.textContainer.subObjects;\n    };\n\n    Component_GameSceneBehavior.prototype.changeVideoDomain = function(domain) {\n      this.object.videoContainer.behavior.changeDomain(domain);\n      return this.object.videos = this.object.videoContainer.subObjects;\n    };\n\n    Component_GameSceneBehavior.prototype.changeHotspotDomain = function(domain) {\n      this.object.hotspotContainer.behavior.changeDomain(domain);\n      return this.object.hotspots = this.object.hotspotContainer.subObjects;\n    };\n\n    Component_GameSceneBehavior.prototype.changeMessageAreaDomain = function(domain) {\n      this.object.messageAreaContainer.behavior.changeDomain(domain);\n      return this.object.messageAreas = this.object.messageAreaContainer.subObjects;\n    };\n\n\n    /**\n    * Shows/Hides the current scene. A hidden scene is no longer shown and executed\n    * but all objects and data is still there and be shown again anytime.\n    *\n    * @method show\n    * @param {boolean} visible - Indicates if the scene should be shown or hidden.\n     */\n\n    Component_GameSceneBehavior.prototype.show = function(visible) {\n      var ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7;\n      if (visible) {\n        this.object.viewport = GameManager.sceneViewport;\n      }\n      window.$dataFields = this.dataFields;\n      this.object.visible = visible;\n      if ((ref = this.object.layout) != null) {\n        ref.update();\n      }\n      this.object.pictureContainer.behavior.setVisible(visible);\n      this.object.hotspotContainer.behavior.setVisible(visible);\n      this.object.textContainer.behavior.setVisible(visible);\n      this.object.videoContainer.behavior.setVisible(visible);\n      this.object.messageAreaContainer.behavior.setVisible(visible);\n      this.object.viewportContainer.behavior.setVisible(visible);\n      this.object.characterContainer.behavior.setVisible(visible);\n      this.object.backgroundContainer.behavior.setVisible(visible);\n      if ((ref1 = this.viewport) != null) {\n        ref1.visible = visible;\n      }\n      if ((ref2 = this.object.choiceWindow) != null) {\n        ref2.visible = visible;\n      }\n      if ((ref3 = this.object.inputNumberBox) != null) {\n        ref3.visible = visible;\n      }\n      if ((ref4 = this.object.inputTextBox) != null) {\n        ref4.visible = visible;\n      }\n      if ((ref5 = this.object.inputTextBox) != null) {\n        ref5.update();\n      }\n      if ((ref6 = this.object.inputNumberBox) != null) {\n        ref6.update();\n      }\n      if ((ref7 = this.object.choiceWindow) != null) {\n        ref7.update();\n      }\n      GameManager.tempSettings.skip = false;\n      return this.setupCommonEvents();\n    };\n\n\n    /**\n    * Sets up common event handling.\n    *\n    * @method setupCommonEvents\n     */\n\n    Component_GameSceneBehavior.prototype.setupCommonEvents = function() {\n      var commonEvents, event, i, j, k, len, len1, ref, ref1, ref2, ref3;\n      commonEvents = (ref = this.object.sceneData) != null ? ref.commonEvents : void 0;\n      if (commonEvents) {\n        for (i = j = 0, len = commonEvents.length; j < len; i = ++j) {\n          event = commonEvents[i];\n          if (event && this.object.commonEventContainer.subObjects.indexOf(event) === -1) {\n            this.object.commonEventContainer.setObject(event, i);\n            event.behavior.setupEventHandlers();\n            if ((ref1 = event.interpreter) != null ? ref1.isRunning : void 0) {\n              event.events.emit(\"start\", event);\n            }\n          }\n        }\n      } else {\n        ref2 = GameManager.commonEvents;\n        for (i = k = 0, len1 = ref2.length; k < len1; i = ++k) {\n          event = ref2[i];\n          if (event && (event.record.startCondition === 1 || event.record.parallel) && this.object.commonEventContainer.subObjects.indexOf(event) === -1) {\n            this.object.commonEventContainer.setObject(event, i);\n            event.events.offByOwner(\"start\", this.object);\n            event.events.offByOwner(\"finish\", this.object);\n            if (!event.record.parallel) {\n              event.events.on(\"start\", gs.CallBack(\"onAutoCommonEventStart\", this), null, this.object);\n              event.events.on(\"finish\", gs.CallBack(\"onAutoCommonEventFinish\", this), null, this.object);\n            }\n            if ((ref3 = event.interpreter) != null ? ref3.isRunning : void 0) {\n              event.events.emit(\"start\", event);\n            }\n          }\n        }\n      }\n      return null;\n    };\n\n\n    /**\n    * Sets up main interpreter.\n    *\n    * @method setupInterpreter\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.setupInterpreter = function() {\n      this.object.commands = this.object.sceneDocument.items.commands;\n      if (this.object.sceneData.interpreter) {\n        this.object.removeComponent(this.object.interpreter);\n        this.object.interpreter = this.object.sceneData.interpreter;\n        this.object.addComponent(this.object.interpreter);\n        this.object.interpreter.context.set(this.object.sceneDocument.uid, this.object);\n        return this.object.interpreter.object = this.object;\n      } else {\n        this.object.interpreter.setup();\n        this.object.interpreter.context.set(this.object.sceneDocument.uid, this.object);\n        return this.object.interpreter.start();\n      }\n    };\n\n\n    /**\n    * Sets up characters and restores them from loaded save game if necessary.\n    *\n    * @method setupCharacters\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.setupCharacters = function() {\n      var c, i, j, len, ref;\n      if (this.object.sceneData.characters != null) {\n        ref = this.object.sceneData.characters;\n        for (i = j = 0, len = ref.length; j < len; i = ++j) {\n          c = ref[i];\n          this.object.characterContainer.setObject(c, i);\n        }\n      }\n      return this.object.currentCharacter = this.object.sceneData.currentCharacter || {\n        name: \"\"\n      };\n    };\n\n\n    /**\n    * Sets up viewports and restores them from loaded save game if necessary.\n    *\n    * @method setupViewports\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.setupViewports = function() {\n      var i, j, len, ref, ref1, results, viewport, viewports;\n      viewports = (ref = (ref1 = this.object.sceneData) != null ? ref1.viewports : void 0) != null ? ref : [];\n      results = [];\n      for (i = j = 0, len = viewports.length; j < len; i = ++j) {\n        viewport = viewports[i];\n        if (viewport) {\n          results.push(this.object.viewportContainer.setObject(viewport, i));\n        } else {\n          results.push(void 0);\n        }\n      }\n      return results;\n    };\n\n\n    /**\n    * Sets up backgrounds and restores them from loaded save game if necessary.\n    *\n    * @method setupBackgrounds\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.setupBackgrounds = function() {\n      var b, backgrounds, i, j, len, ref, ref1, results;\n      backgrounds = (ref = (ref1 = this.object.sceneData) != null ? ref1.backgrounds : void 0) != null ? ref : [];\n      results = [];\n      for (i = j = 0, len = backgrounds.length; j < len; i = ++j) {\n        b = backgrounds[i];\n        results.push(this.object.backgroundContainer.setObject(b, i));\n      }\n      return results;\n    };\n\n\n    /**\n    * Sets up pictures and restores them from loaded save game if necessary.\n    *\n    * @method setupPictures\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.setupPictures = function() {\n      var domain, i, path, picture, pictures, ref, ref1, results;\n      pictures = (ref = (ref1 = this.object.sceneData) != null ? ref1.pictures : void 0) != null ? ref : {};\n      results = [];\n      for (domain in pictures) {\n        this.object.pictureContainer.behavior.changeDomain(domain);\n        if (pictures[domain]) {\n          results.push((function() {\n            var j, len, ref2, results1;\n            ref2 = pictures[domain];\n            results1 = [];\n            for (i = j = 0, len = ref2.length; j < len; i = ++j) {\n              picture = ref2[i];\n              this.object.pictureContainer.setObject(picture, i);\n              if (picture != null ? picture.image : void 0) {\n                path = \"Graphics/Pictures/\" + picture.image;\n                results1.push(this.resourceContext.add(path, ResourceManager.resourcesByPath[path]));\n              } else {\n                results1.push(void 0);\n              }\n            }\n            return results1;\n          }).call(this));\n        } else {\n          results.push(void 0);\n        }\n      }\n      return results;\n    };\n\n\n    /**\n    * Sets up texts and restores them from loaded save game if necessary.\n    *\n    * @method setupTexts\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.setupTexts = function() {\n      var domain, i, ref, ref1, results, text, texts;\n      texts = (ref = (ref1 = this.object.sceneData) != null ? ref1.texts : void 0) != null ? ref : {};\n      results = [];\n      for (domain in texts) {\n        this.object.textContainer.behavior.changeDomain(domain);\n        if (texts[domain]) {\n          results.push((function() {\n            var j, len, ref2, results1;\n            ref2 = texts[domain];\n            results1 = [];\n            for (i = j = 0, len = ref2.length; j < len; i = ++j) {\n              text = ref2[i];\n              results1.push(this.object.textContainer.setObject(text, i));\n            }\n            return results1;\n          }).call(this));\n        } else {\n          results.push(void 0);\n        }\n      }\n      return results;\n    };\n\n\n    /**\n    * Sets up videos and restores them from loaded save game if necessary.\n    *\n    * @method setupVideos\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.setupVideos = function() {\n      var domain, i, path, ref, ref1, results, video, videos;\n      videos = (ref = (ref1 = this.object.sceneData) != null ? ref1.videos : void 0) != null ? ref : {};\n      results = [];\n      for (domain in videos) {\n        this.object.videoContainer.behavior.changeDomain(domain);\n        if (videos[domain]) {\n          results.push((function() {\n            var j, len, ref2, results1;\n            ref2 = videos[domain];\n            results1 = [];\n            for (i = j = 0, len = ref2.length; j < len; i = ++j) {\n              video = ref2[i];\n              if (video) {\n                path = \"Movies/\" + video.video;\n                this.resourceContext.add(path, ResourceManager.resourcesByPath[path]);\n                video.visible = true;\n                video.update();\n              }\n              results1.push(this.object.videoContainer.setObject(video, i));\n            }\n            return results1;\n          }).call(this));\n        } else {\n          results.push(void 0);\n        }\n      }\n      return results;\n    };\n\n\n    /**\n    * Sets up hotspots and restores them from loaded save game if necessary.\n    *\n    * @method setupHotspots\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.setupHotspots = function() {\n      var domain, hotspot, hotspots, i, ref, ref1, results;\n      hotspots = (ref = (ref1 = this.object.sceneData) != null ? ref1.hotspots : void 0) != null ? ref : {};\n      results = [];\n      for (domain in hotspots) {\n        this.object.hotspotContainer.behavior.changeDomain(domain);\n        if (hotspots[domain]) {\n          results.push((function() {\n            var j, len, ref2, results1;\n            ref2 = hotspots[domain];\n            results1 = [];\n            for (i = j = 0, len = ref2.length; j < len; i = ++j) {\n              hotspot = ref2[i];\n              results1.push(this.object.hotspotContainer.setObject(hotspot, i));\n            }\n            return results1;\n          }).call(this));\n        } else {\n          results.push(void 0);\n        }\n      }\n      return results;\n    };\n\n\n    /**\n    * Sets up layout.\n    *\n    * @method setupLayout\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.setupLayout = function() {\n      var advVisible, ref, ref1;\n      this.dataFields = ui.UIManager.dataSources[ui.UiFactory.layouts.gameLayout.dataSource || \"default\"]();\n      this.dataFields.scene = this.object;\n      window.$dataFields = this.dataFields;\n      advVisible = this.object.messageMode === vn.MessageMode.ADV;\n      this.object.layout = ui.UiFactory.createFromDescriptor(ui.UiFactory.layouts.gameLayout, this.object);\n      this.object.layout.visible = advVisible;\n      $gameMessage_message.visible = advVisible;\n      this.object.layout.ui.prepare();\n      this.object.choices = ((ref = this.object.sceneData) != null ? ref.choices : void 0) || this.object.choices;\n      if (((ref1 = this.object.choices) != null ? ref1.length : void 0) > 0) {\n        this.showChoices(gs.CallBack(\"onChoiceAccept\", this.object.interpreter, {\n          pointer: this.object.interpreter.pointer,\n          params: this.params\n        }));\n      }\n      if (this.object.interpreter.waitingFor.inputNumber) {\n        this.showInputNumber(GameManager.tempFields.digits, gs.CallBack(\"onInputNumberFinish\", this.object.interpreter, this.object.interpreter));\n      }\n      if (this.object.interpreter.waitingFor.inputText) {\n        return this.showInputText(GameManager.tempFields.letters, gs.CallBack(\"onInputTextFinish\", this.object.interpreter, this.object.interpreter));\n      }\n    };\n\n\n    /**\n    * Sets up the main viewport / screen viewport.\n    *\n    * @method setupMainViewport\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.setupMainViewport = function() {\n      if (!this.object.sceneData.viewport) {\n        GameManager.sceneViewport.removeComponent(GameManager.sceneViewport.visual);\n        GameManager.sceneViewport.dispose();\n        GameManager.sceneViewport = new gs.Object_Viewport(GameManager.sceneViewport.visual.viewport);\n        this.viewport = GameManager.sceneViewport.visual.viewport;\n        return this.object.viewport = GameManager.sceneViewport;\n      } else {\n        GameManager.sceneViewport.dispose();\n        GameManager.sceneViewport = this.object.sceneData.viewport;\n        this.object.viewport = this.object.sceneData.viewport;\n        this.viewport = this.object.viewport.visual.viewport;\n        return this.viewport.viewport = Graphics.viewport;\n      }\n    };\n\n\n    /**\n    * Sets up screen.\n    *\n    * @method setupScreen\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.setupScreen = function() {\n      if (this.object.sceneData.screen) {\n        return this.object.viewport.restore(this.object.sceneData.screen);\n      }\n    };\n\n\n    /**\n    * Restores main interpreter from loaded save game.\n    *\n    * @method restoreInterpreter\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.restoreInterpreter = function() {\n      if (this.object.sceneData.interpreter) {\n        return this.object.interpreter.restore();\n      }\n    };\n\n\n    /**\n    * Restores message box from loaded save game.\n    *\n    * @method restoreMessageBox\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.restoreMessageBox = function() {\n      var c, j, k, len, len1, message, messageBox, messageBoxes, messageObject, ref, ref1, results;\n      messageBoxes = (ref = this.object.sceneData) != null ? ref.messageBoxes : void 0;\n      if (messageBoxes) {\n        results = [];\n        for (j = 0, len = messageBoxes.length; j < len; j++) {\n          messageBox = messageBoxes[j];\n          messageObject = gs.ObjectManager.current.objectById(messageBox.id);\n          messageObject.visible = messageBox.visible;\n          if (messageBox.message) {\n            messageBox.message.textRenderer.disposeEventHandlers();\n            message = gs.ObjectManager.current.objectById(messageBox.message.id);\n            message.textRenderer.dispose();\n            Object.mixin(message, messageBox.message, ui.Object_Message.objectCodecBlackList.concat([\"origin\"]));\n            ref1 = message.components;\n            for (k = 0, len1 = ref1.length; k < len1; k++) {\n              c = ref1[k];\n              c.object = message;\n            }\n            results.push(message.textRenderer.setupEventHandlers());\n          } else {\n            results.push(void 0);\n          }\n        }\n        return results;\n      }\n    };\n\n\n    /**\n    * Restores message from loaded save game.\n    *\n    * @method restoreMessages\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.restoreMessages = function() {\n      var area, c, domain, i, message, messageArea, messageAreas, messageLayout, ref, results;\n      if ((ref = this.object.sceneData) != null ? ref.messageAreas : void 0) {\n        results = [];\n        for (domain in this.object.sceneData.messageAreas) {\n          this.object.messageAreaContainer.behavior.changeDomain(domain);\n          messageAreas = this.object.sceneData.messageAreas;\n          if (messageAreas[domain]) {\n            results.push((function() {\n              var j, k, len, len1, ref1, ref2, results1;\n              ref1 = messageAreas[domain];\n              results1 = [];\n              for (i = j = 0, len = ref1.length; j < len; i = ++j) {\n                area = ref1[i];\n                if (area) {\n                  messageArea = new gs.Object_MessageArea();\n                  messageLayout = ui.UIManager.createControlFromDescriptor({\n                    type: \"ui.CustomGameMessage\",\n                    id: \"customGameMessage_\" + i,\n                    params: {\n                      id: \"customGameMessage_\" + i\n                    }\n                  }, messageArea);\n                  message = gs.ObjectManager.current.objectById(\"customGameMessage_\" + i + \"_message\");\n                  area.message.textRenderer.disposeEventHandlers();\n                  message.textRenderer.dispose();\n                  Object.mixin(message, area.message);\n                  ref2 = message.components;\n                  for (k = 0, len1 = ref2.length; k < len1; k++) {\n                    c = ref2[k];\n                    c.object = message;\n                  }\n                  messageLayout.dstRect.x = area.layout.dstRect.x;\n                  messageLayout.dstRect.y = area.layout.dstRect.y;\n                  messageLayout.dstRect.width = area.layout.dstRect.width;\n                  messageLayout.dstRect.height = area.layout.dstRect.height;\n                  messageLayout.needsUpdate = true;\n                  message.textRenderer.setupEventHandlers();\n                  messageLayout.update();\n                  messageArea.message = message;\n                  messageArea.layout = messageLayout;\n                  messageArea.addObject(messageLayout);\n                  results1.push(this.object.messageAreaContainer.setObject(messageArea, i));\n                } else {\n                  results1.push(void 0);\n                }\n              }\n              return results1;\n            }).call(this));\n          } else {\n            results.push(void 0);\n          }\n        }\n        return results;\n      }\n    };\n\n\n    /**\n    * Restores audio-playback from loaded save game.\n    *\n    * @method restoreAudioPlayback\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.restoreAudioPlayback = function() {\n      var b, j, len, ref;\n      if (this.object.sceneData.audio) {\n        ref = this.object.sceneData.audio.audioBuffers;\n        for (j = 0, len = ref.length; j < len; j++) {\n          b = ref[j];\n          AudioManager.audioBuffers.push(b);\n        }\n        AudioManager.audioBuffersByLayer = this.object.sceneData.audio.audioBuffersByLayer;\n        AudioManager.audioLayers = this.object.sceneData.audio.audioLayers;\n        return AudioManager.soundReferences = this.object.sceneData.audio.soundReferences;\n      }\n    };\n\n\n    /**\n    * Restores the scene objects from the current loaded save-game. If no save-game is\n    * present in GameManager.loadedSaveGame, nothing will happen.\n    *\n    * @method restoreScene\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.restoreScene = function() {\n      var c, context, j, len, ref, ref1, saveGame;\n      saveGame = GameManager.loadedSaveGame;\n      if (saveGame) {\n        context = new gs.ObjectCodecContext([Graphics.viewport, this.object, this], saveGame.encodedObjectStore, null);\n        saveGame.data = gs.ObjectCodec.decode(saveGame.data, context);\n        ref = saveGame.data.characterNames;\n        for (j = 0, len = ref.length; j < len; j++) {\n          c = ref[j];\n          if (c) {\n            if ((ref1 = RecordManager.characters[c.index]) != null) {\n              ref1.name = c.name;\n            }\n          }\n        }\n        GameManager.restore(saveGame);\n        gs.ObjectCodec.onRestore(saveGame.data, context);\n        this.resourceContext.fromDataBundle(saveGame.data.resourceContext, ResourceManager.resourcesByPath);\n        this.object.sceneData = saveGame.data;\n        return Graphics.frameCount = saveGame.data.frameCount;\n      }\n    };\n\n\n    /**\n    * Prepares all data for the scene and loads the necessary graphic and audio resources.\n    *\n    * @method prepareData\n    * @abstract\n     */\n\n    Component_GameSceneBehavior.prototype.prepareData = function() {\n      GameManager.scene = this.object;\n      gs.ObjectManager.current = this.objectManager;\n      this.object.sceneData.uid = this.object.sceneDocument.uid;\n      if (!ResourceLoader.loadEventCommandsData(this.object.sceneDocument.items.commands)) {\n        ResourceLoader.loadEventCommandsGraphics(this.object.sceneDocument.items.commands);\n        GameManager.backlog = this.object.sceneData.backlog || GameManager.sceneData.backlog || [];\n        ResourceLoader.loadSystemSounds();\n        ResourceLoader.loadSystemGraphics();\n        ResourceLoader.loadUiTypesGraphics(ui.UiFactory.customTypes);\n        ResourceLoader.loadUiLayoutGraphics(ui.UiFactory.layouts.gameLayout);\n        if (this.dataFields != null) {\n          ResourceLoader.loadUiDataFieldsGraphics(this.dataFields);\n        }\n        $tempFields.choiceTimer = this.object.choiceTimer;\n        return GameManager.variableStore.setup({\n          id: this.object.sceneDocument.uid\n        });\n      }\n    };\n\n\n    /**\n    * Prepares all visual game object for the scene.\n    *\n    * @method prepareVisual\n     */\n\n    Component_GameSceneBehavior.prototype.prepareVisual = function() {\n      var ref;\n      if (this.object.layout) {\n        return;\n      }\n      if (GameManager.tempFields.isExitingGame) {\n        GameManager.tempFields.isExitingGame = false;\n        gs.GameNotifier.postResetSceneChange(this.object.sceneDocument.items.name);\n      } else {\n        gs.GameNotifier.postSceneChange(this.object.sceneDocument.items.name);\n      }\n      this.restoreScene();\n      this.object.messageMode = (ref = this.object.sceneData.messageMode) != null ? ref : vn.MessageMode.ADV;\n      this.setupMainViewport();\n      this.setupViewports();\n      this.setupCharacters();\n      this.setupBackgrounds();\n      this.setupPictures();\n      this.setupTexts();\n      this.setupVideos();\n      this.setupHotspots();\n      this.setupInterpreter();\n      this.setupLayout();\n      this.setupCommonEvents();\n      this.restoreMessageBox();\n      this.restoreInterpreter();\n      this.restoreMessages();\n      this.restoreAudioPlayback();\n      this.show(true);\n      this.object.sceneData = {};\n      GameManager.sceneData = {};\n      Graphics.update();\n      return this.transition({\n        duration: 0\n      });\n    };\n\n\n    /**\n    * Adds a new character to the scene.\n    *\n    * @method addCharacter\n    * @param {vn.Object_Character} character - The character to add.\n    * @param {boolean} noAnimation - Indicates if the character should be added immediately witout any appear-animation.\n    * @param {Object} animationData - Contains the appear-animation data -> { animation, easing, duration }.\n     */\n\n    Component_GameSceneBehavior.prototype.addCharacter = function(character, noAnimation, animationData) {\n      if (!noAnimation) {\n        character.motionBlur.set(animationData.motionBlur);\n        if (animationData.duration > 0) {\n          if (!noAnimation) {\n            character.animator.appear(character.dstRect.x, character.dstRect.y, animationData.animation, animationData.easing, animationData.duration);\n          }\n        }\n      }\n      character.viewport = this.viewport;\n      character.visible = true;\n      return this.object.characterContainer.addObject(character);\n    };\n\n\n    /**\n    * Removes a character from the scene.\n    *\n    * @method removeCharacter\n    * @param {vn.Object_Character} character - The character to remove.\n    * @param {boolean} noAnimation - Indicates if the character should be disposed immediately witout any disapear-animation.\n    * @param {Object} animationData - Contains the disappear-animation data -> { animation, easing, duration }.\n     */\n\n    Component_GameSceneBehavior.prototype.removeCharacter = function(character, noAnimation, animationData) {\n      if (!noAnimation) {\n        return character != null ? character.animator.disappear(animationData.animation, animationData.easing, animationData.duration, function(sender) {\n          return sender.dispose();\n        }) : void 0;\n      } else {\n        return character != null ? character.dispose() : void 0;\n      }\n    };\n\n\n    /**\n    * Resumes the current scene if it has been paused.\n    *\n    * @method resumeScene\n     */\n\n    Component_GameSceneBehavior.prototype.resumeScene = function() {\n      var message;\n      this.object.pictureContainer.active = true;\n      this.object.characterContainer.active = true;\n      this.object.backgroundContainer.active = true;\n      this.object.textContainer.active = true;\n      this.object.hotspotContainer.active = true;\n      this.object.videoContainer.active = true;\n      message = gs.ObjectManager.current.objectById(\"gameMessage_message\");\n      return message.active = true;\n    };\n\n\n    /**\n    * Pauses the current scene. A paused scene will not continue, messages, pictures, etc. will\n    * stop until the scene resumes.\n    *\n    * @method pauseScene\n     */\n\n    Component_GameSceneBehavior.prototype.pauseScene = function() {\n      var message;\n      this.object.pictureContainer.active = false;\n      this.object.characterContainer.active = false;\n      this.object.backgroundContainer.active = false;\n      this.object.textContainer.active = false;\n      this.object.hotspotContainer.active = false;\n      this.object.videoContainer.active = false;\n      message = gs.ObjectManager.current.objectById(\"gameMessage_message\");\n      return message.active = false;\n    };\n\n\n    /**\n    * Changes the visibility of the entire game UI like the message boxes, etc. to allows\n    * the player to see the entire scene. Useful for CGs, etc.\n    *\n    * @param {boolean} visible - If <b>true</b>, the game UI will be visible. Otherwise it will be hidden.\n    * @method changeUIVisibility\n     */\n\n    Component_GameSceneBehavior.prototype.changeUIVisibility = function(visible) {\n      this.uiVisible = visible;\n      return this.object.layout.visible = visible;\n    };\n\n\n    /**\n    * Shows input-text box to let the user enter a text.\n    *\n    * @param {number} letters - The max. number of letters the user can enter.\n    * @param {gs.Callback} callback - A callback function called if the input-text box has been accepted by the user.\n    * @method showInputText\n     */\n\n    Component_GameSceneBehavior.prototype.showInputText = function(letters, callback) {\n      var ref;\n      if ((ref = this.object.inputTextBox) != null) {\n        ref.dispose();\n      }\n      this.object.inputTextBox = ui.UiFactory.createControlFromDescriptor(ui.UiFactory.customTypes[\"ui.InputTextBox\"], this.object.layout);\n      this.object.inputTextBox.ui.prepare();\n      return this.object.inputTextBox.events.on(\"accept\", callback);\n    };\n\n\n    /**\n    * Shows input-number box to let the user enter a number.\n    *\n    * @param {number} digits - The max. number of digits the user can enter.\n    * @param {gs.Callback} callback - A callback function called if the input-number box has been accepted by the user.\n    * @method showInputNumber\n     */\n\n    Component_GameSceneBehavior.prototype.showInputNumber = function(digits, callback) {\n      var ref;\n      if ((ref = this.object.inputNumberBox) != null) {\n        ref.dispose();\n      }\n      this.object.inputNumberBox = ui.UiFactory.createControlFromDescriptor(ui.UiFactory.customTypes[\"ui.InputNumberBox\"], this.object.layout);\n      this.object.inputNumberBox.ui.prepare();\n      return this.object.inputNumberBox.events.on(\"accept\", callback);\n    };\n\n\n    /**\n    * Shows choices to let the user pick a choice.\n    *\n    * @param {Object[]} choices - An array of choices\n    * @param {gs.Callback} callback - A callback function called if a choice has been picked by the user.\n    * @method showChoices\n     */\n\n    Component_GameSceneBehavior.prototype.showChoices = function(callback) {\n      var ref, useFreeLayout;\n      useFreeLayout = this.object.choices.where(function(x) {\n        return x.dstRect != null;\n      }).length > 0;\n      if ((ref = this.object.choiceWindow) != null) {\n        ref.dispose();\n      }\n      if (useFreeLayout) {\n        this.object.choiceWindow = ui.UiFactory.createControlFromDescriptor(ui.UiFactory.customTypes[\"ui.FreeChoiceBox\"], this.object.layout);\n      } else {\n        this.object.choiceWindow = ui.UiFactory.createControlFromDescriptor(ui.UiFactory.customTypes[\"ui.ChoiceBox\"], this.object.layout);\n      }\n      this.object.choiceWindow.events.on(\"selectionAccept\", callback);\n      return this.object.choiceWindow.ui.prepare();\n    };\n\n\n    /**\n    * Changes the background of the scene.\n    *\n    * @method changeBackground\n    * @param {Object} background - The background graphic object -> { name }\n    * @param {boolean} noAnimation - Indicates if the background should be changed immediately witout any change-animation.\n    * @param {Object} animation - The appear/disappear animation to use.\n    * @param {Object} easing - The easing of the change animation.\n    * @param {number} duration - The duration of the change in frames.\n    * @param {number} ox - The x-origin of the background.\n    * @param {number} oy - The y-origin of the background.\n    * @param {number} layer - The background-layer to change.\n    * @param {boolean} loopHorizontal - Indicates if the background should be looped horizontally.\n    * @param {boolean} loopVertical - Indicates if the background should be looped vertically.\n     */\n\n    Component_GameSceneBehavior.prototype.changeBackground = function(background, noAnimation, animation, easing, duration, ox, oy, layer, loopHorizontal, loopVertical) {\n      var object, otherObject, ref, ref1;\n      if (background != null) {\n        otherObject = this.object.backgrounds[layer];\n        object = new vn.Object_Background();\n        object.image = background.name;\n        object.origin.x = ox;\n        object.origin.y = oy;\n        object.viewport = this.viewport;\n        object.visual.looping.vertical = false;\n        object.visual.looping.horizontal = false;\n        object.update();\n        this.object.backgroundContainer.setObject(object, layer);\n        duration = duration != null ? duration : 30;\n        if (otherObject != null) {\n          otherObject.zIndex = layer;\n        }\n        if (otherObject != null) {\n          if ((ref = otherObject.animator.otherObject) != null) {\n            ref.dispose();\n          }\n        }\n        if (duration === 0) {\n          if (otherObject != null) {\n            otherObject.dispose();\n          }\n          object.visual.looping.vertical = loopVertical;\n          return object.visual.looping.horizontal = loopHorizontal;\n        } else {\n          if (noAnimation) {\n            object.visual.looping.vertical = loopVertical;\n            return object.visual.looping.horizontal = loopHorizontal;\n          } else {\n            object.animator.otherObject = otherObject;\n            return object.animator.appear(0, 0, animation, easing, duration, (function(_this) {\n              return function(sender) {\n                var ref1;\n                sender.update();\n                if ((ref1 = sender.animator.otherObject) != null) {\n                  ref1.dispose();\n                }\n                sender.animator.otherObject = null;\n                sender.visual.looping.vertical = loopVertical;\n                return sender.visual.looping.horizontal = loopHorizontal;\n              };\n            })(this));\n          }\n        }\n      } else {\n        return (ref1 = this.object.backgrounds[layer]) != null ? ref1.animator.hide(duration, easing, (function(_this) {\n          return function() {\n            _this.object.backgrounds[layer].dispose();\n            return _this.object.backgrounds[layer] = null;\n          };\n        })(this)) : void 0;\n      }\n    };\n\n\n    /**\n    * Skips all viewport animations except the main viewport animation.\n    *\n    * @method skipViewports\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.skipViewports = function() {\n      var component, j, k, len, len1, ref, viewport, viewports;\n      viewports = this.object.viewportContainer.subObjects;\n      for (j = 0, len = viewports.length; j < len; j++) {\n        viewport = viewports[j];\n        if (viewport) {\n          ref = viewport.components;\n          for (k = 0, len1 = ref.length; k < len1; k++) {\n            component = ref[k];\n            if (typeof component.skip === \"function\") {\n              component.skip();\n            }\n          }\n        }\n      }\n      return null;\n    };\n\n\n    /**\n    * Skips all picture animations.\n    *\n    * @method skipPictures\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.skipPictures = function() {\n      var component, j, k, len, len1, picture, ref, ref1;\n      ref = this.object.pictures;\n      for (j = 0, len = ref.length; j < len; j++) {\n        picture = ref[j];\n        if (picture) {\n          ref1 = picture.components;\n          for (k = 0, len1 = ref1.length; k < len1; k++) {\n            component = ref1[k];\n            if (typeof component.skip === \"function\") {\n              component.skip();\n            }\n          }\n        }\n      }\n      return null;\n    };\n\n\n    /**\n    * Skips all text animations.\n    *\n    * @method skipTexts\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.skipTexts = function() {\n      var component, j, k, len, len1, ref, ref1, text;\n      ref = this.object.texts;\n      for (j = 0, len = ref.length; j < len; j++) {\n        text = ref[j];\n        if (text) {\n          ref1 = text.components;\n          for (k = 0, len1 = ref1.length; k < len1; k++) {\n            component = ref1[k];\n            if (typeof component.skip === \"function\") {\n              component.skip();\n            }\n          }\n        }\n      }\n      return null;\n    };\n\n\n    /**\n    * Skips all video animations but not the video-playback itself.\n    *\n    * @method skipVideos\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.skipVideos = function() {\n      var component, j, k, len, len1, ref, ref1, video;\n      ref = this.object.videos;\n      for (j = 0, len = ref.length; j < len; j++) {\n        video = ref[j];\n        if (video) {\n          ref1 = video.components;\n          for (k = 0, len1 = ref1.length; k < len1; k++) {\n            component = ref1[k];\n            if (typeof component.skip === \"function\") {\n              component.skip();\n            }\n          }\n        }\n      }\n      return null;\n    };\n\n\n    /**\n    * Skips all background animations.\n    *\n    * @method skipBackgrounds\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.skipBackgrounds = function() {\n      var background, component, j, k, len, len1, ref, ref1;\n      ref = this.object.backgrounds;\n      for (j = 0, len = ref.length; j < len; j++) {\n        background = ref[j];\n        if (background) {\n          ref1 = background.components;\n          for (k = 0, len1 = ref1.length; k < len1; k++) {\n            component = ref1[k];\n            if (typeof component.skip === \"function\") {\n              component.skip();\n            }\n          }\n        }\n      }\n      return null;\n    };\n\n\n    /**\n    * Skips all character animations\n    *\n    * @method skipCharacters\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.skipCharacters = function() {\n      var character, component, j, k, len, len1, ref, ref1;\n      ref = this.object.characters;\n      for (j = 0, len = ref.length; j < len; j++) {\n        character = ref[j];\n        if (character) {\n          ref1 = character.components;\n          for (k = 0, len1 = ref1.length; k < len1; k++) {\n            component = ref1[k];\n            if (typeof component.skip === \"function\") {\n              component.skip();\n            }\n          }\n        }\n      }\n      return null;\n    };\n\n\n    /**\n    * Skips the main viewport animation.\n    *\n    * @method skipMainViewport\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.skipMainViewport = function() {\n      var component, j, len, ref;\n      ref = this.object.viewport.components;\n      for (j = 0, len = ref.length; j < len; j++) {\n        component = ref[j];\n        if (typeof component.skip === \"function\") {\n          component.skip();\n        }\n      }\n      return null;\n    };\n\n\n    /**\n    * Skips all animations of all message boxes defined in MESSAGE_BOX_IDS ui constant.\n    *\n    * @method skipMessageBoxes\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.skipMessageBoxes = function() {\n      var component, j, k, len, len1, messageBox, messageBoxId, ref, ref1;\n      ref = gs.UIConstants.MESSAGE_BOX_IDS || [\"messageBox\", \"nvlMessageBox\"];\n      for (j = 0, len = ref.length; j < len; j++) {\n        messageBoxId = ref[j];\n        messageBox = gs.ObjectManager.current.objectById(messageBoxId);\n        if (messageBox.components) {\n          ref1 = messageBox.components;\n          for (k = 0, len1 = ref1.length; k < len1; k++) {\n            component = ref1[k];\n            if (typeof component.skip === \"function\") {\n              component.skip();\n            }\n          }\n        }\n      }\n      return null;\n    };\n\n\n    /**\n    * Skips all animations of all message areas.\n    *\n    * @method skipMessageAreas\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.skipMessageAreas = function() {\n      var component, j, k, l, len, len1, len2, len3, m, messageArea, msg, ref, ref1, ref2, ref3;\n      ref = this.object.messageAreas;\n      for (j = 0, len = ref.length; j < len; j++) {\n        messageArea = ref[j];\n        if (messageArea != null ? messageArea.message : void 0) {\n          ref1 = messageArea.message.components;\n          for (k = 0, len1 = ref1.length; k < len1; k++) {\n            component = ref1[k];\n            if (typeof component.skip === \"function\") {\n              component.skip();\n            }\n          }\n        }\n      }\n      msg = gs.ObjectManager.current.objectById(\"gameMessage_message\");\n      if (msg) {\n        ref2 = msg.components;\n        for (l = 0, len2 = ref2.length; l < len2; l++) {\n          component = ref2[l];\n          if (typeof component.skip === \"function\") {\n            component.skip();\n          }\n        }\n      }\n      msg = gs.ObjectManager.current.objectById(\"nvlGameMessage_message\");\n      if (msg) {\n        ref3 = msg.components;\n        for (m = 0, len3 = ref3.length; m < len3; m++) {\n          component = ref3[m];\n          if (typeof component.skip === \"function\") {\n            component.skip();\n          }\n        }\n      }\n      return null;\n    };\n\n\n    /**\n    * Skips the scene interpreter timer.\n    *\n    * @method skipInterpreter\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.skipInterpreter = function() {\n      if (this.object.interpreter.waitCounter > GameManager.tempSettings.skipTime) {\n        this.object.interpreter.waitCounter = GameManager.tempSettings.skipTime;\n        if (this.object.interpreter.waitCounter === 0) {\n          return this.object.interpreter.isWaiting = false;\n        }\n      }\n    };\n\n\n    /**\n    * Skips the interpreter timer of all common events.\n    *\n    * @method skipCommonEvents\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.skipCommonEvents = function() {\n      var event, events, j, len, results;\n      events = this.object.commonEventContainer.subObjects;\n      results = [];\n      for (j = 0, len = events.length; j < len; j++) {\n        event = events[j];\n        if ((event != null ? event.interpreter : void 0) && event.interpreter.waitCounter > GameManager.tempSettings.skipTime) {\n          event.interpreter.waitCounter = GameManager.tempSettings.skipTime;\n          if (event.interpreter.waitCounter === 0) {\n            results.push(event.interpreter.isWaiting = false);\n          } else {\n            results.push(void 0);\n          }\n        } else {\n          results.push(void 0);\n        }\n      }\n      return results;\n    };\n\n\n    /**\n    * Skips the scene's content.\n    *\n    * @method skipContent\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.skipContent = function() {\n      this.skipPictures();\n      this.skipTexts();\n      this.skipVideos();\n      this.skipBackgrounds();\n      this.skipCharacters();\n      this.skipMainViewport();\n      this.skipViewports();\n      this.skipMessageBoxes();\n      this.skipMessageAreas();\n      this.skipInterpreter();\n      return this.skipCommonEvents();\n    };\n\n\n    /**\n    * Checks for the shortcut to hide/show the game UI. By default, this is the space-key. You\n    * can override this method to change the shortcut.\n    *\n    * @method updateUIVisibilityShortcut\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.updateUIVisibilityShortcut = function() {\n      if (!this.uiVisible && (Input.trigger(Input.C) || Input.Mouse.buttonDown)) {\n        this.changeUIVisibility(!this.uiVisible);\n      }\n      if (Input.trigger(Input.KEY_SPACE)) {\n        return this.changeUIVisibility(!this.uiVisible);\n      }\n    };\n\n\n    /**\n    * Checks for the shortcut to exit the game. By default, this is the escape-key. You\n    * can override this method to change the shortcut.\n    *\n    * @method updateQuitShortcut\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.updateQuitShortcut = function() {\n      if (Input.trigger(Input.KEY_ESCAPE)) {\n        return gs.Application.exit();\n      }\n    };\n\n\n    /**\n    * Checks for the shortcut to open the settings menu. By default, this is the s-key. You\n    * can override this method to change the shortcut.\n    *\n    * @method updateSettingsShortcut\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.updateSettingsShortcut = function() {\n      if (GameManager.tempSettings.menuAccess && Input.trigger(Input.X)) {\n        return SceneManager.switchTo(new gs.Object_Layout(\"settingsMenuLayout\"), true);\n      }\n    };\n\n\n    /**\n    * Checks for the shortcut to open the settings menu. By default, this is the control-key. You\n    * can override this method to change the shortcut.\n    *\n    * @method updateSkipShortcut\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.updateSkipShortcut = function() {\n      if (this.object.settings.allowSkip) {\n        if (Input.keys[Input.KEY_CONTROL] === 1) {\n          return GameManager.tempSettings.skip = true;\n        } else if (Input.keys[Input.KEY_CONTROL] === 2) {\n          return GameManager.tempSettings.skip = false;\n        }\n      }\n    };\n\n\n    /**\n    * Checks for default keyboard shortcuts e.g space-key to hide the UI, etc.\n    *\n    * @method updateShortcuts\n    * @protected\n     */\n\n    Component_GameSceneBehavior.prototype.updateShortcuts = function() {\n      this.updateSettingsShortcut();\n      this.updateQuitShortcut();\n      this.updateUIVisibilityShortcut();\n      return this.updateSkipShortcut();\n    };\n\n\n    /**\n    * Updates the full screen video played via Play Movie command.\n    *\n    * @method updateVideo\n     */\n\n    Component_GameSceneBehavior.prototype.updateVideo = function() {\n      if (this.object.video != null) {\n        this.object.video.update();\n        if (this.object.settings.allowVideoSkip && (Input.trigger(Input.C) || Input.Mouse.buttons[Input.Mouse.LEFT] === 2)) {\n          this.object.video.stop();\n        }\n        return Input.clear();\n      }\n    };\n\n\n    /**\n    * Updates skipping if enabled.\n    *\n    * @method updateSkipping\n     */\n\n    Component_GameSceneBehavior.prototype.updateSkipping = function() {\n      if (!this.object.settings.allowSkip) {\n        this.object.tempSettings.skip = false;\n      }\n      if (GameManager.tempSettings.skip) {\n        return this.skipContent();\n      }\n    };\n\n\n    /**\n    * Updates the scene's content.\n    *\n    * @method updateContent\n     */\n\n    Component_GameSceneBehavior.prototype.updateContent = function() {\n      GameManager.scene = this.object;\n      Graphics.viewport.update();\n      this.object.viewport.update();\n      this.updateSkipping();\n      this.updateVideo();\n      this.updateShortcuts();\n      return Component_GameSceneBehavior.__super__.updateContent.call(this);\n    };\n\n    return Component_GameSceneBehavior;\n\n  })(gs.Component_LayoutSceneBehavior);\n\n  vn.Component_GameSceneBehavior = Component_GameSceneBehavior;\n\n}).call(this);\n"
    },
    "summary": [
        "name",
        "type",
        "order"
    ],
    "externalItems": []
}