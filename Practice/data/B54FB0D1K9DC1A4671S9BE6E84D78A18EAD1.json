{
    "uid": "B54FB0D1K9DC1A4671S9BE6E84D78A18EAD1",
    "isLoaded": true,
    "lastModificationTime": 0,
    "items": {
        "name": "Component_LayoutBehavior",
        "type": "game_script",
        "order": 3,
        "parentId": "01A95DA3K01E8A4CB4SBE17E790BCE1FC035",
        "folder": false,
        "content": "# ===================================================================\n#\n#   Script: Component_LayoutBehavior\n#\n#   $$COPYRIGHT$$\n#\n# ===================================================================\nclass Component_LayoutBehavior extends gs.Component_Visual\n    ###*\n    * The base class of all layout-components. A layout-component is used\n    * to layout assigned sub-objects in a specific way depending on the layout-type.\n    * For example: A grid-layout layouts its sub-objects like a grid using rows\n    * and columns. The game object needs a container-component.<br><br>\n    *\n    * A layout can also be configured as scrollable. In that case, layout's content\n    * can be larger than the layout-bounds and is automatically clipped. The content\n    * can be scrolled using mouse-wheel or touch-gesture.\n    *\n    * @module gs\n    * @class Component_LayoutBehavior\n    * @extends gs.Component\n    * @memberof gs\n    * @constructor\n    ###\n    constructor: ->\n        ###*\n        * Content size of the layout.\n        * @property contentSize\n        * @type gs.Size\n        * @readOnly\n        ###\n        @contentSize = width: 0, height: 0\n\n    ###*\n    * Disposes the layout and all its sub-objects.\n    *\n    * @method dispose\n    ###  \n    # FIXME: Is that still necessary? If the parent game object is disposed\n    # all sub-objects are disposed as well.\n    dispose: ->\n        for control in @object.controls\n            control?.dispose()\n    \n    ###*\n    * Initializes the layout.\n    *\n    * @method setup\n    ### \n    setup: ->\n     \n    ###*\n    * Sizes the layout to fit its content.\n    *\n    * @method sizeToFit\n    * @abstract\n    ### \n    sizeToFit: ->\n        \n    ###*\n    * Sort-Function to sort sub-objects by order-index.\n    *\n    * @method sort_\n    * @protected\n    * @param {gs.Object_Base} a Object A\n    * @param {gs.Object_Base} b Object B\n    ###    \n    sort_: (a, b) ->\n        if a.order > b.order\n          return -1\n        else if a.order < b.order\n          return 1\n        else\n          return 0\n    \n    ###*\n    * Updates a specified control.\n    *\n    * @method updateControl\n    * @protected\n    * @param {gs.Object_Base} control The control to update\n    ### \n    updateControl: (control) ->\n        @object.rIndex = Math.max(@object.rIndex, control.rIndex)\n        \n        if control.updateBehavior == ui.UpdateBehavior.CONTINUOUS\n            control.needsUpdate = yes\n            \n        if control.inheritProperties\n            control.ui.enabled = @object.ui.enabled\n            control.opacity = @object.opacity\n            control.zoom = @object.zoom\n            control.color = @object.color\n            control.tone = @object.tone\n            control.angle = @object.angle\n            control.anchor.x = @object.anchor.x\n            control.anchor.y = @object.anchor.y\n            \n            \n        if control.needsUpdate\n            control.needsUpdate = no\n            control.update()\n            control.parent = @object\n            \n        \n        if @object.clipRect?\n            control.clipRect = @object.clipRect\n     \n    ###*\n    * Updates the content size of the layout. Only works if scrolling is\n    * enabled.\n    *\n    * @method updateContentSize\n    * @protected\n    ### \n    updateContentSize: ->\n        if @object.scrollable\n            @contentSize.width = 0\n            @contentSize.height = 0\n            for control in @object.controls\n                if control\n                    @contentSize.width += control.margin.left + control.dstRect.width + control.margin.right\n                    @contentSize.height += control.margin.top + control.dstRect.height + control.margin.bottom\n            \n            @object.contentHeight = @contentSize.height\n            @object.contentWidth = @contentSize.width\n        \n    ###*\n    * Updates scrolling.\n    *\n    * @method updateScroll\n    ###\n    updateScroll: ->\n        if @object.scrollable\n            @object.scrollableHeight = Math.max(0, @contentSize.height - @object.dstRect.height)\n            if Input.Mouse.wheel <= -1\n                @object.scrollOffsetY = Math.max(@object.scrollOffsetY - Input.Mouse.wheelSpeed * 0.1, 0)\n               \n            if Input.Mouse.wheel >= 1\n                @object.scrollOffsetY = Math.min(@object.scrollOffsetY - Input.Mouse.wheelSpeed * 0.1, @object.scrollableHeight)\n                \n        \n            @object.scrollOffsetY = Math.max(Math.min(@object.scrollOffsetY, @object.scrollableHeight), 0)\n     \n    ###*\n    * Updates the layout's content.\n    *\n    * @method updateContent\n    ###  \n    updateContent: ->\n        \n    ###*\n    * Updates the layout.\n    *\n    * @method update\n    ###    \n    update: ->\n        super\n        \n        @updateContentSize()\n        @updateScroll()\n        \n        \n        #if @object.needsSort\n        #    @object.subObjects.sort(@sort_)\n        #    @object.needsSort = no\n    \n        \ngs.Component_LayoutBehavior = Component_LayoutBehavior",
        "compiledContent": "// Generated by CoffeeScript 1.12.7\n(function() {\n  var Component_LayoutBehavior,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  Component_LayoutBehavior = (function(superClass) {\n    extend(Component_LayoutBehavior, superClass);\n\n\n    /**\n    * The base class of all layout-components. A layout-component is used\n    * to layout assigned sub-objects in a specific way depending on the layout-type.\n    * For example: A grid-layout layouts its sub-objects like a grid using rows\n    * and columns. The game object needs a container-component.<br><br>\n    *\n    * A layout can also be configured as scrollable. In that case, layout's content\n    * can be larger than the layout-bounds and is automatically clipped. The content\n    * can be scrolled using mouse-wheel or touch-gesture.\n    *\n    * @module gs\n    * @class Component_LayoutBehavior\n    * @extends gs.Component\n    * @memberof gs\n    * @constructor\n     */\n\n    function Component_LayoutBehavior() {\n\n      /**\n      * Content size of the layout.\n      * @property contentSize\n      * @type gs.Size\n      * @readOnly\n       */\n      this.contentSize = {\n        width: 0,\n        height: 0\n      };\n    }\n\n\n    /**\n    * Disposes the layout and all its sub-objects.\n    *\n    * @method dispose\n     */\n\n    Component_LayoutBehavior.prototype.dispose = function() {\n      var control, i, len, ref, results;\n      ref = this.object.controls;\n      results = [];\n      for (i = 0, len = ref.length; i < len; i++) {\n        control = ref[i];\n        results.push(control != null ? control.dispose() : void 0);\n      }\n      return results;\n    };\n\n\n    /**\n    * Initializes the layout.\n    *\n    * @method setup\n     */\n\n    Component_LayoutBehavior.prototype.setup = function() {};\n\n\n    /**\n    * Sizes the layout to fit its content.\n    *\n    * @method sizeToFit\n    * @abstract\n     */\n\n    Component_LayoutBehavior.prototype.sizeToFit = function() {};\n\n\n    /**\n    * Sort-Function to sort sub-objects by order-index.\n    *\n    * @method sort_\n    * @protected\n    * @param {gs.Object_Base} a Object A\n    * @param {gs.Object_Base} b Object B\n     */\n\n    Component_LayoutBehavior.prototype.sort_ = function(a, b) {\n      if (a.order > b.order) {\n        return -1;\n      } else if (a.order < b.order) {\n        return 1;\n      } else {\n        return 0;\n      }\n    };\n\n\n    /**\n    * Updates a specified control.\n    *\n    * @method updateControl\n    * @protected\n    * @param {gs.Object_Base} control The control to update\n     */\n\n    Component_LayoutBehavior.prototype.updateControl = function(control) {\n      this.object.rIndex = Math.max(this.object.rIndex, control.rIndex);\n      if (control.updateBehavior === ui.UpdateBehavior.CONTINUOUS) {\n        control.needsUpdate = true;\n      }\n      if (control.inheritProperties) {\n        control.ui.enabled = this.object.ui.enabled;\n        control.opacity = this.object.opacity;\n        control.zoom = this.object.zoom;\n        control.color = this.object.color;\n        control.tone = this.object.tone;\n        control.angle = this.object.angle;\n        control.anchor.x = this.object.anchor.x;\n        control.anchor.y = this.object.anchor.y;\n      }\n      if (control.needsUpdate) {\n        control.needsUpdate = false;\n        control.update();\n        control.parent = this.object;\n      }\n      if (this.object.clipRect != null) {\n        return control.clipRect = this.object.clipRect;\n      }\n    };\n\n\n    /**\n    * Updates the content size of the layout. Only works if scrolling is\n    * enabled.\n    *\n    * @method updateContentSize\n    * @protected\n     */\n\n    Component_LayoutBehavior.prototype.updateContentSize = function() {\n      var control, i, len, ref;\n      if (this.object.scrollable) {\n        this.contentSize.width = 0;\n        this.contentSize.height = 0;\n        ref = this.object.controls;\n        for (i = 0, len = ref.length; i < len; i++) {\n          control = ref[i];\n          if (control) {\n            this.contentSize.width += control.margin.left + control.dstRect.width + control.margin.right;\n            this.contentSize.height += control.margin.top + control.dstRect.height + control.margin.bottom;\n          }\n        }\n        this.object.contentHeight = this.contentSize.height;\n        return this.object.contentWidth = this.contentSize.width;\n      }\n    };\n\n\n    /**\n    * Updates scrolling.\n    *\n    * @method updateScroll\n     */\n\n    Component_LayoutBehavior.prototype.updateScroll = function() {\n      if (this.object.scrollable) {\n        this.object.scrollableHeight = Math.max(0, this.contentSize.height - this.object.dstRect.height);\n        if (Input.Mouse.wheel <= -1) {\n          this.object.scrollOffsetY = Math.max(this.object.scrollOffsetY - Input.Mouse.wheelSpeed * 0.1, 0);\n        }\n        if (Input.Mouse.wheel >= 1) {\n          this.object.scrollOffsetY = Math.min(this.object.scrollOffsetY - Input.Mouse.wheelSpeed * 0.1, this.object.scrollableHeight);\n        }\n        return this.object.scrollOffsetY = Math.max(Math.min(this.object.scrollOffsetY, this.object.scrollableHeight), 0);\n      }\n    };\n\n\n    /**\n    * Updates the layout's content.\n    *\n    * @method updateContent\n     */\n\n    Component_LayoutBehavior.prototype.updateContent = function() {};\n\n\n    /**\n    * Updates the layout.\n    *\n    * @method update\n     */\n\n    Component_LayoutBehavior.prototype.update = function() {\n      Component_LayoutBehavior.__super__.update.apply(this, arguments);\n      this.updateContentSize();\n      return this.updateScroll();\n    };\n\n    return Component_LayoutBehavior;\n\n  })(gs.Component_Visual);\n\n  gs.Component_LayoutBehavior = Component_LayoutBehavior;\n\n}).call(this);\n"
    },
    "summary": [
        "name",
        "type",
        "order"
    ],
    "externalItems": []
}