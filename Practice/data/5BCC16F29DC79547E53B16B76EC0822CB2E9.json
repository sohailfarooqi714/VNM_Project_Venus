{
    "uid": "5BCC16F29DC79547E53B16B76EC0822CB2E9",
    "isLoaded": true,
    "lastModificationTime": 0,
    "items": {
        "name": "Component_UIBehavior",
        "type": "game_script",
        "order": 14,
        "parentId": "01A95DA3K01E8A4CB4SBE17E790BCE1FC035",
        "folder": false,
        "content": "# ===================================================================\n#\n#   Script: Component_StyleHandler\n#\n#   $$COPYRIGHT$$\n#\n# ===================================================================\nclass Component_UIBehavior extends gs.Component\n    ###*\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    * \n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n    ###\n    onDataBundleRestore: (data, context) ->\n        @setupEventHandlers()\n        \n    ###*\n    * @module ui\n    * @class Component_UIBehavior\n    * @extends gs.Component\n    * @memberof ui\n    * @constructor\n    ###\n    constructor: () ->\n        @breakChainAt = null\n        @containsPointer = no\n        @isAnimating = no\n        @viewData_ = [yes, no, no, yes, no]\n        @nextKeyObjectId = \"\"\n        @nextKeyObject_ = null\n        @prevKeyObject_ = null\n        \n    @accessors \"nextKeyObject\", \n        set: (v) ->\n            @nextKeyObject_ = v\n            if v\n                v.ui.prevKeyObject_ = @object\n        get: -> @nextKeyObject_\n        \n    @accessors \"prevKeyObject\", \n        set: (v) ->\n            @prevKeyObject_ = v\n            if v\n                v.ui.nextKeyObject_ = @object\n        get: -> @prevKeyObject_\n                \n    @accessors \"selected\", \n        set: (v) -> \n            if v != @viewData_[2]\n                @viewData_[2] = v\n                @updateStyle()\n                \n        get: -> @viewData_[2]\n        \n    @accessors \"hover\", \n        set: (v) -> \n            if v != @viewData_[1]\n                @viewData_[1] = v\n                @updateStyle()\n                \n        get: -> @viewData_[1]\n        \n    @accessors \"enabled\",\n        set: (v) -> \n            if v != @viewData_[3]\n                @viewData_[3] = v\n                @updateStyle()\n                \n        get: -> @viewData_[3]\n        \n    @accessors \"focused\",\n        set: (v) ->\n            if v != @viewData_[4]\n                @viewData_[4] = v\n                @updateStyle()\n        get: -> @viewData_[4]\n        \n    @accessors \"viewData\",\n        set: (v) ->\n            if v != @viewData_\n                @viewData_ = v\n                @updateStyle()\n        get: -> @viewData_\n    \n    \n    ###*\n    * Prepares the UI-Object for display. This method should be called\n    * before a new created UI-Object will be displayed to position all\n    * sub-elements correctly.\n    *\n    * @method prepare\n    ###\n    prepare: ->\n        scene = SceneManager.scene\n        scene.preparing = yes\n        @object.update() # First Update: Bring all sub-elements in correct size\n        @object.update() # Second Update: Correct layout\n        scene.preparing = no\n        @object.events.emit(\"uiPrepareFinish\")\n     \n     \n    ###*\n    * Executes an animation defined for the specified event. Each UI-Object\n    * can have animations for certain events defined in JSON.\n    *\n    * @param {string} event - The event to execute the animation for such as \"onTerminate\" or \"onInitialize\". If\n    * no animation has been defined for the specified event, nothing will happen and the callback will be called \n    * immediately.\n    * @param {Function} callback - An optional callback function called when the animation ends.\n    * @method executeAnimation\n    ###\n    executeAnimation: (event, callback) ->\n        @isAnimating = yes\n        @disappearCounter = @object.subObjects.length + 1\n        @disappearCallback = callback\n        \n        for object in @object.subObjects\n            if object.ui\n                object.ui.executeAnimation(event, (sender) =>\n                    @disappearCounter--\n                    \n                    if @disappearCounter == 0\n                        @isAnimating = no\n                        @disappearCallback?(@object)\n                )\n            else\n                @disappearCounter--\n         \n        animation = @object.animations?.first (a) -> a.events.indexOf(event) != -1\n        \n        if animation\n            @object.animationExecutor.execute(animation, (sender) =>\n                @disappearCounter--\n                if @disappearCounter == 0\n                    @isAnimating = no\n                    @disappearCallback?(@object) \n            )\n        else\n            @disappearCounter--\n            if @disappearCounter == 0\n                @isAnimating = no\n                @disappearCallback?(@object) \n    \n    ###*\n    * Executes the animation defined for the \"onInitialize\" event. Each UI-Object\n    * can have animations for certain events defined in JSON.\n    *\n    * @param {Function} callback - An optional callback function called when the animation ends.\n    * @method appear\n    ###        \n    appear: (callback) -> \n        gs.GlobalEventManager.emit(\"uiAnimationStart\")\n        cb = (sender) => \n            gs.GlobalEventManager.emit(\"uiAnimationFinish\")\n            callback?(sender)\n        @executeAnimation(\"onInitialize\", cb)\n        \n    ###*\n    * Executes the animation defined for the \"onTerminate\" event. Each UI-Object\n    * can have animations for certain events defined in JSON.\n    *\n    * @param {Function} callback - An optional callback function called when the animation ends.\n    * @method disappear\n    ###    \n    disappear: (callback) -> \n        gs.GlobalEventManager.emit(\"uiAnimationStart\")\n        cb = (sender) => \n            gs.GlobalEventManager.emit(\"uiAnimationFinish\")\n            callback?(sender)\n        @executeAnimation(\"onTerminate\", cb)\n        \n    ###*\n    * Disposes the component.\n    *\n    * @method dispose\n    ###\n    dispose: ->\n        super\n        \n        gs.GlobalEventManager.offByOwner \"mouseUp\", @object\n        gs.GlobalEventManager.offByOwner(\"objectGotFocus\", @object)\n        gs.GlobalEventManager.offByOwner(\"keyUp\", @object)\n        gs.GlobalEventManager.offByOwner(\"mouseDown\", @object)\n        gs.GlobalEventManager.offByOwner(\"mouseMoved\", @object)\n     \n    ###*\n    * Adds event-handlers for mouse/touch events\n    *\n    * @method setupEventHandlers\n    ### \n    setupEventHandlers: ->\n        if @object.focusable\n            gs.GlobalEventManager.on \"objectGotFocus\", ((e) =>\n                if e.sender != @object\n                    @blur()\n            ),\n            null, @object\n\n            gs.GlobalEventManager.on \"keyUp\", ((e) =>\n                if @focused\n                    if @nextKeyObject and (Input.release(Input.KEY_DOWN) or Input.release(Input.KEY_RIGHT))\n                        @nextKeyObject.ui.focus()\n                        e.breakChain = yes\n                    else if @prevKeyObject and (Input.release(Input.KEY_UP) or Input.release(Input.KEY_LEFT))\n                        @prevKeyObject.ui.focus()\n                        e.breakChain = yes\n            ),\n            null, @object\n            \n        if @object.styles.first ((s) -> s.selector == 1)\n            gs.GlobalEventManager.on \"mouseMoved\", ((e) =>\n                    return if !@enabled\n                    contains = Rect.contains(@object.dstRect.x, @object.dstRect.y, \n                             @object.dstRect.width, @object.dstRect.height,\n                             Input.Mouse.x - @object.origin.x, Input.Mouse.y - @object.origin.y)\n                \n                    if @containsPointer != contains or (@hover and !contains)\n                        @containsPointer = contains\n                        @object.needsUpdate = yes\n                        @hover = contains\n                        \n                        @updateParentStyle()\n                        @updateChildrenStyle()\n    \n                    return null                       \n                ),\n                null, @object\n            \n        if @object.focusable or @object.styles.first ((s) -> s.selector == 2 || s.selector == 4)\n            gs.GlobalEventManager.on \"mouseDown\", ((e) =>\n                    return if !@enabled or Input.Mouse.buttons[Input.Mouse.LEFT] != 1\n                    contains = Rect.contains(@object.dstRect.x, @object.dstRect.y, \n                             @object.dstRect.width, @object.dstRect.height,\n                             Input.Mouse.x - @object.origin.x, Input.Mouse.y - @object.origin.y)\n                    \n                    if contains\n                        @object.needsUpdate = yes\n                        \n                        @focus()\n                        \n                        if @object.selectable\n                            if @object.group\n                                @selected = yes\n                                group = gs.ObjectManager.current.objectsByGroup(@object.group)\n                                for object in group\n                                    if object != @object\n                                        object.ui.selected = no\n                            else\n                                @selected = !@selected\n                        else\n                            @updateStyle()\n                            \n                        @updateParentStyle()\n                                        \n                    return null                        \n                ),\n                null, @object, 0\n                \n    ###*\n    * Initializes the binding-handler.\n    * \n    * @method setup\n    ###\n    setup: ->\n        @setupEventHandlers()\n    \n    ###*\n    * Gives the input focus to this UI object. If the UI object is not focusable, nothing will happen.\n    * \n    * @method focus\n    ###               \n    focus: ->\n        if @object.focusable and !@focused\n            @focused = yes\n            @updateChildrenStyle()\n            \n            gs.GlobalEventManager.emit(\"objectGotFocus\", @object)\n    \n    ###*\n    * Removes the input focus from this UI object. If the UI object is not focusable, nothing will happen.\n    * \n    * @method blur\n    ###\n    blur: ->\n        if @object.focusable and @focused\n            @focused = no\n            @updateChildrenStyle()\n            gs.GlobalEventManager.emit(\"objectLostFocus\", @object)\n            \n    updateParentStyle: ->\n        parent = @object.parent\n        while parent\n            parent.ui?.updateStyle()\n            parent = parent.parent\n        return null\n    \n    updateChildrenStyle: () ->\n        if @object.controls\n            for control in @object.controls\n                if control and control.ui\n                    control.ui.updateStyle()\n                    control.ui.updateChildrenStyle()\n        return null\n                    \n    updateStyle: ->\n        if @object.styles\n            for style in @object.styles\n                if !@viewData_[style.selector]\n                    style.revert(@object)\n                                \n            for style in @object.styles\n                if style.target == -1\n                    if @viewData_[style.selector]\n                        style.apply(@object)\n                else\n                    objects = @object.parentsByStyle[style.target]\n                    if objects\n                        object = objects[0]\n                        if object and object.ui.viewData_[style.selector]\n                            style.apply(@object)\n                            \n            if @object.font\n                @object.behavior.refresh?() # FIXME: Creates a dependency on Text-Behavior\n                \n        return null\n        \n    ###*\n    * Updates the binding-handler.\n    * \n    * @method update\n    ###   \n    update: ->\n        if @nextKeyObjectId and !@nextKeyObject\n            @nextKeyObject = gs.ObjectManager.current.objectById(@nextKeyObjectId)\n        \n     \nui.Component_UIBehavior = Component_UIBehavior",
        "compiledContent": "// Generated by CoffeeScript 1.12.7\n(function() {\n  var Component_UIBehavior,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  Component_UIBehavior = (function(superClass) {\n    extend(Component_UIBehavior, superClass);\n\n\n    /**\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    * \n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n     */\n\n    Component_UIBehavior.prototype.onDataBundleRestore = function(data, context) {\n      return this.setupEventHandlers();\n    };\n\n\n    /**\n    * @module ui\n    * @class Component_UIBehavior\n    * @extends gs.Component\n    * @memberof ui\n    * @constructor\n     */\n\n    function Component_UIBehavior() {\n      this.breakChainAt = null;\n      this.containsPointer = false;\n      this.isAnimating = false;\n      this.viewData_ = [true, false, false, true, false];\n      this.nextKeyObjectId = \"\";\n      this.nextKeyObject_ = null;\n      this.prevKeyObject_ = null;\n    }\n\n    Component_UIBehavior.accessors(\"nextKeyObject\", {\n      set: function(v) {\n        this.nextKeyObject_ = v;\n        if (v) {\n          return v.ui.prevKeyObject_ = this.object;\n        }\n      },\n      get: function() {\n        return this.nextKeyObject_;\n      }\n    });\n\n    Component_UIBehavior.accessors(\"prevKeyObject\", {\n      set: function(v) {\n        this.prevKeyObject_ = v;\n        if (v) {\n          return v.ui.nextKeyObject_ = this.object;\n        }\n      },\n      get: function() {\n        return this.prevKeyObject_;\n      }\n    });\n\n    Component_UIBehavior.accessors(\"selected\", {\n      set: function(v) {\n        if (v !== this.viewData_[2]) {\n          this.viewData_[2] = v;\n          return this.updateStyle();\n        }\n      },\n      get: function() {\n        return this.viewData_[2];\n      }\n    });\n\n    Component_UIBehavior.accessors(\"hover\", {\n      set: function(v) {\n        if (v !== this.viewData_[1]) {\n          this.viewData_[1] = v;\n          return this.updateStyle();\n        }\n      },\n      get: function() {\n        return this.viewData_[1];\n      }\n    });\n\n    Component_UIBehavior.accessors(\"enabled\", {\n      set: function(v) {\n        if (v !== this.viewData_[3]) {\n          this.viewData_[3] = v;\n          return this.updateStyle();\n        }\n      },\n      get: function() {\n        return this.viewData_[3];\n      }\n    });\n\n    Component_UIBehavior.accessors(\"focused\", {\n      set: function(v) {\n        if (v !== this.viewData_[4]) {\n          this.viewData_[4] = v;\n          return this.updateStyle();\n        }\n      },\n      get: function() {\n        return this.viewData_[4];\n      }\n    });\n\n    Component_UIBehavior.accessors(\"viewData\", {\n      set: function(v) {\n        if (v !== this.viewData_) {\n          this.viewData_ = v;\n          return this.updateStyle();\n        }\n      },\n      get: function() {\n        return this.viewData_;\n      }\n    });\n\n\n    /**\n    * Prepares the UI-Object for display. This method should be called\n    * before a new created UI-Object will be displayed to position all\n    * sub-elements correctly.\n    *\n    * @method prepare\n     */\n\n    Component_UIBehavior.prototype.prepare = function() {\n      var scene;\n      scene = SceneManager.scene;\n      scene.preparing = true;\n      this.object.update();\n      this.object.update();\n      scene.preparing = false;\n      return this.object.events.emit(\"uiPrepareFinish\");\n    };\n\n\n    /**\n    * Executes an animation defined for the specified event. Each UI-Object\n    * can have animations for certain events defined in JSON.\n    *\n    * @param {string} event - The event to execute the animation for such as \"onTerminate\" or \"onInitialize\". If\n    * no animation has been defined for the specified event, nothing will happen and the callback will be called \n    * immediately.\n    * @param {Function} callback - An optional callback function called when the animation ends.\n    * @method executeAnimation\n     */\n\n    Component_UIBehavior.prototype.executeAnimation = function(event, callback) {\n      var animation, i, len, object, ref, ref1;\n      this.isAnimating = true;\n      this.disappearCounter = this.object.subObjects.length + 1;\n      this.disappearCallback = callback;\n      ref = this.object.subObjects;\n      for (i = 0, len = ref.length; i < len; i++) {\n        object = ref[i];\n        if (object.ui) {\n          object.ui.executeAnimation(event, (function(_this) {\n            return function(sender) {\n              _this.disappearCounter--;\n              if (_this.disappearCounter === 0) {\n                _this.isAnimating = false;\n                return typeof _this.disappearCallback === \"function\" ? _this.disappearCallback(_this.object) : void 0;\n              }\n            };\n          })(this));\n        } else {\n          this.disappearCounter--;\n        }\n      }\n      animation = (ref1 = this.object.animations) != null ? ref1.first(function(a) {\n        return a.events.indexOf(event) !== -1;\n      }) : void 0;\n      if (animation) {\n        return this.object.animationExecutor.execute(animation, (function(_this) {\n          return function(sender) {\n            _this.disappearCounter--;\n            if (_this.disappearCounter === 0) {\n              _this.isAnimating = false;\n              return typeof _this.disappearCallback === \"function\" ? _this.disappearCallback(_this.object) : void 0;\n            }\n          };\n        })(this));\n      } else {\n        this.disappearCounter--;\n        if (this.disappearCounter === 0) {\n          this.isAnimating = false;\n          return typeof this.disappearCallback === \"function\" ? this.disappearCallback(this.object) : void 0;\n        }\n      }\n    };\n\n\n    /**\n    * Executes the animation defined for the \"onInitialize\" event. Each UI-Object\n    * can have animations for certain events defined in JSON.\n    *\n    * @param {Function} callback - An optional callback function called when the animation ends.\n    * @method appear\n     */\n\n    Component_UIBehavior.prototype.appear = function(callback) {\n      var cb;\n      gs.GlobalEventManager.emit(\"uiAnimationStart\");\n      cb = (function(_this) {\n        return function(sender) {\n          gs.GlobalEventManager.emit(\"uiAnimationFinish\");\n          return typeof callback === \"function\" ? callback(sender) : void 0;\n        };\n      })(this);\n      return this.executeAnimation(\"onInitialize\", cb);\n    };\n\n\n    /**\n    * Executes the animation defined for the \"onTerminate\" event. Each UI-Object\n    * can have animations for certain events defined in JSON.\n    *\n    * @param {Function} callback - An optional callback function called when the animation ends.\n    * @method disappear\n     */\n\n    Component_UIBehavior.prototype.disappear = function(callback) {\n      var cb;\n      gs.GlobalEventManager.emit(\"uiAnimationStart\");\n      cb = (function(_this) {\n        return function(sender) {\n          gs.GlobalEventManager.emit(\"uiAnimationFinish\");\n          return typeof callback === \"function\" ? callback(sender) : void 0;\n        };\n      })(this);\n      return this.executeAnimation(\"onTerminate\", cb);\n    };\n\n\n    /**\n    * Disposes the component.\n    *\n    * @method dispose\n     */\n\n    Component_UIBehavior.prototype.dispose = function() {\n      Component_UIBehavior.__super__.dispose.apply(this, arguments);\n      gs.GlobalEventManager.offByOwner(\"mouseUp\", this.object);\n      gs.GlobalEventManager.offByOwner(\"objectGotFocus\", this.object);\n      gs.GlobalEventManager.offByOwner(\"keyUp\", this.object);\n      gs.GlobalEventManager.offByOwner(\"mouseDown\", this.object);\n      return gs.GlobalEventManager.offByOwner(\"mouseMoved\", this.object);\n    };\n\n\n    /**\n    * Adds event-handlers for mouse/touch events\n    *\n    * @method setupEventHandlers\n     */\n\n    Component_UIBehavior.prototype.setupEventHandlers = function() {\n      if (this.object.focusable) {\n        gs.GlobalEventManager.on(\"objectGotFocus\", ((function(_this) {\n          return function(e) {\n            if (e.sender !== _this.object) {\n              return _this.blur();\n            }\n          };\n        })(this)), null, this.object);\n        gs.GlobalEventManager.on(\"keyUp\", ((function(_this) {\n          return function(e) {\n            if (_this.focused) {\n              if (_this.nextKeyObject && (Input.release(Input.KEY_DOWN) || Input.release(Input.KEY_RIGHT))) {\n                _this.nextKeyObject.ui.focus();\n                return e.breakChain = true;\n              } else if (_this.prevKeyObject && (Input.release(Input.KEY_UP) || Input.release(Input.KEY_LEFT))) {\n                _this.prevKeyObject.ui.focus();\n                return e.breakChain = true;\n              }\n            }\n          };\n        })(this)), null, this.object);\n      }\n      if (this.object.styles.first((function(s) {\n        return s.selector === 1;\n      }))) {\n        gs.GlobalEventManager.on(\"mouseMoved\", ((function(_this) {\n          return function(e) {\n            var contains;\n            if (!_this.enabled) {\n              return;\n            }\n            contains = Rect.contains(_this.object.dstRect.x, _this.object.dstRect.y, _this.object.dstRect.width, _this.object.dstRect.height, Input.Mouse.x - _this.object.origin.x, Input.Mouse.y - _this.object.origin.y);\n            if (_this.containsPointer !== contains || (_this.hover && !contains)) {\n              _this.containsPointer = contains;\n              _this.object.needsUpdate = true;\n              _this.hover = contains;\n              _this.updateParentStyle();\n              _this.updateChildrenStyle();\n            }\n            return null;\n          };\n        })(this)), null, this.object);\n      }\n      if (this.object.focusable || this.object.styles.first((function(s) {\n        return s.selector === 2 || s.selector === 4;\n      }))) {\n        return gs.GlobalEventManager.on(\"mouseDown\", ((function(_this) {\n          return function(e) {\n            var contains, group, i, len, object;\n            if (!_this.enabled || Input.Mouse.buttons[Input.Mouse.LEFT] !== 1) {\n              return;\n            }\n            contains = Rect.contains(_this.object.dstRect.x, _this.object.dstRect.y, _this.object.dstRect.width, _this.object.dstRect.height, Input.Mouse.x - _this.object.origin.x, Input.Mouse.y - _this.object.origin.y);\n            if (contains) {\n              _this.object.needsUpdate = true;\n              _this.focus();\n              if (_this.object.selectable) {\n                if (_this.object.group) {\n                  _this.selected = true;\n                  group = gs.ObjectManager.current.objectsByGroup(_this.object.group);\n                  for (i = 0, len = group.length; i < len; i++) {\n                    object = group[i];\n                    if (object !== _this.object) {\n                      object.ui.selected = false;\n                    }\n                  }\n                } else {\n                  _this.selected = !_this.selected;\n                }\n              } else {\n                _this.updateStyle();\n              }\n              _this.updateParentStyle();\n            }\n            return null;\n          };\n        })(this)), null, this.object, 0);\n      }\n    };\n\n\n    /**\n    * Initializes the binding-handler.\n    * \n    * @method setup\n     */\n\n    Component_UIBehavior.prototype.setup = function() {\n      return this.setupEventHandlers();\n    };\n\n\n    /**\n    * Gives the input focus to this UI object. If the UI object is not focusable, nothing will happen.\n    * \n    * @method focus\n     */\n\n    Component_UIBehavior.prototype.focus = function() {\n      if (this.object.focusable && !this.focused) {\n        this.focused = true;\n        this.updateChildrenStyle();\n        return gs.GlobalEventManager.emit(\"objectGotFocus\", this.object);\n      }\n    };\n\n\n    /**\n    * Removes the input focus from this UI object. If the UI object is not focusable, nothing will happen.\n    * \n    * @method blur\n     */\n\n    Component_UIBehavior.prototype.blur = function() {\n      if (this.object.focusable && this.focused) {\n        this.focused = false;\n        this.updateChildrenStyle();\n        return gs.GlobalEventManager.emit(\"objectLostFocus\", this.object);\n      }\n    };\n\n    Component_UIBehavior.prototype.updateParentStyle = function() {\n      var parent, ref;\n      parent = this.object.parent;\n      while (parent) {\n        if ((ref = parent.ui) != null) {\n          ref.updateStyle();\n        }\n        parent = parent.parent;\n      }\n      return null;\n    };\n\n    Component_UIBehavior.prototype.updateChildrenStyle = function() {\n      var control, i, len, ref;\n      if (this.object.controls) {\n        ref = this.object.controls;\n        for (i = 0, len = ref.length; i < len; i++) {\n          control = ref[i];\n          if (control && control.ui) {\n            control.ui.updateStyle();\n            control.ui.updateChildrenStyle();\n          }\n        }\n      }\n      return null;\n    };\n\n    Component_UIBehavior.prototype.updateStyle = function() {\n      var base, i, j, len, len1, object, objects, ref, ref1, style;\n      if (this.object.styles) {\n        ref = this.object.styles;\n        for (i = 0, len = ref.length; i < len; i++) {\n          style = ref[i];\n          if (!this.viewData_[style.selector]) {\n            style.revert(this.object);\n          }\n        }\n        ref1 = this.object.styles;\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n          style = ref1[j];\n          if (style.target === -1) {\n            if (this.viewData_[style.selector]) {\n              style.apply(this.object);\n            }\n          } else {\n            objects = this.object.parentsByStyle[style.target];\n            if (objects) {\n              object = objects[0];\n              if (object && object.ui.viewData_[style.selector]) {\n                style.apply(this.object);\n              }\n            }\n          }\n        }\n        if (this.object.font) {\n          if (typeof (base = this.object.behavior).refresh === \"function\") {\n            base.refresh();\n          }\n        }\n      }\n      return null;\n    };\n\n\n    /**\n    * Updates the binding-handler.\n    * \n    * @method update\n     */\n\n    Component_UIBehavior.prototype.update = function() {\n      if (this.nextKeyObjectId && !this.nextKeyObject) {\n        return this.nextKeyObject = gs.ObjectManager.current.objectById(this.nextKeyObjectId);\n      }\n    };\n\n    return Component_UIBehavior;\n\n  })(gs.Component);\n\n  ui.Component_UIBehavior = Component_UIBehavior;\n\n}).call(this);\n"
    },
    "summary": [
        "name",
        "type"
    ],
    "externalItems": []
}