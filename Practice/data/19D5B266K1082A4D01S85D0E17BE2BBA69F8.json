{
    "uid": "19D5B266K1082A4D01S85D0E17BE2BBA69F8",
    "isLoaded": true,
    "lastModificationTime": 0,
    "items": {
        "name": "Object_Base",
        "type": "game_script",
        "order": 0,
        "parentId": "A05E7029K45DBA459BSADF4EEC07A526241A",
        "folder": false,
        "content": "# ===================================================================\n#\n#   Script: Object_Base\n#\n#   $$COPYRIGHT$$\n#\n# ===================================================================\nclass Object_Base\n    ###*\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    * \n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n    ###\n    onDataBundleRestore: (data, context) ->\n        if @id\n            window[\"$\"+@id] = this\n            \n    \n    #\n    # Gets or sets the group the object belongs to.\n    #\n    # @property group\n    # @type string\n    #\n    @accessors \"group\", \n        set: (g) -> \n            @group_ = g\n            gs.ObjectManager.current?.addToGroup(this, g)\n            \n        get: -> @group_\n        \n    #\n    # Gets or sets the order-index of the object. The lower the index, the\n    # earlier the object will be updated in a list of sub-objects.\n    #\n    # @property order\n    # @type number\n    #\n    @accessors \"order\",\n        set: (o) ->\n            if o != @order_\n                @order_ = o\n                @parent?.needsSort = true\n        get: -> @order_\n        \n    #\n    # Gets or sets if an objects needs an update. If true, the parent will update\n    # the object in the next update and resets the needsUpdate property back\n    # to false.\n    #\n    # @property needsUpdate\n    # @type boolean\n    #\n    @accessors \"needsUpdate\", \n        set: (v) ->\n            @needsUpdate_ = v\n            \n            parent = @parent\n            while parent\n                parent.needsUpdate_ = yes\n                parent = parent.parent\n                \n            #if v\n            #    @parent?.needsUpdate = yes\n            #if v\n            #    for object in @subObjects\n            #        object.needsUpdate_ = v\n            if v\n                @requestSubUpdate()\n        get: -> return @needsUpdate_ || SceneManager.scene.preparing\n        \n    requestSubUpdate: ->\n        for object in @subObjects\n            if object\n                object.needsUpdate_ = yes\n                object.requestSubUpdate()\n                \n        return null\n    #\n    # Gets or sets if an object needs a full update. A full update triggers\n    # an update for all sub-objects recursively. \n    #\n    # @property needsFullUpdate\n    # @type boolean\n    #\n    @accessors \"needsFullUpdate\", \n        set: (v) ->\n            @needsUpdate = v\n            if v\n                for object in @subObjects\n                    object.needsFullUpdate = v\n        get: -> @needsUpdate_\n            \n    ###*\n    * The base class for all game objects. A game object itself doesn't implement\n    * any game logic but uses components and sub-objects for that.\n    *\n    * @module gs\n    * @class Object_Base\n    * @memberof gs\n    * @constructor\n    ###\n    constructor: () ->\n        ###*\n        * @property subObjects\n        * @type gs.Object_Base[]\n        * @default []\n        * A list of game-objects grouped under this game object.\n        ###\n        @subObjects = []\n        \n        ###*\n        * @property components\n        * @type gs.Component[]\n        * @default []\n        * A list of components defining the logic/behavior and appearance of the game object.\n        ###\n        @components = []\n        \n        ###*\n        * @property componentsById\n        * @type Object\n        * @default []\n        * All associated components by their ID.\n        ###\n        @componentsById = {}\n        \n        ###*\n        * @property disposed\n        * @type boolean\n        * @default false\n        * Indicates if the game object id disposed. A disposed game object cannot be used anymore.\n        ###\n        @disposed = no\n        \n        ###*\n        * @property active\n        * @default true\n        * Indicates if the game object is active. An inactive game object will not be updated.\n        ###\n        @active = yes\n        \n        @input = no\n        \n        ###*\n        * @property id\n        * @type string\n        * @default null\n        * The game object's UID (Unique ID)\n        ###\n        @id = null \n        \n        ###*\n        * @property group\n        * @default null\n        * @type string\n        * The game object's group. To get all object's of a specific group the gs.ObjectManager.objectsByGroup property can be used.\n        ###\n        @group = null \n        \n        ###*\n        * @property parent\n        * @type gs.Object_Base\n        * @default null\n        * The parent object if the game object is a sub-object of another game object.\n        ###\n        @parent = null\n        \n        ###*\n        * @property order\n        * @type number\n        * @default 0\n        * Controls the update-order. The smaller the value the earlier the game object is updated before other game objects are updated.\n        ###\n        @order = 0\n        \n        ###*\n        * @property rIndex\n        * @type number\n        * @default 0\n        * Holds the render-index if the game object has a graphical representation on screen. The render-index is the\n        * index of the game object's graphic-object(gs.GraphicObject) in the current list of graphic-objects. The render-index\n        * is read-only. Setting the render-index to a certain value has no effect.\n        ###\n        @rIndex = 0\n        \n        ###*\n        * @property needsSort\n        * @type boolean\n        * @default true\n        * Indicates if the list of sub-objects needs to be sorted by order because of a change.\n        ###\n        @needsSort = yes\n        \n        ###*\n        * @property needsSort\n        * @type boolean\n        * @default true\n        * Indicates if the UI object needs to be updated.\n        ###\n        @needsUpdate = yes\n        \n        ###*\n        * @property initialized\n        * @type boolean\n        * @default true\n        * Indicates if the game object and its components have been initialized.\n        ###\n        @initialized = no\n        \n        ###*\n        * @property customData\n        * @type Object\n        * @default {}\n        * A custom data object which can be used to add any custom data/fields to the game\n        * object. It is an empty object by default.\n        ###\n        @customData = {}\n        \n        \n        gs.ObjectManager.current?.registerObject(this)\n        \n    ###*\n    * Disposes the object with all its components and sub-objects. A disposed object will be\n    * removed from the parent automatically.\n    *\n    * @method dispose\n    ###\n    dispose: ->\n        if not @disposed\n            @disposed = yes\n            @disposeComponents()\n            @disposeObjects()\n                \n            gs.ObjectManager.current?.unregisterObject(this)\n        \n        return null\n        \n    ###*\n    * Disposes all sub-objects.\n    *\n    * @method disposeObjects\n    * @protected\n    ###\n    disposeObjects: ->\n        for subObject in @subObjects\n            subObject?.dispose?()\n            \n    ###*\n    * Disposes all components\n    *\n    * @method disposeComponents\n    * @protected\n    ###\n    disposeComponents: ->\n        for component in @components\n            component?.dispose?()\n       \n    ###*\n    * Calls setup-routine on all components.\n    *\n    * @method setup\n    ###\n    setup: ->\n        for component in @components\n            component.setup() if not component?.isSetup\n            \n        @initialized = yes\n        return null\n        \n    ###*\n    * Deserializes components from a data-bundle object.\n    * \n    * @method componentsFromDataBundle\n    * @param {Object} data The data-bundle object.\n    ###\n    componentsFromDataBundle: (data) ->\n        if data?.components\n            for component in data.components\n                componentObject = new gs[component.className](component)\n                @addComponent(componentObject)\n            delete data.components\n                \n        return null\n           \n    ###*\n    * Serializes components of a specified type to a data-bundle. A component\n    * needs to implement the toDataBundle method for correct serialization.\n    *\n    * @method componentsToDataBundle\n    * @param {String} type - A component class name.\n    * @return A data bundle.\n    ###\n    componentsToDataBundle: (type) ->\n        components = []\n        for component in @components\n            if component instanceof type\n                continue unless component.toDataBundle?\n                bundle = component.toDataBundle()\n                bundle.className = component.constructor.name\n                components.push(bundle)\n        return components\n        \n    ###*\n    * Starts a full-refresh on all sub-objects\n    *\n    * @method fullRefresh\n    ###\n    fullRefresh: ->\n        for object in @subObjects\n            if object\n                object.needsUpdate = yes\n                object.fullRefresh()\n            \n        return null\n    \n    ###*\n    * Updates the object with all parent- and sub-objects. \n    *\n    * @method fullUpdate\n    ###\n    fullUpdate: ->\n        parent = this\n        while parent != null\n            parent.update()\n            parent = parent.parent\n            \n        for object in @subObjects\n            object?.update()\n        \n    ###*\n    * Updates the object and all its components. This method is\n    * called automatically by the parent or ObjectManager so in regular it is \n    * not necessary to call it manually.\n    *\n    * @method update\n    ###\n    update: ->\n        return if !@active\n        i = 0\n        while i < @components.length\n            component = @components[i]\n            if not component.disposed\n                component.update()\n                i++\n            else\n                @components.splice(i, 1)\n\n\n        if @input then Input.clear()\n        @input = no\n        \n        return null\n            \n    ###*\n    * Searches for the first component with the specified class name.\n    *\n    * @method findComponent\n    * @param {String} name The class name of the component.\n    * @return {Component} The component or null if a component with the specified class name cannot be found.\n    ###\n    findComponent: (name) -> @components.first (v) -> v.constructor.name == name\n    \n    ###*\n    * Searches for all components with the specified class name.\n    *\n    * @method findComponents\n    * @param {String} name The class name of the components.\n    * @return {Array} The components or null if no component with the specified class name has been found.\n    ###\n    findComponents: (name) -> @components.where (v) -> v.constructor.name == name\n    \n    ###*\n    * Searches for the component with the specified ID.\n    *\n    * @method findComponentById\n    * @param {String} id The unique identifier of the component.\n    * @return {Component} The component or null if a component with the specified ID cannot be found.\n    ###\n    findComponentById: (id) -> @componentsById[id]\n    \n    ###*\n    * Searches for the component with the specified name. If multiple components have the\n    * same name, it will return the first match.\n    *\n    * @method findComponentByName\n    * @param {String} name The name of the component to find.\n    * @return {Component} The component or null if a component with the specified name cannot be found.\n    ###\n    findComponentByName: (name) -> @components.first (v) -> v.name == name\n    \n    ###*\n    * Searches for components with the specified name.\n    *\n    * @method findComponentsByName\n    * @param {String} name The name of the components to find.\n    * @return {Component[]} An array of components matching the specified name or null if no components with the specified name exist.\n    ###\n    findComponentsByName: (name) -> @components.where (v) -> v.name == name\n    \n    ###*\n    * Adds an object to the list of sub-objects.\n    *\n    * @method addObject\n    * @param {Object_Base} object The object which should be added.\n    ###\n    addObject: (object) ->\n        gs.ObjectManager.current?.remove(object)\n        object.parent?.removeObject(object)\n        object.parent = this\n        @subObjects.push(object)\n        @needsSort = yes\n        @needsUpdate = yes\n    \n        if object.id?\n            gs.ObjectManager.current.setObjectById(object, object.id)\n        \n    ###*\n    * Inserts an object into the list of sub-objects at the specified index.\n    *\n    * @method insertObject\n    * @param {Object_Base} object The object which should be inserted.\n    * @param {Number} index The index.\n    ###\n    insertObject:(object, index) ->\n        gs.ObjectManager.current.remove(object)\n        object.parent?.removeObject(object)\n        object.parent = this\n        @subObjects.splice(index, 0, object)\n      \n        if object.id?\n            gs.ObjectManager.current.setObjectById(object, object.id)\n            \n    ###*\n    * Sets sub-object at the specified index.\n    *\n    * @method setObject\n    * @param {Object_Base} object The object.\n    * @param {Number} index The index.\n    ###\n    setObject: (object, index) ->\n        if object\n            gs.ObjectManager.current.remove(object)\n            object.parent?.removeObject(object)\n            object.parent = this\n            \n        @subObjects[index] = object\n      \n        if object?.id?\n            gs.ObjectManager.current.setObjectById(object, object.id)\n    \n    ###*\n    * Removes the specified object from the list of sub-objects.\n    *\n    * @method removeObject\n    * @param {Object_Base} object The object which should be removed.\n    ###\n    removeObject: (object) ->\n        @subObjects.remove(object)\n        object.parent = null\n        @needsUpdate = yes\n     \n    ###*\n    * Removes the object at the specified index from the list of sub-objects.\n    *\n    * @method removeObjectAt\n    * @param {number} index The index of the objec to remove.\n    ###   \n    removeObjectAt: (index) ->\n        object = @subObjects[index]\n        @subObjects.splice(index, 1)\n        object.parent = null\n        @needsUpdate = yes\n    \n    ###*\n    * Removes all sub-objects.\n    *\n    * @method removeAllObjects\n    ###     \n    removeAllObjects: ->\n        while @subObjects.length > 0\n            @removeObjectAt(0)\n    \n    ###*\n    * Erases the object at the specified index. The list size\n    * will not be changed but the the value at the index will be set to null.\n    *\n    * @method eraseObject\n    * @param {Number} object The object which should be erased.\n    ###\n    eraseObject: (index) ->\n        object = @subObjects[index]\n        object?.parent = null\n        @subObjects[index] = null\n    \n    ###*\n    * Adds the specified component to the object.\n    *\n    * @method addComponent\n    * @param {Component} component The component\n    * @param {String} id An optional unique identifier for the component.\n    ###\n    addComponent: (component, id) ->\n        if not @components.contains(component)\n            component.object = this\n            @components.push(component)\n            if id?\n                @componentsById[id] = component\n    ###*\n    * Inserts a component at the specified index.\n    *\n    * @method insertComponent\n    * @param {Component} component The component.\n    * @param {Number} index The index.\n    * @param {String} id An optional unique identifier for the component.\n    ###    \n    insertComponent: (component, index, id) ->\n        @components.remove(component)\n        component.object = this\n        @components.splice(index, 0, component)\n        if id?\n            @componentsById[id] = component\n    \n    ###*\n    * Removes a component from the object.\n    *\n    * @method removeComponent\n    * @param {Component} component The component to remove.\n    ###  \n    removeComponent: (component) -> \n        @components.remove(component)\n        if id?\n            delete @componentsById[id]\n\ngs.Object_Base = Object_Base",
        "compiledContent": "// Generated by CoffeeScript 1.12.7\n(function() {\n  var Object_Base;\n\n  Object_Base = (function() {\n\n    /**\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    * \n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n     */\n    Object_Base.prototype.onDataBundleRestore = function(data, context) {\n      if (this.id) {\n        return window[\"$\" + this.id] = this;\n      }\n    };\n\n    Object_Base.accessors(\"group\", {\n      set: function(g) {\n        var ref;\n        this.group_ = g;\n        return (ref = gs.ObjectManager.current) != null ? ref.addToGroup(this, g) : void 0;\n      },\n      get: function() {\n        return this.group_;\n      }\n    });\n\n    Object_Base.accessors(\"order\", {\n      set: function(o) {\n        var ref;\n        if (o !== this.order_) {\n          this.order_ = o;\n          return (ref = this.parent) != null ? ref.needsSort = true : void 0;\n        }\n      },\n      get: function() {\n        return this.order_;\n      }\n    });\n\n    Object_Base.accessors(\"needsUpdate\", {\n      set: function(v) {\n        var parent;\n        this.needsUpdate_ = v;\n        parent = this.parent;\n        while (parent) {\n          parent.needsUpdate_ = true;\n          parent = parent.parent;\n        }\n        if (v) {\n          return this.requestSubUpdate();\n        }\n      },\n      get: function() {\n        return this.needsUpdate_ || SceneManager.scene.preparing;\n      }\n    });\n\n    Object_Base.prototype.requestSubUpdate = function() {\n      var j, len, object, ref;\n      ref = this.subObjects;\n      for (j = 0, len = ref.length; j < len; j++) {\n        object = ref[j];\n        if (object) {\n          object.needsUpdate_ = true;\n          object.requestSubUpdate();\n        }\n      }\n      return null;\n    };\n\n    Object_Base.accessors(\"needsFullUpdate\", {\n      set: function(v) {\n        var j, len, object, ref, results;\n        this.needsUpdate = v;\n        if (v) {\n          ref = this.subObjects;\n          results = [];\n          for (j = 0, len = ref.length; j < len; j++) {\n            object = ref[j];\n            results.push(object.needsFullUpdate = v);\n          }\n          return results;\n        }\n      },\n      get: function() {\n        return this.needsUpdate_;\n      }\n    });\n\n\n    /**\n    * The base class for all game objects. A game object itself doesn't implement\n    * any game logic but uses components and sub-objects for that.\n    *\n    * @module gs\n    * @class Object_Base\n    * @memberof gs\n    * @constructor\n     */\n\n    function Object_Base() {\n\n      /**\n      * @property subObjects\n      * @type gs.Object_Base[]\n      * @default []\n      * A list of game-objects grouped under this game object.\n       */\n      var ref;\n      this.subObjects = [];\n\n      /**\n      * @property components\n      * @type gs.Component[]\n      * @default []\n      * A list of components defining the logic/behavior and appearance of the game object.\n       */\n      this.components = [];\n\n      /**\n      * @property componentsById\n      * @type Object\n      * @default []\n      * All associated components by their ID.\n       */\n      this.componentsById = {};\n\n      /**\n      * @property disposed\n      * @type boolean\n      * @default false\n      * Indicates if the game object id disposed. A disposed game object cannot be used anymore.\n       */\n      this.disposed = false;\n\n      /**\n      * @property active\n      * @default true\n      * Indicates if the game object is active. An inactive game object will not be updated.\n       */\n      this.active = true;\n      this.input = false;\n\n      /**\n      * @property id\n      * @type string\n      * @default null\n      * The game object's UID (Unique ID)\n       */\n      this.id = null;\n\n      /**\n      * @property group\n      * @default null\n      * @type string\n      * The game object's group. To get all object's of a specific group the gs.ObjectManager.objectsByGroup property can be used.\n       */\n      this.group = null;\n\n      /**\n      * @property parent\n      * @type gs.Object_Base\n      * @default null\n      * The parent object if the game object is a sub-object of another game object.\n       */\n      this.parent = null;\n\n      /**\n      * @property order\n      * @type number\n      * @default 0\n      * Controls the update-order. The smaller the value the earlier the game object is updated before other game objects are updated.\n       */\n      this.order = 0;\n\n      /**\n      * @property rIndex\n      * @type number\n      * @default 0\n      * Holds the render-index if the game object has a graphical representation on screen. The render-index is the\n      * index of the game object's graphic-object(gs.GraphicObject) in the current list of graphic-objects. The render-index\n      * is read-only. Setting the render-index to a certain value has no effect.\n       */\n      this.rIndex = 0;\n\n      /**\n      * @property needsSort\n      * @type boolean\n      * @default true\n      * Indicates if the list of sub-objects needs to be sorted by order because of a change.\n       */\n      this.needsSort = true;\n\n      /**\n      * @property needsSort\n      * @type boolean\n      * @default true\n      * Indicates if the UI object needs to be updated.\n       */\n      this.needsUpdate = true;\n\n      /**\n      * @property initialized\n      * @type boolean\n      * @default true\n      * Indicates if the game object and its components have been initialized.\n       */\n      this.initialized = false;\n\n      /**\n      * @property customData\n      * @type Object\n      * @default {}\n      * A custom data object which can be used to add any custom data/fields to the game\n      * object. It is an empty object by default.\n       */\n      this.customData = {};\n      if ((ref = gs.ObjectManager.current) != null) {\n        ref.registerObject(this);\n      }\n    }\n\n\n    /**\n    * Disposes the object with all its components and sub-objects. A disposed object will be\n    * removed from the parent automatically.\n    *\n    * @method dispose\n     */\n\n    Object_Base.prototype.dispose = function() {\n      var ref;\n      if (!this.disposed) {\n        this.disposed = true;\n        this.disposeComponents();\n        this.disposeObjects();\n        if ((ref = gs.ObjectManager.current) != null) {\n          ref.unregisterObject(this);\n        }\n      }\n      return null;\n    };\n\n\n    /**\n    * Disposes all sub-objects.\n    *\n    * @method disposeObjects\n    * @protected\n     */\n\n    Object_Base.prototype.disposeObjects = function() {\n      var j, len, ref, results, subObject;\n      ref = this.subObjects;\n      results = [];\n      for (j = 0, len = ref.length; j < len; j++) {\n        subObject = ref[j];\n        results.push(subObject != null ? typeof subObject.dispose === \"function\" ? subObject.dispose() : void 0 : void 0);\n      }\n      return results;\n    };\n\n\n    /**\n    * Disposes all components\n    *\n    * @method disposeComponents\n    * @protected\n     */\n\n    Object_Base.prototype.disposeComponents = function() {\n      var component, j, len, ref, results;\n      ref = this.components;\n      results = [];\n      for (j = 0, len = ref.length; j < len; j++) {\n        component = ref[j];\n        results.push(component != null ? typeof component.dispose === \"function\" ? component.dispose() : void 0 : void 0);\n      }\n      return results;\n    };\n\n\n    /**\n    * Calls setup-routine on all components.\n    *\n    * @method setup\n     */\n\n    Object_Base.prototype.setup = function() {\n      var component, j, len, ref;\n      ref = this.components;\n      for (j = 0, len = ref.length; j < len; j++) {\n        component = ref[j];\n        if (!(component != null ? component.isSetup : void 0)) {\n          component.setup();\n        }\n      }\n      this.initialized = true;\n      return null;\n    };\n\n\n    /**\n    * Deserializes components from a data-bundle object.\n    * \n    * @method componentsFromDataBundle\n    * @param {Object} data The data-bundle object.\n     */\n\n    Object_Base.prototype.componentsFromDataBundle = function(data) {\n      var component, componentObject, j, len, ref;\n      if (data != null ? data.components : void 0) {\n        ref = data.components;\n        for (j = 0, len = ref.length; j < len; j++) {\n          component = ref[j];\n          componentObject = new gs[component.className](component);\n          this.addComponent(componentObject);\n        }\n        delete data.components;\n      }\n      return null;\n    };\n\n\n    /**\n    * Serializes components of a specified type to a data-bundle. A component\n    * needs to implement the toDataBundle method for correct serialization.\n    *\n    * @method componentsToDataBundle\n    * @param {String} type - A component class name.\n    * @return A data bundle.\n     */\n\n    Object_Base.prototype.componentsToDataBundle = function(type) {\n      var bundle, component, components, j, len, ref;\n      components = [];\n      ref = this.components;\n      for (j = 0, len = ref.length; j < len; j++) {\n        component = ref[j];\n        if (component instanceof type) {\n          if (component.toDataBundle == null) {\n            continue;\n          }\n          bundle = component.toDataBundle();\n          bundle.className = component.constructor.name;\n          components.push(bundle);\n        }\n      }\n      return components;\n    };\n\n\n    /**\n    * Starts a full-refresh on all sub-objects\n    *\n    * @method fullRefresh\n     */\n\n    Object_Base.prototype.fullRefresh = function() {\n      var j, len, object, ref;\n      ref = this.subObjects;\n      for (j = 0, len = ref.length; j < len; j++) {\n        object = ref[j];\n        if (object) {\n          object.needsUpdate = true;\n          object.fullRefresh();\n        }\n      }\n      return null;\n    };\n\n\n    /**\n    * Updates the object with all parent- and sub-objects. \n    *\n    * @method fullUpdate\n     */\n\n    Object_Base.prototype.fullUpdate = function() {\n      var j, len, object, parent, ref, results;\n      parent = this;\n      while (parent !== null) {\n        parent.update();\n        parent = parent.parent;\n      }\n      ref = this.subObjects;\n      results = [];\n      for (j = 0, len = ref.length; j < len; j++) {\n        object = ref[j];\n        results.push(object != null ? object.update() : void 0);\n      }\n      return results;\n    };\n\n\n    /**\n    * Updates the object and all its components. This method is\n    * called automatically by the parent or ObjectManager so in regular it is \n    * not necessary to call it manually.\n    *\n    * @method update\n     */\n\n    Object_Base.prototype.update = function() {\n      var component, i;\n      if (!this.active) {\n        return;\n      }\n      i = 0;\n      while (i < this.components.length) {\n        component = this.components[i];\n        if (!component.disposed) {\n          component.update();\n          i++;\n        } else {\n          this.components.splice(i, 1);\n        }\n      }\n      if (this.input) {\n        Input.clear();\n      }\n      this.input = false;\n      return null;\n    };\n\n\n    /**\n    * Searches for the first component with the specified class name.\n    *\n    * @method findComponent\n    * @param {String} name The class name of the component.\n    * @return {Component} The component or null if a component with the specified class name cannot be found.\n     */\n\n    Object_Base.prototype.findComponent = function(name) {\n      return this.components.first(function(v) {\n        return v.constructor.name === name;\n      });\n    };\n\n\n    /**\n    * Searches for all components with the specified class name.\n    *\n    * @method findComponents\n    * @param {String} name The class name of the components.\n    * @return {Array} The components or null if no component with the specified class name has been found.\n     */\n\n    Object_Base.prototype.findComponents = function(name) {\n      return this.components.where(function(v) {\n        return v.constructor.name === name;\n      });\n    };\n\n\n    /**\n    * Searches for the component with the specified ID.\n    *\n    * @method findComponentById\n    * @param {String} id The unique identifier of the component.\n    * @return {Component} The component or null if a component with the specified ID cannot be found.\n     */\n\n    Object_Base.prototype.findComponentById = function(id) {\n      return this.componentsById[id];\n    };\n\n\n    /**\n    * Searches for the component with the specified name. If multiple components have the\n    * same name, it will return the first match.\n    *\n    * @method findComponentByName\n    * @param {String} name The name of the component to find.\n    * @return {Component} The component or null if a component with the specified name cannot be found.\n     */\n\n    Object_Base.prototype.findComponentByName = function(name) {\n      return this.components.first(function(v) {\n        return v.name === name;\n      });\n    };\n\n\n    /**\n    * Searches for components with the specified name.\n    *\n    * @method findComponentsByName\n    * @param {String} name The name of the components to find.\n    * @return {Component[]} An array of components matching the specified name or null if no components with the specified name exist.\n     */\n\n    Object_Base.prototype.findComponentsByName = function(name) {\n      return this.components.where(function(v) {\n        return v.name === name;\n      });\n    };\n\n\n    /**\n    * Adds an object to the list of sub-objects.\n    *\n    * @method addObject\n    * @param {Object_Base} object The object which should be added.\n     */\n\n    Object_Base.prototype.addObject = function(object) {\n      var ref, ref1;\n      if ((ref = gs.ObjectManager.current) != null) {\n        ref.remove(object);\n      }\n      if ((ref1 = object.parent) != null) {\n        ref1.removeObject(object);\n      }\n      object.parent = this;\n      this.subObjects.push(object);\n      this.needsSort = true;\n      this.needsUpdate = true;\n      if (object.id != null) {\n        return gs.ObjectManager.current.setObjectById(object, object.id);\n      }\n    };\n\n\n    /**\n    * Inserts an object into the list of sub-objects at the specified index.\n    *\n    * @method insertObject\n    * @param {Object_Base} object The object which should be inserted.\n    * @param {Number} index The index.\n     */\n\n    Object_Base.prototype.insertObject = function(object, index) {\n      var ref;\n      gs.ObjectManager.current.remove(object);\n      if ((ref = object.parent) != null) {\n        ref.removeObject(object);\n      }\n      object.parent = this;\n      this.subObjects.splice(index, 0, object);\n      if (object.id != null) {\n        return gs.ObjectManager.current.setObjectById(object, object.id);\n      }\n    };\n\n\n    /**\n    * Sets sub-object at the specified index.\n    *\n    * @method setObject\n    * @param {Object_Base} object The object.\n    * @param {Number} index The index.\n     */\n\n    Object_Base.prototype.setObject = function(object, index) {\n      var ref;\n      if (object) {\n        gs.ObjectManager.current.remove(object);\n        if ((ref = object.parent) != null) {\n          ref.removeObject(object);\n        }\n        object.parent = this;\n      }\n      this.subObjects[index] = object;\n      if ((object != null ? object.id : void 0) != null) {\n        return gs.ObjectManager.current.setObjectById(object, object.id);\n      }\n    };\n\n\n    /**\n    * Removes the specified object from the list of sub-objects.\n    *\n    * @method removeObject\n    * @param {Object_Base} object The object which should be removed.\n     */\n\n    Object_Base.prototype.removeObject = function(object) {\n      this.subObjects.remove(object);\n      object.parent = null;\n      return this.needsUpdate = true;\n    };\n\n\n    /**\n    * Removes the object at the specified index from the list of sub-objects.\n    *\n    * @method removeObjectAt\n    * @param {number} index The index of the objec to remove.\n     */\n\n    Object_Base.prototype.removeObjectAt = function(index) {\n      var object;\n      object = this.subObjects[index];\n      this.subObjects.splice(index, 1);\n      object.parent = null;\n      return this.needsUpdate = true;\n    };\n\n\n    /**\n    * Removes all sub-objects.\n    *\n    * @method removeAllObjects\n     */\n\n    Object_Base.prototype.removeAllObjects = function() {\n      var results;\n      results = [];\n      while (this.subObjects.length > 0) {\n        results.push(this.removeObjectAt(0));\n      }\n      return results;\n    };\n\n\n    /**\n    * Erases the object at the specified index. The list size\n    * will not be changed but the the value at the index will be set to null.\n    *\n    * @method eraseObject\n    * @param {Number} object The object which should be erased.\n     */\n\n    Object_Base.prototype.eraseObject = function(index) {\n      var object;\n      object = this.subObjects[index];\n      if (object != null) {\n        object.parent = null;\n      }\n      return this.subObjects[index] = null;\n    };\n\n\n    /**\n    * Adds the specified component to the object.\n    *\n    * @method addComponent\n    * @param {Component} component The component\n    * @param {String} id An optional unique identifier for the component.\n     */\n\n    Object_Base.prototype.addComponent = function(component, id) {\n      if (!this.components.contains(component)) {\n        component.object = this;\n        this.components.push(component);\n        if (id != null) {\n          return this.componentsById[id] = component;\n        }\n      }\n    };\n\n\n    /**\n    * Inserts a component at the specified index.\n    *\n    * @method insertComponent\n    * @param {Component} component The component.\n    * @param {Number} index The index.\n    * @param {String} id An optional unique identifier for the component.\n     */\n\n    Object_Base.prototype.insertComponent = function(component, index, id) {\n      this.components.remove(component);\n      component.object = this;\n      this.components.splice(index, 0, component);\n      if (id != null) {\n        return this.componentsById[id] = component;\n      }\n    };\n\n\n    /**\n    * Removes a component from the object.\n    *\n    * @method removeComponent\n    * @param {Component} component The component to remove.\n     */\n\n    Object_Base.prototype.removeComponent = function(component) {\n      this.components.remove(component);\n      if (typeof id !== \"undefined\" && id !== null) {\n        return delete this.componentsById[id];\n      }\n    };\n\n    return Object_Base;\n\n  })();\n\n  gs.Object_Base = Object_Base;\n\n}).call(this);\n"
    },
    "summary": [
        "name",
        "type",
        "order"
    ],
    "externalItems": []
}