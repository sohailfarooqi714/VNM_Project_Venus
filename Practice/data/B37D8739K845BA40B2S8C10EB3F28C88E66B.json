{
    "uid": "B37D8739K845BA40B2S8C10EB3F28C88E66B",
    "isLoaded": true,
    "lastModificationTime": 0,
    "items": {
        "name": "Component_Animator",
        "type": "game_script",
        "order": 13,
        "parentId": "D3325122KACDEA4515SB731E37A42B9D779F",
        "folder": false,
        "content": "# ===================================================================\n#\n#   Script: Component_Animator\n#\n#   $$COPYRIGHT$$\n#\n# ===================================================================\nclass Component_Animator extends gs.Component\n    ###*\n    * An animator-component allows to execute different kind of animations \n    * on a game object. The animations are using the game object's \n    * dstRect & offset-property to execute.\n    *\n    * @module gs\n    * @class Component_Animator\n    * @extends gs.Component\n    * @memberof gs\n    * @constructor\n    ###\n    constructor: ->\n        super\n        \n        @moveAnimation = new gs.Component_MoveAnimation()\n        @pathAnimation = new gs.Component_PathAnimation()\n        @zoomAnimation = new gs.Component_ZoomAnimation()\n        @blendAnimation = new gs.Component_BlendAnimation()\n        @blurAnimation = new gs.Component_BlurAnimation()\n        @pixelateAnimation = new gs.Component_PixelateAnimation()\n        @wobbleAnimation = new gs.Component_WobbleAnimation()\n        @colorAnimation = new gs.Component_ColorAnimation()\n        @imageAnimation = new gs.Component_ImageAnimation()\n        @frameAnimation = new gs.Component_FrameAnimation()\n        @fieldAnimation = new gs.Component_FieldAnimation()\n        @shakeAnimation = new gs.Component_ShakeAnimation()\n        @tintAnimation = new gs.Component_TintAnimation()\n        @rotateAnimation = new gs.Component_RotateAnimation()\n        @maskAnimation = new gs.Component_MaskAnimation()\n        @l2dAnimation = new gs.Component_Live2DAnimation()\n        \n        ###*\n        * Standard Callback Routine\n        * @property callback\n        * @type function\n        * @private\n        ###\n        @callback = (object, animation) -> object.removeComponent(animation)\n        \n        @onBlendFinish = (object, animation, callback) -> \n            object.removeComponent(animation)\n            callback?(object)\n        \n        \n    @accessors \"isAnimating\", get: -> @object\n    ###*\n    * Updates the animator.\n    *\n    * @method update\n    ###\n    update: ->\n        super\n        \n        if @object.mask?.source?.videoElement?\n            @object.mask.source.update()\n        \n    ###*\n    * Moves the game object with a specified speed.\n    *\n    * @method move\n    * @param {number} speedX The speed on x-axis in pixels per frame.\n    * @param {number} speedY The speed on y-axis in pixels per frame.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type used for the animation.\n    ###\n    move: (speedX, speedY, duration, easingType) ->\n        @object.addComponent(@moveAnimation)\n        @moveAnimation.move(speedX, speedY, duration, easingType, @callback)\n        \n        return @moveAnimation\n        \n    ###*\n    * Moves the game object to a specified position.\n    *\n    * @method moveTo\n    * @param {number} x The x-coordinate of the position.\n    * @param {number} y The y-coordinate of the position.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    ###  \n    moveTo: (x, y, duration, easingType) ->\n        @object.addComponent(@moveAnimation)\n        @moveAnimation.moveTo(x, y, duration, easingType, @callback)\n        \n        return @moveAnimation\n    \n    ###*\n    * Moves the game object along a path.\n    *\n    * @method movePath\n    * @param {Object} path The path to follow.\n    * @param {gs.AnimationLoopType} loopType The loop-Type.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    * @param {Object[]} effects Optional array of effects executed during the path-movement like playing a sound.\n    ###  \n    movePath: (path, loopType, duration, easingType, effects) ->\n        c = @object.findComponent(\"Component_PathAnimation\")\n        \n        if c?\n            c.loopType = loopType\n        else\n            @object.addComponent(@pathAnimation)\n            @pathAnimation.start(path, loopType, duration, easingType, effects, @callback)\n            \n        return @pathAnimation\n    \n    ###*\n    * Scrolls the game object with a specified speed.\n    *\n    * @method scroll\n    * @param {number} speedX The speed on x-axis in pixels per frame.\n    * @param {number} speedY The speed on y-axis in pixels per frame.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type used for the animation.\n    ###\n    scroll: (speedX, speedY, duration, easingType) ->\n        @object.addComponent(@moveAnimation)\n        @moveAnimation.scroll(speedX, speedY, duration, easingType, @callback)\n        \n        return @moveAnimation\n        \n    ###*\n    * Scrolls the game object to a specified position.\n    *\n    * @method scrollTo\n    * @param {number} x The x-coordinate of the position.\n    * @param {number} y The y-coordinate of the position.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    ###  \n    scrollTo: (x, y, duration, easingType) ->\n        @object.addComponent(@moveAnimation)\n        @moveAnimation.scrollTo(x, y, duration, easingType, @callback)\n        \n        return @moveAnimation\n        \n    ###*\n    * Scrolls the game object along a path.\n    *\n    * @method scrollPath\n    * @param {Object} path The path to follow.\n    * @param {gs.AnimationLoopType} loopType The loop-Type.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    ###  \n    scrollPath: (path, loopType, duration, easingType) ->\n        @object.addComponent(@pathAnimation)\n        @pathAnimation.scroll(path, loopType, duration, easingType, @callback)\n        \n        return @pathAnimation\n    \n        \n    ###*\n    * Zooms a game object to specified size.\n    *\n    * @method zoomTo\n    * @param {number} x The x-axis zoom-factor.\n    * @param {number} y The y-axis zoom-factor.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    ###      \n    zoomTo: (x, y, duration, easingType) ->\n        @object.addComponent(@zoomAnimation)\n        @zoomAnimation.start(x, y, duration, easingType, @callback)\n        \n        return @zoomAnimation\n        \n    \n    ###*\n    * Blends a game object to specified opacity.\n    *\n    * @method blendTo\n    * @param {number} opacity The target opacity.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    * @param {function} [callback] An optional callback called if blending is finished. \n    ###    \n    blendTo: (opacity, duration, easingType, callback) ->\n        @blendAnimation.stop()\n        @object.addComponent(@blendAnimation)\n        @blendAnimation.start(opacity, duration, easingType, gs.CallBack(\"onBlendFinish\", this, callback)) \n        \n        return @blendAnimation\n     \n    ###*\n    * Animates a Live2D model parameter of a Live2D game object to a specified value.\n    *\n    * @method blendTo\n    * @param {string} param The name of the parameter to animate.\n    * @param {number} value The target value.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    * @param {function} [callback] An optional callback called if blending is finished. \n    ###\n    l2dParameterTo: (param, value, duration, easingType, callback) ->\n        @object.addComponent(@l2dAnimation)\n        @l2dAnimation.start(param, value, duration, easingType, gs.CallBack(\"onBlendFinish\", this, callback)) \n        \n        return @l2dAnimation\n        \n    ###*\n    * Blurs a game object to specified blur-power.\n    *\n    * @method blurTo\n    * @param {number} power The target blur-power.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    ###     \n    blurTo: (power, duration, easingType) ->\n        @object.addComponent(@blurAnimation)\n        @blurAnimation.start(power, duration, easingType) \n        \n        return @blurAnimation\n        \n    ###*\n    * Pixelates a game object to specified pixel-size/block-size\n    *\n    * @method pixelateTo\n    * @param {number} width - The target block-width\n    * @param {number} height - The target block-height\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    ###     \n    pixelateTo: (width, height, duration, easingType) ->\n        @object.addComponent(@pixelateAnimation)\n        @pixelateAnimation.start(width, height, duration, easingType) \n        \n        return @pixelateAnimation\n        \n    ###*\n    * Wobbles a game object to specified wobble-power and wobble-speed.\n    *\n    * @method wobbleTo\n    * @param {number} power The target wobble-power.\n    * @param {number} speed The target wobble-speed.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    ###     \n    wobbleTo: (power, speed, duration, easingType) ->\n        @object.addComponent(@wobbleAnimation)\n        @wobbleAnimation.start(power, speed, duration, easingType) \n        \n        return @wobbleAnimation\n        \n    ###*\n    * Colors a game object to a specified target color.\n    *\n    * @method colorTo\n    * @param {Color} color The target color.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    ###  \n    colorTo: (color, duration, easingType) ->\n        @object.addComponent(@colorAnimation)\n        @colorAnimation.start(color, duration, easingType, @callback)\n        \n        return @colorAnimation\n        \n    ###*\n    * An image animation runs from left to right using the game object's\n    * image-property.\n    *\n    * @method changeImages\n    * @param {Array} images An array of image names.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    ###      \n    changeImages: (images, duration, easingType) ->\n        @object.addComponent(@imageAnimation)\n        @imageAnimation.start(images, duration, easingType, @callback)\n        \n        return @imageAnimation\n        \n    ###*\n    * A frame animation which modifies the game object's srcRect property\n    * a play an animation.\n    *\n    * @method changeFrames\n    * @param {gs.Rect[]} frames An array of source rectangles (frames).\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    ###      \n    #changeFrames: (frames, duration, easingType) ->\n    #    animation = new gs.Component_FrameAnimation()\n    #    @object.addComponent(animation)\n    #    animation.start(frames, duration, easingType, @callback)\n       \n    ###*\n    * A frame animation which modifies the game object's srcRect property\n    * a play an animation.\n    *\n    * @method playAnimation\n    * @param {gs.Rect[]} frames An array of source rectangles (frames).\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    ###     \n    playAnimation: (animationRecord) ->\n        @frameAnimation.refresh(animationRecord)\n        @object.addComponent(@frameAnimation)\n        @frameAnimation.start(@callback)\n        \n        return @frameAnimation\n       \n    ###*\n    * Changes a field of the game object to a specified value.\n    *\n    * @method change\n    * @param {number} Value The target value.\n    * @param {string} field The name of the field/property.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    ###   \n    change: (value, field, duration, easingType) ->\n        @object.addComponent(@fieldAnimation)\n        @fieldAnimation.start(value, field, duration, easingType, @callback)\n        \n        return @fieldAnimation\n       \n    ###*\n    * Shakes the game object horizontally using the game object's offset-property.\n    *\n    * @method shake\n    * @param {gs.Range} range The horizontal shake-range.\n    * @param {number} speed The shake speed.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    ### \n    shake: (range, speed, duration, easing) ->\n        @object.addComponent(@shakeAnimation)\n        @shakeAnimation.start(range, speed, duration, easing, @callback)\n        \n        return @shakeAnimation\n        \n    ###*\n    * Tints the game object to a specified tone.\n    *\n    * @method tintTo\n    * @param {Tone} tone The target tone.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    ### \n    tintTo: (tone, duration, easingType) ->\n        @object.addComponent(@tintAnimation)\n        @tintAnimation.start(tone, duration, easingType, @callback)\n        \n        return @tintAnimation\n    \n    ###*\n    * Rotates the game object around its anchor-point.\n    *\n    * @method rotate\n    * @param {gs.RotationDirection} direction The rotation-direction.\n    * @param {number} speed The rotation speed in degrees per frame.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    ### \n    rotate: (direction, speed, duration, easingType) ->\n        @object.addComponent(@rotateAnimation)\n        @rotateAnimation.rotate(direction, speed, duration, easingType, @callback)\n        \n        return @rotateAnimation\n    \n    ###*\n    * Rotates the game object around its anchor-point to a specified angle.\n    *\n    * @method rotateTo\n    * @param {number} angle The target angle.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    ### \n    rotateTo: (angle, duration, easingType) ->\n        @object.addComponent(@rotateAnimation)\n        @rotateAnimation.rotateTo(angle, duration, easingType, @callback)\n        \n        return @rotateAnimation\n        \n    ###*\n    * Lets a game object appear on screen using a masking-effect.\n    *\n    * @method maskIn\n    * @param {gs.Mask} mask The mask used for the animation.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    * @param {function} [callback] An optional callback-function called when the animation is finished. \n    ###     \n    maskIn: (mask, duration, easing, callback) ->\n        @object.addComponent(@maskAnimation)\n        @maskAnimation.maskIn(mask, duration, easing, (object, animation) -> object.removeComponent(animation); callback?(object);)\n        \n        return @maskAnimation\n     \n    ###*\n    * Description follows...\n    *\n    * @method maskTo\n    * @param {gs.Mask} mask The mask used for the animation.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    * @param {function} [callback] An optional callback-function called when the animation is finished. \n    ###     \n    maskTo: (mask, duration, easing, callback) ->\n        @object.addComponent(@maskAnimation)\n        @maskAnimation.maskTo(mask, duration, easing, (object, animation) -> object.removeComponent(animation); callback?(object);)\n        \n        return @maskAnimation\n        \n    ###*\n    * Lets a game object disappear from screen using a masking-effect.\n    *\n    * @method maskOut\n    * @param {gs.Mask} mask The mask used for the animation.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    * @param {function} [callback] An optional callback-function called when the animation is finished. \n    ###  \n    maskOut: (mask, duration, easing, callback) ->\n        @object.addComponent(@maskAnimation)\n        @maskAnimation.maskOut(mask, duration, easing, (object, animation) -> object.removeComponent(animation); callback?(object);)\n        \n        return @maskAnimation\n\n    ###*\n    * Lets a game object appear on screen from left, top, right or bottom using \n    * a move-animation\n    *\n    * @method moveIn\n    * @param {number} x The x-coordinate of the target-position.\n    * @param {number} y The y-coordinate of the target-position.\n    * @param {number} type The movement-direction from where the game object should move-in.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    * @param {function} [callback] An optional callback-function called when the animation is finished. \n    ###  \n    moveIn: (x, y, type, duration, easing, callback) ->\n        @object.addComponent(@moveAnimation)\n        @moveAnimation.moveIn(x, y, type, duration, easing, (object, animation) -> \n            object.removeComponent(animation)\n            callback?(object))\n        \n        return @moveAnimation\n      \n    ###*\n    * Lets a game object disappear from screen to the left, top, right or bottom using \n    * a move-animation\n    *\n    * @method moveOut\n    * @param {number} type The movement-direction in which the game object should move-out.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    * @param {function} [callback] An optional callback-function called when the animation is finished. \n    ###    \n    moveOut: (type, duration, easing, callback) ->\n        @object.addComponent(@moveAnimation)\n        @moveAnimation.moveOut(type, duration, easing, (object, animation) -> \n            object.removeComponent(animation)\n            callback?(object)\n        )\n        \n        return @moveAnimation\n        \n    ###*\n    * Lets a game object appear on screen using blending.\n    *\n    * @method show\n    * @param {number} duration The duration in frames.\n    * @param {Object} easing The easing-type.\n    * @param {function} [callback] An optional callback-function called when the animation is finished. \n    ###  \n    show: (duration, easing, callback) ->\n        @object.opacity = 0\n        @object.visual?.update()\n        \n        return @blendTo(255, duration, easing, callback)\n     \n    ###*\n    * Lets a game object disappear from screen using blending.\n    *\n    * @method hide\n    * @param {number} duration The duration in frames.\n    * @param {Object} easing The easing-type.\n    * @param {function} [callback] An optional callback-function called when the animation is finished. \n    ###     \n    hide: (duration, easing, callback) ->\n        return @blendTo(0, duration, easing, callback)\n       \n    ###*\n    * Changes visible-property to true. This method is deprecated.\n    * \n    * @method open\n    * @deprecated\n    ###   \n    open: -> @object.visible = yes\n    \n    ###*\n    * Changes visible-property to false. This method is deprecated.\n    * \n    * @method close\n    * @deprecated\n    ###   \n    close: -> @object.visible = no\n    \n    ###*\n    * Flashes the game object.\n    *\n    * @method flash\n    * @param {Color} color The flash-color.\n    * @param {number} duration The duration in frames.\n    ###\n    flash: (color, duration) ->\n        @object.color = color\n        color = new Color(color)\n        color.alpha = 0\n        return @colorTo(color, duration, gs.Easings.EASE_LINEAR[gs.EasingTypes.EASE_IN])\n    \n    ###*\n    * Lets a game object appear on screen using a specified animation.\n    *\n    * @method appear\n    * @param {number} x The x-coordinate of the target-position.\n    * @param {number} y The y-coordinate of the target-position.\n    * @param {gs.AppearAnimationInfo} animation The animation info-object.\n    * @param {Object} easing The easing-type.\n    * @param {number} duration The duration in frames.\n    * @param {function} [callback] An optional callback-function called when the animation is finished. \n    ###      \n    appear: (x, y, animation, easing, duration, callback) ->\n        easing = easing || gs.Easings.EASE_LINEAR[gs.EasingTypes.EASE_IN]\n        @object.visible = yes\n\n        if animation.type == gs.AnimationTypes.MOVEMENT\n            @moveIn(x, y, animation.movement, duration, easing, callback)\n        else if animation.type == gs.AnimationTypes.MASKING\n            @maskIn(animation.mask, duration, easing, callback)\n        else\n            @show(duration, easing, callback)\n    \n    ###*\n    * Lets a game object disappear from screen using a specified animation.\n    *\n    * @method disappear\n    * @param {gs.AppearAnimationInfo} animation The animation info-object.\n    * @param {Object} easing The easing-type.\n    * @param {number} duration The duration in frames.\n    * @param {function} [callback] An optional callback-function called when the animation is finished. \n    ###       \n    disappear: (animation, easing, duration, callback) ->\n        @object.visible = yes\n        if animation.type == gs.AnimationTypes.MOVEMENT\n            @moveOut(animation.movement, duration, easing, callback)\n        else if animation.type == gs.AnimationTypes.MASKING\n            @maskOut(animation.mask, duration, easing, callback)\n        else\n            @hide(duration, easing, callback)\n        \n\ngs.Animator = Component_Animator\ngs.Component_Animator = Component_Animator",
        "compiledContent": "// Generated by CoffeeScript 1.12.7\n(function() {\n  var Component_Animator,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  Component_Animator = (function(superClass) {\n    extend(Component_Animator, superClass);\n\n\n    /**\n    * An animator-component allows to execute different kind of animations \n    * on a game object. The animations are using the game object's \n    * dstRect & offset-property to execute.\n    *\n    * @module gs\n    * @class Component_Animator\n    * @extends gs.Component\n    * @memberof gs\n    * @constructor\n     */\n\n    function Component_Animator() {\n      Component_Animator.__super__.constructor.apply(this, arguments);\n      this.moveAnimation = new gs.Component_MoveAnimation();\n      this.pathAnimation = new gs.Component_PathAnimation();\n      this.zoomAnimation = new gs.Component_ZoomAnimation();\n      this.blendAnimation = new gs.Component_BlendAnimation();\n      this.blurAnimation = new gs.Component_BlurAnimation();\n      this.pixelateAnimation = new gs.Component_PixelateAnimation();\n      this.wobbleAnimation = new gs.Component_WobbleAnimation();\n      this.colorAnimation = new gs.Component_ColorAnimation();\n      this.imageAnimation = new gs.Component_ImageAnimation();\n      this.frameAnimation = new gs.Component_FrameAnimation();\n      this.fieldAnimation = new gs.Component_FieldAnimation();\n      this.shakeAnimation = new gs.Component_ShakeAnimation();\n      this.tintAnimation = new gs.Component_TintAnimation();\n      this.rotateAnimation = new gs.Component_RotateAnimation();\n      this.maskAnimation = new gs.Component_MaskAnimation();\n      this.l2dAnimation = new gs.Component_Live2DAnimation();\n\n      /**\n      * Standard Callback Routine\n      * @property callback\n      * @type function\n      * @private\n       */\n      this.callback = function(object, animation) {\n        return object.removeComponent(animation);\n      };\n      this.onBlendFinish = function(object, animation, callback) {\n        object.removeComponent(animation);\n        return typeof callback === \"function\" ? callback(object) : void 0;\n      };\n    }\n\n    Component_Animator.accessors(\"isAnimating\", {\n      get: function() {\n        return this.object;\n      }\n\n      /**\n      * Updates the animator.\n      *\n      * @method update\n       */\n    });\n\n    Component_Animator.prototype.update = function() {\n      var ref, ref1;\n      Component_Animator.__super__.update.apply(this, arguments);\n      if (((ref = this.object.mask) != null ? (ref1 = ref.source) != null ? ref1.videoElement : void 0 : void 0) != null) {\n        return this.object.mask.source.update();\n      }\n    };\n\n\n    /**\n    * Moves the game object with a specified speed.\n    *\n    * @method move\n    * @param {number} speedX The speed on x-axis in pixels per frame.\n    * @param {number} speedY The speed on y-axis in pixels per frame.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type used for the animation.\n     */\n\n    Component_Animator.prototype.move = function(speedX, speedY, duration, easingType) {\n      this.object.addComponent(this.moveAnimation);\n      this.moveAnimation.move(speedX, speedY, duration, easingType, this.callback);\n      return this.moveAnimation;\n    };\n\n\n    /**\n    * Moves the game object to a specified position.\n    *\n    * @method moveTo\n    * @param {number} x The x-coordinate of the position.\n    * @param {number} y The y-coordinate of the position.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n     */\n\n    Component_Animator.prototype.moveTo = function(x, y, duration, easingType) {\n      this.object.addComponent(this.moveAnimation);\n      this.moveAnimation.moveTo(x, y, duration, easingType, this.callback);\n      return this.moveAnimation;\n    };\n\n\n    /**\n    * Moves the game object along a path.\n    *\n    * @method movePath\n    * @param {Object} path The path to follow.\n    * @param {gs.AnimationLoopType} loopType The loop-Type.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    * @param {Object[]} effects Optional array of effects executed during the path-movement like playing a sound.\n     */\n\n    Component_Animator.prototype.movePath = function(path, loopType, duration, easingType, effects) {\n      var c;\n      c = this.object.findComponent(\"Component_PathAnimation\");\n      if (c != null) {\n        c.loopType = loopType;\n      } else {\n        this.object.addComponent(this.pathAnimation);\n        this.pathAnimation.start(path, loopType, duration, easingType, effects, this.callback);\n      }\n      return this.pathAnimation;\n    };\n\n\n    /**\n    * Scrolls the game object with a specified speed.\n    *\n    * @method scroll\n    * @param {number} speedX The speed on x-axis in pixels per frame.\n    * @param {number} speedY The speed on y-axis in pixels per frame.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type used for the animation.\n     */\n\n    Component_Animator.prototype.scroll = function(speedX, speedY, duration, easingType) {\n      this.object.addComponent(this.moveAnimation);\n      this.moveAnimation.scroll(speedX, speedY, duration, easingType, this.callback);\n      return this.moveAnimation;\n    };\n\n\n    /**\n    * Scrolls the game object to a specified position.\n    *\n    * @method scrollTo\n    * @param {number} x The x-coordinate of the position.\n    * @param {number} y The y-coordinate of the position.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n     */\n\n    Component_Animator.prototype.scrollTo = function(x, y, duration, easingType) {\n      this.object.addComponent(this.moveAnimation);\n      this.moveAnimation.scrollTo(x, y, duration, easingType, this.callback);\n      return this.moveAnimation;\n    };\n\n\n    /**\n    * Scrolls the game object along a path.\n    *\n    * @method scrollPath\n    * @param {Object} path The path to follow.\n    * @param {gs.AnimationLoopType} loopType The loop-Type.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n     */\n\n    Component_Animator.prototype.scrollPath = function(path, loopType, duration, easingType) {\n      this.object.addComponent(this.pathAnimation);\n      this.pathAnimation.scroll(path, loopType, duration, easingType, this.callback);\n      return this.pathAnimation;\n    };\n\n\n    /**\n    * Zooms a game object to specified size.\n    *\n    * @method zoomTo\n    * @param {number} x The x-axis zoom-factor.\n    * @param {number} y The y-axis zoom-factor.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n     */\n\n    Component_Animator.prototype.zoomTo = function(x, y, duration, easingType) {\n      this.object.addComponent(this.zoomAnimation);\n      this.zoomAnimation.start(x, y, duration, easingType, this.callback);\n      return this.zoomAnimation;\n    };\n\n\n    /**\n    * Blends a game object to specified opacity.\n    *\n    * @method blendTo\n    * @param {number} opacity The target opacity.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    * @param {function} [callback] An optional callback called if blending is finished.\n     */\n\n    Component_Animator.prototype.blendTo = function(opacity, duration, easingType, callback) {\n      this.blendAnimation.stop();\n      this.object.addComponent(this.blendAnimation);\n      this.blendAnimation.start(opacity, duration, easingType, gs.CallBack(\"onBlendFinish\", this, callback));\n      return this.blendAnimation;\n    };\n\n\n    /**\n    * Animates a Live2D model parameter of a Live2D game object to a specified value.\n    *\n    * @method blendTo\n    * @param {string} param The name of the parameter to animate.\n    * @param {number} value The target value.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    * @param {function} [callback] An optional callback called if blending is finished.\n     */\n\n    Component_Animator.prototype.l2dParameterTo = function(param, value, duration, easingType, callback) {\n      this.object.addComponent(this.l2dAnimation);\n      this.l2dAnimation.start(param, value, duration, easingType, gs.CallBack(\"onBlendFinish\", this, callback));\n      return this.l2dAnimation;\n    };\n\n\n    /**\n    * Blurs a game object to specified blur-power.\n    *\n    * @method blurTo\n    * @param {number} power The target blur-power.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n     */\n\n    Component_Animator.prototype.blurTo = function(power, duration, easingType) {\n      this.object.addComponent(this.blurAnimation);\n      this.blurAnimation.start(power, duration, easingType);\n      return this.blurAnimation;\n    };\n\n\n    /**\n    * Pixelates a game object to specified pixel-size/block-size\n    *\n    * @method pixelateTo\n    * @param {number} width - The target block-width\n    * @param {number} height - The target block-height\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n     */\n\n    Component_Animator.prototype.pixelateTo = function(width, height, duration, easingType) {\n      this.object.addComponent(this.pixelateAnimation);\n      this.pixelateAnimation.start(width, height, duration, easingType);\n      return this.pixelateAnimation;\n    };\n\n\n    /**\n    * Wobbles a game object to specified wobble-power and wobble-speed.\n    *\n    * @method wobbleTo\n    * @param {number} power The target wobble-power.\n    * @param {number} speed The target wobble-speed.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n     */\n\n    Component_Animator.prototype.wobbleTo = function(power, speed, duration, easingType) {\n      this.object.addComponent(this.wobbleAnimation);\n      this.wobbleAnimation.start(power, speed, duration, easingType);\n      return this.wobbleAnimation;\n    };\n\n\n    /**\n    * Colors a game object to a specified target color.\n    *\n    * @method colorTo\n    * @param {Color} color The target color.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n     */\n\n    Component_Animator.prototype.colorTo = function(color, duration, easingType) {\n      this.object.addComponent(this.colorAnimation);\n      this.colorAnimation.start(color, duration, easingType, this.callback);\n      return this.colorAnimation;\n    };\n\n\n    /**\n    * An image animation runs from left to right using the game object's\n    * image-property.\n    *\n    * @method changeImages\n    * @param {Array} images An array of image names.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n     */\n\n    Component_Animator.prototype.changeImages = function(images, duration, easingType) {\n      this.object.addComponent(this.imageAnimation);\n      this.imageAnimation.start(images, duration, easingType, this.callback);\n      return this.imageAnimation;\n    };\n\n\n    /**\n    * A frame animation which modifies the game object's srcRect property\n    * a play an animation.\n    *\n    * @method changeFrames\n    * @param {gs.Rect[]} frames An array of source rectangles (frames).\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n     */\n\n\n    /**\n    * A frame animation which modifies the game object's srcRect property\n    * a play an animation.\n    *\n    * @method playAnimation\n    * @param {gs.Rect[]} frames An array of source rectangles (frames).\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n     */\n\n    Component_Animator.prototype.playAnimation = function(animationRecord) {\n      this.frameAnimation.refresh(animationRecord);\n      this.object.addComponent(this.frameAnimation);\n      this.frameAnimation.start(this.callback);\n      return this.frameAnimation;\n    };\n\n\n    /**\n    * Changes a field of the game object to a specified value.\n    *\n    * @method change\n    * @param {number} Value The target value.\n    * @param {string} field The name of the field/property.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n     */\n\n    Component_Animator.prototype.change = function(value, field, duration, easingType) {\n      this.object.addComponent(this.fieldAnimation);\n      this.fieldAnimation.start(value, field, duration, easingType, this.callback);\n      return this.fieldAnimation;\n    };\n\n\n    /**\n    * Shakes the game object horizontally using the game object's offset-property.\n    *\n    * @method shake\n    * @param {gs.Range} range The horizontal shake-range.\n    * @param {number} speed The shake speed.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n     */\n\n    Component_Animator.prototype.shake = function(range, speed, duration, easing) {\n      this.object.addComponent(this.shakeAnimation);\n      this.shakeAnimation.start(range, speed, duration, easing, this.callback);\n      return this.shakeAnimation;\n    };\n\n\n    /**\n    * Tints the game object to a specified tone.\n    *\n    * @method tintTo\n    * @param {Tone} tone The target tone.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n     */\n\n    Component_Animator.prototype.tintTo = function(tone, duration, easingType) {\n      this.object.addComponent(this.tintAnimation);\n      this.tintAnimation.start(tone, duration, easingType, this.callback);\n      return this.tintAnimation;\n    };\n\n\n    /**\n    * Rotates the game object around its anchor-point.\n    *\n    * @method rotate\n    * @param {gs.RotationDirection} direction The rotation-direction.\n    * @param {number} speed The rotation speed in degrees per frame.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n     */\n\n    Component_Animator.prototype.rotate = function(direction, speed, duration, easingType) {\n      this.object.addComponent(this.rotateAnimation);\n      this.rotateAnimation.rotate(direction, speed, duration, easingType, this.callback);\n      return this.rotateAnimation;\n    };\n\n\n    /**\n    * Rotates the game object around its anchor-point to a specified angle.\n    *\n    * @method rotateTo\n    * @param {number} angle The target angle.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n     */\n\n    Component_Animator.prototype.rotateTo = function(angle, duration, easingType) {\n      this.object.addComponent(this.rotateAnimation);\n      this.rotateAnimation.rotateTo(angle, duration, easingType, this.callback);\n      return this.rotateAnimation;\n    };\n\n\n    /**\n    * Lets a game object appear on screen using a masking-effect.\n    *\n    * @method maskIn\n    * @param {gs.Mask} mask The mask used for the animation.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    * @param {function} [callback] An optional callback-function called when the animation is finished.\n     */\n\n    Component_Animator.prototype.maskIn = function(mask, duration, easing, callback) {\n      this.object.addComponent(this.maskAnimation);\n      this.maskAnimation.maskIn(mask, duration, easing, function(object, animation) {\n        object.removeComponent(animation);\n        return typeof callback === \"function\" ? callback(object) : void 0;\n      });\n      return this.maskAnimation;\n    };\n\n\n    /**\n    * Description follows...\n    *\n    * @method maskTo\n    * @param {gs.Mask} mask The mask used for the animation.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    * @param {function} [callback] An optional callback-function called when the animation is finished.\n     */\n\n    Component_Animator.prototype.maskTo = function(mask, duration, easing, callback) {\n      this.object.addComponent(this.maskAnimation);\n      this.maskAnimation.maskTo(mask, duration, easing, function(object, animation) {\n        object.removeComponent(animation);\n        return typeof callback === \"function\" ? callback(object) : void 0;\n      });\n      return this.maskAnimation;\n    };\n\n\n    /**\n    * Lets a game object disappear from screen using a masking-effect.\n    *\n    * @method maskOut\n    * @param {gs.Mask} mask The mask used for the animation.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    * @param {function} [callback] An optional callback-function called when the animation is finished.\n     */\n\n    Component_Animator.prototype.maskOut = function(mask, duration, easing, callback) {\n      this.object.addComponent(this.maskAnimation);\n      this.maskAnimation.maskOut(mask, duration, easing, function(object, animation) {\n        object.removeComponent(animation);\n        return typeof callback === \"function\" ? callback(object) : void 0;\n      });\n      return this.maskAnimation;\n    };\n\n\n    /**\n    * Lets a game object appear on screen from left, top, right or bottom using \n    * a move-animation\n    *\n    * @method moveIn\n    * @param {number} x The x-coordinate of the target-position.\n    * @param {number} y The y-coordinate of the target-position.\n    * @param {number} type The movement-direction from where the game object should move-in.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    * @param {function} [callback] An optional callback-function called when the animation is finished.\n     */\n\n    Component_Animator.prototype.moveIn = function(x, y, type, duration, easing, callback) {\n      this.object.addComponent(this.moveAnimation);\n      this.moveAnimation.moveIn(x, y, type, duration, easing, function(object, animation) {\n        object.removeComponent(animation);\n        return typeof callback === \"function\" ? callback(object) : void 0;\n      });\n      return this.moveAnimation;\n    };\n\n\n    /**\n    * Lets a game object disappear from screen to the left, top, right or bottom using \n    * a move-animation\n    *\n    * @method moveOut\n    * @param {number} type The movement-direction in which the game object should move-out.\n    * @param {number} duration The duration in frames.\n    * @param {Object} easingType The easing-type.\n    * @param {function} [callback] An optional callback-function called when the animation is finished.\n     */\n\n    Component_Animator.prototype.moveOut = function(type, duration, easing, callback) {\n      this.object.addComponent(this.moveAnimation);\n      this.moveAnimation.moveOut(type, duration, easing, function(object, animation) {\n        object.removeComponent(animation);\n        return typeof callback === \"function\" ? callback(object) : void 0;\n      });\n      return this.moveAnimation;\n    };\n\n\n    /**\n    * Lets a game object appear on screen using blending.\n    *\n    * @method show\n    * @param {number} duration The duration in frames.\n    * @param {Object} easing The easing-type.\n    * @param {function} [callback] An optional callback-function called when the animation is finished.\n     */\n\n    Component_Animator.prototype.show = function(duration, easing, callback) {\n      var ref;\n      this.object.opacity = 0;\n      if ((ref = this.object.visual) != null) {\n        ref.update();\n      }\n      return this.blendTo(255, duration, easing, callback);\n    };\n\n\n    /**\n    * Lets a game object disappear from screen using blending.\n    *\n    * @method hide\n    * @param {number} duration The duration in frames.\n    * @param {Object} easing The easing-type.\n    * @param {function} [callback] An optional callback-function called when the animation is finished.\n     */\n\n    Component_Animator.prototype.hide = function(duration, easing, callback) {\n      return this.blendTo(0, duration, easing, callback);\n    };\n\n\n    /**\n    * Changes visible-property to true. This method is deprecated.\n    * \n    * @method open\n    * @deprecated\n     */\n\n    Component_Animator.prototype.open = function() {\n      return this.object.visible = true;\n    };\n\n\n    /**\n    * Changes visible-property to false. This method is deprecated.\n    * \n    * @method close\n    * @deprecated\n     */\n\n    Component_Animator.prototype.close = function() {\n      return this.object.visible = false;\n    };\n\n\n    /**\n    * Flashes the game object.\n    *\n    * @method flash\n    * @param {Color} color The flash-color.\n    * @param {number} duration The duration in frames.\n     */\n\n    Component_Animator.prototype.flash = function(color, duration) {\n      this.object.color = color;\n      color = new Color(color);\n      color.alpha = 0;\n      return this.colorTo(color, duration, gs.Easings.EASE_LINEAR[gs.EasingTypes.EASE_IN]);\n    };\n\n\n    /**\n    * Lets a game object appear on screen using a specified animation.\n    *\n    * @method appear\n    * @param {number} x The x-coordinate of the target-position.\n    * @param {number} y The y-coordinate of the target-position.\n    * @param {gs.AppearAnimationInfo} animation The animation info-object.\n    * @param {Object} easing The easing-type.\n    * @param {number} duration The duration in frames.\n    * @param {function} [callback] An optional callback-function called when the animation is finished.\n     */\n\n    Component_Animator.prototype.appear = function(x, y, animation, easing, duration, callback) {\n      easing = easing || gs.Easings.EASE_LINEAR[gs.EasingTypes.EASE_IN];\n      this.object.visible = true;\n      if (animation.type === gs.AnimationTypes.MOVEMENT) {\n        return this.moveIn(x, y, animation.movement, duration, easing, callback);\n      } else if (animation.type === gs.AnimationTypes.MASKING) {\n        return this.maskIn(animation.mask, duration, easing, callback);\n      } else {\n        return this.show(duration, easing, callback);\n      }\n    };\n\n\n    /**\n    * Lets a game object disappear from screen using a specified animation.\n    *\n    * @method disappear\n    * @param {gs.AppearAnimationInfo} animation The animation info-object.\n    * @param {Object} easing The easing-type.\n    * @param {number} duration The duration in frames.\n    * @param {function} [callback] An optional callback-function called when the animation is finished.\n     */\n\n    Component_Animator.prototype.disappear = function(animation, easing, duration, callback) {\n      this.object.visible = true;\n      if (animation.type === gs.AnimationTypes.MOVEMENT) {\n        return this.moveOut(animation.movement, duration, easing, callback);\n      } else if (animation.type === gs.AnimationTypes.MASKING) {\n        return this.maskOut(animation.mask, duration, easing, callback);\n      } else {\n        return this.hide(duration, easing, callback);\n      }\n    };\n\n    return Component_Animator;\n\n  })(gs.Component);\n\n  gs.Animator = Component_Animator;\n\n  gs.Component_Animator = Component_Animator;\n\n}).call(this);\n"
    },
    "summary": [
        "name",
        "type",
        "order"
    ],
    "externalItems": []
}