{
    "uid": "21B4CFA0K977AA4FDAS8B9DE2F942A1341C2",
    "isLoaded": true,
    "lastModificationTime": 0,
    "items": {
        "name": "Component_Frame",
        "type": "game_script",
        "order": 15,
        "parentId": "01A95DA3K01E8A4CB4SBE17E790BCE1FC035",
        "folder": false,
        "content": "# ===================================================================\n#\n#   Script: Component_Frame\n#\n#   $$COPYRIGHT$$\n#\n# ===================================================================\nclass Component_Frame extends gs.Component_Visual\n    ###*\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    * \n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n    ###\n    onDataBundleRestore: (data, context) ->\n        @setupEventHandlers()\n        \n    ###*\n    * A frame constructs a graphical frame from its skin-image. The frame can\n    * rendered by tiling or strechting the four sides of the frame. A frame\n    * is useful for creating In-Game UI windows and boxes. For more info about \n    * the skin-image format, see help-file.\n    * \n    * @module gs\n    * @class Component_Frame\n    * @extends gs.Component_Visual\n    * @memberof gs\n    * @constructor\n    * @param {gs.Viewport} viewport An optional native viewport object.\n    ###\n    constructor: (viewport) ->\n        super()\n        \n        ###*\n        * The native frame-object.\n        * @property frame\n        * @type gs.Frame\n        ###\n        @frame = new gs.Frame(viewport ? Graphics.viewport)\n        \n        ###*\n        * The name of the skin-image used to construct the frame.\n        * @property image\n        * @type string\n        * @protected\n        ###\n        @image = null\n        \n        \n    ###*\n    * Disposes the frame.\n    * \n    * @method dispose\n    ###    \n    dispose: ->\n        super\n        @frame.dispose()\n        \n    ###*\n    * Adds event-handlers for mouse/touch events\n    *\n    * @method setupEventHandlers\n    ### \n    setupEventHandlers: ->\n        @frame.onIndexChange = =>\n            @object.rIndex = @frame.index\n            \n    ###*\n    * Setup the frame component. This method is automatically called by the\n    * system.\n    * @method setup\n    ###\n    setup: ->\n        @setupEventHandlers()\n    \n    ###*\n    * Updates the padding.\n    * \n    * @method updatePadding\n    ###  \n    updatePadding: ->\n        if @object.padding?\n            @frame.x += @object.padding.left\n            @frame.y += @object.padding.top\n            @frame.width -= (@object.padding.left+@object.padding.right)# / @object.zoom.x\n            @frame.height -= (@object.padding.top+@object.padding.bottom)# / @object.zoom.y\n    \n    ###*\n    * Updates the frame properties from the game object properties.\n    *\n    * @method updateProperties\n    ###\n    updateProperties: ->\n        @frame.x = @object.dstRect.x #- @object.dstRect.width * (@object.zoom.x - 1.0) * @object.anchor.x\n        @frame.y = @object.dstRect.y #- @object.dstRect.height * (@object.zoom.y - 1.0) * @object.anchor.y\n        @frame.width = @object.dstRect.width\n        @frame.height = @object.dstRect.height\n        @frame.thickness = @object.frameThickness || 16\n        @frame.cornerSize = @object.frameCornerSize || 16\n        @frame.clipRect = @object.clipRect\n        @frame.visible = @object.visible\n        @frame.ox = -@object.origin.x\n        @frame.oy = -@object.origin.y\n        @frame.zoomX = @object.zoom.x\n        @frame.zoomY = @object.zoom.y\n        @frame.angle = @object.angle || 0\n        @frame.opacity = @object.opacity\n        @frame.z = (@object.zIndex || 0) + (if !@object.parent then 0 else @object.parent.zIndex || 0)\n    \n    ###*\n    * Updates the optional sprite properties from the game object properties.\n    * @method updateOptionalProperties\n    ###\n    updateOptionalProperties: ->\n        if @object.tone?\n            @frame.tone = @object.tone\n        if @object.color?\n            @frame.color = @object.color\n        if @object.viewport?\n            @frame.viewport = @object.viewport\n        if @object.effects?\n            @frame.wobble = @object.effects.wobble\n        if @object.anchor?\n            @frame.anchor.x = @object.anchor.x\n            @frame.anchor.y = @object.anchor.y\n            \n    ###*\n    * Updates the frame's skin-image used to construct the frame.\n    *\n    * @method updateImage\n    ###\n    updateImage: ->\n        if @object.image? and @image != @object.image\n            @image = @object.image\n            bitmap = ResourceManager.getBitmap(\"#{@object.imageFolder||\"Graphics/Pictures\"}/#{@object.image}\")\n            @frame.skin = bitmap\n        \n    ###*\n    * Updates the frame's padding, properties and skin-image.\n    * \n    * @method update\n    ###   \n    update: ->\n        super\n\n        @object.rIndex = @frame.index\n        @updateProperties()\n        @updateOptionalProperties()\n        @updatePadding()\n        @updateImage()\n        \n        \n\n        \n        \n        \ngs.Component_Frame = Component_Frame",
        "compiledContent": "// Generated by CoffeeScript 1.12.7\n(function() {\n  var Component_Frame,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  Component_Frame = (function(superClass) {\n    extend(Component_Frame, superClass);\n\n\n    /**\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    * \n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n     */\n\n    Component_Frame.prototype.onDataBundleRestore = function(data, context) {\n      return this.setupEventHandlers();\n    };\n\n\n    /**\n    * A frame constructs a graphical frame from its skin-image. The frame can\n    * rendered by tiling or strechting the four sides of the frame. A frame\n    * is useful for creating In-Game UI windows and boxes. For more info about \n    * the skin-image format, see help-file.\n    * \n    * @module gs\n    * @class Component_Frame\n    * @extends gs.Component_Visual\n    * @memberof gs\n    * @constructor\n    * @param {gs.Viewport} viewport An optional native viewport object.\n     */\n\n    function Component_Frame(viewport) {\n      Component_Frame.__super__.constructor.call(this);\n\n      /**\n      * The native frame-object.\n      * @property frame\n      * @type gs.Frame\n       */\n      this.frame = new gs.Frame(viewport != null ? viewport : Graphics.viewport);\n\n      /**\n      * The name of the skin-image used to construct the frame.\n      * @property image\n      * @type string\n      * @protected\n       */\n      this.image = null;\n    }\n\n\n    /**\n    * Disposes the frame.\n    * \n    * @method dispose\n     */\n\n    Component_Frame.prototype.dispose = function() {\n      Component_Frame.__super__.dispose.apply(this, arguments);\n      return this.frame.dispose();\n    };\n\n\n    /**\n    * Adds event-handlers for mouse/touch events\n    *\n    * @method setupEventHandlers\n     */\n\n    Component_Frame.prototype.setupEventHandlers = function() {\n      return this.frame.onIndexChange = (function(_this) {\n        return function() {\n          return _this.object.rIndex = _this.frame.index;\n        };\n      })(this);\n    };\n\n\n    /**\n    * Setup the frame component. This method is automatically called by the\n    * system.\n    * @method setup\n     */\n\n    Component_Frame.prototype.setup = function() {\n      return this.setupEventHandlers();\n    };\n\n\n    /**\n    * Updates the padding.\n    * \n    * @method updatePadding\n     */\n\n    Component_Frame.prototype.updatePadding = function() {\n      if (this.object.padding != null) {\n        this.frame.x += this.object.padding.left;\n        this.frame.y += this.object.padding.top;\n        this.frame.width -= this.object.padding.left + this.object.padding.right;\n        return this.frame.height -= this.object.padding.top + this.object.padding.bottom;\n      }\n    };\n\n\n    /**\n    * Updates the frame properties from the game object properties.\n    *\n    * @method updateProperties\n     */\n\n    Component_Frame.prototype.updateProperties = function() {\n      this.frame.x = this.object.dstRect.x;\n      this.frame.y = this.object.dstRect.y;\n      this.frame.width = this.object.dstRect.width;\n      this.frame.height = this.object.dstRect.height;\n      this.frame.thickness = this.object.frameThickness || 16;\n      this.frame.cornerSize = this.object.frameCornerSize || 16;\n      this.frame.clipRect = this.object.clipRect;\n      this.frame.visible = this.object.visible;\n      this.frame.ox = -this.object.origin.x;\n      this.frame.oy = -this.object.origin.y;\n      this.frame.zoomX = this.object.zoom.x;\n      this.frame.zoomY = this.object.zoom.y;\n      this.frame.angle = this.object.angle || 0;\n      this.frame.opacity = this.object.opacity;\n      return this.frame.z = (this.object.zIndex || 0) + (!this.object.parent ? 0 : this.object.parent.zIndex || 0);\n    };\n\n\n    /**\n    * Updates the optional sprite properties from the game object properties.\n    * @method updateOptionalProperties\n     */\n\n    Component_Frame.prototype.updateOptionalProperties = function() {\n      if (this.object.tone != null) {\n        this.frame.tone = this.object.tone;\n      }\n      if (this.object.color != null) {\n        this.frame.color = this.object.color;\n      }\n      if (this.object.viewport != null) {\n        this.frame.viewport = this.object.viewport;\n      }\n      if (this.object.effects != null) {\n        this.frame.wobble = this.object.effects.wobble;\n      }\n      if (this.object.anchor != null) {\n        this.frame.anchor.x = this.object.anchor.x;\n        return this.frame.anchor.y = this.object.anchor.y;\n      }\n    };\n\n\n    /**\n    * Updates the frame's skin-image used to construct the frame.\n    *\n    * @method updateImage\n     */\n\n    Component_Frame.prototype.updateImage = function() {\n      var bitmap;\n      if ((this.object.image != null) && this.image !== this.object.image) {\n        this.image = this.object.image;\n        bitmap = ResourceManager.getBitmap((this.object.imageFolder || \"Graphics/Pictures\") + \"/\" + this.object.image);\n        return this.frame.skin = bitmap;\n      }\n    };\n\n\n    /**\n    * Updates the frame's padding, properties and skin-image.\n    * \n    * @method update\n     */\n\n    Component_Frame.prototype.update = function() {\n      Component_Frame.__super__.update.apply(this, arguments);\n      this.object.rIndex = this.frame.index;\n      this.updateProperties();\n      this.updateOptionalProperties();\n      this.updatePadding();\n      return this.updateImage();\n    };\n\n    return Component_Frame;\n\n  })(gs.Component_Visual);\n\n  gs.Component_Frame = Component_Frame;\n\n}).call(this);\n"
    },
    "summary": [
        "name",
        "type",
        "order"
    ],
    "externalItems": []
}