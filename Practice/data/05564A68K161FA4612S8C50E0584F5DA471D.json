{
    "uid": "05564A68K161FA4612S8C50E0584F5DA471D",
    "isLoaded": true,
    "lastModificationTime": 0,
    "items": {
        "name": "Component_ActionHandler",
        "type": "game_script",
        "order": 11,
        "parentId": "01A95DA3K01E8A4CB4SBE17E790BCE1FC035",
        "folder": false,
        "content": "# ===================================================================\n#\n#   Script: Component_ActionHandler\n#\n#   $$COPYRIGHT$$\n#\n# ===================================================================\nclass Component_ActionHandler extends ui.Component_Handler\n    ###*\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    * \n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n    ###\n    onDataBundleRestore: (data, context) ->\n        @setupEventHandlers()\n        \n    ###*\n    * An action-handler component allows a UI game object to execute\n    * actions. An action can be a method-call of a component or of the scene which\n    * always takes two parameters: Sender and Params. For more info about\n    * UI actions, see help-file.\n    * \n    * @module ui\n    * @class Component_ActionHandler\n    * @extends ui.Component_Handler\n    * @memberof ui\n    * @constructor\n    ###\n    constructor: ->\n        ###*\n        * @property initialized\n        * @type boolean\n        * @protected\n        ###\n        @initialized = no\n        \n        ###*\n        * Counter for delayed/timed actions.\n        * @property waitCounter\n        * @type number\n        * @protected\n        ###\n        @waitCounter = 0\n        \n        ###*\n        * Indicates if the mouse/touch pointer is inside the UI object's bounds.\n        * @property contains\n        * @type boolean\n        * @protected\n        ###\n        @containsPointer = no\n    \n    \n    ###*\n    * Disposes the component.\n    *\n    * @method dispose\n    ###\n    dispose: ->\n        super\n        \n        gs.GlobalEventManager.offByOwner(\"keyUp\", @object)\n        gs.GlobalEventManager.offByOwner(\"mouseUp\", @object)\n        gs.GlobalEventManager.offByOwner(\"mouseMoved\", @object)\n        \n    \n    ###*\n    * Adds event-handler for mouse/touch events to update the component only if \n    * a user-action happened.\n    *\n    * @method setupEventHandlers\n    ### \n    setupEventHandlers: ->\n        gs.GlobalEventManager.offByOwner(\"keyUp\", @object)\n        gs.GlobalEventManager.offByOwner(\"mouseUp\", @object)\n        gs.GlobalEventManager.offByOwner(\"mouseMoved\", @object)\n       \n        \n        if @object.focusable\n            gs.GlobalEventManager.on \"keyUp\", ((e) => \n                if Input.release(Input.KEY_RETURN) and @object.ui.focused\n                    @object.needsUpdate = yes\n                    @executeActions()\n            ), null, @object\n        \n        gs.GlobalEventManager.on \"mouseUp\", ((e) => \n            contains = Rect.contains(@object.dstRect.x, @object.dstRect.y, \n                         @object.dstRect.width, @object.dstRect.height,\n                         Input.Mouse.x - @object.origin.x, Input.Mouse.y - @object.origin.y)\n            \n            if contains\n                exec = no\n                actions = actions || @object.actions\n                if actions?\n                    for action in actions\n                        exec = @checkAction(action) and !@checkActionWait(action)\n                        break if exec\n                        \n                if exec\n                    e.breakChain = yes\n                    @executeActions()\n                @object.needsUpdate = yes\n                \n        ), null, @object\n        \n            \n        if @object.actions?.first((a) -> a and (a.event == \"onMouseEnter\" or a.event == \"onMouseLeave\" or a.event == \"onMouseHover\"))\n            gs.GlobalEventManager.on \"mouseMoved\", ((e) =>\n                contains = Rect.contains(@object.dstRect.x, @object.dstRect.y, \n                         @object.dstRect.width, @object.dstRect.height,\n                         Input.Mouse.x - @object.origin.x, Input.Mouse.y - @object.origin.y)\n            \n                if @containsPointer != contains\n                    @containsPointer = contains\n                    @object.needsUpdate = yes\n            ),\n            null, @object\n            \n        @object.events.on \"action\", (e) =>\n            if e.actions or e.action\n                @executeAction(if e.actions? then e.actions[0] else e.action)\n     \n    ###*\n    * Sets up associated actions. Each action is validated and specific default values for the action-target\n    * and other options are set if not specified.\n    *\n    * @method setupActions\n    ###        \n    setupActions: ->\n        if @object.actions?\n            for action in @object.actions\n                continue unless action\n                if not action.event then action.event = \"onAction\"\n                if action.wait? then continue\n                if not action.target? then action.target = @object.controller\n                if typeof action.target == \"string\"\n                    if action.target.contains(\".\")\n                        action.target = ui.Component_FormulaHandler.fieldValue(@object, action.target)\n                    targets = action.target.split(\".\")\n                    target = gs.ObjectManager.current.objectById(targets[0])\n                    if target?\n                        component = target.findComponentById(targets[1])\n                        if not component?\n                            target = target.components.where((v) -> typeof v[action.name] == \"function\").first()\n                        else\n                            target = component\n                    else\n                        target = @object\n                    action.target = target\n                if action.condition?\n                    action.conditions = [action.condition]\n                    delete action.condition\n                \n    ###*\n    * Initializes the action-handler.\n    * \n    * @method setup\n    ###\n    setup: ->\n        @initialized = yes\n        \n        @setupEventHandlers()\n        @setupActions()    \n        \n    ###*\n    * Updates the action-handler.\n    * \n    * @method update\n    ###\n    update: ->\n\n      \n    checkAction: (action) -> (action?.event or action?.events) and @checkObject(action)\n    checkActionWait: (action) ->\n        result = no\n        \n        if action.wait? and action.wait > 0\n            @waitCounter = action.wait\n            action.wait = 0\n            result = yes\n            \n        return result\n    updateActionTarget: (action) ->\n        if not action.target? then action.target = @object.controller\n        if action.target.exec or typeof action.target == \"string\"\n            if action.target.exec\n               action.target = ui.Component_FormulaHandler.fieldValue(@object, action.target)\n            targets = action.target.split(\".\")\n            target = gs.ObjectManager.current.objectById(targets[0])\n            if target?\n                component = target.findComponentById(targets[1])\n                if not component?\n                    target = target.components.where((v) -> typeof v[action.name] == \"function\").first()\n                else\n                    target = component\n            else\n                target = @object\n            action.target = target\n    \n    canExecuteActions: -> @waitCounter <= 0 and @object.ui.enabled and @object.visible         \n    \n    ###*\n    * Executes the specified actions. A single action is only executed if\n    * all assigned events and conditions are true.\n    * \n    * @method executeActions\n    * @return If <b>true</b> there was at least one action executed. Otherwise <b>false</b>\n    ###\n    executeActions: (actions) ->\n        return if not @canExecuteActions()\n        \n        result = no\n        actions = actions || @object.actions\n        if actions?\n            for action in actions\n                continue if not @checkAction(action)\n                break if @checkActionWait(action)\n                    \n                @updateActionTarget(action)\n                @executeAction(action)\n                \n                result = yes\n                \n        return result\n    \n    ###*\n    * Executes the specified action if all assigned events and conditions\n    * are true.\n    * \n    * @method executeAction\n    * @param {Object} action The action to execute.\n    ###            \n    executeAction: (action) ->\n        target = action.target || @object.target\n        \n        if target? \n            AudioManager.playSound(action.sound) if action.sound\n            target[action.name]?(@object, action.params)\n            \nui.Component_ActionHandler = Component_ActionHandler",
        "compiledContent": "// Generated by CoffeeScript 1.12.7\n(function() {\n  var Component_ActionHandler,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  Component_ActionHandler = (function(superClass) {\n    extend(Component_ActionHandler, superClass);\n\n\n    /**\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    * \n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n     */\n\n    Component_ActionHandler.prototype.onDataBundleRestore = function(data, context) {\n      return this.setupEventHandlers();\n    };\n\n\n    /**\n    * An action-handler component allows a UI game object to execute\n    * actions. An action can be a method-call of a component or of the scene which\n    * always takes two parameters: Sender and Params. For more info about\n    * UI actions, see help-file.\n    * \n    * @module ui\n    * @class Component_ActionHandler\n    * @extends ui.Component_Handler\n    * @memberof ui\n    * @constructor\n     */\n\n    function Component_ActionHandler() {\n\n      /**\n      * @property initialized\n      * @type boolean\n      * @protected\n       */\n      this.initialized = false;\n\n      /**\n      * Counter for delayed/timed actions.\n      * @property waitCounter\n      * @type number\n      * @protected\n       */\n      this.waitCounter = 0;\n\n      /**\n      * Indicates if the mouse/touch pointer is inside the UI object's bounds.\n      * @property contains\n      * @type boolean\n      * @protected\n       */\n      this.containsPointer = false;\n    }\n\n\n    /**\n    * Disposes the component.\n    *\n    * @method dispose\n     */\n\n    Component_ActionHandler.prototype.dispose = function() {\n      Component_ActionHandler.__super__.dispose.apply(this, arguments);\n      gs.GlobalEventManager.offByOwner(\"keyUp\", this.object);\n      gs.GlobalEventManager.offByOwner(\"mouseUp\", this.object);\n      return gs.GlobalEventManager.offByOwner(\"mouseMoved\", this.object);\n    };\n\n\n    /**\n    * Adds event-handler for mouse/touch events to update the component only if \n    * a user-action happened.\n    *\n    * @method setupEventHandlers\n     */\n\n    Component_ActionHandler.prototype.setupEventHandlers = function() {\n      var ref;\n      gs.GlobalEventManager.offByOwner(\"keyUp\", this.object);\n      gs.GlobalEventManager.offByOwner(\"mouseUp\", this.object);\n      gs.GlobalEventManager.offByOwner(\"mouseMoved\", this.object);\n      if (this.object.focusable) {\n        gs.GlobalEventManager.on(\"keyUp\", ((function(_this) {\n          return function(e) {\n            if (Input.release(Input.KEY_RETURN) && _this.object.ui.focused) {\n              _this.object.needsUpdate = true;\n              return _this.executeActions();\n            }\n          };\n        })(this)), null, this.object);\n      }\n      gs.GlobalEventManager.on(\"mouseUp\", ((function(_this) {\n        return function(e) {\n          var action, actions, contains, exec, i, len;\n          contains = Rect.contains(_this.object.dstRect.x, _this.object.dstRect.y, _this.object.dstRect.width, _this.object.dstRect.height, Input.Mouse.x - _this.object.origin.x, Input.Mouse.y - _this.object.origin.y);\n          if (contains) {\n            exec = false;\n            actions = actions || _this.object.actions;\n            if (actions != null) {\n              for (i = 0, len = actions.length; i < len; i++) {\n                action = actions[i];\n                exec = _this.checkAction(action) && !_this.checkActionWait(action);\n                if (exec) {\n                  break;\n                }\n              }\n            }\n            if (exec) {\n              e.breakChain = true;\n              _this.executeActions();\n            }\n            return _this.object.needsUpdate = true;\n          }\n        };\n      })(this)), null, this.object);\n      if ((ref = this.object.actions) != null ? ref.first(function(a) {\n        return a && (a.event === \"onMouseEnter\" || a.event === \"onMouseLeave\" || a.event === \"onMouseHover\");\n      }) : void 0) {\n        gs.GlobalEventManager.on(\"mouseMoved\", ((function(_this) {\n          return function(e) {\n            var contains;\n            contains = Rect.contains(_this.object.dstRect.x, _this.object.dstRect.y, _this.object.dstRect.width, _this.object.dstRect.height, Input.Mouse.x - _this.object.origin.x, Input.Mouse.y - _this.object.origin.y);\n            if (_this.containsPointer !== contains) {\n              _this.containsPointer = contains;\n              return _this.object.needsUpdate = true;\n            }\n          };\n        })(this)), null, this.object);\n      }\n      return this.object.events.on(\"action\", (function(_this) {\n        return function(e) {\n          if (e.actions || e.action) {\n            return _this.executeAction(e.actions != null ? e.actions[0] : e.action);\n          }\n        };\n      })(this));\n    };\n\n\n    /**\n    * Sets up associated actions. Each action is validated and specific default values for the action-target\n    * and other options are set if not specified.\n    *\n    * @method setupActions\n     */\n\n    Component_ActionHandler.prototype.setupActions = function() {\n      var action, component, i, len, ref, results, target, targets;\n      if (this.object.actions != null) {\n        ref = this.object.actions;\n        results = [];\n        for (i = 0, len = ref.length; i < len; i++) {\n          action = ref[i];\n          if (!action) {\n            continue;\n          }\n          if (!action.event) {\n            action.event = \"onAction\";\n          }\n          if (action.wait != null) {\n            continue;\n          }\n          if (action.target == null) {\n            action.target = this.object.controller;\n          }\n          if (typeof action.target === \"string\") {\n            if (action.target.contains(\".\")) {\n              action.target = ui.Component_FormulaHandler.fieldValue(this.object, action.target);\n            }\n            targets = action.target.split(\".\");\n            target = gs.ObjectManager.current.objectById(targets[0]);\n            if (target != null) {\n              component = target.findComponentById(targets[1]);\n              if (component == null) {\n                target = target.components.where(function(v) {\n                  return typeof v[action.name] === \"function\";\n                }).first();\n              } else {\n                target = component;\n              }\n            } else {\n              target = this.object;\n            }\n            action.target = target;\n          }\n          if (action.condition != null) {\n            action.conditions = [action.condition];\n            results.push(delete action.condition);\n          } else {\n            results.push(void 0);\n          }\n        }\n        return results;\n      }\n    };\n\n\n    /**\n    * Initializes the action-handler.\n    * \n    * @method setup\n     */\n\n    Component_ActionHandler.prototype.setup = function() {\n      this.initialized = true;\n      this.setupEventHandlers();\n      return this.setupActions();\n    };\n\n\n    /**\n    * Updates the action-handler.\n    * \n    * @method update\n     */\n\n    Component_ActionHandler.prototype.update = function() {};\n\n    Component_ActionHandler.prototype.checkAction = function(action) {\n      return ((action != null ? action.event : void 0) || (action != null ? action.events : void 0)) && this.checkObject(action);\n    };\n\n    Component_ActionHandler.prototype.checkActionWait = function(action) {\n      var result;\n      result = false;\n      if ((action.wait != null) && action.wait > 0) {\n        this.waitCounter = action.wait;\n        action.wait = 0;\n        result = true;\n      }\n      return result;\n    };\n\n    Component_ActionHandler.prototype.updateActionTarget = function(action) {\n      var component, target, targets;\n      if (action.target == null) {\n        action.target = this.object.controller;\n      }\n      if (action.target.exec || typeof action.target === \"string\") {\n        if (action.target.exec) {\n          action.target = ui.Component_FormulaHandler.fieldValue(this.object, action.target);\n        }\n        targets = action.target.split(\".\");\n        target = gs.ObjectManager.current.objectById(targets[0]);\n        if (target != null) {\n          component = target.findComponentById(targets[1]);\n          if (component == null) {\n            target = target.components.where(function(v) {\n              return typeof v[action.name] === \"function\";\n            }).first();\n          } else {\n            target = component;\n          }\n        } else {\n          target = this.object;\n        }\n        return action.target = target;\n      }\n    };\n\n    Component_ActionHandler.prototype.canExecuteActions = function() {\n      return this.waitCounter <= 0 && this.object.ui.enabled && this.object.visible;\n    };\n\n\n    /**\n    * Executes the specified actions. A single action is only executed if\n    * all assigned events and conditions are true.\n    * \n    * @method executeActions\n    * @return If <b>true</b> there was at least one action executed. Otherwise <b>false</b>\n     */\n\n    Component_ActionHandler.prototype.executeActions = function(actions) {\n      var action, i, len, result;\n      if (!this.canExecuteActions()) {\n        return;\n      }\n      result = false;\n      actions = actions || this.object.actions;\n      if (actions != null) {\n        for (i = 0, len = actions.length; i < len; i++) {\n          action = actions[i];\n          if (!this.checkAction(action)) {\n            continue;\n          }\n          if (this.checkActionWait(action)) {\n            break;\n          }\n          this.updateActionTarget(action);\n          this.executeAction(action);\n          result = true;\n        }\n      }\n      return result;\n    };\n\n\n    /**\n    * Executes the specified action if all assigned events and conditions\n    * are true.\n    * \n    * @method executeAction\n    * @param {Object} action The action to execute.\n     */\n\n    Component_ActionHandler.prototype.executeAction = function(action) {\n      var name, target;\n      target = action.target || this.object.target;\n      if (target != null) {\n        if (action.sound) {\n          AudioManager.playSound(action.sound);\n        }\n        return typeof target[name = action.name] === \"function\" ? target[name](this.object, action.params) : void 0;\n      }\n    };\n\n    return Component_ActionHandler;\n\n  })(ui.Component_Handler);\n\n  ui.Component_ActionHandler = Component_ActionHandler;\n\n}).call(this);\n"
    },
    "summary": [
        "name",
        "type",
        "order"
    ],
    "externalItems": []
}