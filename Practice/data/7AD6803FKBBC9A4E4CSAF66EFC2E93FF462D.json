{
    "uid": "7AD6803FKBBC9A4E4CSAF66EFC2E93FF462D",
    "isLoaded": true,
    "lastModificationTime": 0,
    "items": {
        "name": "Component_LayoutSceneBehavior",
        "type": "game_script",
        "order": 1,
        "parentId": "0C1D8BE8KDB63A469AS9782EB90E63254DB3",
        "folder": false,
        "content": "# ===================================================================\n#\n#   Script: Component_LayoutSceneBehaviorã€€\n#\n#   $$COPYRIGHT$$\n#\n# ===================================================================\nclass Component_LayoutSceneBehavior extends gs.Component_SceneBehavior\n  #  @objectCodecBlackList = [\"objectManager\"]\n    ###*\n    * The base class of all scene-behavior components. A scene-behavior component\n    * define the logic of a single game scene.\n    *\n    * @module gs\n    * @class Component_LayoutSceneBehavior\n    * @extends gs.Component_SceneBehavior\n    * @memberof gs\n    ###\n    constructor: ->\n        super()\n\n        @objectManager = SceneManager\n        @layout = null\n        @resourceContext = null\n\n    ###*\n    * Initializes the scene.\n    *\n    * @method initialize\n    ###\n    initialize: ->\n        super\n\n        @resourceContext = ResourceManager.createContext()\n        ResourceManager.context = @resourceContext\n\n        if not @object.layoutData?\n            @object.layoutData = { \"type\": \"ui.FreeLayout\", \"controls\": [], \"frame\": [0, 0, 1, 1] }\n\n        LanguageManager.loadBundles()\n\n    ###*\n    * Disposes the scene.\n    *\n    * @method dispose\n    ###\n    dispose: ->\n        super\n\n    ###*\n    * Prepares all data for the scene and loads the necessary graphic and audio resources.\n    *\n    * @method prepareData\n    * @abstract\n    ###\n    prepareData: ->\n        gs.ObjectManager.current = @objectManager\n\n        if not GameManager.initialized\n            GameManager.initialize()\n\n        @dataFields = ui.UiFactory.dataSources[@object.layoutData.dataSource || \"default\"]()\n        window.$dataFields = @dataFields\n        @music = ui.Component_FormulaHandler.fieldValue(@object, @object.layoutData.music)\n        AudioManager.loadMusic(@music)\n        @prepareTransition(RecordManager.system.menuTransition)\n\n        ResourceLoader.loadUiTypesGraphics(ui.UiFactory.customTypes)\n        ResourceLoader.loadUiLayoutGraphics(@object.layoutData)\n\n        if @dataFields?\n            ResourceLoader.loadUiDataFieldsGraphics(@dataFields)\n\n    ###*\n    * Prepares all visual game object for the scene.\n    *\n    * @method prepareVisual\n    ###\n    prepareVisual: ->\n        scale = Graphics.scale\n        vocab = RecordManager.vocabulary\n\n        if not @layout?\n            @dataObject = {}\n            @layout = ui.UiFactory.createFromDescriptor(@object.layoutData, @object)\n\n            if @music?\n                AudioManager.changeMusic(@music, 30)\n\n\n        @layout.ui.prepare()\n        @layout.ui.appear()\n        @layout.update()\n\n        @transition()\n\n        if SceneManager.previousScenes.length == 0\n            if GameManager.tempFields.isExitingGame\n                GameManager.tempFields.isExitingGame = no\n                gs.GameNotifier.postResetSceneChange(@object.layoutName)\n            else\n                gs.GameNotifier.postSceneChange(@object.layoutName)\n\n    ###*\n    * Updates the scene's content.\n    *\n    * @method updateContent\n    ###\n    updateContent: ->\n        GameManager.update()\n        Graphics.viewport.update()\n\n    ###*\n    * Shows/Hides the current scene. A hidden scene is no longer shown and executed\n    * but all objects and data is still there and be shown again anytime.\n    *\n    * @method show\n    * @param {boolean} visible - Indicates if the scene should be shown or hidden.\n    ###\n    show: (visible) ->\n        if visible\n            ResourceManager.context = @resourceContext\n        @layout.visible = visible\n        @layout.update()\n        @objectManager.active = visible\n        if visible\n            gs.ObjectManager.current = SceneManager #@objectManager\n        #@objectManager.update()\n\n    ###*\n    * Action method which triggers a full refresh on the object returned by the specified binding-expression.\n    * The params must be a direct binding-expression string.\n    *\n    * @method fullRefreshObject\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {string} params -  The binding expression.\n    ###\n    fullRefreshObject: (sender, object) ->\n        object = ui.Component_FormulaHandler.fieldValue(sender, object)\n        object?.fullRefresh()\n\n    ###*\n    * Action method which triggers a refresh on the object returned by the specified binding-expression.\n    * The params must be a direct binding-expression string.\n    *\n    * @method refreshObject\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {string} params -  The binding expression.\n    ###\n    refreshObject: (sender, object) ->\n        object = ui.Component_FormulaHandler.fieldValue(sender, object)\n        object?.needsUpdate = true\n\n    addStyle: (sender, style) ->\n        styleObject = ui.UIManager.styles[style]\n        styleObject?.apply(sender)\n        sender.needsUpdate = yes\n        if styleObject?.font\n            sender.behavior.refresh()\n\n    removeStyle: (sender, style) ->\n        styleObject = ui.UIManager.styles[style]\n        styleObject?.revert(sender)\n        sender.descriptor.styles.remove(style)\n\n        for s in sender.descriptor.styles\n            ui.UIManager.styles[s]?.apply(sender)\n        sender.needsUpdate = yes\n        if styleObject?.font\n            sender.behavior.refresh()\n\n\n\n    ###*\n    * Action method which executes the specified bindings.\n    *\n    * @method executeBindings\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object[]} params -  An array of binding-definitions.\n    ###\n    executeBindings: (sender, bindings) ->\n        for binding in bindings\n            ui.Component_FormulaHandler.executeBinding(sender, binding)\n\n        return null\n\n    ###*\n    * Action method which executes the specified formulas.\n    *\n    * @method executeFormulas\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {ui.Formula[]} params -  An array of formula-definitions.\n    ###\n    executeFormulas: (sender, formulas) ->\n        for formula in formulas\n            ui.Component_FormulaHandler.executeFormula(sender, formula)\n\n    ###*\n    * Action method which executes an animation on a specified target game object.\n    *\n    * @method executeAnimation\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object} params -  Contains target-id and animations: { target, animations }\n    ###\n    executeAnimation: (sender, params) ->\n        object = ui.Component_FormulaHandler.fieldValue(sender, params.target)\n        animation = object?.animations.first (a) -> a.event == params.event\n\n        if animation and object\n            object.animationExecutor.execute(animation)\n\n    ###*\n    * Action method which emits the specified event.\n    *\n    * @method emitEvent\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object} params - Contains event name, source and data.\n    * <ul>\n    * <li>params.name - The name of the event to emit</li>\n    * <li>params.source - A binding-expression to define the game object which should emit the event.</li>\n    * <li>params.data - An object containing additional event specific data.</li>\n    * </ul>\n    ###\n    emitEvent: (sender, params) ->\n        object = ui.Component_FormulaHandler.fieldValue(sender, params.source)\n        object?.events.emit(params.name, object, ui.Component_FormulaHandler.fieldValue(sender, params.data))\n\n    ###*\n    * Action method which changes the game's aspect ratio.\n    *\n    * @method executeBindings\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {boolean} params -  If <b>true</b> the game screen will stretched so that it fills the entire screen\n    * of the player without any black borders. Otherwise the game screen stretches but keeps its ratio\n    * so black borders are possible if the game resolution's ratio and the target display's ratio are not match. It can also\n    * be a binding-expression.\n    ###\n    adjustAspectRatio: (sender, adjust) ->\n        adjust = ui.Component_FormulaHandler.fieldValue(sender, adjust)\n\n        GameManager.settings.adjustAspectRatio = adjust\n        Graphics.keepRatio = !adjust\n        Graphics.onResize()\n\n    ###*\n    * Action method which enters fullscreen mode.\n    *\n    * @method enterFullScreen\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {boolean} params - Can be <b>null</b>\n    ###\n    enterFullScreen: (sender, params) ->\n        gs.Graphics.enterFullscreen()\n        GameManager.settings.fullScreen = Graphics.isFullscreen()\n\n\n    ###*\n    * Action method which leaves fullscreen mode.\n    *\n    * @method leaveFullScreen\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {boolean} params - Can be <b>null</b>\n    ###\n    leaveFullScreen: ->\n        gs.Graphics.leaveFullscreen()\n        GameManager.settings.fullScreen = Graphics.isFullscreen()\n\n    ###*\n    * Action method which toggles between window and fullscreen mode.\n    *\n    * @method toggleFullScreen\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {boolean|string} params - Can be <b>null</b>\n    ###\n    toggleFullScreen: (sender, params) ->\n        if gs.Graphics.isFullscreen()\n            gs.Graphics.leaveFullscreen()\n        else\n            gs.Graphics.enterFullscreen()\n\n        GameManager.settings.fullScreen = gs.Graphics.isFullscreen()\n\n    ###*\n    * Action method which plays the specified sound.\n    *\n    * @method playSound\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object} params - The sound to play.\n    ###\n    playSound: (sender, params) ->\n        AudioManager.loadSound(params)\n        AudioManager.playSound(params)\n\n    ###*\n    * Action method which plays the specified voice.\n    *\n    * @method playVoice\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object} params - The voice to play.\n    ###\n    playVoice: (sender, params) ->\n        AudioManager.loadSound(params)\n        AudioManager.playVoice(params)\n\n\n    ###*\n    * Action method which turns voice on or off.\n    *\n    * @method turnOnOffVoice\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {boolean|string} params - If <b>true</b> voice will be turned on. Otherwise it will be turned off. Can also be a binding-expression.\n    ###\n    turnOnOffVoice: (sender, state) ->\n        if ui.Component_FormulaHandler.fieldValue(sender, state) then @turnOnVoice() else @turnOffVoice()\n\n    ###*\n    * Action method which turns music on or off.\n    *\n    * @method turnOnOffMusic\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {boolean|string} params - If <b>true</b> music will be turned on. Otherwise it will be turned off. Can also be a binding-expression.\n    ###\n    turnOnOffMusic: (sender, state) ->\n        if ui.Component_FormulaHandler.fieldValue(sender, state) then @turnOnMusic() else @turnOffMusic()\n\n    ###*\n    * Action method which turns sound on or off.\n    *\n    * @method turnOnOffSound\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {boolean|string} params - If <b>true</b> sound will be turned on. Otherwise it will be turned off. Can also be a binding-expression.\n    ###\n    turnOnOffSound: (sender, state) ->\n        if ui.Component_FormulaHandler.fieldValue(sender, state) then @turnOnSound() else @turnOffSound()\n\n    ###*\n    * Action method which turns off voice.\n    *\n    * @method turnOffVoice\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {boolean|string} params - Can be <b>null</b>.\n    ###\n    turnOffVoice: ->\n        AudioManager.stopAllVoices()\n\n    ###*\n    * Action method which turns off music.\n    *\n    * @method turnOffMusic\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {boolean|string} params - Can be <b>null</b>.\n    ###\n    turnOffMusic: ->\n        AudioManager.stopMusic()\n\n    ###*\n    * Action method which turns off sound.\n    *\n    * @method turnOffSound\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {boolean|string} params - Can be <b>null</b>.\n    ###\n    turnOffSound: ->\n        AudioManager.stopAllSounds()\n\n    ###*\n    * Action method which turns on voice.\n    *\n    * @method turnOnVoice\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {boolean|string} params - Can be <b>null</b>.\n    ###\n    turnOnVoice: ->\n\n    ###*\n    * Action method which turns on sound.\n    *\n    * @method turnOnSound\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {boolean|string} params - Can be <b>null</b>.\n    ###\n    turnOnSound: ->\n\n    ###*\n    * Action method which turns on music.\n    *\n    * @method turnOnMusic\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {boolean|string} params - Can be <b>null</b>.\n    ###\n    turnOnMusic: ->\n        AudioManager.resumeMusic()\n\n    ###*\n    * Action method which selects the specified language.\n    *\n    * @method selectLanguage\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {number|string} params - Index of the language to set. Can be a binding-expression.\n    ###\n    selectLanguage: (sender, params)->\n        language = LanguageManager.languages[ui.Component_FormulaHandler.fieldValue(sender, params)]\n        LanguageManager.selectLanguage(language)\n\n    ###*\n    * Action method which resets global data storage.\n    *\n    * @method resetGlobalData\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object} params - Can be <b>null</b>.\n    ###\n    resetGlobalData: (sender) ->\n        GameManager.resetGlobalData()\n\n    ###*\n    * Action method which saves game settings.\n    *\n    * @method saveSettings\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object} params - Can be <b>null</b>.\n    ###\n    saveSettings: (sender) -> GameManager.saveSettings()\n\n    ###*\n    * Action method which prepares the game for saving by taking a snapshot of the current game state\n    * and storing it in GameManager.saveGame.\n    *\n    * @method prepareSaveGame\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object} params - Can be <b>null</b>.\n    ###\n    prepareSaveGame: (sender, params) ->\n        GameManager.prepareSaveGame(params?.snapshot)\n\n    ###*\n    * Action method which saves the current game at the specified save slot.\n    *\n    * @method saveGame\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object} params - Contains the slot-index where the game should be saved.\n    * <ul>\n    * <li>params.slot - The slot-index where the game should be saved. Can be a binding-expression.</li>\n    * </ul>\n    ###\n    saveGame: (sender, params) -> GameManager.save(ui.Component_FormulaHandler.fieldValue(sender, params.slot))\n\n    ###*\n    * Action method which loads the game from the specified save slot.\n    *\n    * @method loadGame\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object} params - Contains the slot-index where the game should be loaded from.\n    * <ul>\n    * <li>params.slot - The slot-index where the game should be loaded from. Can be a binding-expression.</li>\n    * </ul>\n    ###\n    loadGame: (sender, params) ->\n        GameManager.tempSettings.skip = no\n        GameManager.load(ui.Component_FormulaHandler.fieldValue(sender, params.slot))\n\n    ###*\n    * Action method which starts a new game.\n    *\n    * @method newGame\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object} params - Can be <b>null</b>\n    ###\n    newGame: (sender, params) ->\n        AudioManager.stopAllMusic(30)\n        GameManager.newGame()\n\n        scene = new vn.Object_Scene()\n        SceneManager.clear()\n        SceneManager.switchTo(scene)\n\n    ###*\n    * Action method which exists the current game. It doesn't change the scene and\n    * should be called before switching back to the title screen or main menu.\n    *\n    * @method exitGame\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object} params - Can be <b>null</b>\n    ###\n    exitGame: (sender, params) ->\n        GameManager.exitGame()\n\n    ###*\n    * Action method which switches to another scene.\n    *\n    * @method switchScene\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object} params - Contains the class name of the scene to switch to.\n    * <ul>\n    * <li>params.name - The class-name of the scene to switch to. The class must be defined in vn-namespace.</li>\n    * </ul>\n    ###\n    switchScene: (sender, params) ->\n        f = =>\n            if params.clear\n                SceneManager.clear()\n\n            scene = new vn[params.name]()\n            SceneManager.switchTo(scene, params.savePrevious)\n\n        if !params.savePrevious\n            @layout.ui.disappear (e) => f()\n        else\n            f()\n\n    ###*\n    * Action method which switches to another game scene.\n    *\n    * @method switchGameScene\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object} params - Contains the UID of the scene to switch to.\n    * <ul>\n    * <li>params.uid - The UID of the scene to switch to.</li>\n    * </ul>\n    ###\n    switchGameScene: (sender, params) ->\n        f = =>\n            if params.clear\n                SceneManager.clear()\n\n            uid = params.uid\n            if params.name\n                sceneDocuments = DataManager.getDocumentsByType(\"vn.scene\")\n                sceneDocument = sceneDocuments.first (d) -> d.items.name == params.name\n                if sceneDocument\n                    uid = sceneDocument.uid\n\n            sceneData = uid: uid, pictures: [], texts: []\n            GameManager.sceneData = sceneData\n            newScene = new vn.Object_Scene()\n            newScene.sceneData = sceneData\n\n            SceneManager.switchTo(newScene, params.savePrevious)\n\n        if !params.savePrevious\n            (@layout||@object.layout).ui.disappear (e) => f()\n        else\n            f()\n\n    ###*\n    * Action method which switches to another layout.\n    *\n    * @method switchLayout\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object} params - Contains the name of the layout to switch to.\n    * <ul>\n    * <li>params.name - The name of the layout to switch to.</li>\n    * <li>params.savePrevious - Indicates if the current layout should not be erased but paused and hidden instead so\n    * that it can be restored using <i>returnToPrevious</i> action.</li>\n    * <li>params.dataFields - Defines the data of \"$dataFields\" binding-expression variable. Can be a binding-expression\n    * or a direct object. Optional.</li>\n    * </ul>\n    ###\n    switchLayout: (sender, layout) ->\n        f = =>\n            Graphics.freeze()\n            if layout.clear\n                SceneManager.clear()\n\n            scene = new gs.Object_Layout(layout.name)\n\n            dataFields = sender.dataFields\n            if typeof layout.dataFields == \"string\"\n                dataFields = ui.Component_FormulaHandler.fieldValue(sender, layout.dataFields)\n            else if layout.dataFields?\n                dataFields = layout.dataFields\n\n            scene.dataFields = dataFields\n            scene.controllers = layout.controllers\n\n            if layout.senderData?\n                for senderField in layout.senderData\n                    scene[senderField] = sender[senderField]\n            SceneManager.switchTo(scene, layout.savePrevious, layout.stack)\n\n        if !layout.savePrevious\n            (@layout||@object.layout).ui.disappear (e) => f()\n        else\n            f()\n\n    ###*\n    * Action method which returns to previous layout. (If savePrevious was set to <b>true</b> on switchLayout.).\n    *\n    * @method previousLayout\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object} params - Can be <b>null</b>.\n    ###\n    previousLayout: (sender) ->\n        SceneManager.returnToPrevious()\n\n    ###*\n    * Action method which disposes the specified control.\n    *\n    * @method disposeControl\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {string} params - The ID of the control to dispose. Can be a binding-expression.\n    ###\n    disposeControl: (sender, id) ->\n        control = @objectManager.objectById(ui.Component_FormulaHandler.fieldValue(sender, id))\n\n\n        control?.ui.disappear (sender) -> sender.dispose()\n\n    ###*\n    * Action method which creates a new control from the specified descriptor.\n    *\n    * @method createControl\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {string} params - Contains the descriptor and other data needed to construct the control.\n    * <ul>\n    * <li>params.descriptor - The control' descriptor. Can be a direct descriptor definition or a template name</li>\n    * <li>params.parent - A binding-expression which returns the control's parent.</li>\n    * <li>params.senderData - An object containing additional data merged into the control object.</li>\n    * </ul>\n    ###\n    createControl: (sender, data) ->\n        if typeof data.descriptor == \"string\"\n            descriptor = ui.UIManager.customTypes[data.descriptor]\n        else\n            descriptor = data.descriptor\n\n        parent = ui.Component_FormulaHandler.fieldValue(sender, data.parent)\n        control = ui.UiFactory._createFromDescriptor(descriptor, parent ? (@object.layout||@object) )\n\n        if data.senderData?\n            for fieldName in data.senderData\n                control[fieldName] = sender[fieldName]\n        control.ui.prepare()\n        control.ui.appear()\n\n        return control\n\n    ###*\n    * Action method which quits the game.\n    *\n    * @method quitGame\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {string} params - Can be <b>null</b>.\n    ###\n    quitGame: (sender, data) ->\n        SceneManager.switchTo(null)\n\n\n\ngs.Component_LayoutSceneBehavior = Component_LayoutSceneBehavior",
        "compiledContent": "// Generated by CoffeeScript 1.12.7\n(function() {\n  var Component_LayoutSceneBehavior,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  Component_LayoutSceneBehavior = (function(superClass) {\n    extend(Component_LayoutSceneBehavior, superClass);\n\n\n    /**\n    * The base class of all scene-behavior components. A scene-behavior component\n    * define the logic of a single game scene.\n    *\n    * @module gs\n    * @class Component_LayoutSceneBehavior\n    * @extends gs.Component_SceneBehavior\n    * @memberof gs\n     */\n\n    function Component_LayoutSceneBehavior() {\n      Component_LayoutSceneBehavior.__super__.constructor.call(this);\n      this.objectManager = SceneManager;\n      this.layout = null;\n      this.resourceContext = null;\n    }\n\n\n    /**\n    * Initializes the scene.\n    *\n    * @method initialize\n     */\n\n    Component_LayoutSceneBehavior.prototype.initialize = function() {\n      Component_LayoutSceneBehavior.__super__.initialize.apply(this, arguments);\n      this.resourceContext = ResourceManager.createContext();\n      ResourceManager.context = this.resourceContext;\n      if (this.object.layoutData == null) {\n        this.object.layoutData = {\n          \"type\": \"ui.FreeLayout\",\n          \"controls\": [],\n          \"frame\": [0, 0, 1, 1]\n        };\n      }\n      return LanguageManager.loadBundles();\n    };\n\n\n    /**\n    * Disposes the scene.\n    *\n    * @method dispose\n     */\n\n    Component_LayoutSceneBehavior.prototype.dispose = function() {\n      return Component_LayoutSceneBehavior.__super__.dispose.apply(this, arguments);\n    };\n\n\n    /**\n    * Prepares all data for the scene and loads the necessary graphic and audio resources.\n    *\n    * @method prepareData\n    * @abstract\n     */\n\n    Component_LayoutSceneBehavior.prototype.prepareData = function() {\n      gs.ObjectManager.current = this.objectManager;\n      if (!GameManager.initialized) {\n        GameManager.initialize();\n      }\n      this.dataFields = ui.UiFactory.dataSources[this.object.layoutData.dataSource || \"default\"]();\n      window.$dataFields = this.dataFields;\n      this.music = ui.Component_FormulaHandler.fieldValue(this.object, this.object.layoutData.music);\n      AudioManager.loadMusic(this.music);\n      this.prepareTransition(RecordManager.system.menuTransition);\n      ResourceLoader.loadUiTypesGraphics(ui.UiFactory.customTypes);\n      ResourceLoader.loadUiLayoutGraphics(this.object.layoutData);\n      if (this.dataFields != null) {\n        return ResourceLoader.loadUiDataFieldsGraphics(this.dataFields);\n      }\n    };\n\n\n    /**\n    * Prepares all visual game object for the scene.\n    *\n    * @method prepareVisual\n     */\n\n    Component_LayoutSceneBehavior.prototype.prepareVisual = function() {\n      var scale, vocab;\n      scale = Graphics.scale;\n      vocab = RecordManager.vocabulary;\n      if (this.layout == null) {\n        this.dataObject = {};\n        this.layout = ui.UiFactory.createFromDescriptor(this.object.layoutData, this.object);\n        if (this.music != null) {\n          AudioManager.changeMusic(this.music, 30);\n        }\n      }\n      this.layout.ui.prepare();\n      this.layout.ui.appear();\n      this.layout.update();\n      this.transition();\n      if (SceneManager.previousScenes.length === 0) {\n        if (GameManager.tempFields.isExitingGame) {\n          GameManager.tempFields.isExitingGame = false;\n          return gs.GameNotifier.postResetSceneChange(this.object.layoutName);\n        } else {\n          return gs.GameNotifier.postSceneChange(this.object.layoutName);\n        }\n      }\n    };\n\n\n    /**\n    * Updates the scene's content.\n    *\n    * @method updateContent\n     */\n\n    Component_LayoutSceneBehavior.prototype.updateContent = function() {\n      GameManager.update();\n      return Graphics.viewport.update();\n    };\n\n\n    /**\n    * Shows/Hides the current scene. A hidden scene is no longer shown and executed\n    * but all objects and data is still there and be shown again anytime.\n    *\n    * @method show\n    * @param {boolean} visible - Indicates if the scene should be shown or hidden.\n     */\n\n    Component_LayoutSceneBehavior.prototype.show = function(visible) {\n      if (visible) {\n        ResourceManager.context = this.resourceContext;\n      }\n      this.layout.visible = visible;\n      this.layout.update();\n      this.objectManager.active = visible;\n      if (visible) {\n        return gs.ObjectManager.current = SceneManager;\n      }\n    };\n\n\n    /**\n    * Action method which triggers a full refresh on the object returned by the specified binding-expression.\n    * The params must be a direct binding-expression string.\n    *\n    * @method fullRefreshObject\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {string} params -  The binding expression.\n     */\n\n    Component_LayoutSceneBehavior.prototype.fullRefreshObject = function(sender, object) {\n      object = ui.Component_FormulaHandler.fieldValue(sender, object);\n      return object != null ? object.fullRefresh() : void 0;\n    };\n\n\n    /**\n    * Action method which triggers a refresh on the object returned by the specified binding-expression.\n    * The params must be a direct binding-expression string.\n    *\n    * @method refreshObject\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {string} params -  The binding expression.\n     */\n\n    Component_LayoutSceneBehavior.prototype.refreshObject = function(sender, object) {\n      object = ui.Component_FormulaHandler.fieldValue(sender, object);\n      return object != null ? object.needsUpdate = true : void 0;\n    };\n\n    Component_LayoutSceneBehavior.prototype.addStyle = function(sender, style) {\n      var styleObject;\n      styleObject = ui.UIManager.styles[style];\n      if (styleObject != null) {\n        styleObject.apply(sender);\n      }\n      sender.needsUpdate = true;\n      if (styleObject != null ? styleObject.font : void 0) {\n        return sender.behavior.refresh();\n      }\n    };\n\n    Component_LayoutSceneBehavior.prototype.removeStyle = function(sender, style) {\n      var i, len, ref, ref1, s, styleObject;\n      styleObject = ui.UIManager.styles[style];\n      if (styleObject != null) {\n        styleObject.revert(sender);\n      }\n      sender.descriptor.styles.remove(style);\n      ref = sender.descriptor.styles;\n      for (i = 0, len = ref.length; i < len; i++) {\n        s = ref[i];\n        if ((ref1 = ui.UIManager.styles[s]) != null) {\n          ref1.apply(sender);\n        }\n      }\n      sender.needsUpdate = true;\n      if (styleObject != null ? styleObject.font : void 0) {\n        return sender.behavior.refresh();\n      }\n    };\n\n\n    /**\n    * Action method which executes the specified bindings.\n    *\n    * @method executeBindings\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object[]} params -  An array of binding-definitions.\n     */\n\n    Component_LayoutSceneBehavior.prototype.executeBindings = function(sender, bindings) {\n      var binding, i, len;\n      for (i = 0, len = bindings.length; i < len; i++) {\n        binding = bindings[i];\n        ui.Component_FormulaHandler.executeBinding(sender, binding);\n      }\n      return null;\n    };\n\n\n    /**\n    * Action method which executes the specified formulas.\n    *\n    * @method executeFormulas\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {ui.Formula[]} params -  An array of formula-definitions.\n     */\n\n    Component_LayoutSceneBehavior.prototype.executeFormulas = function(sender, formulas) {\n      var formula, i, len, results;\n      results = [];\n      for (i = 0, len = formulas.length; i < len; i++) {\n        formula = formulas[i];\n        results.push(ui.Component_FormulaHandler.executeFormula(sender, formula));\n      }\n      return results;\n    };\n\n\n    /**\n    * Action method which executes an animation on a specified target game object.\n    *\n    * @method executeAnimation\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object} params -  Contains target-id and animations: { target, animations }\n     */\n\n    Component_LayoutSceneBehavior.prototype.executeAnimation = function(sender, params) {\n      var animation, object;\n      object = ui.Component_FormulaHandler.fieldValue(sender, params.target);\n      animation = object != null ? object.animations.first(function(a) {\n        return a.event === params.event;\n      }) : void 0;\n      if (animation && object) {\n        return object.animationExecutor.execute(animation);\n      }\n    };\n\n\n    /**\n    * Action method which emits the specified event.\n    *\n    * @method emitEvent\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object} params - Contains event name, source and data.\n    * <ul>\n    * <li>params.name - The name of the event to emit</li>\n    * <li>params.source - A binding-expression to define the game object which should emit the event.</li>\n    * <li>params.data - An object containing additional event specific data.</li>\n    * </ul>\n     */\n\n    Component_LayoutSceneBehavior.prototype.emitEvent = function(sender, params) {\n      var object;\n      object = ui.Component_FormulaHandler.fieldValue(sender, params.source);\n      return object != null ? object.events.emit(params.name, object, ui.Component_FormulaHandler.fieldValue(sender, params.data)) : void 0;\n    };\n\n\n    /**\n    * Action method which changes the game's aspect ratio.\n    *\n    * @method executeBindings\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {boolean} params -  If <b>true</b> the game screen will stretched so that it fills the entire screen\n    * of the player without any black borders. Otherwise the game screen stretches but keeps its ratio\n    * so black borders are possible if the game resolution's ratio and the target display's ratio are not match. It can also\n    * be a binding-expression.\n     */\n\n    Component_LayoutSceneBehavior.prototype.adjustAspectRatio = function(sender, adjust) {\n      adjust = ui.Component_FormulaHandler.fieldValue(sender, adjust);\n      GameManager.settings.adjustAspectRatio = adjust;\n      Graphics.keepRatio = !adjust;\n      return Graphics.onResize();\n    };\n\n\n    /**\n    * Action method which enters fullscreen mode.\n    *\n    * @method enterFullScreen\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {boolean} params - Can be <b>null</b>\n     */\n\n    Component_LayoutSceneBehavior.prototype.enterFullScreen = function(sender, params) {\n      gs.Graphics.enterFullscreen();\n      return GameManager.settings.fullScreen = Graphics.isFullscreen();\n    };\n\n\n    /**\n    * Action method which leaves fullscreen mode.\n    *\n    * @method leaveFullScreen\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {boolean} params - Can be <b>null</b>\n     */\n\n    Component_LayoutSceneBehavior.prototype.leaveFullScreen = function() {\n      gs.Graphics.leaveFullscreen();\n      return GameManager.settings.fullScreen = Graphics.isFullscreen();\n    };\n\n\n    /**\n    * Action method which toggles between window and fullscreen mode.\n    *\n    * @method toggleFullScreen\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {boolean|string} params - Can be <b>null</b>\n     */\n\n    Component_LayoutSceneBehavior.prototype.toggleFullScreen = function(sender, params) {\n      if (gs.Graphics.isFullscreen()) {\n        gs.Graphics.leaveFullscreen();\n      } else {\n        gs.Graphics.enterFullscreen();\n      }\n      return GameManager.settings.fullScreen = gs.Graphics.isFullscreen();\n    };\n\n\n    /**\n    * Action method which plays the specified sound.\n    *\n    * @method playSound\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object} params - The sound to play.\n     */\n\n    Component_LayoutSceneBehavior.prototype.playSound = function(sender, params) {\n      AudioManager.loadSound(params);\n      return AudioManager.playSound(params);\n    };\n\n\n    /**\n    * Action method which plays the specified voice.\n    *\n    * @method playVoice\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object} params - The voice to play.\n     */\n\n    Component_LayoutSceneBehavior.prototype.playVoice = function(sender, params) {\n      AudioManager.loadSound(params);\n      return AudioManager.playVoice(params);\n    };\n\n\n    /**\n    * Action method which turns voice on or off.\n    *\n    * @method turnOnOffVoice\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {boolean|string} params - If <b>true</b> voice will be turned on. Otherwise it will be turned off. Can also be a binding-expression.\n     */\n\n    Component_LayoutSceneBehavior.prototype.turnOnOffVoice = function(sender, state) {\n      if (ui.Component_FormulaHandler.fieldValue(sender, state)) {\n        return this.turnOnVoice();\n      } else {\n        return this.turnOffVoice();\n      }\n    };\n\n\n    /**\n    * Action method which turns music on or off.\n    *\n    * @method turnOnOffMusic\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {boolean|string} params - If <b>true</b> music will be turned on. Otherwise it will be turned off. Can also be a binding-expression.\n     */\n\n    Component_LayoutSceneBehavior.prototype.turnOnOffMusic = function(sender, state) {\n      if (ui.Component_FormulaHandler.fieldValue(sender, state)) {\n        return this.turnOnMusic();\n      } else {\n        return this.turnOffMusic();\n      }\n    };\n\n\n    /**\n    * Action method which turns sound on or off.\n    *\n    * @method turnOnOffSound\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {boolean|string} params - If <b>true</b> sound will be turned on. Otherwise it will be turned off. Can also be a binding-expression.\n     */\n\n    Component_LayoutSceneBehavior.prototype.turnOnOffSound = function(sender, state) {\n      if (ui.Component_FormulaHandler.fieldValue(sender, state)) {\n        return this.turnOnSound();\n      } else {\n        return this.turnOffSound();\n      }\n    };\n\n\n    /**\n    * Action method which turns off voice.\n    *\n    * @method turnOffVoice\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {boolean|string} params - Can be <b>null</b>.\n     */\n\n    Component_LayoutSceneBehavior.prototype.turnOffVoice = function() {\n      return AudioManager.stopAllVoices();\n    };\n\n\n    /**\n    * Action method which turns off music.\n    *\n    * @method turnOffMusic\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {boolean|string} params - Can be <b>null</b>.\n     */\n\n    Component_LayoutSceneBehavior.prototype.turnOffMusic = function() {\n      return AudioManager.stopMusic();\n    };\n\n\n    /**\n    * Action method which turns off sound.\n    *\n    * @method turnOffSound\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {boolean|string} params - Can be <b>null</b>.\n     */\n\n    Component_LayoutSceneBehavior.prototype.turnOffSound = function() {\n      return AudioManager.stopAllSounds();\n    };\n\n\n    /**\n    * Action method which turns on voice.\n    *\n    * @method turnOnVoice\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {boolean|string} params - Can be <b>null</b>.\n     */\n\n    Component_LayoutSceneBehavior.prototype.turnOnVoice = function() {};\n\n\n    /**\n    * Action method which turns on sound.\n    *\n    * @method turnOnSound\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {boolean|string} params - Can be <b>null</b>.\n     */\n\n    Component_LayoutSceneBehavior.prototype.turnOnSound = function() {};\n\n\n    /**\n    * Action method which turns on music.\n    *\n    * @method turnOnMusic\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {boolean|string} params - Can be <b>null</b>.\n     */\n\n    Component_LayoutSceneBehavior.prototype.turnOnMusic = function() {\n      return AudioManager.resumeMusic();\n    };\n\n\n    /**\n    * Action method which selects the specified language.\n    *\n    * @method selectLanguage\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {number|string} params - Index of the language to set. Can be a binding-expression.\n     */\n\n    Component_LayoutSceneBehavior.prototype.selectLanguage = function(sender, params) {\n      var language;\n      language = LanguageManager.languages[ui.Component_FormulaHandler.fieldValue(sender, params)];\n      return LanguageManager.selectLanguage(language);\n    };\n\n\n    /**\n    * Action method which resets global data storage.\n    *\n    * @method resetGlobalData\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object} params - Can be <b>null</b>.\n     */\n\n    Component_LayoutSceneBehavior.prototype.resetGlobalData = function(sender) {\n      return GameManager.resetGlobalData();\n    };\n\n\n    /**\n    * Action method which saves game settings.\n    *\n    * @method saveSettings\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object} params - Can be <b>null</b>.\n     */\n\n    Component_LayoutSceneBehavior.prototype.saveSettings = function(sender) {\n      return GameManager.saveSettings();\n    };\n\n\n    /**\n    * Action method which prepares the game for saving by taking a snapshot of the current game state\n    * and storing it in GameManager.saveGame.\n    *\n    * @method prepareSaveGame\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object} params - Can be <b>null</b>.\n     */\n\n    Component_LayoutSceneBehavior.prototype.prepareSaveGame = function(sender, params) {\n      return GameManager.prepareSaveGame(params != null ? params.snapshot : void 0);\n    };\n\n\n    /**\n    * Action method which saves the current game at the specified save slot.\n    *\n    * @method saveGame\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object} params - Contains the slot-index where the game should be saved.\n    * <ul>\n    * <li>params.slot - The slot-index where the game should be saved. Can be a binding-expression.</li>\n    * </ul>\n     */\n\n    Component_LayoutSceneBehavior.prototype.saveGame = function(sender, params) {\n      return GameManager.save(ui.Component_FormulaHandler.fieldValue(sender, params.slot));\n    };\n\n\n    /**\n    * Action method which loads the game from the specified save slot.\n    *\n    * @method loadGame\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object} params - Contains the slot-index where the game should be loaded from.\n    * <ul>\n    * <li>params.slot - The slot-index where the game should be loaded from. Can be a binding-expression.</li>\n    * </ul>\n     */\n\n    Component_LayoutSceneBehavior.prototype.loadGame = function(sender, params) {\n      GameManager.tempSettings.skip = false;\n      return GameManager.load(ui.Component_FormulaHandler.fieldValue(sender, params.slot));\n    };\n\n\n    /**\n    * Action method which starts a new game.\n    *\n    * @method newGame\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object} params - Can be <b>null</b>\n     */\n\n    Component_LayoutSceneBehavior.prototype.newGame = function(sender, params) {\n      var scene;\n      AudioManager.stopAllMusic(30);\n      GameManager.newGame();\n      scene = new vn.Object_Scene();\n      SceneManager.clear();\n      return SceneManager.switchTo(scene);\n    };\n\n\n    /**\n    * Action method which exists the current game. It doesn't change the scene and\n    * should be called before switching back to the title screen or main menu.\n    *\n    * @method exitGame\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object} params - Can be <b>null</b>\n     */\n\n    Component_LayoutSceneBehavior.prototype.exitGame = function(sender, params) {\n      return GameManager.exitGame();\n    };\n\n\n    /**\n    * Action method which switches to another scene.\n    *\n    * @method switchScene\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object} params - Contains the class name of the scene to switch to.\n    * <ul>\n    * <li>params.name - The class-name of the scene to switch to. The class must be defined in vn-namespace.</li>\n    * </ul>\n     */\n\n    Component_LayoutSceneBehavior.prototype.switchScene = function(sender, params) {\n      var f;\n      f = (function(_this) {\n        return function() {\n          var scene;\n          if (params.clear) {\n            SceneManager.clear();\n          }\n          scene = new vn[params.name]();\n          return SceneManager.switchTo(scene, params.savePrevious);\n        };\n      })(this);\n      if (!params.savePrevious) {\n        return this.layout.ui.disappear((function(_this) {\n          return function(e) {\n            return f();\n          };\n        })(this));\n      } else {\n        return f();\n      }\n    };\n\n\n    /**\n    * Action method which switches to another game scene.\n    *\n    * @method switchGameScene\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object} params - Contains the UID of the scene to switch to.\n    * <ul>\n    * <li>params.uid - The UID of the scene to switch to.</li>\n    * </ul>\n     */\n\n    Component_LayoutSceneBehavior.prototype.switchGameScene = function(sender, params) {\n      var f;\n      f = (function(_this) {\n        return function() {\n          var newScene, sceneData, sceneDocument, sceneDocuments, uid;\n          if (params.clear) {\n            SceneManager.clear();\n          }\n          uid = params.uid;\n          if (params.name) {\n            sceneDocuments = DataManager.getDocumentsByType(\"vn.scene\");\n            sceneDocument = sceneDocuments.first(function(d) {\n              return d.items.name === params.name;\n            });\n            if (sceneDocument) {\n              uid = sceneDocument.uid;\n            }\n          }\n          sceneData = {\n            uid: uid,\n            pictures: [],\n            texts: []\n          };\n          GameManager.sceneData = sceneData;\n          newScene = new vn.Object_Scene();\n          newScene.sceneData = sceneData;\n          return SceneManager.switchTo(newScene, params.savePrevious);\n        };\n      })(this);\n      if (!params.savePrevious) {\n        return (this.layout || this.object.layout).ui.disappear((function(_this) {\n          return function(e) {\n            return f();\n          };\n        })(this));\n      } else {\n        return f();\n      }\n    };\n\n\n    /**\n    * Action method which switches to another layout.\n    *\n    * @method switchLayout\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object} params - Contains the name of the layout to switch to.\n    * <ul>\n    * <li>params.name - The name of the layout to switch to.</li>\n    * <li>params.savePrevious - Indicates if the current layout should not be erased but paused and hidden instead so\n    * that it can be restored using <i>returnToPrevious</i> action.</li>\n    * <li>params.dataFields - Defines the data of \"$dataFields\" binding-expression variable. Can be a binding-expression\n    * or a direct object. Optional.</li>\n    * </ul>\n     */\n\n    Component_LayoutSceneBehavior.prototype.switchLayout = function(sender, layout) {\n      var f;\n      f = (function(_this) {\n        return function() {\n          var dataFields, i, len, ref, scene, senderField;\n          Graphics.freeze();\n          if (layout.clear) {\n            SceneManager.clear();\n          }\n          scene = new gs.Object_Layout(layout.name);\n          dataFields = sender.dataFields;\n          if (typeof layout.dataFields === \"string\") {\n            dataFields = ui.Component_FormulaHandler.fieldValue(sender, layout.dataFields);\n          } else if (layout.dataFields != null) {\n            dataFields = layout.dataFields;\n          }\n          scene.dataFields = dataFields;\n          scene.controllers = layout.controllers;\n          if (layout.senderData != null) {\n            ref = layout.senderData;\n            for (i = 0, len = ref.length; i < len; i++) {\n              senderField = ref[i];\n              scene[senderField] = sender[senderField];\n            }\n          }\n          return SceneManager.switchTo(scene, layout.savePrevious, layout.stack);\n        };\n      })(this);\n      if (!layout.savePrevious) {\n        return (this.layout || this.object.layout).ui.disappear((function(_this) {\n          return function(e) {\n            return f();\n          };\n        })(this));\n      } else {\n        return f();\n      }\n    };\n\n\n    /**\n    * Action method which returns to previous layout. (If savePrevious was set to <b>true</b> on switchLayout.).\n    *\n    * @method previousLayout\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {Object} params - Can be <b>null</b>.\n     */\n\n    Component_LayoutSceneBehavior.prototype.previousLayout = function(sender) {\n      return SceneManager.returnToPrevious();\n    };\n\n\n    /**\n    * Action method which disposes the specified control.\n    *\n    * @method disposeControl\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {string} params - The ID of the control to dispose. Can be a binding-expression.\n     */\n\n    Component_LayoutSceneBehavior.prototype.disposeControl = function(sender, id) {\n      var control;\n      control = this.objectManager.objectById(ui.Component_FormulaHandler.fieldValue(sender, id));\n      return control != null ? control.ui.disappear(function(sender) {\n        return sender.dispose();\n      }) : void 0;\n    };\n\n\n    /**\n    * Action method which creates a new control from the specified descriptor.\n    *\n    * @method createControl\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {string} params - Contains the descriptor and other data needed to construct the control.\n    * <ul>\n    * <li>params.descriptor - The control' descriptor. Can be a direct descriptor definition or a template name</li>\n    * <li>params.parent - A binding-expression which returns the control's parent.</li>\n    * <li>params.senderData - An object containing additional data merged into the control object.</li>\n    * </ul>\n     */\n\n    Component_LayoutSceneBehavior.prototype.createControl = function(sender, data) {\n      var control, descriptor, fieldName, i, len, parent, ref;\n      if (typeof data.descriptor === \"string\") {\n        descriptor = ui.UIManager.customTypes[data.descriptor];\n      } else {\n        descriptor = data.descriptor;\n      }\n      parent = ui.Component_FormulaHandler.fieldValue(sender, data.parent);\n      control = ui.UiFactory._createFromDescriptor(descriptor, parent != null ? parent : this.object.layout || this.object);\n      if (data.senderData != null) {\n        ref = data.senderData;\n        for (i = 0, len = ref.length; i < len; i++) {\n          fieldName = ref[i];\n          control[fieldName] = sender[fieldName];\n        }\n      }\n      control.ui.prepare();\n      control.ui.appear();\n      return control;\n    };\n\n\n    /**\n    * Action method which quits the game.\n    *\n    * @method quitGame\n    * @param {gs.Object_Base} sender - The sender object.\n    * @param {string} params - Can be <b>null</b>.\n     */\n\n    Component_LayoutSceneBehavior.prototype.quitGame = function(sender, data) {\n      return SceneManager.switchTo(null);\n    };\n\n    return Component_LayoutSceneBehavior;\n\n  })(gs.Component_SceneBehavior);\n\n  gs.Component_LayoutSceneBehavior = Component_LayoutSceneBehavior;\n\n}).call(this);\n"
    },
    "summary": [
        "name",
        "type",
        "order"
    ],
    "externalItems": []
}