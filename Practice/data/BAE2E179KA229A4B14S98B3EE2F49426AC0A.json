{
    "uid": "BAE2E179KA229A4B14S98B3EE2F49426AC0A",
    "isLoaded": true,
    "lastModificationTime": 0,
    "items": {
        "name": "Component_CharacterBehavior",
        "type": "game_script",
        "order": 16,
        "parentId": "D3325122KACDEA4515SB731E37A42B9D779F",
        "folder": false,
        "content": "# ===================================================================\n#\n#   Script: Component_CharacterBehavior\n#\n#   $$COPYRIGHT$$\n#\n# ===================================================================\nclass Component_CharacterBehavior extends gs.Component\n    ###*\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    *\n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n    ###\n    onDataBundleRestore: (data, context) ->\n        @setupEventHandlers()\n\n    ###*\n    * A behavior-component which handles the character-specific behavior like\n    * talking and idle.\n    *\n    * @module vn\n    * @class Component_CharacterBehavior\n    * @extends gs.Component\n    * @memberof vn\n    * @constructor\n    ###\n    constructor: () ->\n        super\n\n        ###*\n        * @property imageIndex\n        * @type number\n        * @private\n        ###\n        @imageIndex = 0\n\n        ###*\n        * @property imageDuration\n        * @type number\n        * @private\n        ###\n        @imageDuration = 30\n\n        ###*\n        * @property idleTime\n        * @type number\n        * @private\n        ###\n\n        @idleTime = 120 + 120 * Math.random()\n        ###*\n        * Indicates if the character is currently talking.\n        * @property talking\n        * @type boolean\n        ###\n        @talking = no\n\n        ###*\n        * @property initialized\n        * @type boolean\n        * @private\n        ###\n        @initialized = no\n\n        ###*\n        * Temporary game settings used by this character.\n        * @property imageIndex\n        * @type number\n        ###\n        @tempSettings = GameManager.tempSettings\n\n    ###*\n    * Adds event-handlers\n    *\n    * @method setupEventHandlers\n    ###\n    setupEventHandlers: ->\n        gs.GlobalEventManager.on \"talkingStarted\", (e) =>\n            if e.character?.index == @object.rid\n                @object.talking = yes\n                @imageIndex = 0\n        gs.GlobalEventManager.on \"talkingEnded\", (e) =>\n            if e.character?.index == @object.rid\n                @object.talking = no\n                @imageIndex = 0\n\n    ###*\n    * Initializes the component. Adds event-handlers.\n    *\n    * @method setup\n    ###\n    setup: ->\n        @initialized = yes\n        @setupEventHandlers()\n        @update()\n\n    ###*\n    * Changes the characters expression using blending. If the duration is set\n    * to 0 the expression change is executed immediately without animation.\n    *\n    * @method changeExpression\n    * @param {vn.CharacterExpression} expression - The character expression database-record.\n    * @param {number} duration - The animation-duration in frames. Pass 0 to skip animation.\n    * @param {function} [callback] An optional callback-function called when the change is finished.\n    ###\n    changeExpression: (expression, animation, easing, duration, callback) ->\n        prevExpression = @object.expression\n        @object.expression = expression\n\n        if prevExpression?.idle?.length > 0 and @object.expression? and prevExpression != @object.expression\n            @imageIndex = 0\n\n            picture = new gs.Object_Picture()\n            picture.imageFolder = \"Graphics/Characters\"\n            picture.image = prevExpression.idle[0].resource.name\n            picture.update()\n            picture.anchor.x = @object.anchor.x\n            picture.anchor.y = @object.anchor.y\n            picture.dstRect.x = @object.dstRect.x + Math.round((@object.dstRect.width - picture.dstRect.width) / 2)\n            picture.dstRect.y = @object.dstRect.y + Math.round((@object.dstRect.height - picture.dstRect.height) / 2)\n            picture.zIndex = @object.zIndex - 1\n            picture.zoom.x = @object.zoom.x\n            picture.zoom.y = @object.zoom.y\n            picture.update()\n\n\n            @object.parent.addObject(picture)\n\n            switch animation.fading\n                when 0 # Overlay\n                    @object.animator.appear(@object.dstRect.x, @object.dstRect.y, animation, easing, duration, () ->\n                        picture.dispose()\n                        callback?()\n                    )\n                    @object.update()\n                when 1 # Cross Fade\n                    picture.animator.disappear(animation, easing, duration, (object) ->\n                        object.dispose())\n                    picture.update()\n\n                    @object.animator.appear(@object.dstRect.x, @object.dstRect.y, animation, easing, duration, (object) ->\n                        callback?())\n                    @object.update()\n        else\n            callback?()\n\n\n    ###*\n    * Lets the character start talking.\n    *\n    * @method startTalking\n    ###\n    startTalking: -> @object.talking = yes\n\n    ###*\n    * Lets the character stop with talking.\n    *\n    * @method stopTalking\n    ###\n    stopTalking: -> @object.talking = no\n\n    ###*\n    * Updates character's talking-animation.\n    *\n    * @method updateTalking\n    * @protected\n    ###\n    updateTalking: ->\n        if @tempSettings.skip and @object.expression.talking?.length > 0\n            @object.talking = no\n            @imageIndex = 0\n            @object.image = @object.expression.talking[@imageIndex].resource.name\n        else if @object.expression?\n            if @object.expression.talking?.length > 0\n                @imageDuration--\n                if @imageDuration <= 0\n                    imageIndex = @imageIndex\n                    while imageIndex == @imageIndex and @object.expression.talking.length > 1\n                        @imageIndex = Math.round(Math.random() * (@object.expression.talking.length-1))\n                    speed = @object.expression.talkingSpeed / 100 * 5\n                    @imageDuration = speed + Math.round(speed * Math.random())\n                @object.image = @object.expression.talking[@imageIndex].resource.name\n            else\n                @updateIdle()\n\n    ###*\n    * Updates character's idle-animation.\n    *\n    * @method updateIdle\n    * @protected\n    ###\n    updateIdle: ->\n        if @object.expression? and @object.expression.idle?.length > 0\n            if @imageDuration <= 0\n                @idleTime--\n                if @idleTime <= 0\n                    @idleTime = @object.expression.idleTime.start + (@object.expression.idleTime.end - @object.expression.idleTime.start) * Math.random()\n                    @imageDuration = @object.expression.idleSpeed / 100 * 5\n\n            if @imageDuration > 0\n                @imageDuration--\n                if @imageDuration <= 0\n                    @imageIndex++\n                    if @imageIndex >= @object.expression.idle.length\n                        @imageIndex = 0\n                        @imageDuration = 0\n                    else\n                        @imageDuration = @object.expression.idleSpeed / 100 * 5\n            @object.image = @object.expression.idle[@imageIndex].resource.name\n\n    ###*\n    * Updates character logic & animation-handling.\n    *\n    * @method update\n    ###\n    update: ->\n        super\n        if not @initialized then @setup()\n\n        if @object.talking\n            @updateTalking()\n        else\n            @updateIdle()\n\n\n\nvn.Component_CharacterBehavior = Component_CharacterBehavior",
        "compiledContent": "// Generated by CoffeeScript 1.12.7\n(function() {\n  var Component_CharacterBehavior,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  Component_CharacterBehavior = (function(superClass) {\n    extend(Component_CharacterBehavior, superClass);\n\n\n    /**\n    * Called if this object instance is restored from a data-bundle. It can be used\n    * re-assign event-handler, anonymous functions, etc.\n    *\n    * @method onDataBundleRestore.\n    * @param Object data - The data-bundle\n    * @param gs.ObjectCodecContext context - The codec-context.\n     */\n\n    Component_CharacterBehavior.prototype.onDataBundleRestore = function(data, context) {\n      return this.setupEventHandlers();\n    };\n\n\n    /**\n    * A behavior-component which handles the character-specific behavior like\n    * talking and idle.\n    *\n    * @module vn\n    * @class Component_CharacterBehavior\n    * @extends gs.Component\n    * @memberof vn\n    * @constructor\n     */\n\n    function Component_CharacterBehavior() {\n      Component_CharacterBehavior.__super__.constructor.apply(this, arguments);\n\n      /**\n      * @property imageIndex\n      * @type number\n      * @private\n       */\n      this.imageIndex = 0;\n\n      /**\n      * @property imageDuration\n      * @type number\n      * @private\n       */\n      this.imageDuration = 30;\n\n      /**\n      * @property idleTime\n      * @type number\n      * @private\n       */\n      this.idleTime = 120 + 120 * Math.random();\n\n      /**\n      * Indicates if the character is currently talking.\n      * @property talking\n      * @type boolean\n       */\n      this.talking = false;\n\n      /**\n      * @property initialized\n      * @type boolean\n      * @private\n       */\n      this.initialized = false;\n\n      /**\n      * Temporary game settings used by this character.\n      * @property imageIndex\n      * @type number\n       */\n      this.tempSettings = GameManager.tempSettings;\n    }\n\n\n    /**\n    * Adds event-handlers\n    *\n    * @method setupEventHandlers\n     */\n\n    Component_CharacterBehavior.prototype.setupEventHandlers = function() {\n      gs.GlobalEventManager.on(\"talkingStarted\", (function(_this) {\n        return function(e) {\n          var ref;\n          if (((ref = e.character) != null ? ref.index : void 0) === _this.object.rid) {\n            _this.object.talking = true;\n            return _this.imageIndex = 0;\n          }\n        };\n      })(this));\n      return gs.GlobalEventManager.on(\"talkingEnded\", (function(_this) {\n        return function(e) {\n          var ref;\n          if (((ref = e.character) != null ? ref.index : void 0) === _this.object.rid) {\n            _this.object.talking = false;\n            return _this.imageIndex = 0;\n          }\n        };\n      })(this));\n    };\n\n\n    /**\n    * Initializes the component. Adds event-handlers.\n    *\n    * @method setup\n     */\n\n    Component_CharacterBehavior.prototype.setup = function() {\n      this.initialized = true;\n      this.setupEventHandlers();\n      return this.update();\n    };\n\n\n    /**\n    * Changes the characters expression using blending. If the duration is set\n    * to 0 the expression change is executed immediately without animation.\n    *\n    * @method changeExpression\n    * @param {vn.CharacterExpression} expression - The character expression database-record.\n    * @param {number} duration - The animation-duration in frames. Pass 0 to skip animation.\n    * @param {function} [callback] An optional callback-function called when the change is finished.\n     */\n\n    Component_CharacterBehavior.prototype.changeExpression = function(expression, animation, easing, duration, callback) {\n      var picture, prevExpression, ref;\n      prevExpression = this.object.expression;\n      this.object.expression = expression;\n      if ((prevExpression != null ? (ref = prevExpression.idle) != null ? ref.length : void 0 : void 0) > 0 && (this.object.expression != null) && prevExpression !== this.object.expression) {\n        this.imageIndex = 0;\n        picture = new gs.Object_Picture();\n        picture.imageFolder = \"Graphics/Characters\";\n        picture.image = prevExpression.idle[0].resource.name;\n        picture.update();\n        picture.anchor.x = this.object.anchor.x;\n        picture.anchor.y = this.object.anchor.y;\n        picture.dstRect.x = this.object.dstRect.x + Math.round((this.object.dstRect.width - picture.dstRect.width) / 2);\n        picture.dstRect.y = this.object.dstRect.y + Math.round((this.object.dstRect.height - picture.dstRect.height) / 2);\n        picture.zIndex = this.object.zIndex - 1;\n        picture.zoom.x = this.object.zoom.x;\n        picture.zoom.y = this.object.zoom.y;\n        picture.update();\n        this.object.parent.addObject(picture);\n        switch (animation.fading) {\n          case 0:\n            this.object.animator.appear(this.object.dstRect.x, this.object.dstRect.y, animation, easing, duration, function() {\n              picture.dispose();\n              return typeof callback === \"function\" ? callback() : void 0;\n            });\n            return this.object.update();\n          case 1:\n            picture.animator.disappear(animation, easing, duration, function(object) {\n              return object.dispose();\n            });\n            picture.update();\n            this.object.animator.appear(this.object.dstRect.x, this.object.dstRect.y, animation, easing, duration, function(object) {\n              return typeof callback === \"function\" ? callback() : void 0;\n            });\n            return this.object.update();\n        }\n      } else {\n        return typeof callback === \"function\" ? callback() : void 0;\n      }\n    };\n\n\n    /**\n    * Lets the character start talking.\n    *\n    * @method startTalking\n     */\n\n    Component_CharacterBehavior.prototype.startTalking = function() {\n      return this.object.talking = true;\n    };\n\n\n    /**\n    * Lets the character stop with talking.\n    *\n    * @method stopTalking\n     */\n\n    Component_CharacterBehavior.prototype.stopTalking = function() {\n      return this.object.talking = false;\n    };\n\n\n    /**\n    * Updates character's talking-animation.\n    *\n    * @method updateTalking\n    * @protected\n     */\n\n    Component_CharacterBehavior.prototype.updateTalking = function() {\n      var imageIndex, ref, ref1, speed;\n      if (this.tempSettings.skip && ((ref = this.object.expression.talking) != null ? ref.length : void 0) > 0) {\n        this.object.talking = false;\n        this.imageIndex = 0;\n        return this.object.image = this.object.expression.talking[this.imageIndex].resource.name;\n      } else if (this.object.expression != null) {\n        if (((ref1 = this.object.expression.talking) != null ? ref1.length : void 0) > 0) {\n          this.imageDuration--;\n          if (this.imageDuration <= 0) {\n            imageIndex = this.imageIndex;\n            while (imageIndex === this.imageIndex && this.object.expression.talking.length > 1) {\n              this.imageIndex = Math.round(Math.random() * (this.object.expression.talking.length - 1));\n            }\n            speed = this.object.expression.talkingSpeed / 100 * 5;\n            this.imageDuration = speed + Math.round(speed * Math.random());\n          }\n          return this.object.image = this.object.expression.talking[this.imageIndex].resource.name;\n        } else {\n          return this.updateIdle();\n        }\n      }\n    };\n\n\n    /**\n    * Updates character's idle-animation.\n    *\n    * @method updateIdle\n    * @protected\n     */\n\n    Component_CharacterBehavior.prototype.updateIdle = function() {\n      var ref;\n      if ((this.object.expression != null) && ((ref = this.object.expression.idle) != null ? ref.length : void 0) > 0) {\n        if (this.imageDuration <= 0) {\n          this.idleTime--;\n          if (this.idleTime <= 0) {\n            this.idleTime = this.object.expression.idleTime.start + (this.object.expression.idleTime.end - this.object.expression.idleTime.start) * Math.random();\n            this.imageDuration = this.object.expression.idleSpeed / 100 * 5;\n          }\n        }\n        if (this.imageDuration > 0) {\n          this.imageDuration--;\n          if (this.imageDuration <= 0) {\n            this.imageIndex++;\n            if (this.imageIndex >= this.object.expression.idle.length) {\n              this.imageIndex = 0;\n              this.imageDuration = 0;\n            } else {\n              this.imageDuration = this.object.expression.idleSpeed / 100 * 5;\n            }\n          }\n        }\n        return this.object.image = this.object.expression.idle[this.imageIndex].resource.name;\n      }\n    };\n\n\n    /**\n    * Updates character logic & animation-handling.\n    *\n    * @method update\n     */\n\n    Component_CharacterBehavior.prototype.update = function() {\n      Component_CharacterBehavior.__super__.update.apply(this, arguments);\n      if (!this.initialized) {\n        this.setup();\n      }\n      if (this.object.talking) {\n        return this.updateTalking();\n      } else {\n        return this.updateIdle();\n      }\n    };\n\n    return Component_CharacterBehavior;\n\n  })(gs.Component);\n\n  vn.Component_CharacterBehavior = Component_CharacterBehavior;\n\n}).call(this);\n"
    },
    "summary": [
        "name",
        "type",
        "order"
    ],
    "externalItems": []
}