{
    "uid": "FBEA2EE7K25F8A42F1SBA1BE55C1458BD892",
    "isLoaded": true,
    "lastModificationTime": 0,
    "items": {
        "name": "Component_TilingSprite",
        "type": "game_script",
        "order": 6,
        "parentId": "D3325122KACDEA4515SB731E37A42B9D779F",
        "folder": false,
        "content": "# ===================================================================\n#\n#   Script: Component_TilingSprite\n#\n#   $$COPYRIGHT$$\n#\n# ===================================================================\nclass Component_TilingSprite extends gs.Component_Sprite\n    ###*\n    * A tiling sprite component tiles the image of the game object on screen. The\n    * tiling can be vertical, horizontal or both. The sprite can be managed or\n    * unmanaged. A managed sprite is automatically added to the graphics-system\n    * and processed every frame until it gets disposed. An unmanaged sprite needs\n    * to be added and removed manually.\n    *\n    * @module gs\n    * @class Component_TilingSprite\n    * @extends gs.Component_Sprite\n    * @memberof gs\n    * @constructor\n    * @param {boolean} managed - Indicates if the sprite is managed by the graphics system.\n    ###\n    constructor: (managed) ->\n        @sprite = null\n        @image = null\n        @video = null\n        @imageFolder = \"Graphics/Pictures\"\n        @visible = yes\n        @looping = vertical: yes, horizontal: yes\n        @scroll = x: 0, y: 0\n    \n    \n    ###*\n    * Creates sprite object.\n    *\n    * @method setupSprite\n    ###\n    setupSprite: ->\n        if !@sprite\n            @sprite = new gs.TilingSprite(Graphics.viewport, managed ? yes)\n        \n    ###*\n    * Updates the padding.\n    *\n    * @method updatePadding\n    ###\n    updatePadding: ->\n        if @object.padding?\n            @sprite.rect.x += @object.padding.left\n            @sprite.rect.y += @object.padding.top\n            @sprite.rect.width -= @object.padding.left+@object.padding.right\n            @sprite.rect.height -= @object.padding.bottom+@object.padding.bottom\n            \n    ###*\n    * Updates the source- and destination-rectangle of the game object so that\n    * the associated bitmap fits in. \n    *\n    * @method updateRect\n    ###\n    updateRect: ->\n        if @sprite.bitmap?\n            @object.srcRect = new Rect(0, 0, @sprite.bitmap.width, @sprite.bitmap.height)\n          #  @object.dstRect.width = @object.srcRect.width\n          #  @object.dstRect.height = @object.srcRect.height\n            \n    ###*\n    * Updates the sprite properties from the game object properties.\n    *\n    * @method updateProperties\n    ###\n    updateProperties: ->\n        super()\n\n        @sprite.zoomX = @object.zoom.x\n        @sprite.zoomY = @object.zoom.y\n        @sprite.vertical = @looping.vertical\n        @sprite.horizontal = @looping.horizontal\n        @sprite.x = @scroll.x\n        @sprite.y = @scroll.y\n        @sprite.angle = @object.angle\n        @sprite.rect.x = @object.dstRect.x #- @object.dstRect.width * (@object.zoom.x - 1.0) * @object.anchor.x\n        @sprite.rect.y = @object.dstRect.y #- @object.dstRect.height * (@object.zoom.y - 1.0) * @object.anchor.y\n        @sprite.rect.width = @object.dstRect.width\n        @sprite.rect.height = @object.dstRect.height\n        \n    ###*\n    * Updates the optional sprite properties from the game object properties.\n    * @method updateOptionalProperties\n    ###\n    updateOptionalProperties: ->\n        super\n        \n        if @object.zoom?\n            @sprite.zoomX = @object.zoom.x\n            @sprite.zoomY = @object.zoom.y\n        \n        \ngs.Component_TilingSprite = Component_TilingSprite\n",
        "compiledContent": "// Generated by CoffeeScript 1.12.7\n(function() {\n  var Component_TilingSprite,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  Component_TilingSprite = (function(superClass) {\n    extend(Component_TilingSprite, superClass);\n\n\n    /**\n    * A tiling sprite component tiles the image of the game object on screen. The\n    * tiling can be vertical, horizontal or both. The sprite can be managed or\n    * unmanaged. A managed sprite is automatically added to the graphics-system\n    * and processed every frame until it gets disposed. An unmanaged sprite needs\n    * to be added and removed manually.\n    *\n    * @module gs\n    * @class Component_TilingSprite\n    * @extends gs.Component_Sprite\n    * @memberof gs\n    * @constructor\n    * @param {boolean} managed - Indicates if the sprite is managed by the graphics system.\n     */\n\n    function Component_TilingSprite(managed) {\n      this.sprite = null;\n      this.image = null;\n      this.video = null;\n      this.imageFolder = \"Graphics/Pictures\";\n      this.visible = true;\n      this.looping = {\n        vertical: true,\n        horizontal: true\n      };\n      this.scroll = {\n        x: 0,\n        y: 0\n      };\n    }\n\n\n    /**\n    * Creates sprite object.\n    *\n    * @method setupSprite\n     */\n\n    Component_TilingSprite.prototype.setupSprite = function() {\n      if (!this.sprite) {\n        return this.sprite = new gs.TilingSprite(Graphics.viewport, typeof managed !== \"undefined\" && managed !== null ? managed : true);\n      }\n    };\n\n\n    /**\n    * Updates the padding.\n    *\n    * @method updatePadding\n     */\n\n    Component_TilingSprite.prototype.updatePadding = function() {\n      if (this.object.padding != null) {\n        this.sprite.rect.x += this.object.padding.left;\n        this.sprite.rect.y += this.object.padding.top;\n        this.sprite.rect.width -= this.object.padding.left + this.object.padding.right;\n        return this.sprite.rect.height -= this.object.padding.bottom + this.object.padding.bottom;\n      }\n    };\n\n\n    /**\n    * Updates the source- and destination-rectangle of the game object so that\n    * the associated bitmap fits in. \n    *\n    * @method updateRect\n     */\n\n    Component_TilingSprite.prototype.updateRect = function() {\n      if (this.sprite.bitmap != null) {\n        return this.object.srcRect = new Rect(0, 0, this.sprite.bitmap.width, this.sprite.bitmap.height);\n      }\n    };\n\n\n    /**\n    * Updates the sprite properties from the game object properties.\n    *\n    * @method updateProperties\n     */\n\n    Component_TilingSprite.prototype.updateProperties = function() {\n      Component_TilingSprite.__super__.updateProperties.call(this);\n      this.sprite.zoomX = this.object.zoom.x;\n      this.sprite.zoomY = this.object.zoom.y;\n      this.sprite.vertical = this.looping.vertical;\n      this.sprite.horizontal = this.looping.horizontal;\n      this.sprite.x = this.scroll.x;\n      this.sprite.y = this.scroll.y;\n      this.sprite.angle = this.object.angle;\n      this.sprite.rect.x = this.object.dstRect.x;\n      this.sprite.rect.y = this.object.dstRect.y;\n      this.sprite.rect.width = this.object.dstRect.width;\n      return this.sprite.rect.height = this.object.dstRect.height;\n    };\n\n\n    /**\n    * Updates the optional sprite properties from the game object properties.\n    * @method updateOptionalProperties\n     */\n\n    Component_TilingSprite.prototype.updateOptionalProperties = function() {\n      Component_TilingSprite.__super__.updateOptionalProperties.apply(this, arguments);\n      if (this.object.zoom != null) {\n        this.sprite.zoomX = this.object.zoom.x;\n        return this.sprite.zoomY = this.object.zoom.y;\n      }\n    };\n\n    return Component_TilingSprite;\n\n  })(gs.Component_Sprite);\n\n  gs.Component_TilingSprite = Component_TilingSprite;\n\n}).call(this);\n"
    },
    "summary": [
        "name",
        "type",
        "order"
    ],
    "externalItems": []
}