{
    "uid": "E442F997KC428A496DSA01EE8D171F72BDCA",
    "isLoaded": true,
    "lastModificationTime": 0,
    "items": {
        "name": "Component_StackLayoutBehavior",
        "type": "game_script",
        "order": 6,
        "parentId": "01A95DA3K01E8A4CB4SBE17E790BCE1FC035",
        "folder": false,
        "content": "# ===================================================================\n#\n#   Script: Component_StackLayoutBehavior\n#\n#   $$COPYRIGHT$$\n#\n# ===================================================================\nclass Component_StackLayoutBehavior extends gs.Component_LayoutBehavior\n    ###*\n    * Turns a game object into a stack-layout and layouts all sub-objects\n    * like stack vertically or horizontally. The game object needs a \n    * container-component.\n    * <br>\n    * The sub-objects in a stack-layout can be configured as resizable or\n    * non-resizable(fixed-size). For example:<br>\n    * <br>\n    * Lets say we have a layout-size of 500px in width with three controls.<br>\n    * <br>\n    * | 80px | dynamic | 80px | <br>\n    * <br>\n    * Two controls have a fixed size of 80px and the middle-control has a\n    * dynamic-size because it is configured to be resizable. In that case, \n    * the size of the resizable control would be 340px because that is the\n    * free space left after subtracting the size(160px) of the fixed-size controls.<br>\n    * <br>\n    * In addition, each sub-object can have different alignment options.\n    *\n    * @module gs\n    * @class Component_StackLayoutBehavior\n    * @extends gs.Component_LayoutBehavior\n    * @memberof gs\n    * @constructor\n    ###\n    constructor: (orientation) ->\n        super\n        \n        ###*\n        * The orientation of the stack-layout. Can be vertical or horizontal.\n        * @property orientation\n        * @type gs.Orientation\n        ###\n        @orientation = orientation || 0\n        \n        ###*\n        * @property scrollOffsetX\n        * @type number\n        * @protected\n        ###\n        @scrollOffsetX = 0\n        \n        ###*\n        * @property scrollOffsetY\n        * @type number\n        * @protected\n        ###\n        @scrollOffsetY = 0\n        \n        ###*\n        * @property contentHeight\n        * @type number\n        * @protected\n        ###\n        @contentHeight = 0\n        \n        ###*\n        * Control list-offset.\n        * @property offset\n        * @type number\n        * @protected\n        ###\n        @offset = 0\n        \n        ###*\n        * Count of controls to process.\n        * @property contentHeight\n        * @type number\n        * @protected\n        ###\n        @count = 0\n        \n        ###*\n        * Current x-coordinate. \n        * @property cx\n        * @type number\n        * @protected\n        ###\n        @cx = 0\n        \n        ###*\n        * Current y-coordinate. \n        * @property cy\n        * @type number\n        * @protected\n        ###\n        @cy = 0\n        \n        ###*\n        * Total size of all centered controls. \n        * @property centerSize\n        * @type number\n        * @protected\n        ###\n        @centerSize = 0\n        \n        ###*\n        * Current x/y-coordinate for a centered control.\n        * @property center\n        * @type number\n        * @protected\n        ###\n        @center = 0\n        \n        ###*\n        * Current x/y-coordinate for a bottom/right aligned control.\n        * @property bottom\n        * @type number\n        * @protected\n        ###\n        @bottom = 0\n        \n        @managementMode = 0\n        \n    ###*\n    * Initializes the layout.\n    *\n    * @method setup\n    ### \n    setup: ->\n        @update()\n                \n        if @object.scrollable\n            gs.GlobalEventManager.on \"mouseWheel\", =>\n                r = @object.dstRect\n                \n                if Rect.contains(r.x, r.y, r.width, r.height, Input.Mouse.x - @object.origin.x, Input.Mouse.y - @object.origin.y)\n                    @object.update()\n\n    ###*\n    * Updates the layout depending on its orientation.\n    *\n    * @method update\n    ### \n    update: ->\n        super\n        \n        if @orientation == 0\n            @layoutHorizontal()\n        else\n            @layoutVertical()\n    \n    ###*\n    * Sizes the layout to fit its content\n    *\n    * @method sizeToFit\n    * @return number The content size.\n    ###\n    sizeToFit: ->\n        if @orientation == 0\n            return @sizeToFitHorizontal()\n        else\n            return @sizeToFitVertical()\n            \n    ###*\n    * Sizes the horizontal-layout to fit its content\n    *\n    * @method sizeToFitHorizontal\n    ###\n    sizeToFitHorizontal: ->\n        x = 0\n        y = 0\n        rect = @object.dstRect\n        \n        if @object.sizeToFit\n            for i in [@offset...@count]\n                control = @object.subObjects[i]\n\n                if !control.alignment\n                    rect.width = Math.max(x + control.margin.left + control.dstRect.width + control.margin.right, rect.width || 0)\n                    x += control.margin.left + control.dstRect.width + control.margin.right\n                if !control.alignmentY\n                    rect.height = Math.max(y + control.margin.top + control.dstRect.height + control.margin.bottom, rect.height || 0)\n    \n    ###*\n    * Sizes the vertical-layout to fit its content\n    *\n    * @method sizeToFitVertical\n    ###    \n    sizeToFitVertical: ->\n        rect = @object.dstRect\n        if @object.sizeToFit\n            for control in @object.subObjects\n                rect.width = Math.max(control.dstRect.x + control.dstRect.width + control.margin.right, rect.width || 1)\n                rect.height = Math.max(control.dstRect.y + control.dstRect.height + control.margin.bottom, rect.height || 1)\n            \n    ###*\n    * Calculates the dynamic-size of a horizontal stack-layout. That size is used for\n    * resizable-controls to let them fill all free space. It is calculated in the\n    * following way:<br>\n    * <br>\n    * dynamic-size = sum-of-all-fixed-control-sizes / count-of-resizable-controls\n    * <br>\n    *\n    * @method calculateDynamicSizeHorizontal\n    * @return {number} The dynamic size.\n    * @protected\n    ### \n    calculateDynamicSizeHorizontal: ->\n        fixedSize = 0\n        dynamicCount = 0\n        rect = @object.dstRect\n        for control, i in @object.subObjects\n            if control.resizable and !control.sizeToFit\n                dynamicCount++\n            else\n                fixedSize += control.margin.left + control.dstRect.width + control.margin.right\n                if control.alignmentX == 1\n                    @centerSize += control.dstRect.width + control.margin.right\n                \n        return Math.round((rect.width - fixedSize) / dynamicCount) \n     \n    ###*\n    * Calculates the dynamic-size of a vertical stack-layout. That size is used for\n    * resizable-controls to let them fill all free space. It is calculated in the\n    * following way:<br>\n    * <br>\n    * dynamic-size = sum-of-all-fixed-control-sizes / count-of-resizable-controls\n    * <br>\n    *\n    * @method calculateDynamicSizeVertical\n    * @return {number} The dynamic size.\n    * @protected\n    ### \n    calculateDynamicSizeVertical: ->\n        fixedSize = 0\n        dynamicCount = 0\n        \n        for control in @object.subObjects\n            if control.resizable and !control.sizeToFit\n                dynamicCount++\n            else\n                fixedSize += control.dstRect.height\n                if control.alignmentY == 1\n                    @centerSize += control.dstRect.height + control.margin.bottom\n                \n        return Math.round((@object.dstRect.height - fixedSize) / dynamicCount)\n        \n    ###*\n    * Layouts the specified control as fixed-size control for a horizontal stack-layout. \n    *\n    * @method updateControlRectFixedH\n    * @param {gs.Object_Base} control The control to update.\n    * @protected\n    ###\n    updateControlRectFixedH: (control) ->\n        rect = @object.dstRect\n        if control.alignmentX == 0\n            @cx += control.margin.left\n            control.dstRect.x = @cx\n            @cx += control.dstRect.width + control.margin.right\n        else if control.alignmentX == 2\n            @bottom += control.margin.right\n            control.dstRect.x = (rect.x+rect.width) - control.dstRect.width - @bottom\n            @bottom += control.dstRect.width + control.margin.left\n        else if control.alignmentX == 1\n            control.dstRect.x = @center + (rect.width - @centerSize) / 2\n            @center += control.dstRect.width + control.margin.right\n            \n        if control.alignmentY == 1\n            control.dstRect.y = @cy + Math.round((rect.height-(control.dstRect.height+control.margin.top+control.margin.bottom)) / 2)\n        else\n            control.dstRect.y = @cy + control.margin.top\n     \n    ###*\n    * Layouts the specified control as fixed-size control for a vertical stack-layout. \n    *\n    * @method updateControlRectFixedV\n    * @param {gs.Object_Base} control The control to update.\n    * @protected\n    ###        \n    updateControlRectFixedV: (control) ->\n        rect = @object.dstRect\n        if control.alignmentY == 0\n            @cy += control.margin.top\n            control.dstRect.y = @cy\n            @cy += control.dstRect.height + control.margin.bottom\n            control.dstRect.x = @cx + control.margin.left\n        else if control.alignmentY == 2\n            @bottom += control.margin.bottom\n            control.dstRect.y = (rect.height) - control.dstRect.height - @bottom\n            @bottom += control.dstRect.height + control.margin.top\n            control.dstRect.x = @cx + control.margin.left\n        else if control.alignmentY == 1\n            control.dstRect.y = @center + (rect.height - @centerSize) / 2\n            control.dstRect.x = @cx + control.margin.left\n            @center += control.dstRect.height + control.margin.bottom\n        if control.alignmentX == 1\n            control.dstRect.x = @cx + Math.round((rect.width-control.dstRect.width) / 2)\n     \n    ###*\n    * Layouts the specified control as resizable-control for a horizontal stack-layout. \n    * That means the control will take up all free space after subtracting all \n    * fixed-size controls.\n    *\n    * @method updateControlRectResizableH\n    * @param {gs.Object_Base} control The control to update.\n    * @protected\n    ###        \n    updateControlRectResizableH: (control) ->\n        dynamicSize = @calculateDynamicSizeHorizontal() \n        control.dstRect.y = control.margin.top\n        control.dstRect.height = @object.dstRect.height - control.margin.bottom - control.margin.top\n        control.dstRect.x = @cx + control.margin.left\n        control.dstRect.width = dynamicSize - control.margin.right - control.margin.left\n        @cx += dynamicSize\n    \n    ###*\n    * Layouts the specified control as resizable-control for a vertical stack-layout. \n    * That means the control will take up all free space after subtracting all \n    * fixed-size controls.\n    *\n    * @method updateControlRectResizableV\n    * @param {gs.Object_Base} control The control to update.\n    * @protected\n    ### \n    updateControlRectResizableV: (control) ->\n        dynamicSize = @calculateDynamicSizeVertical()\n        control.dstRect.x = control.margin.left\n        control.dstRect.width = @object.dstRect.width - control.margin.right - control.margin.left\n        control.dstRect.y = @cy + control.margin.top\n        control.dstRect.height = dynamicSize - control.margin.bottom - control.margin.top\n        @cy += dynamicSize\n    \n    \n    ###*\n    * Updates a control.\n    *\n    * @method updateControl\n    * @param {gs.Object_Base} control The control to update.\n    * @protected\n    ### \n    updateControl: (control) ->\n        if @orientation == 1\n            if not control.clipRect? then control.clipRect = @object.clipRect\n            if yes #!control.updated or (Rect.intersect(control.dstRect.x+@object.dstRect.x, control.dstRect.y+ @object.dstRect.y, control.dstRect.width, control.dstRect.height, @object.dstRect.x, @object.dstRect.y, @object.dstRect.width, @object.dstRect.height))\n                if control.needsUpdate\n                    control.needsUpdate = no\n                    control.update()\n                    \n                control.updated = yes\n                control.visible = yes\n            else\n                if control.visible\n                    control.visible = no\n                    control.update()\n        else\n            super(control)\n                    \n    ###*\n    * Layouts the sub-objects horizontally.\n    *\n    * @method layoutHorizontal\n    ### \n    layoutHorizontal: ->\n        @bottom = 0\n        @center = 0\n        @centerSize = 0\n        @offset = (@object.listOffset||0)\n        @count = @object.subObjects.length\n        @cx = 0\n        @cy = 0\n        \n        \n        @sizeToFitHorizontal()\n        \n        i = @offset\n        while i < @object.subObjects.length\n            control = @object.subObjects[i]\n            \n            @updateControl(control)\n\n            if control.disposed\n                @object.removeObject(control)\n                i--\n            else\n                if control.resizable and !control.sizeToFit\n                    @updateControlRectResizableH(control)\n                else\n                    @updateControlRectFixedH(control)\n            i++    \n        @object.clipRect?.set(@object.dstRect.x + @object.origin.x, @object.dstRect.y + @object.origin.y, @object.dstRect.width, @object.dstRect.height)  \n            \n        \n        \n        return null \n        \n    ###*\n    * Layouts the sub-objects vertically.\n    *\n    * @method layoutVertical\n    ###           \n    layoutVertical: ->\n        @bottom = 0\n        @center = 0\n        @centerSize = 0\n        @offset = (@object.listOffset||0)\n        @count = @object.subObjects.length\n        @cx = 0\n        @cy = 0\n        \n        @cy -= @object.scrollOffsetY\n        i = @offset\n        currentY = 0\n        \n        while i < @object.subObjects.length\n            control = @object.subObjects[i]\n            i++\n            continue unless control\n            \n            @updateControl(control)\n \n            if control.disposed\n                @object.removeObject(control)\n                i--\n            else\n                if control.resizable and !control.sizeToFit\n                    @updateControlRectResizableV(control)\n                else\n                    @updateControlRectFixedV(control)\n            \n        @sizeToFitVertical()  \n        \n        \n        @object.clipRect?.set(@object.dstRect.x + @object.origin.x, @object.dstRect.y + @object.origin.y, @object.dstRect.width, @object.dstRect.height)  \n            \n        return null    \ngs.Component_StackLayoutBehavior = Component_StackLayoutBehavior",
        "compiledContent": "// Generated by CoffeeScript 1.12.7\n(function() {\n  var Component_StackLayoutBehavior,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  Component_StackLayoutBehavior = (function(superClass) {\n    extend(Component_StackLayoutBehavior, superClass);\n\n\n    /**\n    * Turns a game object into a stack-layout and layouts all sub-objects\n    * like stack vertically or horizontally. The game object needs a \n    * container-component.\n    * <br>\n    * The sub-objects in a stack-layout can be configured as resizable or\n    * non-resizable(fixed-size). For example:<br>\n    * <br>\n    * Lets say we have a layout-size of 500px in width with three controls.<br>\n    * <br>\n    * | 80px | dynamic | 80px | <br>\n    * <br>\n    * Two controls have a fixed size of 80px and the middle-control has a\n    * dynamic-size because it is configured to be resizable. In that case, \n    * the size of the resizable control would be 340px because that is the\n    * free space left after subtracting the size(160px) of the fixed-size controls.<br>\n    * <br>\n    * In addition, each sub-object can have different alignment options.\n    *\n    * @module gs\n    * @class Component_StackLayoutBehavior\n    * @extends gs.Component_LayoutBehavior\n    * @memberof gs\n    * @constructor\n     */\n\n    function Component_StackLayoutBehavior(orientation) {\n      Component_StackLayoutBehavior.__super__.constructor.apply(this, arguments);\n\n      /**\n      * The orientation of the stack-layout. Can be vertical or horizontal.\n      * @property orientation\n      * @type gs.Orientation\n       */\n      this.orientation = orientation || 0;\n\n      /**\n      * @property scrollOffsetX\n      * @type number\n      * @protected\n       */\n      this.scrollOffsetX = 0;\n\n      /**\n      * @property scrollOffsetY\n      * @type number\n      * @protected\n       */\n      this.scrollOffsetY = 0;\n\n      /**\n      * @property contentHeight\n      * @type number\n      * @protected\n       */\n      this.contentHeight = 0;\n\n      /**\n      * Control list-offset.\n      * @property offset\n      * @type number\n      * @protected\n       */\n      this.offset = 0;\n\n      /**\n      * Count of controls to process.\n      * @property contentHeight\n      * @type number\n      * @protected\n       */\n      this.count = 0;\n\n      /**\n      * Current x-coordinate. \n      * @property cx\n      * @type number\n      * @protected\n       */\n      this.cx = 0;\n\n      /**\n      * Current y-coordinate. \n      * @property cy\n      * @type number\n      * @protected\n       */\n      this.cy = 0;\n\n      /**\n      * Total size of all centered controls. \n      * @property centerSize\n      * @type number\n      * @protected\n       */\n      this.centerSize = 0;\n\n      /**\n      * Current x/y-coordinate for a centered control.\n      * @property center\n      * @type number\n      * @protected\n       */\n      this.center = 0;\n\n      /**\n      * Current x/y-coordinate for a bottom/right aligned control.\n      * @property bottom\n      * @type number\n      * @protected\n       */\n      this.bottom = 0;\n      this.managementMode = 0;\n    }\n\n\n    /**\n    * Initializes the layout.\n    *\n    * @method setup\n     */\n\n    Component_StackLayoutBehavior.prototype.setup = function() {\n      this.update();\n      if (this.object.scrollable) {\n        return gs.GlobalEventManager.on(\"mouseWheel\", (function(_this) {\n          return function() {\n            var r;\n            r = _this.object.dstRect;\n            if (Rect.contains(r.x, r.y, r.width, r.height, Input.Mouse.x - _this.object.origin.x, Input.Mouse.y - _this.object.origin.y)) {\n              return _this.object.update();\n            }\n          };\n        })(this));\n      }\n    };\n\n\n    /**\n    * Updates the layout depending on its orientation.\n    *\n    * @method update\n     */\n\n    Component_StackLayoutBehavior.prototype.update = function() {\n      Component_StackLayoutBehavior.__super__.update.apply(this, arguments);\n      if (this.orientation === 0) {\n        return this.layoutHorizontal();\n      } else {\n        return this.layoutVertical();\n      }\n    };\n\n\n    /**\n    * Sizes the layout to fit its content\n    *\n    * @method sizeToFit\n    * @return number The content size.\n     */\n\n    Component_StackLayoutBehavior.prototype.sizeToFit = function() {\n      if (this.orientation === 0) {\n        return this.sizeToFitHorizontal();\n      } else {\n        return this.sizeToFitVertical();\n      }\n    };\n\n\n    /**\n    * Sizes the horizontal-layout to fit its content\n    *\n    * @method sizeToFitHorizontal\n     */\n\n    Component_StackLayoutBehavior.prototype.sizeToFitHorizontal = function() {\n      var control, i, j, rect, ref, ref1, results, x, y;\n      x = 0;\n      y = 0;\n      rect = this.object.dstRect;\n      if (this.object.sizeToFit) {\n        results = [];\n        for (i = j = ref = this.offset, ref1 = this.count; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {\n          control = this.object.subObjects[i];\n          if (!control.alignment) {\n            rect.width = Math.max(x + control.margin.left + control.dstRect.width + control.margin.right, rect.width || 0);\n            x += control.margin.left + control.dstRect.width + control.margin.right;\n          }\n          if (!control.alignmentY) {\n            results.push(rect.height = Math.max(y + control.margin.top + control.dstRect.height + control.margin.bottom, rect.height || 0));\n          } else {\n            results.push(void 0);\n          }\n        }\n        return results;\n      }\n    };\n\n\n    /**\n    * Sizes the vertical-layout to fit its content\n    *\n    * @method sizeToFitVertical\n     */\n\n    Component_StackLayoutBehavior.prototype.sizeToFitVertical = function() {\n      var control, j, len, rect, ref, results;\n      rect = this.object.dstRect;\n      if (this.object.sizeToFit) {\n        ref = this.object.subObjects;\n        results = [];\n        for (j = 0, len = ref.length; j < len; j++) {\n          control = ref[j];\n          rect.width = Math.max(control.dstRect.x + control.dstRect.width + control.margin.right, rect.width || 1);\n          results.push(rect.height = Math.max(control.dstRect.y + control.dstRect.height + control.margin.bottom, rect.height || 1));\n        }\n        return results;\n      }\n    };\n\n\n    /**\n    * Calculates the dynamic-size of a horizontal stack-layout. That size is used for\n    * resizable-controls to let them fill all free space. It is calculated in the\n    * following way:<br>\n    * <br>\n    * dynamic-size = sum-of-all-fixed-control-sizes / count-of-resizable-controls\n    * <br>\n    *\n    * @method calculateDynamicSizeHorizontal\n    * @return {number} The dynamic size.\n    * @protected\n     */\n\n    Component_StackLayoutBehavior.prototype.calculateDynamicSizeHorizontal = function() {\n      var control, dynamicCount, fixedSize, i, j, len, rect, ref;\n      fixedSize = 0;\n      dynamicCount = 0;\n      rect = this.object.dstRect;\n      ref = this.object.subObjects;\n      for (i = j = 0, len = ref.length; j < len; i = ++j) {\n        control = ref[i];\n        if (control.resizable && !control.sizeToFit) {\n          dynamicCount++;\n        } else {\n          fixedSize += control.margin.left + control.dstRect.width + control.margin.right;\n          if (control.alignmentX === 1) {\n            this.centerSize += control.dstRect.width + control.margin.right;\n          }\n        }\n      }\n      return Math.round((rect.width - fixedSize) / dynamicCount);\n    };\n\n\n    /**\n    * Calculates the dynamic-size of a vertical stack-layout. That size is used for\n    * resizable-controls to let them fill all free space. It is calculated in the\n    * following way:<br>\n    * <br>\n    * dynamic-size = sum-of-all-fixed-control-sizes / count-of-resizable-controls\n    * <br>\n    *\n    * @method calculateDynamicSizeVertical\n    * @return {number} The dynamic size.\n    * @protected\n     */\n\n    Component_StackLayoutBehavior.prototype.calculateDynamicSizeVertical = function() {\n      var control, dynamicCount, fixedSize, j, len, ref;\n      fixedSize = 0;\n      dynamicCount = 0;\n      ref = this.object.subObjects;\n      for (j = 0, len = ref.length; j < len; j++) {\n        control = ref[j];\n        if (control.resizable && !control.sizeToFit) {\n          dynamicCount++;\n        } else {\n          fixedSize += control.dstRect.height;\n          if (control.alignmentY === 1) {\n            this.centerSize += control.dstRect.height + control.margin.bottom;\n          }\n        }\n      }\n      return Math.round((this.object.dstRect.height - fixedSize) / dynamicCount);\n    };\n\n\n    /**\n    * Layouts the specified control as fixed-size control for a horizontal stack-layout. \n    *\n    * @method updateControlRectFixedH\n    * @param {gs.Object_Base} control The control to update.\n    * @protected\n     */\n\n    Component_StackLayoutBehavior.prototype.updateControlRectFixedH = function(control) {\n      var rect;\n      rect = this.object.dstRect;\n      if (control.alignmentX === 0) {\n        this.cx += control.margin.left;\n        control.dstRect.x = this.cx;\n        this.cx += control.dstRect.width + control.margin.right;\n      } else if (control.alignmentX === 2) {\n        this.bottom += control.margin.right;\n        control.dstRect.x = (rect.x + rect.width) - control.dstRect.width - this.bottom;\n        this.bottom += control.dstRect.width + control.margin.left;\n      } else if (control.alignmentX === 1) {\n        control.dstRect.x = this.center + (rect.width - this.centerSize) / 2;\n        this.center += control.dstRect.width + control.margin.right;\n      }\n      if (control.alignmentY === 1) {\n        return control.dstRect.y = this.cy + Math.round((rect.height - (control.dstRect.height + control.margin.top + control.margin.bottom)) / 2);\n      } else {\n        return control.dstRect.y = this.cy + control.margin.top;\n      }\n    };\n\n\n    /**\n    * Layouts the specified control as fixed-size control for a vertical stack-layout. \n    *\n    * @method updateControlRectFixedV\n    * @param {gs.Object_Base} control The control to update.\n    * @protected\n     */\n\n    Component_StackLayoutBehavior.prototype.updateControlRectFixedV = function(control) {\n      var rect;\n      rect = this.object.dstRect;\n      if (control.alignmentY === 0) {\n        this.cy += control.margin.top;\n        control.dstRect.y = this.cy;\n        this.cy += control.dstRect.height + control.margin.bottom;\n        control.dstRect.x = this.cx + control.margin.left;\n      } else if (control.alignmentY === 2) {\n        this.bottom += control.margin.bottom;\n        control.dstRect.y = rect.height - control.dstRect.height - this.bottom;\n        this.bottom += control.dstRect.height + control.margin.top;\n        control.dstRect.x = this.cx + control.margin.left;\n      } else if (control.alignmentY === 1) {\n        control.dstRect.y = this.center + (rect.height - this.centerSize) / 2;\n        control.dstRect.x = this.cx + control.margin.left;\n        this.center += control.dstRect.height + control.margin.bottom;\n      }\n      if (control.alignmentX === 1) {\n        return control.dstRect.x = this.cx + Math.round((rect.width - control.dstRect.width) / 2);\n      }\n    };\n\n\n    /**\n    * Layouts the specified control as resizable-control for a horizontal stack-layout. \n    * That means the control will take up all free space after subtracting all \n    * fixed-size controls.\n    *\n    * @method updateControlRectResizableH\n    * @param {gs.Object_Base} control The control to update.\n    * @protected\n     */\n\n    Component_StackLayoutBehavior.prototype.updateControlRectResizableH = function(control) {\n      var dynamicSize;\n      dynamicSize = this.calculateDynamicSizeHorizontal();\n      control.dstRect.y = control.margin.top;\n      control.dstRect.height = this.object.dstRect.height - control.margin.bottom - control.margin.top;\n      control.dstRect.x = this.cx + control.margin.left;\n      control.dstRect.width = dynamicSize - control.margin.right - control.margin.left;\n      return this.cx += dynamicSize;\n    };\n\n\n    /**\n    * Layouts the specified control as resizable-control for a vertical stack-layout. \n    * That means the control will take up all free space after subtracting all \n    * fixed-size controls.\n    *\n    * @method updateControlRectResizableV\n    * @param {gs.Object_Base} control The control to update.\n    * @protected\n     */\n\n    Component_StackLayoutBehavior.prototype.updateControlRectResizableV = function(control) {\n      var dynamicSize;\n      dynamicSize = this.calculateDynamicSizeVertical();\n      control.dstRect.x = control.margin.left;\n      control.dstRect.width = this.object.dstRect.width - control.margin.right - control.margin.left;\n      control.dstRect.y = this.cy + control.margin.top;\n      control.dstRect.height = dynamicSize - control.margin.bottom - control.margin.top;\n      return this.cy += dynamicSize;\n    };\n\n\n    /**\n    * Updates a control.\n    *\n    * @method updateControl\n    * @param {gs.Object_Base} control The control to update.\n    * @protected\n     */\n\n    Component_StackLayoutBehavior.prototype.updateControl = function(control) {\n      if (this.orientation === 1) {\n        if (control.clipRect == null) {\n          control.clipRect = this.object.clipRect;\n        }\n        if (true) {\n          if (control.needsUpdate) {\n            control.needsUpdate = false;\n            control.update();\n          }\n          control.updated = true;\n          return control.visible = true;\n        } else {\n          if (control.visible) {\n            control.visible = false;\n            return control.update();\n          }\n        }\n      } else {\n        return Component_StackLayoutBehavior.__super__.updateControl.call(this, control);\n      }\n    };\n\n\n    /**\n    * Layouts the sub-objects horizontally.\n    *\n    * @method layoutHorizontal\n     */\n\n    Component_StackLayoutBehavior.prototype.layoutHorizontal = function() {\n      var control, i, ref;\n      this.bottom = 0;\n      this.center = 0;\n      this.centerSize = 0;\n      this.offset = this.object.listOffset || 0;\n      this.count = this.object.subObjects.length;\n      this.cx = 0;\n      this.cy = 0;\n      this.sizeToFitHorizontal();\n      i = this.offset;\n      while (i < this.object.subObjects.length) {\n        control = this.object.subObjects[i];\n        this.updateControl(control);\n        if (control.disposed) {\n          this.object.removeObject(control);\n          i--;\n        } else {\n          if (control.resizable && !control.sizeToFit) {\n            this.updateControlRectResizableH(control);\n          } else {\n            this.updateControlRectFixedH(control);\n          }\n        }\n        i++;\n      }\n      if ((ref = this.object.clipRect) != null) {\n        ref.set(this.object.dstRect.x + this.object.origin.x, this.object.dstRect.y + this.object.origin.y, this.object.dstRect.width, this.object.dstRect.height);\n      }\n      return null;\n    };\n\n\n    /**\n    * Layouts the sub-objects vertically.\n    *\n    * @method layoutVertical\n     */\n\n    Component_StackLayoutBehavior.prototype.layoutVertical = function() {\n      var control, currentY, i, ref;\n      this.bottom = 0;\n      this.center = 0;\n      this.centerSize = 0;\n      this.offset = this.object.listOffset || 0;\n      this.count = this.object.subObjects.length;\n      this.cx = 0;\n      this.cy = 0;\n      this.cy -= this.object.scrollOffsetY;\n      i = this.offset;\n      currentY = 0;\n      while (i < this.object.subObjects.length) {\n        control = this.object.subObjects[i];\n        i++;\n        if (!control) {\n          continue;\n        }\n        this.updateControl(control);\n        if (control.disposed) {\n          this.object.removeObject(control);\n          i--;\n        } else {\n          if (control.resizable && !control.sizeToFit) {\n            this.updateControlRectResizableV(control);\n          } else {\n            this.updateControlRectFixedV(control);\n          }\n        }\n      }\n      this.sizeToFitVertical();\n      if ((ref = this.object.clipRect) != null) {\n        ref.set(this.object.dstRect.x + this.object.origin.x, this.object.dstRect.y + this.object.origin.y, this.object.dstRect.width, this.object.dstRect.height);\n      }\n      return null;\n    };\n\n    return Component_StackLayoutBehavior;\n\n  })(gs.Component_LayoutBehavior);\n\n  gs.Component_StackLayoutBehavior = Component_StackLayoutBehavior;\n\n}).call(this);\n"
    },
    "summary": [
        "name",
        "type",
        "order"
    ],
    "externalItems": []
}