// Generated by CoffeeScript 1.12.7

/**
* Different methods of field-animation.
*
* @module gs
* @class AnimationLoopType
* @memberof gs
* @static
* @final
 */

(function() {
  var Component_FieldAnimation, FieldAnimationMethod,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  FieldAnimationMethod = (function() {
    function FieldAnimationMethod() {}

    FieldAnimationMethod.initialize = function() {

      /**
      * Set the value calculated by the easing-logic.
      * @property SET
      * @static
      * @final
       */
      this.SET = 0;

      /**
      * Adds the value calculated by the easing-logic.
      * @property ADD
      * @static
      * @final
       */
      return this.ADD = 1;
    };

    return FieldAnimationMethod;

  })();

  FieldAnimationMethod.initialize();

  gs.FieldAnimationMethod = FieldAnimationMethod;

  Component_FieldAnimation = (function(superClass) {
    extend(Component_FieldAnimation, superClass);


    /**
    * Executes a field-animation. A field-animation animates a certain
    * property of the game-object as long as it is a number-property.
    *
    * @module gs
    * @class Component_FieldAnimation
    * @extends gs.Component_Animation
    * @memberof gs
    * @constructor
     */

    function Component_FieldAnimation(data) {
      Component_FieldAnimation.__super__.constructor.apply(this, arguments);

      /**
      * The field to animate as property-path.
      * @property field
      * @type string
       */
      this.field = data != null ? data.field : void 0;

      /**
      * The animation-method.
      * @property method
      * @type gs.FieldAnimationMethod
      * @default gs.FieldAnimationMethod.SET
       */
      this.method = data != null ? data.method : void 0;

      /**
      * The easing-object used for the animation.
      * @property easing
      * @type gs.Easing
       */
      this.easing = new gs.Easing(null, data != null ? data.easing : void 0);
    }


    /**
    * Serializes the path-animation into a data-bundle.
    *
    * @method toDataBundle
     */

    Component_FieldAnimation.prototype.toDataBundle = function() {
      return {
        easing: this.easing,
        method: this.method,
        field: this.field
      };
    };


    /**
    * Updates the field-animation.
    *
    * @method update
     */

    Component_FieldAnimation.prototype.update = function() {
      var value;
      Component_FieldAnimation.__super__.update.apply(this, arguments);
      if (!this.easing.isRunning) {
        return;
      }
      this.easing.updateValue();
      value = ui.Component_BindingHandler.resolveFieldPath(this.object, this.field);
      if (!this.method) {
        value.set(this.object, this.easing.value);
      } else {
        value.set(this.object, value.get(this.object) + this.easing.value);
      }
      if (!this.easing.isRunning) {
        return typeof this.callback === "function" ? this.callback(this.object, this) : void 0;
      }
    };


    /**
    * Starts the field-animation.
    *
    * @method start
    * @param {number} Value The target value.
    * @param {string} field The name of the field/property.
    * @param {number} duration The duration in frames.
    * @param {Object} easingType The easing-type.
    * @param {function} [callback] An optional callback called if blending is finished.
     */

    Component_FieldAnimation.prototype.start = function(value, field, duration, easingType, callback) {
      var startValue, valueField;
      this.callback = callback;
      this.field = field;
      this.easing.type = easingType || gs.Easings.EASE_LINEAR[gs.EasingTypes.EASE_IN];
      if (duration === 0 || this.isInstantSkip()) {
        valueField = ui.Component_BindingHandler.resolveFieldPath(this.object, this.field);
        valueField.set(this.object, value);
        return typeof this.callback === "function" ? this.callback(this.object, this) : void 0;
      } else {
        startValue = ui.Component_BindingHandler.fieldValue(this.object, field);
        return this.easing.startValue(startValue, value - startValue, duration);
      }
    };

    return Component_FieldAnimation;

  })(gs.Component_Animation);

  gs.Component_FieldAnimation = Component_FieldAnimation;

}).call(this);
