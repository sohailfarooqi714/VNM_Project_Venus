// Generated by CoffeeScript 1.12.7
(function() {
  var Object_Base;

  Object_Base = (function() {

    /**
    * Called if this object instance is restored from a data-bundle. It can be used
    * re-assign event-handler, anonymous functions, etc.
    * 
    * @method onDataBundleRestore.
    * @param Object data - The data-bundle
    * @param gs.ObjectCodecContext context - The codec-context.
     */
    Object_Base.prototype.onDataBundleRestore = function(data, context) {
      if (this.id) {
        return window["$" + this.id] = this;
      }
    };

    Object_Base.accessors("group", {
      set: function(g) {
        var ref;
        this.group_ = g;
        return (ref = gs.ObjectManager.current) != null ? ref.addToGroup(this, g) : void 0;
      },
      get: function() {
        return this.group_;
      }
    });

    Object_Base.accessors("order", {
      set: function(o) {
        var ref;
        if (o !== this.order_) {
          this.order_ = o;
          return (ref = this.parent) != null ? ref.needsSort = true : void 0;
        }
      },
      get: function() {
        return this.order_;
      }
    });

    Object_Base.accessors("needsUpdate", {
      set: function(v) {
        var parent;
        this.needsUpdate_ = v;
        parent = this.parent;
        while (parent) {
          parent.needsUpdate_ = true;
          parent = parent.parent;
        }
        if (v) {
          return this.requestSubUpdate();
        }
      },
      get: function() {
        return this.needsUpdate_ || SceneManager.scene.preparing;
      }
    });

    Object_Base.prototype.requestSubUpdate = function() {
      var j, len, object, ref;
      ref = this.subObjects;
      for (j = 0, len = ref.length; j < len; j++) {
        object = ref[j];
        if (object) {
          object.needsUpdate_ = true;
          object.requestSubUpdate();
        }
      }
      return null;
    };

    Object_Base.accessors("needsFullUpdate", {
      set: function(v) {
        var j, len, object, ref, results;
        this.needsUpdate = v;
        if (v) {
          ref = this.subObjects;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            object = ref[j];
            results.push(object.needsFullUpdate = v);
          }
          return results;
        }
      },
      get: function() {
        return this.needsUpdate_;
      }
    });


    /**
    * The base class for all game objects. A game object itself doesn't implement
    * any game logic but uses components and sub-objects for that.
    *
    * @module gs
    * @class Object_Base
    * @memberof gs
    * @constructor
     */

    function Object_Base() {

      /**
      * @property subObjects
      * @type gs.Object_Base[]
      * @default []
      * A list of game-objects grouped under this game object.
       */
      var ref;
      this.subObjects = [];

      /**
      * @property components
      * @type gs.Component[]
      * @default []
      * A list of components defining the logic/behavior and appearance of the game object.
       */
      this.components = [];

      /**
      * @property componentsById
      * @type Object
      * @default []
      * All associated components by their ID.
       */
      this.componentsById = {};

      /**
      * @property disposed
      * @type boolean
      * @default false
      * Indicates if the game object id disposed. A disposed game object cannot be used anymore.
       */
      this.disposed = false;

      /**
      * @property active
      * @default true
      * Indicates if the game object is active. An inactive game object will not be updated.
       */
      this.active = true;
      this.input = false;

      /**
      * @property id
      * @type string
      * @default null
      * The game object's UID (Unique ID)
       */
      this.id = null;

      /**
      * @property group
      * @default null
      * @type string
      * The game object's group. To get all object's of a specific group the gs.ObjectManager.objectsByGroup property can be used.
       */
      this.group = null;

      /**
      * @property parent
      * @type gs.Object_Base
      * @default null
      * The parent object if the game object is a sub-object of another game object.
       */
      this.parent = null;

      /**
      * @property order
      * @type number
      * @default 0
      * Controls the update-order. The smaller the value the earlier the game object is updated before other game objects are updated.
       */
      this.order = 0;

      /**
      * @property rIndex
      * @type number
      * @default 0
      * Holds the render-index if the game object has a graphical representation on screen. The render-index is the
      * index of the game object's graphic-object(gs.GraphicObject) in the current list of graphic-objects. The render-index
      * is read-only. Setting the render-index to a certain value has no effect.
       */
      this.rIndex = 0;

      /**
      * @property needsSort
      * @type boolean
      * @default true
      * Indicates if the list of sub-objects needs to be sorted by order because of a change.
       */
      this.needsSort = true;

      /**
      * @property needsSort
      * @type boolean
      * @default true
      * Indicates if the UI object needs to be updated.
       */
      this.needsUpdate = true;

      /**
      * @property initialized
      * @type boolean
      * @default true
      * Indicates if the game object and its components have been initialized.
       */
      this.initialized = false;

      /**
      * @property customData
      * @type Object
      * @default {}
      * A custom data object which can be used to add any custom data/fields to the game
      * object. It is an empty object by default.
       */
      this.customData = {};
      if ((ref = gs.ObjectManager.current) != null) {
        ref.registerObject(this);
      }
    }


    /**
    * Disposes the object with all its components and sub-objects. A disposed object will be
    * removed from the parent automatically.
    *
    * @method dispose
     */

    Object_Base.prototype.dispose = function() {
      var ref;
      if (!this.disposed) {
        this.disposed = true;
        this.disposeComponents();
        this.disposeObjects();
        if ((ref = gs.ObjectManager.current) != null) {
          ref.unregisterObject(this);
        }
      }
      return null;
    };


    /**
    * Disposes all sub-objects.
    *
    * @method disposeObjects
    * @protected
     */

    Object_Base.prototype.disposeObjects = function() {
      var j, len, ref, results, subObject;
      ref = this.subObjects;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        subObject = ref[j];
        results.push(subObject != null ? typeof subObject.dispose === "function" ? subObject.dispose() : void 0 : void 0);
      }
      return results;
    };


    /**
    * Disposes all components
    *
    * @method disposeComponents
    * @protected
     */

    Object_Base.prototype.disposeComponents = function() {
      var component, j, len, ref, results;
      ref = this.components;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        component = ref[j];
        results.push(component != null ? typeof component.dispose === "function" ? component.dispose() : void 0 : void 0);
      }
      return results;
    };


    /**
    * Calls setup-routine on all components.
    *
    * @method setup
     */

    Object_Base.prototype.setup = function() {
      var component, j, len, ref;
      ref = this.components;
      for (j = 0, len = ref.length; j < len; j++) {
        component = ref[j];
        if (!(component != null ? component.isSetup : void 0)) {
          component.setup();
        }
      }
      this.initialized = true;
      return null;
    };


    /**
    * Deserializes components from a data-bundle object.
    * 
    * @method componentsFromDataBundle
    * @param {Object} data The data-bundle object.
     */

    Object_Base.prototype.componentsFromDataBundle = function(data) {
      var component, componentObject, j, len, ref;
      if (data != null ? data.components : void 0) {
        ref = data.components;
        for (j = 0, len = ref.length; j < len; j++) {
          component = ref[j];
          componentObject = new gs[component.className](component);
          this.addComponent(componentObject);
        }
        delete data.components;
      }
      return null;
    };


    /**
    * Serializes components of a specified type to a data-bundle. A component
    * needs to implement the toDataBundle method for correct serialization.
    *
    * @method componentsToDataBundle
    * @param {String} type - A component class name.
    * @return A data bundle.
     */

    Object_Base.prototype.componentsToDataBundle = function(type) {
      var bundle, component, components, j, len, ref;
      components = [];
      ref = this.components;
      for (j = 0, len = ref.length; j < len; j++) {
        component = ref[j];
        if (component instanceof type) {
          if (component.toDataBundle == null) {
            continue;
          }
          bundle = component.toDataBundle();
          bundle.className = component.constructor.name;
          components.push(bundle);
        }
      }
      return components;
    };


    /**
    * Starts a full-refresh on all sub-objects
    *
    * @method fullRefresh
     */

    Object_Base.prototype.fullRefresh = function() {
      var j, len, object, ref;
      ref = this.subObjects;
      for (j = 0, len = ref.length; j < len; j++) {
        object = ref[j];
        if (object) {
          object.needsUpdate = true;
          object.fullRefresh();
        }
      }
      return null;
    };


    /**
    * Updates the object with all parent- and sub-objects. 
    *
    * @method fullUpdate
     */

    Object_Base.prototype.fullUpdate = function() {
      var j, len, object, parent, ref, results;
      parent = this;
      while (parent !== null) {
        parent.update();
        parent = parent.parent;
      }
      ref = this.subObjects;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        object = ref[j];
        results.push(object != null ? object.update() : void 0);
      }
      return results;
    };


    /**
    * Updates the object and all its components. This method is
    * called automatically by the parent or ObjectManager so in regular it is 
    * not necessary to call it manually.
    *
    * @method update
     */

    Object_Base.prototype.update = function() {
      var component, i;
      if (!this.active) {
        return;
      }
      i = 0;
      while (i < this.components.length) {
        component = this.components[i];
        if (!component.disposed) {
          component.update();
          i++;
        } else {
          this.components.splice(i, 1);
        }
      }
      if (this.input) {
        Input.clear();
      }
      this.input = false;
      return null;
    };


    /**
    * Searches for the first component with the specified class name.
    *
    * @method findComponent
    * @param {String} name The class name of the component.
    * @return {Component} The component or null if a component with the specified class name cannot be found.
     */

    Object_Base.prototype.findComponent = function(name) {
      return this.components.first(function(v) {
        return v.constructor.name === name;
      });
    };


    /**
    * Searches for all components with the specified class name.
    *
    * @method findComponents
    * @param {String} name The class name of the components.
    * @return {Array} The components or null if no component with the specified class name has been found.
     */

    Object_Base.prototype.findComponents = function(name) {
      return this.components.where(function(v) {
        return v.constructor.name === name;
      });
    };


    /**
    * Searches for the component with the specified ID.
    *
    * @method findComponentById
    * @param {String} id The unique identifier of the component.
    * @return {Component} The component or null if a component with the specified ID cannot be found.
     */

    Object_Base.prototype.findComponentById = function(id) {
      return this.componentsById[id];
    };


    /**
    * Searches for the component with the specified name. If multiple components have the
    * same name, it will return the first match.
    *
    * @method findComponentByName
    * @param {String} name The name of the component to find.
    * @return {Component} The component or null if a component with the specified name cannot be found.
     */

    Object_Base.prototype.findComponentByName = function(name) {
      return this.components.first(function(v) {
        return v.name === name;
      });
    };


    /**
    * Searches for components with the specified name.
    *
    * @method findComponentsByName
    * @param {String} name The name of the components to find.
    * @return {Component[]} An array of components matching the specified name or null if no components with the specified name exist.
     */

    Object_Base.prototype.findComponentsByName = function(name) {
      return this.components.where(function(v) {
        return v.name === name;
      });
    };


    /**
    * Adds an object to the list of sub-objects.
    *
    * @method addObject
    * @param {Object_Base} object The object which should be added.
     */

    Object_Base.prototype.addObject = function(object) {
      var ref, ref1;
      if ((ref = gs.ObjectManager.current) != null) {
        ref.remove(object);
      }
      if ((ref1 = object.parent) != null) {
        ref1.removeObject(object);
      }
      object.parent = this;
      this.subObjects.push(object);
      this.needsSort = true;
      this.needsUpdate = true;
      if (object.id != null) {
        return gs.ObjectManager.current.setObjectById(object, object.id);
      }
    };


    /**
    * Inserts an object into the list of sub-objects at the specified index.
    *
    * @method insertObject
    * @param {Object_Base} object The object which should be inserted.
    * @param {Number} index The index.
     */

    Object_Base.prototype.insertObject = function(object, index) {
      var ref;
      gs.ObjectManager.current.remove(object);
      if ((ref = object.parent) != null) {
        ref.removeObject(object);
      }
      object.parent = this;
      this.subObjects.splice(index, 0, object);
      if (object.id != null) {
        return gs.ObjectManager.current.setObjectById(object, object.id);
      }
    };


    /**
    * Sets sub-object at the specified index.
    *
    * @method setObject
    * @param {Object_Base} object The object.
    * @param {Number} index The index.
     */

    Object_Base.prototype.setObject = function(object, index) {
      var ref;
      if (object) {
        gs.ObjectManager.current.remove(object);
        if ((ref = object.parent) != null) {
          ref.removeObject(object);
        }
        object.parent = this;
      }
      this.subObjects[index] = object;
      if ((object != null ? object.id : void 0) != null) {
        return gs.ObjectManager.current.setObjectById(object, object.id);
      }
    };


    /**
    * Removes the specified object from the list of sub-objects.
    *
    * @method removeObject
    * @param {Object_Base} object The object which should be removed.
     */

    Object_Base.prototype.removeObject = function(object) {
      this.subObjects.remove(object);
      object.parent = null;
      return this.needsUpdate = true;
    };


    /**
    * Removes the object at the specified index from the list of sub-objects.
    *
    * @method removeObjectAt
    * @param {number} index The index of the objec to remove.
     */

    Object_Base.prototype.removeObjectAt = function(index) {
      var object;
      object = this.subObjects[index];
      this.subObjects.splice(index, 1);
      object.parent = null;
      return this.needsUpdate = true;
    };


    /**
    * Removes all sub-objects.
    *
    * @method removeAllObjects
     */

    Object_Base.prototype.removeAllObjects = function() {
      var results;
      results = [];
      while (this.subObjects.length > 0) {
        results.push(this.removeObjectAt(0));
      }
      return results;
    };


    /**
    * Erases the object at the specified index. The list size
    * will not be changed but the the value at the index will be set to null.
    *
    * @method eraseObject
    * @param {Number} object The object which should be erased.
     */

    Object_Base.prototype.eraseObject = function(index) {
      var object;
      object = this.subObjects[index];
      if (object != null) {
        object.parent = null;
      }
      return this.subObjects[index] = null;
    };


    /**
    * Adds the specified component to the object.
    *
    * @method addComponent
    * @param {Component} component The component
    * @param {String} id An optional unique identifier for the component.
     */

    Object_Base.prototype.addComponent = function(component, id) {
      if (!this.components.contains(component)) {
        component.object = this;
        this.components.push(component);
        if (id != null) {
          return this.componentsById[id] = component;
        }
      }
    };


    /**
    * Inserts a component at the specified index.
    *
    * @method insertComponent
    * @param {Component} component The component.
    * @param {Number} index The index.
    * @param {String} id An optional unique identifier for the component.
     */

    Object_Base.prototype.insertComponent = function(component, index, id) {
      this.components.remove(component);
      component.object = this;
      this.components.splice(index, 0, component);
      if (id != null) {
        return this.componentsById[id] = component;
      }
    };


    /**
    * Removes a component from the object.
    *
    * @method removeComponent
    * @param {Component} component The component to remove.
     */

    Object_Base.prototype.removeComponent = function(component) {
      this.components.remove(component);
      if (typeof id !== "undefined" && id !== null) {
        return delete this.componentsById[id];
      }
    };

    return Object_Base;

  })();

  gs.Object_Base = Object_Base;

}).call(this);
