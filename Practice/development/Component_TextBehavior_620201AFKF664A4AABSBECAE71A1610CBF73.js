// Generated by CoffeeScript 1.12.7
(function() {
  var Component_TextBehavior,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Component_TextBehavior = (function(superClass) {
    extend(Component_TextBehavior, superClass);

    Component_TextBehavior.memoryUsage = 0;


    /**
    * Called if this object instance is restored from a data-bundle. It can be used
    * re-assign event-handler, anonymous functions, etc.
    * 
    * @method onDataBundleRestore.
    * @param Object data - The data-bundle
    * @param gs.ObjectCodecContext context - The codec-context.
     */

    Component_TextBehavior.prototype.onDataBundleRestore = function(data, context) {
      var ref, ref1, size;
      if (this.renderedLines) {
        size = this.object.textRenderer.measureFormattedLines(this.renderedLines, (ref = this.object.wordWrap) != null ? ref : true);
        this.refreshWithSize(size);
        this.refreshBitmap();
        return this.object.textRenderer.drawFormattedLines(this.padding.left, this.padding.top, this.padding.right, this.padding.bottom, this.renderedLines, (ref1 = this.object.wordWrap) != null ? ref1 : true);
      } else {
        return this.refresh(true);
      }
    };


    /**
    * 
    *
    * @module gs
    * @class Component_TextBehavior
    * @extends gs.Component
    * @memberof gs
    * @constructor
     */

    function Component_TextBehavior() {
      Component_TextBehavior.__super__.constructor.call(this);

      /**
      * The current text displayed.
      * @property text
      * @type string
      * @protected
       */
      this.text = "";
      this.renderedLines = null;

      /**
      * The space around the text.
      * @property padding
      * @type string
      * @protected
       */
      this.padding = new ui.Space(6, 0, 6, 0);

      /**
      * The font used for text-rendering.
      * @property font
      * @type string
      * @protected
       */
      this.font = new Font(gs.Fonts.TEXT);

      /**
      * Standard Format String which can be used if the text represents a number value.
      * Example: If the text is "3" and format is "%0d3" then 003 is the displayed text.
      * @property format
      * @type string
      * @protected
       */
      this.format = null;
    }


    /**
    * Disposes the component and bitmap.
    *
    * @method dispose
     */

    Component_TextBehavior.prototype.dispose = function() {
      if (this.object.bitmap != null) {
        this.object.bitmap.dispose();
        return this.object.bitmap = null;
      }
    };


    /**
    * Redraws the texts on game object's bitmap.
    *
    * @method redraw
     */

    Component_TextBehavior.prototype.redraw = function() {
      var ref, text;
      if (this.text != null) {
        this.object.bitmap.clear();
        this.object.bitmap.font = this.object.font;
        text = lcs(this.text);
        if (this.format != null) {
          text = sprintf(this.format, text);
        }
        if (this.object.formatting) {
          return this.renderedLines = this.object.textRenderer.drawFormattedText(this.padding.left, this.padding.top, this.padding.right, this.padding.bottom, text, (ref = this.object.wordWrap) != null ? ref : true);
        } else {
          return this.object.textRenderer.drawText(this.padding.left, this.padding.top, this.padding.right, this.padding.bottom, text);
        }
      }
    };


    /**
    * Updates the game object's <b>dstRect</b> so that the text fits in. That only works
    * if the game object's <b>sizeToFit</b> property is set.
    *
    * @method refreshSize
     */

    Component_TextBehavior.prototype.refreshSize = function() {
      var ref, size, text;
      if (this.object.text == null) {
        return;
      }
      this.text = this.object.text;
      text = lcs(this.object.text).toString();
      if (this.format != null) {
        text = sprintf(this.format, text);
      }
      if (this.object.sizeToFit) {
        this.object.font = this.object.font || this.font;
        if (this.object.formatting) {
          size = this.object.textRenderer.measureFormattedText(text, (ref = this.object.wordWrap) != null ? ref : true);
        } else {
          size = this.object.textRenderer.measureText(text);
        }
        return this.refreshWithSize(size);
      }
    };


    /**
    * Updates the game object's <b>dstRect</b> with the specified text size.
    *
    * @param {gs.Size} size - The text size to resize the game object for.
    * @method refreshWithSize
     */

    Component_TextBehavior.prototype.refreshWithSize = function(size) {
      if (!(this.object.sizeToFit.horizontal != null) || this.object.sizeToFit.horizontal) {
        this.object.dstRect.width = size.width + this.padding.right + this.padding.left;
      }
      if (!(this.object.sizeToFit.vertical != null) || this.object.sizeToFit.vertical) {
        return this.object.dstRect.height = size.height + this.padding.bottom + this.padding.top;
      }
    };


    /**
    * Recreates and clears the game object's bitmap if necessary.
    *
    * @method refreshBitmap
     */

    Component_TextBehavior.prototype.refreshBitmap = function() {
      var height, ref, ref1, ref2, width;
      width = ((ref = this.object.bitmap) != null ? ref.width : void 0) || 0;
      height = ((ref1 = this.object.bitmap) != null ? ref1.height : void 0) || 0;
      if (!this.object.bitmap || width !== this.object.dstRect.width || height !== this.object.dstRect.height) {
        if ((ref2 = this.object.bitmap) != null) {
          ref2.dispose();
        }
        this.object.bitmap = new Bitmap(this.object.dstRect.width, this.object.dstRect.height);
      } else {
        this.object.bitmap.clear();
      }
      return this.object.bitmap.font = this.object.font;
    };


    /**
    * Refreshes the texts on game object's bitmap. If the text or font has not been
    * changed, no refresh will happen.
    *
    * @method refresh
    * @param {boolean} force - If set to <b>true</b> it will force redrawing the text even if the
    * text and font has not been changed.
     */

    Component_TextBehavior.prototype.refresh = function(force) {
      var fontChange;
      fontChange = !this.font.compare(this.object.font);
      if ((this.object.text == null) || (!force && this.object.text === this.text && !fontChange)) {
        return;
      }
      if (fontChange) {
        this.font.set(this.object.font);
      }
      this.refreshSize();
      this.refreshBitmap();
      this.srcRect = new Rect(0, 0, this.object.dstRect.width, this.object.dstRect.height);
      this.object.srcRect = this.srcRect;
      return this.redraw();
    };


    /**
    * Action to append a specified text.
    *
    * @method addText
    * @param {Object} sender - The sender of the action.
    * @param {Object} params - The action's parameters.
     */

    Component_TextBehavior.prototype.addText = function(sender, params) {
      return this.object.text += ui.Component_FormulaHandler.fieldValue(sender, params.text);
    };


    /**
    * Updates the component. Checks if the game object's bitmap needs a refresh
    * and maybe disposes the bitmap if the game object's is out of the
    * screen and memory usage is too high.
    *
    * @method update
     */

    Component_TextBehavior.prototype.update = function() {
      var ref, visible;
      Component_TextBehavior.__super__.update.apply(this, arguments);
      visible = this.object.visual.visible;
      if (!this.object.bitmap || this.object.bitmap.width !== this.object.dstRect.width || this.object.bitmap.height !== this.object.dstRect.height || ((ref = lcs(this.object.text)) != null ? ref.toString() : void 0) !== lcs(this.text)) {
        return this.refresh();
      }
    };

    return Component_TextBehavior;

  })(gs.Component);

  gs.Component_TextBehavior = Component_TextBehavior;

}).call(this);
