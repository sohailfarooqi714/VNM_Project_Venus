// Generated by CoffeeScript 1.12.7
(function() {
  var Component_TilingSprite,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Component_TilingSprite = (function(superClass) {
    extend(Component_TilingSprite, superClass);


    /**
    * A tiling sprite component tiles the image of the game object on screen. The
    * tiling can be vertical, horizontal or both. The sprite can be managed or
    * unmanaged. A managed sprite is automatically added to the graphics-system
    * and processed every frame until it gets disposed. An unmanaged sprite needs
    * to be added and removed manually.
    *
    * @module gs
    * @class Component_TilingSprite
    * @extends gs.Component_Sprite
    * @memberof gs
    * @constructor
    * @param {boolean} managed - Indicates if the sprite is managed by the graphics system.
     */

    function Component_TilingSprite(managed) {
      this.sprite = null;
      this.image = null;
      this.video = null;
      this.imageFolder = "Graphics/Pictures";
      this.visible = true;
      this.looping = {
        vertical: true,
        horizontal: true
      };
      this.scroll = {
        x: 0,
        y: 0
      };
    }


    /**
    * Creates sprite object.
    *
    * @method setupSprite
     */

    Component_TilingSprite.prototype.setupSprite = function() {
      if (!this.sprite) {
        return this.sprite = new gs.TilingSprite(Graphics.viewport, typeof managed !== "undefined" && managed !== null ? managed : true);
      }
    };


    /**
    * Updates the padding.
    *
    * @method updatePadding
     */

    Component_TilingSprite.prototype.updatePadding = function() {
      if (this.object.padding != null) {
        this.sprite.rect.x += this.object.padding.left;
        this.sprite.rect.y += this.object.padding.top;
        this.sprite.rect.width -= this.object.padding.left + this.object.padding.right;
        return this.sprite.rect.height -= this.object.padding.bottom + this.object.padding.bottom;
      }
    };


    /**
    * Updates the source- and destination-rectangle of the game object so that
    * the associated bitmap fits in. 
    *
    * @method updateRect
     */

    Component_TilingSprite.prototype.updateRect = function() {
      if (this.sprite.bitmap != null) {
        return this.object.srcRect = new Rect(0, 0, this.sprite.bitmap.width, this.sprite.bitmap.height);
      }
    };


    /**
    * Updates the sprite properties from the game object properties.
    *
    * @method updateProperties
     */

    Component_TilingSprite.prototype.updateProperties = function() {
      Component_TilingSprite.__super__.updateProperties.call(this);
      this.sprite.zoomX = this.object.zoom.x;
      this.sprite.zoomY = this.object.zoom.y;
      this.sprite.vertical = this.looping.vertical;
      this.sprite.horizontal = this.looping.horizontal;
      this.sprite.x = this.scroll.x;
      this.sprite.y = this.scroll.y;
      this.sprite.angle = this.object.angle;
      this.sprite.rect.x = this.object.dstRect.x;
      this.sprite.rect.y = this.object.dstRect.y;
      this.sprite.rect.width = this.object.dstRect.width;
      return this.sprite.rect.height = this.object.dstRect.height;
    };


    /**
    * Updates the optional sprite properties from the game object properties.
    * @method updateOptionalProperties
     */

    Component_TilingSprite.prototype.updateOptionalProperties = function() {
      Component_TilingSprite.__super__.updateOptionalProperties.apply(this, arguments);
      if (this.object.zoom != null) {
        this.sprite.zoomX = this.object.zoom.x;
        return this.sprite.zoomY = this.object.zoom.y;
      }
    };

    return Component_TilingSprite;

  })(gs.Component_Sprite);

  gs.Component_TilingSprite = Component_TilingSprite;

}).call(this);
