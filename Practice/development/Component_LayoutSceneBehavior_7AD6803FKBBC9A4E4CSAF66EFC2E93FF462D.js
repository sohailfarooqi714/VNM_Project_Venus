// Generated by CoffeeScript 1.12.7
(function() {
  var Component_LayoutSceneBehavior,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Component_LayoutSceneBehavior = (function(superClass) {
    extend(Component_LayoutSceneBehavior, superClass);


    /**
    * The base class of all scene-behavior components. A scene-behavior component
    * define the logic of a single game scene.
    *
    * @module gs
    * @class Component_LayoutSceneBehavior
    * @extends gs.Component_SceneBehavior
    * @memberof gs
     */

    function Component_LayoutSceneBehavior() {
      Component_LayoutSceneBehavior.__super__.constructor.call(this);
      this.objectManager = SceneManager;
      this.layout = null;
      this.resourceContext = null;
    }


    /**
    * Initializes the scene.
    *
    * @method initialize
     */

    Component_LayoutSceneBehavior.prototype.initialize = function() {
      Component_LayoutSceneBehavior.__super__.initialize.apply(this, arguments);
      this.resourceContext = ResourceManager.createContext();
      ResourceManager.context = this.resourceContext;
      if (this.object.layoutData == null) {
        this.object.layoutData = {
          "type": "ui.FreeLayout",
          "controls": [],
          "frame": [0, 0, 1, 1]
        };
      }
      return LanguageManager.loadBundles();
    };


    /**
    * Disposes the scene.
    *
    * @method dispose
     */

    Component_LayoutSceneBehavior.prototype.dispose = function() {
      return Component_LayoutSceneBehavior.__super__.dispose.apply(this, arguments);
    };


    /**
    * Prepares all data for the scene and loads the necessary graphic and audio resources.
    *
    * @method prepareData
    * @abstract
     */

    Component_LayoutSceneBehavior.prototype.prepareData = function() {
      gs.ObjectManager.current = this.objectManager;
      if (!GameManager.initialized) {
        GameManager.initialize();
      }
      this.dataFields = ui.UiFactory.dataSources[this.object.layoutData.dataSource || "default"]();
      window.$dataFields = this.dataFields;
      this.music = ui.Component_FormulaHandler.fieldValue(this.object, this.object.layoutData.music);
      AudioManager.loadMusic(this.music);
      this.prepareTransition(RecordManager.system.menuTransition);
      ResourceLoader.loadUiTypesGraphics(ui.UiFactory.customTypes);
      ResourceLoader.loadUiLayoutGraphics(this.object.layoutData);
      if (this.dataFields != null) {
        return ResourceLoader.loadUiDataFieldsGraphics(this.dataFields);
      }
    };


    /**
    * Prepares all visual game object for the scene.
    *
    * @method prepareVisual
     */

    Component_LayoutSceneBehavior.prototype.prepareVisual = function() {
      var scale, vocab;
      scale = Graphics.scale;
      vocab = RecordManager.vocabulary;
      if (this.layout == null) {
        this.dataObject = {};
        this.layout = ui.UiFactory.createFromDescriptor(this.object.layoutData, this.object);
        if (this.music != null) {
          AudioManager.changeMusic(this.music, 30);
        }
      }
      this.layout.ui.prepare();
      this.layout.ui.appear();
      this.layout.update();
      this.transition();
      if (SceneManager.previousScenes.length === 0) {
        if (GameManager.tempFields.isExitingGame) {
          GameManager.tempFields.isExitingGame = false;
          return gs.GameNotifier.postResetSceneChange(this.object.layoutName);
        } else {
          return gs.GameNotifier.postSceneChange(this.object.layoutName);
        }
      }
    };


    /**
    * Updates the scene's content.
    *
    * @method updateContent
     */

    Component_LayoutSceneBehavior.prototype.updateContent = function() {
      GameManager.update();
      return Graphics.viewport.update();
    };


    /**
    * Shows/Hides the current scene. A hidden scene is no longer shown and executed
    * but all objects and data is still there and be shown again anytime.
    *
    * @method show
    * @param {boolean} visible - Indicates if the scene should be shown or hidden.
     */

    Component_LayoutSceneBehavior.prototype.show = function(visible) {
      if (visible) {
        ResourceManager.context = this.resourceContext;
      }
      this.layout.visible = visible;
      this.layout.update();
      this.objectManager.active = visible;
      if (visible) {
        return gs.ObjectManager.current = SceneManager;
      }
    };


    /**
    * Action method which triggers a full refresh on the object returned by the specified binding-expression.
    * The params must be a direct binding-expression string.
    *
    * @method fullRefreshObject
    * @param {gs.Object_Base} sender - The sender object.
    * @param {string} params -  The binding expression.
     */

    Component_LayoutSceneBehavior.prototype.fullRefreshObject = function(sender, object) {
      object = ui.Component_FormulaHandler.fieldValue(sender, object);
      return object != null ? object.fullRefresh() : void 0;
    };


    /**
    * Action method which triggers a refresh on the object returned by the specified binding-expression.
    * The params must be a direct binding-expression string.
    *
    * @method refreshObject
    * @param {gs.Object_Base} sender - The sender object.
    * @param {string} params -  The binding expression.
     */

    Component_LayoutSceneBehavior.prototype.refreshObject = function(sender, object) {
      object = ui.Component_FormulaHandler.fieldValue(sender, object);
      return object != null ? object.needsUpdate = true : void 0;
    };

    Component_LayoutSceneBehavior.prototype.addStyle = function(sender, style) {
      var styleObject;
      styleObject = ui.UIManager.styles[style];
      if (styleObject != null) {
        styleObject.apply(sender);
      }
      sender.needsUpdate = true;
      if (styleObject != null ? styleObject.font : void 0) {
        return sender.behavior.refresh();
      }
    };

    Component_LayoutSceneBehavior.prototype.removeStyle = function(sender, style) {
      var i, len, ref, ref1, s, styleObject;
      styleObject = ui.UIManager.styles[style];
      if (styleObject != null) {
        styleObject.revert(sender);
      }
      sender.descriptor.styles.remove(style);
      ref = sender.descriptor.styles;
      for (i = 0, len = ref.length; i < len; i++) {
        s = ref[i];
        if ((ref1 = ui.UIManager.styles[s]) != null) {
          ref1.apply(sender);
        }
      }
      sender.needsUpdate = true;
      if (styleObject != null ? styleObject.font : void 0) {
        return sender.behavior.refresh();
      }
    };


    /**
    * Action method which executes the specified bindings.
    *
    * @method executeBindings
    * @param {gs.Object_Base} sender - The sender object.
    * @param {Object[]} params -  An array of binding-definitions.
     */

    Component_LayoutSceneBehavior.prototype.executeBindings = function(sender, bindings) {
      var binding, i, len;
      for (i = 0, len = bindings.length; i < len; i++) {
        binding = bindings[i];
        ui.Component_FormulaHandler.executeBinding(sender, binding);
      }
      return null;
    };


    /**
    * Action method which executes the specified formulas.
    *
    * @method executeFormulas
    * @param {gs.Object_Base} sender - The sender object.
    * @param {ui.Formula[]} params -  An array of formula-definitions.
     */

    Component_LayoutSceneBehavior.prototype.executeFormulas = function(sender, formulas) {
      var formula, i, len, results;
      results = [];
      for (i = 0, len = formulas.length; i < len; i++) {
        formula = formulas[i];
        results.push(ui.Component_FormulaHandler.executeFormula(sender, formula));
      }
      return results;
    };


    /**
    * Action method which executes an animation on a specified target game object.
    *
    * @method executeAnimation
    * @param {gs.Object_Base} sender - The sender object.
    * @param {Object} params -  Contains target-id and animations: { target, animations }
     */

    Component_LayoutSceneBehavior.prototype.executeAnimation = function(sender, params) {
      var animation, object;
      object = ui.Component_FormulaHandler.fieldValue(sender, params.target);
      animation = object != null ? object.animations.first(function(a) {
        return a.event === params.event;
      }) : void 0;
      if (animation && object) {
        return object.animationExecutor.execute(animation);
      }
    };


    /**
    * Action method which emits the specified event.
    *
    * @method emitEvent
    * @param {gs.Object_Base} sender - The sender object.
    * @param {Object} params - Contains event name, source and data.
    * <ul>
    * <li>params.name - The name of the event to emit</li>
    * <li>params.source - A binding-expression to define the game object which should emit the event.</li>
    * <li>params.data - An object containing additional event specific data.</li>
    * </ul>
     */

    Component_LayoutSceneBehavior.prototype.emitEvent = function(sender, params) {
      var object;
      object = ui.Component_FormulaHandler.fieldValue(sender, params.source);
      return object != null ? object.events.emit(params.name, object, ui.Component_FormulaHandler.fieldValue(sender, params.data)) : void 0;
    };


    /**
    * Action method which changes the game's aspect ratio.
    *
    * @method executeBindings
    * @param {gs.Object_Base} sender - The sender object.
    * @param {boolean} params -  If <b>true</b> the game screen will stretched so that it fills the entire screen
    * of the player without any black borders. Otherwise the game screen stretches but keeps its ratio
    * so black borders are possible if the game resolution's ratio and the target display's ratio are not match. It can also
    * be a binding-expression.
     */

    Component_LayoutSceneBehavior.prototype.adjustAspectRatio = function(sender, adjust) {
      adjust = ui.Component_FormulaHandler.fieldValue(sender, adjust);
      GameManager.settings.adjustAspectRatio = adjust;
      Graphics.keepRatio = !adjust;
      return Graphics.onResize();
    };


    /**
    * Action method which enters fullscreen mode.
    *
    * @method enterFullScreen
    * @param {gs.Object_Base} sender - The sender object.
    * @param {boolean} params - Can be <b>null</b>
     */

    Component_LayoutSceneBehavior.prototype.enterFullScreen = function(sender, params) {
      gs.Graphics.enterFullscreen();
      return GameManager.settings.fullScreen = Graphics.isFullscreen();
    };


    /**
    * Action method which leaves fullscreen mode.
    *
    * @method leaveFullScreen
    * @param {gs.Object_Base} sender - The sender object.
    * @param {boolean} params - Can be <b>null</b>
     */

    Component_LayoutSceneBehavior.prototype.leaveFullScreen = function() {
      gs.Graphics.leaveFullscreen();
      return GameManager.settings.fullScreen = Graphics.isFullscreen();
    };


    /**
    * Action method which toggles between window and fullscreen mode.
    *
    * @method toggleFullScreen
    * @param {gs.Object_Base} sender - The sender object.
    * @param {boolean|string} params - Can be <b>null</b>
     */

    Component_LayoutSceneBehavior.prototype.toggleFullScreen = function(sender, params) {
      if (gs.Graphics.isFullscreen()) {
        gs.Graphics.leaveFullscreen();
      } else {
        gs.Graphics.enterFullscreen();
      }
      return GameManager.settings.fullScreen = gs.Graphics.isFullscreen();
    };


    /**
    * Action method which plays the specified sound.
    *
    * @method playSound
    * @param {gs.Object_Base} sender - The sender object.
    * @param {Object} params - The sound to play.
     */

    Component_LayoutSceneBehavior.prototype.playSound = function(sender, params) {
      AudioManager.loadSound(params);
      return AudioManager.playSound(params);
    };


    /**
    * Action method which plays the specified voice.
    *
    * @method playVoice
    * @param {gs.Object_Base} sender - The sender object.
    * @param {Object} params - The voice to play.
     */

    Component_LayoutSceneBehavior.prototype.playVoice = function(sender, params) {
      AudioManager.loadSound(params);
      return AudioManager.playVoice(params);
    };


    /**
    * Action method which turns voice on or off.
    *
    * @method turnOnOffVoice
    * @param {gs.Object_Base} sender - The sender object.
    * @param {boolean|string} params - If <b>true</b> voice will be turned on. Otherwise it will be turned off. Can also be a binding-expression.
     */

    Component_LayoutSceneBehavior.prototype.turnOnOffVoice = function(sender, state) {
      if (ui.Component_FormulaHandler.fieldValue(sender, state)) {
        return this.turnOnVoice();
      } else {
        return this.turnOffVoice();
      }
    };


    /**
    * Action method which turns music on or off.
    *
    * @method turnOnOffMusic
    * @param {gs.Object_Base} sender - The sender object.
    * @param {boolean|string} params - If <b>true</b> music will be turned on. Otherwise it will be turned off. Can also be a binding-expression.
     */

    Component_LayoutSceneBehavior.prototype.turnOnOffMusic = function(sender, state) {
      if (ui.Component_FormulaHandler.fieldValue(sender, state)) {
        return this.turnOnMusic();
      } else {
        return this.turnOffMusic();
      }
    };


    /**
    * Action method which turns sound on or off.
    *
    * @method turnOnOffSound
    * @param {gs.Object_Base} sender - The sender object.
    * @param {boolean|string} params - If <b>true</b> sound will be turned on. Otherwise it will be turned off. Can also be a binding-expression.
     */

    Component_LayoutSceneBehavior.prototype.turnOnOffSound = function(sender, state) {
      if (ui.Component_FormulaHandler.fieldValue(sender, state)) {
        return this.turnOnSound();
      } else {
        return this.turnOffSound();
      }
    };


    /**
    * Action method which turns off voice.
    *
    * @method turnOffVoice
    * @param {gs.Object_Base} sender - The sender object.
    * @param {boolean|string} params - Can be <b>null</b>.
     */

    Component_LayoutSceneBehavior.prototype.turnOffVoice = function() {
      return AudioManager.stopAllVoices();
    };


    /**
    * Action method which turns off music.
    *
    * @method turnOffMusic
    * @param {gs.Object_Base} sender - The sender object.
    * @param {boolean|string} params - Can be <b>null</b>.
     */

    Component_LayoutSceneBehavior.prototype.turnOffMusic = function() {
      return AudioManager.stopMusic();
    };


    /**
    * Action method which turns off sound.
    *
    * @method turnOffSound
    * @param {gs.Object_Base} sender - The sender object.
    * @param {boolean|string} params - Can be <b>null</b>.
     */

    Component_LayoutSceneBehavior.prototype.turnOffSound = function() {
      return AudioManager.stopAllSounds();
    };


    /**
    * Action method which turns on voice.
    *
    * @method turnOnVoice
    * @param {gs.Object_Base} sender - The sender object.
    * @param {boolean|string} params - Can be <b>null</b>.
     */

    Component_LayoutSceneBehavior.prototype.turnOnVoice = function() {};


    /**
    * Action method which turns on sound.
    *
    * @method turnOnSound
    * @param {gs.Object_Base} sender - The sender object.
    * @param {boolean|string} params - Can be <b>null</b>.
     */

    Component_LayoutSceneBehavior.prototype.turnOnSound = function() {};


    /**
    * Action method which turns on music.
    *
    * @method turnOnMusic
    * @param {gs.Object_Base} sender - The sender object.
    * @param {boolean|string} params - Can be <b>null</b>.
     */

    Component_LayoutSceneBehavior.prototype.turnOnMusic = function() {
      return AudioManager.resumeMusic();
    };


    /**
    * Action method which selects the specified language.
    *
    * @method selectLanguage
    * @param {gs.Object_Base} sender - The sender object.
    * @param {number|string} params - Index of the language to set. Can be a binding-expression.
     */

    Component_LayoutSceneBehavior.prototype.selectLanguage = function(sender, params) {
      var language;
      language = LanguageManager.languages[ui.Component_FormulaHandler.fieldValue(sender, params)];
      return LanguageManager.selectLanguage(language);
    };


    /**
    * Action method which resets global data storage.
    *
    * @method resetGlobalData
    * @param {gs.Object_Base} sender - The sender object.
    * @param {Object} params - Can be <b>null</b>.
     */

    Component_LayoutSceneBehavior.prototype.resetGlobalData = function(sender) {
      return GameManager.resetGlobalData();
    };


    /**
    * Action method which saves game settings.
    *
    * @method saveSettings
    * @param {gs.Object_Base} sender - The sender object.
    * @param {Object} params - Can be <b>null</b>.
     */

    Component_LayoutSceneBehavior.prototype.saveSettings = function(sender) {
      return GameManager.saveSettings();
    };


    /**
    * Action method which prepares the game for saving by taking a snapshot of the current game state
    * and storing it in GameManager.saveGame.
    *
    * @method prepareSaveGame
    * @param {gs.Object_Base} sender - The sender object.
    * @param {Object} params - Can be <b>null</b>.
     */

    Component_LayoutSceneBehavior.prototype.prepareSaveGame = function(sender, params) {
      return GameManager.prepareSaveGame(params != null ? params.snapshot : void 0);
    };


    /**
    * Action method which saves the current game at the specified save slot.
    *
    * @method saveGame
    * @param {gs.Object_Base} sender - The sender object.
    * @param {Object} params - Contains the slot-index where the game should be saved.
    * <ul>
    * <li>params.slot - The slot-index where the game should be saved. Can be a binding-expression.</li>
    * </ul>
     */

    Component_LayoutSceneBehavior.prototype.saveGame = function(sender, params) {
      return GameManager.save(ui.Component_FormulaHandler.fieldValue(sender, params.slot));
    };


    /**
    * Action method which loads the game from the specified save slot.
    *
    * @method loadGame
    * @param {gs.Object_Base} sender - The sender object.
    * @param {Object} params - Contains the slot-index where the game should be loaded from.
    * <ul>
    * <li>params.slot - The slot-index where the game should be loaded from. Can be a binding-expression.</li>
    * </ul>
     */

    Component_LayoutSceneBehavior.prototype.loadGame = function(sender, params) {
      GameManager.tempSettings.skip = false;
      return GameManager.load(ui.Component_FormulaHandler.fieldValue(sender, params.slot));
    };


    /**
    * Action method which starts a new game.
    *
    * @method newGame
    * @param {gs.Object_Base} sender - The sender object.
    * @param {Object} params - Can be <b>null</b>
     */

    Component_LayoutSceneBehavior.prototype.newGame = function(sender, params) {
      var scene;
      AudioManager.stopAllMusic(30);
      GameManager.newGame();
      scene = new vn.Object_Scene();
      SceneManager.clear();
      return SceneManager.switchTo(scene);
    };


    /**
    * Action method which exists the current game. It doesn't change the scene and
    * should be called before switching back to the title screen or main menu.
    *
    * @method exitGame
    * @param {gs.Object_Base} sender - The sender object.
    * @param {Object} params - Can be <b>null</b>
     */

    Component_LayoutSceneBehavior.prototype.exitGame = function(sender, params) {
      return GameManager.exitGame();
    };


    /**
    * Action method which switches to another scene.
    *
    * @method switchScene
    * @param {gs.Object_Base} sender - The sender object.
    * @param {Object} params - Contains the class name of the scene to switch to.
    * <ul>
    * <li>params.name - The class-name of the scene to switch to. The class must be defined in vn-namespace.</li>
    * </ul>
     */

    Component_LayoutSceneBehavior.prototype.switchScene = function(sender, params) {
      var f;
      f = (function(_this) {
        return function() {
          var scene;
          if (params.clear) {
            SceneManager.clear();
          }
          scene = new vn[params.name]();
          return SceneManager.switchTo(scene, params.savePrevious);
        };
      })(this);
      if (!params.savePrevious) {
        return this.layout.ui.disappear((function(_this) {
          return function(e) {
            return f();
          };
        })(this));
      } else {
        return f();
      }
    };


    /**
    * Action method which switches to another game scene.
    *
    * @method switchGameScene
    * @param {gs.Object_Base} sender - The sender object.
    * @param {Object} params - Contains the UID of the scene to switch to.
    * <ul>
    * <li>params.uid - The UID of the scene to switch to.</li>
    * </ul>
     */

    Component_LayoutSceneBehavior.prototype.switchGameScene = function(sender, params) {
      var f;
      f = (function(_this) {
        return function() {
          var newScene, sceneData, sceneDocument, sceneDocuments, uid;
          if (params.clear) {
            SceneManager.clear();
          }
          uid = params.uid;
          if (params.name) {
            sceneDocuments = DataManager.getDocumentsByType("vn.scene");
            sceneDocument = sceneDocuments.first(function(d) {
              return d.items.name === params.name;
            });
            if (sceneDocument) {
              uid = sceneDocument.uid;
            }
          }
          sceneData = {
            uid: uid,
            pictures: [],
            texts: []
          };
          GameManager.sceneData = sceneData;
          newScene = new vn.Object_Scene();
          newScene.sceneData = sceneData;
          return SceneManager.switchTo(newScene, params.savePrevious);
        };
      })(this);
      if (!params.savePrevious) {
        return (this.layout || this.object.layout).ui.disappear((function(_this) {
          return function(e) {
            return f();
          };
        })(this));
      } else {
        return f();
      }
    };


    /**
    * Action method which switches to another layout.
    *
    * @method switchLayout
    * @param {gs.Object_Base} sender - The sender object.
    * @param {Object} params - Contains the name of the layout to switch to.
    * <ul>
    * <li>params.name - The name of the layout to switch to.</li>
    * <li>params.savePrevious - Indicates if the current layout should not be erased but paused and hidden instead so
    * that it can be restored using <i>returnToPrevious</i> action.</li>
    * <li>params.dataFields - Defines the data of "$dataFields" binding-expression variable. Can be a binding-expression
    * or a direct object. Optional.</li>
    * </ul>
     */

    Component_LayoutSceneBehavior.prototype.switchLayout = function(sender, layout) {
      var f;
      f = (function(_this) {
        return function() {
          var dataFields, i, len, ref, scene, senderField;
          Graphics.freeze();
          if (layout.clear) {
            SceneManager.clear();
          }
          scene = new gs.Object_Layout(layout.name);
          dataFields = sender.dataFields;
          if (typeof layout.dataFields === "string") {
            dataFields = ui.Component_FormulaHandler.fieldValue(sender, layout.dataFields);
          } else if (layout.dataFields != null) {
            dataFields = layout.dataFields;
          }
          scene.dataFields = dataFields;
          scene.controllers = layout.controllers;
          if (layout.senderData != null) {
            ref = layout.senderData;
            for (i = 0, len = ref.length; i < len; i++) {
              senderField = ref[i];
              scene[senderField] = sender[senderField];
            }
          }
          return SceneManager.switchTo(scene, layout.savePrevious, layout.stack);
        };
      })(this);
      if (!layout.savePrevious) {
        return (this.layout || this.object.layout).ui.disappear((function(_this) {
          return function(e) {
            return f();
          };
        })(this));
      } else {
        return f();
      }
    };


    /**
    * Action method which returns to previous layout. (If savePrevious was set to <b>true</b> on switchLayout.).
    *
    * @method previousLayout
    * @param {gs.Object_Base} sender - The sender object.
    * @param {Object} params - Can be <b>null</b>.
     */

    Component_LayoutSceneBehavior.prototype.previousLayout = function(sender) {
      return SceneManager.returnToPrevious();
    };


    /**
    * Action method which disposes the specified control.
    *
    * @method disposeControl
    * @param {gs.Object_Base} sender - The sender object.
    * @param {string} params - The ID of the control to dispose. Can be a binding-expression.
     */

    Component_LayoutSceneBehavior.prototype.disposeControl = function(sender, id) {
      var control;
      control = this.objectManager.objectById(ui.Component_FormulaHandler.fieldValue(sender, id));
      return control != null ? control.ui.disappear(function(sender) {
        return sender.dispose();
      }) : void 0;
    };


    /**
    * Action method which creates a new control from the specified descriptor.
    *
    * @method createControl
    * @param {gs.Object_Base} sender - The sender object.
    * @param {string} params - Contains the descriptor and other data needed to construct the control.
    * <ul>
    * <li>params.descriptor - The control' descriptor. Can be a direct descriptor definition or a template name</li>
    * <li>params.parent - A binding-expression which returns the control's parent.</li>
    * <li>params.senderData - An object containing additional data merged into the control object.</li>
    * </ul>
     */

    Component_LayoutSceneBehavior.prototype.createControl = function(sender, data) {
      var control, descriptor, fieldName, i, len, parent, ref;
      if (typeof data.descriptor === "string") {
        descriptor = ui.UIManager.customTypes[data.descriptor];
      } else {
        descriptor = data.descriptor;
      }
      parent = ui.Component_FormulaHandler.fieldValue(sender, data.parent);
      control = ui.UiFactory._createFromDescriptor(descriptor, parent != null ? parent : this.object.layout || this.object);
      if (data.senderData != null) {
        ref = data.senderData;
        for (i = 0, len = ref.length; i < len; i++) {
          fieldName = ref[i];
          control[fieldName] = sender[fieldName];
        }
      }
      control.ui.prepare();
      control.ui.appear();
      return control;
    };


    /**
    * Action method which quits the game.
    *
    * @method quitGame
    * @param {gs.Object_Base} sender - The sender object.
    * @param {string} params - Can be <b>null</b>.
     */

    Component_LayoutSceneBehavior.prototype.quitGame = function(sender, data) {
      return SceneManager.switchTo(null);
    };

    return Component_LayoutSceneBehavior;

  })(gs.Component_SceneBehavior);

  gs.Component_LayoutSceneBehavior = Component_LayoutSceneBehavior;

}).call(this);
