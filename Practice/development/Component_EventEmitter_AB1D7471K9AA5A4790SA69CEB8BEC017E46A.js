// Generated by CoffeeScript 1.12.7
(function() {
  var Component_EventEmitter,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Component_EventEmitter = (function(superClass) {
    extend(Component_EventEmitter, superClass);


    /**
    * Called if this object instance is restored from a data-bundle. It can be used
    * re-assign event-handler, anonymous functions, etc.
    *
    * @method onDataBundleRestore.
    * @param Object data - The data-bundle
    * @param gs.ObjectCodecContext context - The codec-context.
     */

    Component_EventEmitter.prototype.onDataBundleRestore = function(data, context) {
      var handler, handlers, i, j, k, l, list, ref;
      for (k in this.handlers) {
        list = this.handlers[k];
        for (i = l = 0, ref = list.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
          handlers = list[i];
          j = 0;
          while (j < handlers.length) {
            handler = handlers[j];
            if (!handler.handler || !handler.handler.$vnm_cb) {
              handlers.splice(j, 1);
            } else {
              j++;
            }
          }
        }
      }
      return null;
    };


    /**
    * A component which allow a game object to fire events and manage a list
    * of observers.
    *
    * @module gs
    * @class Component_EventEmitter
    * @extends gs.Component
    * @memberof gs
     */

    function Component_EventEmitter() {
      Component_EventEmitter.__super__.constructor.apply(this, arguments);

      /**
      * List of registered observers.
      *
      * @property handlers
      * @type Object
      * @private
       */
      this.handlers = {};

      /**
      * @property defaultData
      * @type Object
      * @private
       */
      this.defaultData = {};

      /**
      * @property chainInfo
      * @type Object
      * @private
       */
      this.chainInfo = {};

      /**
      * @property needsSort
      * @type boolean
      * @private
       */
      this.needsSort = {};

      /**
      * @property markedForRemove
      * @type Object[]
      * @private
       */
      this.markedForRemove = [];

      /**
      * @property isEmitting
      * @type number
      * @private
       */
      this.isEmitting = 0;
    }


    /**
    * Clears the event emitter by removing all handlers/listeners.
    *
    * @method clear
     */

    Component_EventEmitter.prototype.clear = function() {
      this.needsSort = {};
      this.handlers = {};
      return this.defaultData = {};
    };


    /**
    * Clears the event emitter by removing all handlers/listeners except those
    * which are associated with an owner in the specified owners array.
    *
    * @method clearExcept
    * @param {Object[]} owners - An array of owner objects. Only handlers/listeners which are not
    * associated with that owners are removed.
     */

    Component_EventEmitter.prototype.clearExcept = function(owners) {
      var event, events, handlerList, handlers, i, l, len, results;
      this.needsSort = {};
      this.defaultData = {};
      events = Object.keys(this.handlers);
      results = [];
      for (l = 0, len = events.length; l < len; l++) {
        event = events[l];
        handlers = this.handlers[event];
        results.push((function() {
          var len1, m, results1;
          results1 = [];
          for (i = m = 0, len1 = handlers.length; m < len1; i = ++m) {
            handlerList = handlers[i];
            handlerList = handlerList.filter(function(h) {
              return owners.indexOf(h.owner) !== 1;
            });
            results1.push(handlers[i] = handlerList);
          }
          return results1;
        })());
      }
      return results;
    };


    /**
    * Adds a new observer/listener for a specified event.
    *
    * @method on
    * @param {string} eventName - The event name.
    * @param {function} handler - The handler-function called when the event is fired.
    * @param {Object} [data={}] - An optional info-object passed to the handler-function.
    * @param {Object} [owner=null] - An optional owner-object associated with the observer/listener.
    * @param {number} priority - An optional priority level. An observer/listener with a higher level will receive the event before observers/listeners with a lower level.
    * @return {gs.EventObserver} - The added observer-object.
     */

    Component_EventEmitter.prototype.on = function(eventName, handler, data, owner, priority) {
      var handlerObject;
      priority = priority || 0;
      this.needsSort[eventName] = true;
      if (this.handlers[eventName] == null) {
        this.handlers[eventName] = [];
      }
      if (!this.handlers[eventName][priority]) {
        this.handlers[eventName][priority] = [];
      }
      handlerObject = {
        handler: handler,
        once: false,
        data: data,
        owner: owner,
        eventName: eventName,
        priority: priority
      };
      this.handlers[eventName][priority].push(handlerObject);
      return handlerObject;
    };


    /**
    * Adds a new observer/listener for a specified event and removes it
    * after the even has been emitted once.
    *
    * @method once
    * @param {string} eventName - The event name.
    * @param {function} handler - The handler-function called when the event is fired.
    * @param {Object} [data={}] - An optional info-object passed to the handler-function.
    * @param {Object} [owner=null] - An optional owner-object associated with the observer/listener.
    * @param {number} priority - An optional priority level. An observer/listener with a higher level will receive the event before observers/listeners with a lower level.
    * @return {gs.EventObserver} - The added observer-object.
     */

    Component_EventEmitter.prototype.once = function(eventName, handler, data, owner, priority) {
      var handlerObject;
      handlerObject = this.on(eventName, handler, data, owner, priority);
      handlerObject.once = true;
      return handlerObject;
    };


    /**
    * Removes an observer/listener from a specified event. If handler parameter
    * is null, all observers for the specified event are removed.
    *
    * @method off
    * @param {string} eventName - The event name.
    * @param {gs.EventObserver} [handler=null] - The observer-object to remove.
    * If null, all observers for the specified event are removed.
     */

    Component_EventEmitter.prototype.off = function(eventName, handler) {
      var ref, ref1;
      if (this.isEmitting > 0 && handler) {
        return this.markedForRemove.push(handler);
      } else if (handler != null) {
        return (ref = this.handlers[eventName]) != null ? (ref1 = ref[handler.priority]) != null ? ref1.remove(handler) : void 0 : void 0;
      } else {
        return this.handlers[eventName] = [];
      }
    };


    /**
    * Removes all observers/listeners from an event which are belonging to the specified
    * owner.
    *
    * @method offByOwner
    * @param {string} eventName - The event name.
    * @param {Object} owner - The owner.
    * @return {number} Count of removed observers/listeners.
     */

    Component_EventEmitter.prototype.offByOwner = function(eventName, owner) {
      var handler, handlerList, handlers, l, len, len1, m, ref, ref1, results, results1;
      if (this.handlers[eventName]) {
        if (this.isEmitting > 0) {
          ref = this.handlers[eventName];
          results = [];
          for (l = 0, len = ref.length; l < len; l++) {
            handlerList = ref[l];
            handlers = handlerList != null ? handlerList.where(function(x) {
              return x.owner === owner;
            }) : void 0;
            results.push((function() {
              var len1, m, results1;
              results1 = [];
              for (m = 0, len1 = handlers.length; m < len1; m++) {
                handler = handlers[m];
                results1.push(this.markedForRemove.push(handler));
              }
              return results1;
            }).call(this));
          }
          return results;
        } else {
          ref1 = this.handlers[eventName];
          results1 = [];
          for (m = 0, len1 = ref1.length; m < len1; m++) {
            handlerList = ref1[m];
            results1.push(handlerList.removeAll(function(x) {
              return x.owner === owner;
            }));
          }
          return results1;
        }
      }
    };


    /**
    * Emits the specified event. All observers/listeners registered for the
    * specified event are informed.
    *
    * @method emit
    * @param {string} eventName - The name of the event to fire.
    * @param {Object} [sender=null] - The sender of the event.
    * @param {Object} [data={}] - An optional object passed to each handler-function.
     */

    Component_EventEmitter.prototype.emit = function(eventName, sender, data) {
      var breakOwner, count, handler, handlerList, handlerLists, i, l, len, len1, m, n, ref;
      handlerLists = this.handlers[eventName];
      data = data != null ? data : {};
      if (handlerLists && this.needsSort[eventName]) {
        this.needsSort[eventName] = false;
        for (l = 0, len = handlerLists.length; l < len; l++) {
          handlerList = handlerLists[l];
          handlerList.sort(function(a, b) {
            if (a.owner && b.owner) {
              if (a.owner.rIndex > b.owner.rIndex) {
                return -1;
              } else if (a.owner.rIndex < b.owner.rIndex) {
                return 1;
              } else {
                return 0;
              }
            } else {
              return -1;
            }
          });
        }
      }
      if (handlerLists != null) {
        breakOwner = null;
        for (m = handlerLists.length - 1; m >= 0; m += -1) {
          handlerList = handlerLists[m];
          if (!handlerList) {
            continue;
          }
          i = 0;
          count = handlerList.length;
          this.isEmitting++;
          while (i < count) {
            handler = handlerList[i];
            data.handler = handler;
            data.sender = sender;
            data.data = handler.data;
            if ((!breakOwner && (!handler.owner || (handler.owner.visible == null) || handler.owner.visible)) || breakOwner === handler.owner) {
              handler.handler(data);
            }
            if (handler.once) {
              this.markedForRemove.push(handler);
            }
            if (data.breakChain) {
              breakOwner = handler.owner;
            }
            i++;
          }
          this.isEmitting--;
          if (data.breakChain) {
            data.breakChain = false;
            break;
          }
        }
        if (!this.isEmitting && this.markedForRemove.length > 0) {
          ref = this.markedForRemove;
          for (n = 0, len1 = ref.length; n < len1; n++) {
            handler = ref[n];
            this.handlers[handler.eventName][handler.priority].remove(handler);
          }
          this.markedForRemove = [];
        }
      }
      return null;
    };


    /**
    * Checks if an event-handler with a specified owner exists for the
    * given event.
    *
    * @method checkForOwner
    * @param {string} eventName - The event name.
    * @param {function} owner - The owner to search for.
    * @return {boolean} If <b>true</b>, an event-handler with the specified owner
    * exists for the given event. Otherwise <b>false</b>.
     */

    Component_EventEmitter.prototype.checkForOwner = function(eventName, owner) {
      var handler, l, len, ref, result;
      result = false;
      ref = this.handlers[eventName];
      for (l = 0, len = ref.length; l < len; l++) {
        handler = ref[l];
        if (handler.owner === owner) {
          result = true;
          break;
        }
      }
      return result;
    };


    /**
    * Checks if an event-handler with a specified handler-function exists for the
    * given event.
    *
    * @method checkForHandlerFunction
    * @param {string} eventName - The event name.
    * @param {function} handlerFunction - The handler-function to search for.
    * @return {boolean} If true, an observer witht he specified handler-function
    * exists for the given event. Otherwise false.
     */

    Component_EventEmitter.prototype.checkForHandlerFunction = function(eventName, handlerFunction) {
      var handler, l, len, ref, result;
      result = false;
      if (handlerFunction != null) {
        ref = this.handlers[eventName];
        for (l = 0, len = ref.length; l < len; l++) {
          handler = ref[l];
          if (handler.handler === handlerFunction) {
            result = true;
            break;
          }
        }
      }
      return result;
    };


    /**
    * Not implemented yet.
    * @method update
     */

    Component_EventEmitter.prototype.update = function() {
      return this.object.active = this.object.active && (!this.object.parent || this.object.parent.active);
    };

    return Component_EventEmitter;

  })(gs.Component);

  gs.Component_EventEmitter = Component_EventEmitter;

  gs.EventEmitter = Component_EventEmitter;

  gs.GlobalEventManager = new Component_EventEmitter();

}).call(this);
