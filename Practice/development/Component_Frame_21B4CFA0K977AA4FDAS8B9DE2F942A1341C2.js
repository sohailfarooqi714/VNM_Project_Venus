// Generated by CoffeeScript 1.12.7
(function() {
  var Component_Frame,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Component_Frame = (function(superClass) {
    extend(Component_Frame, superClass);


    /**
    * Called if this object instance is restored from a data-bundle. It can be used
    * re-assign event-handler, anonymous functions, etc.
    * 
    * @method onDataBundleRestore.
    * @param Object data - The data-bundle
    * @param gs.ObjectCodecContext context - The codec-context.
     */

    Component_Frame.prototype.onDataBundleRestore = function(data, context) {
      return this.setupEventHandlers();
    };


    /**
    * A frame constructs a graphical frame from its skin-image. The frame can
    * rendered by tiling or strechting the four sides of the frame. A frame
    * is useful for creating In-Game UI windows and boxes. For more info about 
    * the skin-image format, see help-file.
    * 
    * @module gs
    * @class Component_Frame
    * @extends gs.Component_Visual
    * @memberof gs
    * @constructor
    * @param {gs.Viewport} viewport An optional native viewport object.
     */

    function Component_Frame(viewport) {
      Component_Frame.__super__.constructor.call(this);

      /**
      * The native frame-object.
      * @property frame
      * @type gs.Frame
       */
      this.frame = new gs.Frame(viewport != null ? viewport : Graphics.viewport);

      /**
      * The name of the skin-image used to construct the frame.
      * @property image
      * @type string
      * @protected
       */
      this.image = null;
    }


    /**
    * Disposes the frame.
    * 
    * @method dispose
     */

    Component_Frame.prototype.dispose = function() {
      Component_Frame.__super__.dispose.apply(this, arguments);
      return this.frame.dispose();
    };


    /**
    * Adds event-handlers for mouse/touch events
    *
    * @method setupEventHandlers
     */

    Component_Frame.prototype.setupEventHandlers = function() {
      return this.frame.onIndexChange = (function(_this) {
        return function() {
          return _this.object.rIndex = _this.frame.index;
        };
      })(this);
    };


    /**
    * Setup the frame component. This method is automatically called by the
    * system.
    * @method setup
     */

    Component_Frame.prototype.setup = function() {
      return this.setupEventHandlers();
    };


    /**
    * Updates the padding.
    * 
    * @method updatePadding
     */

    Component_Frame.prototype.updatePadding = function() {
      if (this.object.padding != null) {
        this.frame.x += this.object.padding.left;
        this.frame.y += this.object.padding.top;
        this.frame.width -= this.object.padding.left + this.object.padding.right;
        return this.frame.height -= this.object.padding.top + this.object.padding.bottom;
      }
    };


    /**
    * Updates the frame properties from the game object properties.
    *
    * @method updateProperties
     */

    Component_Frame.prototype.updateProperties = function() {
      this.frame.x = this.object.dstRect.x;
      this.frame.y = this.object.dstRect.y;
      this.frame.width = this.object.dstRect.width;
      this.frame.height = this.object.dstRect.height;
      this.frame.thickness = this.object.frameThickness || 16;
      this.frame.cornerSize = this.object.frameCornerSize || 16;
      this.frame.clipRect = this.object.clipRect;
      this.frame.visible = this.object.visible;
      this.frame.ox = -this.object.origin.x;
      this.frame.oy = -this.object.origin.y;
      this.frame.zoomX = this.object.zoom.x;
      this.frame.zoomY = this.object.zoom.y;
      this.frame.angle = this.object.angle || 0;
      this.frame.opacity = this.object.opacity;
      return this.frame.z = (this.object.zIndex || 0) + (!this.object.parent ? 0 : this.object.parent.zIndex || 0);
    };


    /**
    * Updates the optional sprite properties from the game object properties.
    * @method updateOptionalProperties
     */

    Component_Frame.prototype.updateOptionalProperties = function() {
      if (this.object.tone != null) {
        this.frame.tone = this.object.tone;
      }
      if (this.object.color != null) {
        this.frame.color = this.object.color;
      }
      if (this.object.viewport != null) {
        this.frame.viewport = this.object.viewport;
      }
      if (this.object.effects != null) {
        this.frame.wobble = this.object.effects.wobble;
      }
      if (this.object.anchor != null) {
        this.frame.anchor.x = this.object.anchor.x;
        return this.frame.anchor.y = this.object.anchor.y;
      }
    };


    /**
    * Updates the frame's skin-image used to construct the frame.
    *
    * @method updateImage
     */

    Component_Frame.prototype.updateImage = function() {
      var bitmap;
      if ((this.object.image != null) && this.image !== this.object.image) {
        this.image = this.object.image;
        bitmap = ResourceManager.getBitmap((this.object.imageFolder || "Graphics/Pictures") + "/" + this.object.image);
        return this.frame.skin = bitmap;
      }
    };


    /**
    * Updates the frame's padding, properties and skin-image.
    * 
    * @method update
     */

    Component_Frame.prototype.update = function() {
      Component_Frame.__super__.update.apply(this, arguments);
      this.object.rIndex = this.frame.index;
      this.updateProperties();
      this.updateOptionalProperties();
      this.updatePadding();
      return this.updateImage();
    };

    return Component_Frame;

  })(gs.Component_Visual);

  gs.Component_Frame = Component_Frame;

}).call(this);
