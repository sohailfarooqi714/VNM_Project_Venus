// Generated by CoffeeScript 1.12.7
(function() {
  var Component_CommandInterpreter, InterpreterContext, LivePreviewInfo,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  LivePreviewInfo = (function() {

    /**
    * Stores internal preview-info if the game runs currently in Live-Preview.
    *
    * @module gs
    * @class LivePreviewInfo
    * @memberof gs
     */
    function LivePreviewInfo() {

      /**
      * Timer ID if a timeout for live-preview was configured to exit the game loop after a certain amount of time.
      * @property timeout
      * @type number
       */
      this.timeout = null;

      /**
      * Indicates if Live-Preview is currently waiting for the next user-action. (Selecting another command, etc.)
      * @property waiting
      * @type boolean
       */
      this.waiting = false;

      /**
      * Counts the amount of executed commands since the last
      * interpreter-pause(waiting, etc.). If its more than 500, the interpreter will automatically pause for 1 frame to
      * avoid that Live-Preview freezes the Editor in case of endless loops.
      * @property executedCommands
      * @type number
       */
      this.executedCommands = 0;

      /**
      * Indicates that the command to skip to has not been found.
      * @property commandNotFound
      * @type boolean
       */
      this.commandNotFound = false;
    }

    return LivePreviewInfo;

  })();

  gs.LivePreviewInfo = LivePreviewInfo;

  InterpreterContext = (function() {
    InterpreterContext.objectCodecBlackList = ["owner"];


    /**
    * Describes an interpreter-context which holds information about
    * the interpreter's owner and also unique ID used for accessing correct
    * local variables.
    *
    * @module gs
    * @class InterpreterContext
    * @memberof gs
    * @param {number|string} id - A unique ID
    * @param {Object} owner - The owner of the interpreter
     */

    function InterpreterContext(id, owner) {

      /**
      * A unique numeric or textual ID used for accessing correct local variables.
      * @property id
      * @type number|string
       */
      this.id = id;

      /**
      * The owner of the interpreter (e.g. current scene, etc.).
      * @property owner
      * @type Object
       */
      this.owner = owner;
    }


    /**
    * Sets the context's data.
    * @param {number|string} id - A unique ID
    * @param {Object} owner - The owner of the interpreter
    * @method set
     */

    InterpreterContext.prototype.set = function(id, owner) {
      this.id = id;
      return this.owner = owner;
    };

    return InterpreterContext;

  })();

  gs.InterpreterContext = InterpreterContext;

  Component_CommandInterpreter = (function(superClass) {
    extend(Component_CommandInterpreter, superClass);

    Component_CommandInterpreter.objectCodecBlackList = ["object", "command", "onMessageADVWaiting", "onMessageADVDisappear", "onMessageADVFinish"];


    /**
    * Called if this object instance is restored from a data-bundle. It can be used
    * re-assign event-handler, anonymous functions, etc.
    *
    * @method onDataBundleRestore.
    * @param Object data - The data-bundle
    * @param gs.ObjectCodecContext context - The codec-context.
     */

    Component_CommandInterpreter.prototype.onDataBundleRestore = function(data, context) {};


    /**
    * A component which allows a game object to process commands like for
    * scene-objects. For each command a command-function exists. To add
    * own custom commands to the interpreter just create a sub-class and
    * override the gs.Component_CommandInterpreter.assignCommand method
    * and assign the command-function for your custom-command.
    *
    * @module gs
    * @class Component_CommandInterpreter
    * @extends gs.Component
    * @memberof gs
     */

    function Component_CommandInterpreter() {
      Component_CommandInterpreter.__super__.constructor.call(this);

      /**
      * Wait-Counter in frames. If greater than 0, the interpreter will for that amount of frames before continue.
      * @property waitCounter
      * @type number
       */
      this.waitCounter = 0;

      /**
      * Index to the next command to execute.
      * @property pointer
      * @type number
       */
      this.pointer = 0;

      /**
      * Stores states of conditions.
      * @property conditions
      * @type number
      * @protected
       */
      this.conditions = [];

      /**
      * Stores states of loops.
      * @property loops
      * @type number
      * @protected
       */
      this.loops = [];
      this.timers = [];

      /**
      * Indicates if the interpreter is currently running.
      * @property isRunning
      * @type boolean
      * @readOnly
       */
      this.isRunning = false;

      /**
      * Indicates if the interpreter is currently waiting.
      * @property isWaiting
      * @type boolean
       */
      this.isWaiting = false;

      /**
      * Indicates if the interpreter is currently waiting until a message processed by another context like a Common Event
      * is finished.
      * FIXME: Conflict handling can be removed maybe.
      * @property isWaitingForMessage
      * @type boolean
       */
      this.isWaitingForMessage = false;

      /**
      * Stores internal preview-info if the game runs currently in Live-Preview.
      * <ul>
      * <li>previewInfo.timeout - Timer ID if a timeout for live-preview was configured to exit the game loop after a certain amount of time.</li>
      * <li>previewInfo.waiting - Indicates if Live-Preview is currently waiting for the next user-action. (Selecting another command, etc.)</li>
      * <li>previewInfo.executedCommands - Counts the amount of executed commands since the last
      * interpreter-pause(waiting, etc.). If its more than 500, the interpreter will automatically pause for 1 frame to
      * avoid that Live-Preview freezes the Editor in case of endless loops.</li>
      * </ul>
      * @property previewInfo
      * @type boolean
      * @protected
       */
      this.previewInfo = new gs.LivePreviewInfo();

      /**
      * Stores Live-Preview related info passed from the VN Maker editor like the command-index the player clicked on, etc.
      * @property previewData
      * @type Object
      * @protected
       */
      this.previewData = null;

      /**
      * Indicates if the interpreter automatically repeats execution after the last command was executed.
      * @property repeat
      * @type boolean
       */
      this.repeat = false;

      /**
      * The execution context of the interpreter.
      * @property context
      * @type gs.InterpreterContext
      * @protected
       */
      this.context = new gs.InterpreterContext(0, null);

      /**
      * Sub-Interpreter from a Common Event Call. The interpreter will wait until the sub-interpreter is done and set back to
      * <b>null</b>.
      * @property subInterpreter
      * @type gs.Component_CommandInterpreter
      * @protected
       */
      this.subInterpreter = null;

      /**
      * Current indent-level of execution
      * @property indent
      * @type number
      * @protected
       */
      this.indent = 0;

      /**
      * Stores information about for what the interpreter is currently waiting for like for a ADV message, etc. to
      * restore probably when loaded from a save-game.
      * @property waitingFor
      * @type Object
      * @protected
       */
      this.waitingFor = {};

      /**
      * Stores interpreter related settings like how to handle messages, etc.
      * @property settings
      * @type Object
      * @protected
       */
      this.settings = {
        message: {
          byId: {},
          autoErase: true,
          waitAtEnd: true,
          backlog: true
        },
        screen: {
          pan: new gs.Point(0, 0)
        }
      };

      /**
      * Mapping table to quickly get the anchor point for the an inserted anchor-point constant such as
      * Top-Left(0), Top(1), Top-Right(2) and so on.
      * @property graphicAnchorPointsByConstant
      * @type gs.Point[]
      * @protected
       */
      this.graphicAnchorPointsByConstant = [new gs.Point(0.0, 0.0), new gs.Point(0.5, 0.0), new gs.Point(1.0, 0.0), new gs.Point(1.0, 0.5), new gs.Point(1.0, 1.0), new gs.Point(0.5, 1.0), new gs.Point(0.0, 1.0), new gs.Point(0.0, 0.5), new gs.Point(0.5, 0.5)];
    }

    Component_CommandInterpreter.prototype.onHotspotClick = function(e, data) {
      return this.executeAction(data.params.actions.onClick, false, data.bindValue);
    };

    Component_CommandInterpreter.prototype.onHotspotEnter = function(e, data) {
      return this.executeAction(data.params.actions.onEnter, true, data.bindValue);
    };

    Component_CommandInterpreter.prototype.onHotspotLeave = function(e, data) {
      return this.executeAction(data.params.actions.onLeave, false, data.bindValue);
    };

    Component_CommandInterpreter.prototype.onHotspotDragStart = function(e, data) {
      return this.executeAction(data.params.actions.onDrag, true, data.bindValue);
    };

    Component_CommandInterpreter.prototype.onHotspotDrag = function(e, data) {
      return this.executeAction(data.params.actions.onDrag, true, data.bindValue);
    };

    Component_CommandInterpreter.prototype.onHotspotDragEnd = function(e, data) {
      return this.executeAction(data.params.actions.onDrag, false, data.bindValue);
    };

    Component_CommandInterpreter.prototype.onHotspotDrop = function(e, data) {
      this.executeAction(data.params.actions.onDrop, false, data.bindValue);
      return gs.GlobalEventManager.emit("hotspotDrop", e.sender);
    };

    Component_CommandInterpreter.prototype.onHotspotDropReceived = function(e, data) {
      return this.executeAction(data.params.actions.onDropReceive, true, data.bindValue);
    };

    Component_CommandInterpreter.prototype.onHotspotStateChanged = function(e, params) {
      if (e.sender.behavior.selected) {
        return this.executeAction(params.actions.onSelect, true);
      } else {
        return this.executeAction(params.actions.onDeselect, false);
      }
    };


    /**
    * Called when a ADV message finished rendering and is now waiting
    * for the user/autom-message timer to proceed.
    *
    * @method onMessageADVWaiting
    * @return {Object} Event Object containing additional data.
    * @protected
     */

    Component_CommandInterpreter.prototype.onMessageADVWaiting = function(e) {
      var messageObject;
      messageObject = e.sender.object;
      if (!this.messageSettings().waitAtEnd) {
        if (e.data.params.waitForCompletion) {
          this.isWaiting = false;
        }
        messageObject.textRenderer.isWaiting = false;
        messageObject.textRenderer.isRunning = false;
      }
      messageObject.events.off("waiting", e.handler);
      if (this.messageSettings().backlog && (messageObject.settings.autoErase || messageObject.settings.paragraphSpacing > 0)) {
        return GameManager.backlog.push({
          character: messageObject.character,
          message: messageObject.behavior.message,
          choices: []
        });
      }
    };


    /**
    * Called when an ADV message finished fade-out.
    *
    * @method onMessageADVDisappear
    * @return {Object} Event Object containing additional data.
    * @protected
     */

    Component_CommandInterpreter.prototype.onMessageADVDisappear = function(messageObject, waitForCompletion) {
      SceneManager.scene.currentCharacter = {
        name: ""
      };
      messageObject.behavior.clear();
      messageObject.visible = false;
      if (messageObject.waitForCompletion) {
        this.isWaiting = false;
      }
      return this.waitingFor.messageADV = null;
    };


    /**
    * Called when an ADV message finished clear.
    *
    * @method onMessageADVClear
    * @return {Object} Event Object containing additional data.
    * @protected
     */

    Component_CommandInterpreter.prototype.onMessageADVClear = function(messageObject, waitForCompletion) {
      messageObject = this.targetMessage();
      if (this.messageSettings().backlog) {
        GameManager.backlog.push({
          character: messageObject.character,
          message: messageObject.behavior.message,
          choices: []
        });
      }
      return this.onMessageADVDisappear(messageObject, waitForCompletion);
    };


    /**
    * Called when a hotspot/image-map sends a "jumpTo" event to let the
    * interpreter jump to the position defined in the event object.
    *
    * @method onJumpTo
    * @return {Object} Event Object containing additional data.
    * @protected
     */

    Component_CommandInterpreter.prototype.onJumpTo = function(e) {
      this.jumpToLabel(e.label);
      return this.isWaiting = false;
    };


    /**
    * Called when a hotspot/image-map sends a "callCommonEvent" event to let the
    * interpreter call the common event defined in the event object.
    *
    * @method onJumpTo
    * @return {Object} Event Object containing additional data.
    * @protected
     */

    Component_CommandInterpreter.prototype.onCallCommonEvent = function(e) {
      var event, eventId, ref;
      eventId = e.commonEventId;
      event = RecordManager.commonEvents[eventId];
      if (!event) {
        event = RecordManager.commonEvents.first((function(_this) {
          return function(x) {
            return x.name === eventId;
          };
        })(this));
        if (event) {
          eventId = event.index;
        }
      }
      this.callCommonEvent(eventId, e.params || [], !e.finish);
      return this.isWaiting = (ref = e.waiting) != null ? ref : false;
    };


    /**
    * Called when a ADV message finishes.
    *
    * @method onMessageADVFinish
    * @return {Object} Event Object containing additional data.
    * @protected
     */

    Component_CommandInterpreter.prototype.onMessageADVFinish = function(e) {
      var commands, duration, fading, messageObject, pointer;
      messageObject = e.sender.object;
      if (!this.messageSettings().waitAtEnd) {
        return;
      }
      GameManager.globalData.messages[lcsm(e.data.params.message)] = {
        read: true
      };
      GameManager.saveGlobalData();
      if (e.data.params.waitForCompletion) {
        this.isWaiting = false;
      }
      this.waitingFor.messageADV = null;
      pointer = this.pointer;
      commands = this.object.commands;
      messageObject.events.off("finish", e.handler);
      if ((messageObject.voice != null) && GameManager.settings.skipVoiceOnAction) {
        AudioManager.stopSound(messageObject.voice.name);
      }
      if (!this.isMessageCommand(pointer, commands) && this.messageSettings().autoErase) {
        this.isWaiting = true;
        this.waitingFor.messageADV = e.data.params;
        fading = GameManager.tempSettings.messageFading;
        duration = GameManager.tempSettings.skip ? 0 : fading.duration;
        messageObject.waitForCompletion = e.data.params.waitForCompletion;
        return messageObject.animator.disappear(fading.animation, fading.easing, duration, gs.CallBack("onMessageADVDisappear", this, e.data.params.waitForCompletion));
      }
    };


    /**
    * Called when a common event finished execution. In most cases, the interpreter
    * will stop waiting and continue processing after this. But h
    *
    * @method onCommonEventFinish
    * @return {Object} Event Object containing additional data.
    * @protected
     */

    Component_CommandInterpreter.prototype.onCommonEventFinish = function(e) {
      var ref;
      SceneManager.scene.commonEventContainer.removeObject(e.sender.object);
      e.sender.object.events.off("finish");
      this.subInterpreter = null;
      return this.isWaiting = (ref = e.data.waiting) != null ? ref : false;
    };


    /**
    * Called when a scene call finished execution.
    *
    * @method onCallSceneFinish
    * @param {Object} sender - The sender of this event.
    * @protected
     */

    Component_CommandInterpreter.prototype.onCallSceneFinish = function(sender) {
      this.isWaiting = false;
      return this.subInterpreter = null;
    };


    /**
    * Serializes the interpreter into a data-bundle.
    *
    * @method toDataBundle
    * @return {Object} The data-bundle.
     */

    Component_CommandInterpreter.prototype.toDataBundle = function() {
      if (this.isInputDataCommand(Math.max(this.pointer - 1, 0), this.object.commands)) {
        return {
          pointer: Math.max(this.pointer - 1, 0),
          choice: this.choice,
          conditions: this.conditions,
          loops: this.loops,
          labels: this.labels,
          isWaiting: false,
          isRunning: this.isRunning,
          waitCounter: this.waitCounter,
          waitingFor: this.waitingFor,
          indent: this.indent,
          settings: this.settings
        };
      } else {
        return {
          pointer: this.pointer,
          choice: this.choice,
          conditions: this.conditions,
          loops: this.loops,
          labels: this.labels,
          isWaiting: this.isWaiting,
          isRunning: this.isRunning,
          waitCounter: this.waitCounter,
          waitingFor: this.waitingFor,
          indent: this.indent,
          settings: this.settings
        };
      }
    };


    /**
     * Previews the current scene at the specified pointer. This method is called from the
     * VN Maker Scene-Editor if live-preview is enabled and the user clicked on a command.
     *
     * @method preview
     */

    Component_CommandInterpreter.prototype.preview = function() {
      var ex, scene;
      try {
        if (!$PARAMS.preview || !$PARAMS.preview.scene) {
          return;
        }
        AudioManager.stopAllSounds();
        AudioManager.stopAllMusic();
        AudioManager.stopAllVoices();
        SceneManager.scene.choices = [];
        GameManager.setupCursor();
        this.previewData = $PARAMS.preview;
        gs.GlobalEventManager.emit("previewRestart");
        if (this.previewInfo.timeout) {
          clearTimeout(this.previewInfo.timeout);
        }
        if (Graphics.stopped) {
          Graphics.stopped = false;
          Graphics.onEachFrame(gs.Main.frameCallback);
        }
        scene = new vn.Object_Scene();
        scene.sceneData.uid = this.previewData.scene.uid;
        return SceneManager.switchTo(scene);
      } catch (error) {
        ex = error;
        return console.warn(ex);
      }
    };


    /**
     * Sets up the interpreter.
     *
     * @method setup
     */

    Component_CommandInterpreter.prototype.setup = function() {
      Component_CommandInterpreter.__super__.setup.apply(this, arguments);
      this.previewData = $PARAMS.preview;
      if (this.previewData) {
        return gs.GlobalEventManager.on("mouseDown", ((function(_this) {
          return function() {
            if (_this.previewInfo.waiting) {
              if (_this.previewInfo.timeout) {
                clearTimeout(_this.previewInfo.timeout);
              }
              _this.previewInfo.waiting = false;
              GameManager.tempSettings.skip = false;
              _this.previewData = null;
              return gs.GlobalEventManager.emit("previewRestart");
            }
          };
        })(this)), null, this.object);
      }
    };


    /**
     * Disposes the interpreter.
     *
     * @method dispose
     */

    Component_CommandInterpreter.prototype.dispose = function() {
      if (this.previewData) {
        gs.GlobalEventManager.offByOwner("mouseDown", this.object);
      }
      return Component_CommandInterpreter.__super__.dispose.apply(this, arguments);
    };

    Component_CommandInterpreter.prototype.isInstantSkip = function() {
      return GameManager.tempSettings.skip && GameManager.tempSettings.skipTime === 0;
    };


    /**
    * Restores the interpreter from a data-bundle
    *
    * @method restore
    * @param {Object} bundle- The data-bundle.
     */

    Component_CommandInterpreter.prototype.restore = function() {};


    /**
    * Gets the default game message for novel-mode.
    *
    * @method messageObjectNVL
    * @return {ui.Object_Message} The NVL game message object.
     */

    Component_CommandInterpreter.prototype.messageObjectNVL = function() {
      return gs.ObjectManager.current.objectById("nvlGameMessage_message");
    };


    /**
    * Gets the default game message for adventure-mode.
    *
    * @method messageObjectADV
    * @return {ui.Object_Message} The ADV game message object.
     */

    Component_CommandInterpreter.prototype.messageObjectADV = function() {
      return gs.ObjectManager.current.objectById("gameMessage_message");
    };


    /**
    * Starts the interpreter
    *
    * @method start
     */

    Component_CommandInterpreter.prototype.start = function() {
      this.conditions = [];
      this.loops = [];
      this.indent = 0;
      this.pointer = 0;
      this.isRunning = true;
      this.isWaiting = false;
      this.subInterpreter = null;
      return this.waitCounter = 0;
    };


    /**
    * Stops the interpreter
    *
    * @method stop
     */

    Component_CommandInterpreter.prototype.stop = function() {
      return this.isRunning = false;
    };


    /**
    * Resumes the interpreter
    *
    * @method resume
     */

    Component_CommandInterpreter.prototype.resume = function() {
      return this.isRunning = true;
    };


    /**
    * Updates the interpreter and executes all commands until the next wait is
    * triggered by a command. So in the case of an endless-loop the method will
    * never return.
    *
    * @method update
     */

    Component_CommandInterpreter.prototype.update = function() {
      if (this.subInterpreter != null) {
        this.subInterpreter.update();
        return;
      }
      GameManager.variableStore.setupTempVariables(this.context);
      if (((this.object.commands == null) || this.pointer >= this.object.commands.length) && !this.isWaiting) {
        if (this.repeat) {
          this.start();
        } else if (this.isRunning) {
          this.isRunning = false;
          if (this.onFinish != null) {
            this.onFinish(this);
          }
          return;
        }
      }
      if (!this.isRunning) {
        return;
      }
      if (!this.object.commands.optimized) {
        DataOptimizer.optimizeEventCommands(this.object.commands);
      }
      if (this.waitCounter > 0) {
        this.waitCounter--;
        this.isWaiting = this.waitCounter > 0;
        return;
      }
      if (this.isWaitingForMessage) {
        this.isWaiting = true;
        if (!this.isProcessingMessageInOtherContext()) {
          this.isWaiting = false;
          this.isWaitingForMessage = false;
        } else {
          return;
        }
      }
      if (GameManager.inLivePreview) {
        while (!(this.isWaiting || this.previewInfo.waiting) && this.pointer < this.object.commands.length && this.isRunning) {
          this.executeCommand(this.pointer);
          this.previewInfo.executedCommands++;
          if (this.previewInfo.executedCommands > 500) {
            this.previewInfo.executedCommands = 0;
            this.isWaiting = true;
            this.waitCounter = 1;
          }
        }
      } else {
        while (!(this.isWaiting || this.previewInfo.waiting) && this.pointer < this.object.commands.length && this.isRunning) {
          this.executeCommand(this.pointer);
        }
      }
      if (this.pointer >= this.object.commands.length && !this.isWaiting) {
        if (this.repeat) {
          return this.start();
        } else if (this.isRunning) {
          this.isRunning = false;
          if (this.onFinish != null) {
            return this.onFinish(this);
          }
        }
      }
    };


    /**
    * Assigns the correct command-function to the specified command-object if
    * necessary.
    *
    * @method assignCommand
     */

    Component_CommandInterpreter.prototype.assignCommand = function(command) {
      switch (command.id) {
        case "gs.Idle":
          return command.execute = this.commandIdle;
        case "gs.StartTimer":
          return command.execute = this.commandStartTimer;
        case "gs.PauseTimer":
          return command.execute = this.commandPauseTimer;
        case "gs.ResumeTimer":
          return command.execute = this.commandResumeTimer;
        case "gs.StopTimer":
          return command.execute = this.commandStopTimer;
        case "gs.WaitCommand":
          return command.execute = this.commandWait;
        case "gs.LoopCommand":
          return command.execute = this.commandLoop;
        case "gs.BreakLoopCommand":
          return command.execute = this.commandBreakLoop;
        case "gs.Comment":
          return command.execute = function() {
            return 0;
          };
        case "gs.EmptyCommand":
          return command.execute = function() {
            return 0;
          };
        case "gs.ListAdd":
          return command.execute = this.commandListAdd;
        case "gs.ListPop":
          return command.execute = this.commandListPop;
        case "gs.ListShift":
          return command.execute = this.commandListShift;
        case "gs.ListRemoveAt":
          return command.execute = this.commandListRemoveAt;
        case "gs.ListInsertAt":
          return command.execute = this.commandListInsertAt;
        case "gs.ListValueAt":
          return command.execute = this.commandListValueAt;
        case "gs.ListClear":
          return command.execute = this.commandListClear;
        case "gs.ListShuffle":
          return command.execute = this.commandListShuffle;
        case "gs.ListSort":
          return command.execute = this.commandListSort;
        case "gs.ListIndexOf":
          return command.execute = this.commandListIndexOf;
        case "gs.ListSet":
          return command.execute = this.commandListSet;
        case "gs.ListCopy":
          return command.execute = this.commandListCopy;
        case "gs.ListLength":
          return command.execute = this.commandListLength;
        case "gs.ListJoin":
          return command.execute = this.commandListJoin;
        case "gs.ListFromText":
          return command.execute = this.commandListFromText;
        case "gs.ResetVariables":
          return command.execute = this.commandResetVariables;
        case "gs.ChangeVariableDomain":
          return command.execute = this.commandChangeVariableDomain;
        case "gs.ChangeNumberVariables":
          return command.execute = this.commandChangeNumberVariables;
        case "gs.ChangeDecimalVariables":
          return command.execute = this.commandChangeDecimalVariables;
        case "gs.ChangeBooleanVariables":
          return command.execute = this.commandChangeBooleanVariables;
        case "gs.ChangeStringVariables":
          return command.execute = this.commandChangeStringVariables;
        case "gs.CheckSwitch":
          return command.execute = this.commandCheckSwitch;
        case "gs.CheckNumberVariable":
          return command.execute = this.commandCheckNumberVariable;
        case "gs.CheckTextVariable":
          return command.execute = this.commandCheckTextVariable;
        case "gs.Condition":
          return command.execute = this.commandCondition;
        case "gs.ConditionElse":
          return command.execute = this.commandConditionElse;
        case "gs.ConditionElseIf":
          return command.execute = this.commandConditionElseIf;
        case "gs.Label":
          return command.execute = this.commandLabel;
        case "gs.JumpToLabel":
          return command.execute = this.commandJumpToLabel;
        case "gs.SetMessageArea":
          return command.execute = this.commandSetMessageArea;
        case "gs.ShowMessage":
          return command.execute = this.commandShowMessage;
        case "gs.ShowPartialMessage":
          return command.execute = this.commandShowPartialMessage;
        case "gs.MessageFading":
          return command.execute = this.commandMessageFading;
        case "gs.MessageSettings":
          return command.execute = this.commandMessageSettings;
        case "gs.CreateMessageArea":
          return command.execute = this.commandCreateMessageArea;
        case "gs.EraseMessageArea":
          return command.execute = this.commandEraseMessageArea;
        case "gs.SetTargetMessage":
          return command.execute = this.commandSetTargetMessage;
        case "vn.MessageBoxDefaults":
          return command.execute = this.commandMessageBoxDefaults;
        case "vn.MessageBoxVisibility":
          return command.execute = this.commandMessageBoxVisibility;
        case "vn.MessageVisibility":
          return command.execute = this.commandMessageVisibility;
        case "vn.BacklogVisibility":
          return command.execute = this.commandBacklogVisibility;
        case "gs.ClearMessage":
          return command.execute = this.commandClearMessage;
        case "gs.ChangeWeather":
          return command.execute = this.commandChangeWeather;
        case "gs.FreezeScreen":
          return command.execute = this.commandFreezeScreen;
        case "gs.ScreenTransition":
          return command.execute = this.commandScreenTransition;
        case "gs.ShakeScreen":
          return command.execute = this.commandShakeScreen;
        case "gs.TintScreen":
          return command.execute = this.commandTintScreen;
        case "gs.FlashScreen":
          return command.execute = this.commandFlashScreen;
        case "gs.ZoomScreen":
          return command.execute = this.commandZoomScreen;
        case "gs.RotateScreen":
          return command.execute = this.commandRotateScreen;
        case "gs.PanScreen":
          return command.execute = this.commandPanScreen;
        case "gs.ScreenEffect":
          return command.execute = this.commandScreenEffect;
        case "gs.ShowVideo":
          return command.execute = this.commandShowVideo;
        case "gs.MoveVideo":
          return command.execute = this.commandMoveVideo;
        case "gs.MoveVideoPath":
          return command.execute = this.commandMoveVideoPath;
        case "gs.TintVideo":
          return command.execute = this.commandTintVideo;
        case "gs.FlashVideo":
          return command.execute = this.commandFlashVideo;
        case "gs.CropVideo":
          return command.execute = this.commandCropVideo;
        case "gs.RotateVideo":
          return command.execute = this.commandRotateVideo;
        case "gs.ZoomVideo":
          return command.execute = this.commandZoomVideo;
        case "gs.BlendVideo":
          return command.execute = this.commandBlendVideo;
        case "gs.MaskVideo":
          return command.execute = this.commandMaskVideo;
        case "gs.VideoEffect":
          return command.execute = this.commandVideoEffect;
        case "gs.VideoMotionBlur":
          return command.execute = this.commandVideoMotionBlur;
        case "gs.VideoDefaults":
          return command.execute = this.commandVideoDefaults;
        case "gs.EraseVideo":
          return command.execute = this.commandEraseVideo;
        case "gs.ShowImageMap":
          return command.execute = this.commandShowImageMap;
        case "gs.EraseImageMap":
          return command.execute = this.commandEraseImageMap;
        case "gs.AddHotspot":
          return command.execute = this.commandAddHotspot;
        case "gs.EraseHotspot":
          return command.execute = this.commandEraseHotspot;
        case "gs.ChangeHotspotState":
          return command.execute = this.commandChangeHotspotState;
        case "gs.ShowPicture":
          return command.execute = this.commandShowPicture;
        case "gs.MovePicture":
          return command.execute = this.commandMovePicture;
        case "gs.MovePicturePath":
          return command.execute = this.commandMovePicturePath;
        case "gs.TintPicture":
          return command.execute = this.commandTintPicture;
        case "gs.FlashPicture":
          return command.execute = this.commandFlashPicture;
        case "gs.CropPicture":
          return command.execute = this.commandCropPicture;
        case "gs.RotatePicture":
          return command.execute = this.commandRotatePicture;
        case "gs.ZoomPicture":
          return command.execute = this.commandZoomPicture;
        case "gs.BlendPicture":
          return command.execute = this.commandBlendPicture;
        case "gs.ShakePicture":
          return command.execute = this.commandShakePicture;
        case "gs.MaskPicture":
          return command.execute = this.commandMaskPicture;
        case "gs.PictureEffect":
          return command.execute = this.commandPictureEffect;
        case "gs.PictureMotionBlur":
          return command.execute = this.commandPictureMotionBlur;
        case "gs.PictureDefaults":
          return command.execute = this.commandPictureDefaults;
        case "gs.PlayPictureAnimation":
          return command.execute = this.commandPlayPictureAnimation;
        case "gs.ErasePicture":
          return command.execute = this.commandErasePicture;
        case "gs.InputNumber":
          return command.execute = this.commandInputNumber;
        case "vn.Choice":
          return command.execute = this.commandShowChoice;
        case "vn.ChoiceTimer":
          return command.execute = this.commandChoiceTimer;
        case "vn.ShowChoices":
          return command.execute = this.commandShowChoices;
        case "vn.UnlockCG":
          return command.execute = this.commandUnlockCG;
        case "vn.L2DJoinScene":
          return command.execute = this.commandL2DJoinScene;
        case "vn.L2DExitScene":
          return command.execute = this.commandL2DExitScene;
        case "vn.L2DMotion":
          return command.execute = this.commandL2DMotion;
        case "vn.L2DMotionGroup":
          return command.execute = this.commandL2DMotionGroup;
        case "vn.L2DExpression":
          return command.execute = this.commandL2DExpression;
        case "vn.L2DMove":
          return command.execute = this.commandL2DMove;
        case "vn.L2DParameter":
          return command.execute = this.commandL2DParameter;
        case "vn.L2DSettings":
          return command.execute = this.commandL2DSettings;
        case "vn.L2DDefaults":
          return command.execute = this.commandL2DDefaults;
        case "vn.CharacterJoinScene":
          return command.execute = this.commandCharacterJoinScene;
        case "vn.CharacterExitScene":
          return command.execute = this.commandCharacterExitScene;
        case "vn.CharacterChangeExpression":
          return command.execute = this.commandCharacterChangeExpression;
        case "vn.CharacterSetParameter":
          return command.execute = this.commandCharacterSetParameter;
        case "vn.CharacterGetParameter":
          return command.execute = this.commandCharacterGetParameter;
        case "vn.CharacterDefaults":
          return command.execute = this.commandCharacterDefaults;
        case "vn.CharacterEffect":
          return command.execute = this.commandCharacterEffect;
        case "vn.ZoomCharacter":
          return command.execute = this.commandZoomCharacter;
        case "vn.RotateCharacter":
          return command.execute = this.commandRotateCharacter;
        case "vn.BlendCharacter":
          return command.execute = this.commandBlendCharacter;
        case "vn.ShakeCharacter":
          return command.execute = this.commandShakeCharacter;
        case "vn.MaskCharacter":
          return command.execute = this.commandMaskCharacter;
        case "vn.MoveCharacter":
          return command.execute = this.commandMoveCharacter;
        case "vn.MoveCharacterPath":
          return command.execute = this.commandMoveCharacterPath;
        case "vn.FlashCharacter":
          return command.execute = this.commandFlashCharacter;
        case "vn.TintCharacter":
          return command.execute = this.commandTintCharacter;
        case "vn.CharacterMotionBlur":
          return command.execute = this.commandCharacterMotionBlur;
        case "vn.ChangeBackground":
          return command.execute = this.commandChangeBackground;
        case "vn.ShakeBackground":
          return command.execute = this.commandShakeBackground;
        case "vn.ScrollBackground":
          return command.execute = this.commandScrollBackground;
        case "vn.ScrollBackgroundTo":
          return command.execute = this.commandScrollBackgroundTo;
        case "vn.ScrollBackgroundPath":
          return command.execute = this.commandScrollBackgroundPath;
        case "vn.ZoomBackground":
          return command.execute = this.commandZoomBackground;
        case "vn.RotateBackground":
          return command.execute = this.commandRotateBackground;
        case "vn.TintBackground":
          return command.execute = this.commandTintBackground;
        case "vn.BlendBackground":
          return command.execute = this.commandBlendBackground;
        case "vn.MaskBackground":
          return command.execute = this.commandMaskBackground;
        case "vn.BackgroundMotionBlur":
          return command.execute = this.commandBackgroundMotionBlur;
        case "vn.BackgroundEffect":
          return command.execute = this.commandBackgroundEffect;
        case "vn.BackgroundDefaults":
          return command.execute = this.commandBackgroundDefaults;
        case "vn.ChangeScene":
          return command.execute = this.commandChangeScene;
        case "vn.ReturnToPreviousScene":
          return command.execute = this.commandReturnToPreviousScene;
        case "vn.CallScene":
          return command.execute = this.commandCallScene;
        case "vn.SwitchToLayout":
          return command.execute = this.commandSwitchToLayout;
        case "gs.ChangeTransition":
          return command.execute = this.commandChangeTransition;
        case "gs.ChangeWindowSkin":
          return command.execute = this.commandChangeWindowSkin;
        case "gs.ChangeScreenTransitions":
          return command.execute = this.commandChangeScreenTransitions;
        case "vn.UIAccess":
          return command.execute = this.commandUIAccess;
        case "gs.PlayVideo":
          return command.execute = this.commandPlayVideo;
        case "gs.PlayMusic":
          return command.execute = this.commandPlayMusic;
        case "gs.StopMusic":
          return command.execute = this.commandStopMusic;
        case "gs.PlaySound":
          return command.execute = this.commandPlaySound;
        case "gs.StopSound":
          return command.execute = this.commandStopSound;
        case "gs.PauseMusic":
          return command.execute = this.commandPauseMusic;
        case "gs.ResumeMusic":
          return command.execute = this.commandResumeMusic;
        case "gs.AudioDefaults":
          return command.execute = this.commandAudioDefaults;
        case "gs.EndCommonEvent":
          return command.execute = this.commandEndCommonEvent;
        case "gs.ResumeCommonEvent":
          return command.execute = this.commandResumeCommonEvent;
        case "gs.CallCommonEvent":
          return command.execute = this.commandCallCommonEvent;
        case "gs.ChangeTimer":
          return command.execute = this.commandChangeTimer;
        case "gs.ShowText":
          return command.execute = this.commandShowText;
        case "gs.RefreshText":
          return command.execute = this.commandRefreshText;
        case "gs.TextMotionBlur":
          return command.execute = this.commandTextMotionBlur;
        case "gs.MoveText":
          return command.execute = this.commandMoveText;
        case "gs.MoveTextPath":
          return command.execute = this.commandMoveTextPath;
        case "gs.RotateText":
          return command.execute = this.commandRotateText;
        case "gs.ZoomText":
          return command.execute = this.commandZoomText;
        case "gs.BlendText":
          return command.execute = this.commandBlendText;
        case "gs.ColorText":
          return command.execute = this.commandColorText;
        case "gs.EraseText":
          return command.execute = this.commandEraseText;
        case "gs.TextEffect":
          return command.execute = this.commandTextEffect;
        case "gs.TextDefaults":
          return command.execute = this.commandTextDefaults;
        case "gs.ChangeTextSettings":
          return command.execute = this.commandChangeTextSettings;
        case "gs.InputText":
          return command.execute = this.commandInputText;
        case "gs.InputName":
          return command.execute = this.commandInputName;
        case "gs.SavePersistentData":
          return command.execute = this.commandSavePersistentData;
        case "gs.SaveSettings":
          return command.execute = this.commandSaveSettings;
        case "gs.PrepareSaveGame":
          return command.execute = this.commandPrepareSaveGame;
        case "gs.SaveGame":
          return command.execute = this.commandSaveGame;
        case "gs.LoadGame":
          return command.execute = this.commandLoadGame;
        case "gs.GetInputData":
          return command.execute = this.commandGetInputData;
        case "gs.WaitForInput":
          return command.execute = this.commandWaitForInput;
        case "gs.ChangeObjectDomain":
          return command.execute = this.commandChangeObjectDomain;
        case "vn.GetGameData":
          return command.execute = this.commandGetGameData;
        case "vn.SetGameData":
          return command.execute = this.commandSetGameData;
        case "vn.GetObjectData":
          return command.execute = this.commandGetObjectData;
        case "vn.SetObjectData":
          return command.execute = this.commandSetObjectData;
        case "vn.ChangeSounds":
          return command.execute = this.commandChangeSounds;
        case "vn.ChangeColors":
          return command.execute = this.commandChangeColors;
        case "gs.ChangeScreenCursor":
          return command.execute = this.commandChangeScreenCursor;
        case "gs.ResetGlobalData":
          return command.execute = this.commandResetGlobalData;
        case "gs.Script":
          return command.execute = this.commandScript;
      }
    };


    /**
    * Executes the command at the specified index and increases the command-pointer.
    *
    * @method executeCommand
     */

    Component_CommandInterpreter.prototype.executeCommand = function(index) {
      var indent;
      this.command = this.object.commands[index];
      if (this.previewData) {
        if (this.previewData.uid && this.previewData.uid !== this.command.uid) {
          GameManager.tempSettings.skip = true;
          GameManager.tempSettings.skipTime = 0;
        } else if (this.pointer < this.previewData.pointer) {
          GameManager.tempSettings.skip = true;
          GameManager.tempSettings.skipTime = 0;
        } else {
          GameManager.tempSettings.skip = this.previewData.settings.animationDisabled;
          GameManager.tempSettings.skipTime = 0;
          this.previewInfo.waiting = true;
          gs.GlobalEventManager.emit("previewWaiting");
          if (this.previewData.settings.animationDisabled || this.previewData.settings.animationTime > 0) {
            this.previewInfo.timeout = setTimeout((function() {
              return Graphics.stopped = true;
            }), this.previewData.settings.animationTime * 1000);
          }
        }
      }
      if (this.command.execute != null) {
        this.command.interpreter = this;
        if (this.command.indent === this.indent) {
          this.command.execute();
        }
        this.pointer++;
        this.command = this.object.commands[this.pointer];
        if (this.command != null) {
          indent = this.command.indent;
        } else {
          indent = this.indent;
          while (indent > 0 && (this.loops[indent] == null)) {
            indent--;
          }
        }
        if (indent < this.indent) {
          this.indent = indent;
          if (this.loops[this.indent] != null) {
            this.pointer = this.loops[this.indent];
            this.command = this.object.commands[this.pointer];
            return this.command.interpreter = this;
          }
        }
      } else {
        this.assignCommand(this.command);
        if (this.command.execute != null) {
          this.command.interpreter = this;
          if (this.command.indent === this.indent) {
            this.command.execute();
          }
          this.pointer++;
          this.command = this.object.commands[this.pointer];
          if (this.command != null) {
            indent = this.command.indent;
          } else {
            indent = this.indent;
            while (indent > 0 && (this.loops[indent] == null)) {
              indent--;
            }
          }
          if (indent < this.indent) {
            this.indent = indent;
            if (this.loops[this.indent] != null) {
              this.pointer = this.loops[this.indent];
              this.command = this.object.commands[this.pointer];
              return this.command.interpreter = this;
            }
          }
        } else {
          return this.pointer++;
        }
      }
    };


    /**
    * Skips all commands until a command with the specified indent-level is
    * found. So for example: To jump from a Condition-Command to the next
    * Else-Command just pass the indent-level of the Condition/Else command.
    *
    * @method skip
    * @param {number} indent - The indent-level.
    * @param {boolean} backward - If true the skip runs backward.
     */

    Component_CommandInterpreter.prototype.skip = function(indent, backward) {
      var results, results1;
      if (backward) {
        this.pointer--;
        results = [];
        while (this.pointer > 0 && this.object.commands[this.pointer].indent !== indent) {
          results.push(this.pointer--);
        }
        return results;
      } else {
        this.pointer++;
        results1 = [];
        while (this.pointer < this.object.commands.length && this.object.commands[this.pointer].indent !== indent) {
          results1.push(this.pointer++);
        }
        return results1;
      }
    };


    /**
    * Halts the interpreter for the specified amount of time. An optionally
    * callback function can be passed which is called when the time is up.
    *
    * @method wait
    * @param {number} time - The time to wait
    * @param {gs.Callback} callback - Called if the wait time is up.
     */

    Component_CommandInterpreter.prototype.wait = function(time, callback) {
      this.isWaiting = true;
      this.waitCounter = time;
      return this.waitCallback = callback;
    };


    /**
    * Checks if the command at the specified pointer-index is a game message
    * related command.
    *
    * @method isMessageCommand
    * @param {number} pointer - The pointer/index.
    * @param {Object[]} commands - The list of commands to check.
    * @return {boolean} <b>true</b> if its a game message related command. Otherwise <b>false</b>.
     */

    Component_CommandInterpreter.prototype.isMessageCommand = function(pointer, commands) {
      var result;
      result = true;
      if (pointer >= commands.length || (commands[pointer].id !== "gs.InputNumber" && commands[pointer].id !== "vn.Choice" && commands[pointer].id !== "gs.InputText" && commands[pointer].id !== "gs.InputName")) {
        result = false;
      }
      return result;
    };


    /**
    * Checks if the command at the specified pointer-index asks for user-input like
    * the Input Number or Input Text command.
    *
    * @method isInputDataCommand
    * @param {number} pointer - The pointer/index.
    * @param {Object[]} commands - The list of commands to check.
    * @return {boolean} <b>true</b> if its an input-data command. Otherwise <b>false</b>
     */

    Component_CommandInterpreter.prototype.isInputDataCommand = function(pointer, commands) {
      return pointer < commands.length && (commands[pointer].id === "gs.InputNumber" || commands[pointer].id === "gs.InputText" || commands[pointer].id === "vn.Choice" || commands[pointer].id === "vn.ShowChoices");
    };


    /**
    * Checks if a game message is currently running by another interpreter like a
    * common-event interpreter.
    *
    * @method isProcessingMessageInOtherContext
    * @return {boolean} <b>true</b> a game message is running in another context. Otherwise <b>false</b>
     */

    Component_CommandInterpreter.prototype.isProcessingMessageInOtherContext = function() {
      var gm, result, s;
      result = false;
      gm = GameManager;
      s = SceneManager.scene;
      result = ((s.inputNumberWindow != null) && s.inputNumberWindow.visible && s.inputNumberWindow.executionContext !== this.context) || ((s.inputTextWindow != null) && s.inputTextWindow.active && s.inputTextWindow.executionContext !== this.context);
      return result;
    };


    /**
    * If a game message is currently running by an other interpreter like a common-event
    * interpreter, this method trigger a wait until the other interpreter is finished
    * with the game message.
    *
    * @method waitForMessage
    * @return {boolean} <b>true</b> a game message is running in another context. Otherwise <b>false</b>
     */

    Component_CommandInterpreter.prototype.waitForMessage = function() {
      this.isWaitingForMessage = true;
      this.isWaiting = true;
      return this.pointer--;
    };


    /**
    * Gets the value the number variable at the specified index.
    *
    * @method numberValueAtIndex
    * @param {number} scope - The variable's scope.
    * @param {number} index - The index of the variable to get the value from.
    * @return {Number} The value of the variable.
     */

    Component_CommandInterpreter.prototype.numberValueAtIndex = function(scope, index, domain) {
      return GameManager.variableStore.numberValueAtIndex(scope, index, domain);
    };


    /**
    * Gets the value of a (possible) number variable. If a constant number value is specified, this method
    * does nothing an just returns that constant value. That's to make it more comfortable to just pass a value which
    * can be calculated by variable but also be just a constant value.
    *
    * @method numberValueOf
    * @param {number|Object} object - A number variable or constant number value.
    * @return {Number} The value of the variable.
     */

    Component_CommandInterpreter.prototype.numberValueOf = function(object) {
      return GameManager.variableStore.numberValueOf(object);
    };


    /**
    * It does the same like <b>numberValueOf</b> with one difference: If the specified object
    * is a variable, it's value is considered as a duration-value in milliseconds and automatically converted
    * into frames.
    *
    * @method durationValueOf
    * @param {number|Object} object - A number variable or constant number value.
    * @return {Number} The value of the variable.
     */

    Component_CommandInterpreter.prototype.durationValueOf = function(object) {
      if (object && (object.index != null)) {
        return Math.round(GameManager.variableStore.numberValueOf(object) / 1000 * Graphics.frameRate);
      } else {
        return Math.round(GameManager.variableStore.numberValueOf(object));
      }
    };


    /**
    * Gets a position ({x, y}) for the specified predefined object position configured in
    * Database - System.
    *
    * @method predefinedObjectPosition
    * @param {number} position - The index/ID of the predefined object position to set.
    * @param {gs.Object_Base} object - The game object to set the position for.
    * @param {Object} params - The params object of the scene command.
    * @return {Object} The position {x, y}.
     */

    Component_CommandInterpreter.prototype.predefinedObjectPosition = function(position, object, params) {
      var objectPosition;
      objectPosition = RecordManager.system.objectPositions[position];
      if (!objectPosition) {
        return {
          x: 0,
          y: 0
        };
      }
      return objectPosition.func.call(null, object, params) || {
        x: 0,
        y: 0
      };
    };


    /**
    * Sets the value of a number variable at the specified index.
    *
    * @method setNumberValueAtIndex
    * @param {number} scope - The variable's scope.
    * @param {number} index - The index of the variable to set.
    * @param {number} value - The number value to set the variable to.
     */

    Component_CommandInterpreter.prototype.setNumberValueAtIndex = function(scope, index, value, domain) {
      return GameManager.variableStore.setNumberValueAtIndex(scope, index, value, domain);
    };


    /**
    * Sets the value of a number variable.
    *
    * @method setNumberValueTo
    * @param {number} variable - The variable to set.
    * @param {number} value - The number value to set the variable to.
     */

    Component_CommandInterpreter.prototype.setNumberValueTo = function(variable, value) {
      return GameManager.variableStore.setNumberValueTo(variable, value);
    };


    /**
    * Sets the value of a list variable.
    *
    * @method setListObjectTo
    * @param {Object} variable - The variable to set.
    * @param {Object} value - The list object to set the variable to.
     */

    Component_CommandInterpreter.prototype.setListObjectTo = function(variable, value) {
      return GameManager.variableStore.setListObjectTo(variable, value);
    };


    /**
    * Sets the value of a boolean/switch variable.
    *
    * @method setBooleanValueTo
    * @param {Object} variable - The variable to set.
    * @param {boolean} value - The boolean value to set the variable to.
     */

    Component_CommandInterpreter.prototype.setBooleanValueTo = function(variable, value) {
      return GameManager.variableStore.setBooleanValueTo(variable, value);
    };


    /**
    * Sets the value of a number variable at the specified index.
    *
    * @method setBooleanValueAtIndex
    * @param {number} scope - The variable's scope.
    * @param {number} index - The index of the variable to set.
    * @param {boolean} value - The boolean value to set the variable to.
     */

    Component_CommandInterpreter.prototype.setBooleanValueAtIndex = function(scope, index, value, domain) {
      return GameManager.variableStore.setBooleanValueAtIndex(scope, index, value, domain);
    };


    /**
    * Sets the value of a string/text variable.
    *
    * @method setStringValueTo
    * @param {Object} variable - The variable to set.
    * @param {string} value - The string/text value to set the variable to.
     */

    Component_CommandInterpreter.prototype.setStringValueTo = function(variable, value) {
      return GameManager.variableStore.setStringValueTo(variable, value);
    };


    /**
    * Sets the value of the string variable at the specified index.
    *
    * @method setStringValueAtIndex
    * @param {number} scope - The variable scope.
    * @param {number} index - The variable's index.
    * @param {string} value - The value to set.
     */

    Component_CommandInterpreter.prototype.setStringValueAtIndex = function(scope, index, value, domain) {
      return GameManager.variableStore.setStringValueAtIndex(scope, index, value, domain);
    };


    /**
    * Gets the value of a (possible) string variable. If a constant string value is specified, this method
    * does nothing an just returns that constant value. That's to make it more comfortable to just pass a value which
    * can be calculated by variable but also be just a constant value.
    *
    * @method stringValueOf
    * @param {string|Object} object - A string variable or constant string value.
    * @return {string} The value of the variable.
     */

    Component_CommandInterpreter.prototype.stringValueOf = function(object) {
      return GameManager.variableStore.stringValueOf(object);
    };


    /**
    * Gets the value of the string variable at the specified index.
    *
    * @method stringValueAtIndex
    * @param {number} scope - The variable's scope.
    * @param {number} index - The index of the variable to get the value from.
    * @return {string} The value of the variable.
     */

    Component_CommandInterpreter.prototype.stringValueAtIndex = function(scope, index, domain) {
      return GameManager.variableStore.stringValueAtIndex(scope, index, domain);
    };


    /**
    * Gets the value of a (possible) boolean variable. If a constant boolean value is specified, this method
    * does nothing an just returns that constant value. That's to make it more comfortable to just pass a value which
    * can be calculated by variable but also be just a constant value.
    *
    * @method booleanValueOf
    * @param {boolean|Object} object - A boolean variable or constant boolean value.
    * @return {boolean} The value of the variable.
     */

    Component_CommandInterpreter.prototype.booleanValueOf = function(object) {
      return GameManager.variableStore.booleanValueOf(object);
    };


    /**
    * Gets the value of the boolean variable at the specified index.
    *
    * @method booleanValueAtIndex
    * @param {number} scope - The variable's scope.
    * @param {number} index - The index of the variable to get the value from.
    * @return {string} The value of the variable.
     */

    Component_CommandInterpreter.prototype.booleanValueAtIndex = function(scope, index, domain) {
      return GameManager.variableStore.booleanValueAtIndex(scope, index, domain);
    };


    /**
    * Gets the value of a (possible) list variable.
    *
    * @method listObjectOf
    * @param {Object} object - A list variable.
    * @return {Object} The value of the list variable.
     */

    Component_CommandInterpreter.prototype.listObjectOf = function(object) {
      return GameManager.variableStore.listObjectOf(object);
    };


    /**
    * Compares two object using the specified operation and returns the result.
    *
    * @method compare
    * @param {Object} a - Object A.
    * @param {Object} b - Object B.
    * @param {number} operation - The compare-operation to compare Object A with Object B.
    * <ul>
    * <li>0 = Equal To</li>
    * <li>1 = Not Equal To</li>
    * <li>2 = Greater Than</li>
    * <li>3 = Greater or Equal To</li>
    * <li>4 = Less Than</li>
    * <li>5 = Less or Equal To</li>
    * </ul>
    * @return {boolean} The comparison result.
     */

    Component_CommandInterpreter.prototype.compare = function(a, b, operation) {
      switch (operation) {
        case 0:
          return a == b;
        case 1:
          return a != b;
        case 2:
          return a > b;
        case 3:
          return a >= b;
        case 4:
          return a < b;
        case 5:
          return a <= b;
      }
    };


    /**
    * Changes number variables and allows decimal values such as 0.5 too.
    *
    * @method changeDecimalVariables
    * @param {Object} params - Input params from the command
    * @param {Object} roundMethod - The result of the operation will be rounded using the specified method.
    * <ul>
    * <li>0 = None. The result will not be rounded.</li>
    * <li>1 = Commercially</li>
    * <li>2 = Round Up</li>
    * <li>3 = Round Down</li>
    * </ul>
     */

    Component_CommandInterpreter.prototype.changeDecimalVariables = function(params, roundMethod) {
      var diff, end, i, index, k, ref, ref1, roundFunc, scope, source, start;
      source = 0;
      roundFunc = null;
      switch (roundMethod) {
        case 0:
          roundFunc = function(value) {
            return value;
          };
          break;
        case 1:
          roundFunc = function(value) {
            return Math.round(value);
          };
          break;
        case 2:
          roundFunc = function(value) {
            return Math.ceil(value);
          };
          break;
        case 3:
          roundFunc = function(value) {
            return Math.floor(value);
          };
      }
      switch (params.source) {
        case 0:
          source = this.numberValueOf(params.sourceValue);
          break;
        case 1:
          start = this.numberValueOf(params.sourceRandom.start);
          end = this.numberValueOf(params.sourceRandom.end);
          diff = end - start;
          source = Math.floor(start + Math.random() * (diff + 1));
          break;
        case 2:
          source = this.numberValueAtIndex(params.sourceScope, this.numberValueOf(params.sourceReference) - 1, params.sourceReferenceDomain);
          break;
        case 3:
          source = this.numberValueOfGameData(params.sourceValue1);
          break;
        case 4:
          source = this.numberValueOfDatabaseData(params.sourceValue1);
      }
      switch (params.target) {
        case 0:
          switch (params.operation) {
            case 0:
              this.setNumberValueTo(params.targetVariable, roundFunc(source));
              break;
            case 1:
              this.setNumberValueTo(params.targetVariable, roundFunc(this.numberValueOf(params.targetVariable) + source));
              break;
            case 2:
              this.setNumberValueTo(params.targetVariable, roundFunc(this.numberValueOf(params.targetVariable) - source));
              break;
            case 3:
              this.setNumberValueTo(params.targetVariable, roundFunc(this.numberValueOf(params.targetVariable) * source));
              break;
            case 4:
              this.setNumberValueTo(params.targetVariable, roundFunc(this.numberValueOf(params.targetVariable) / source));
              break;
            case 5:
              this.setNumberValueTo(params.targetVariable, this.numberValueOf(params.targetVariable) % source);
          }
          break;
        case 1:
          scope = params.targetScope;
          start = params.targetRange.start - 1;
          end = params.targetRange.end - 1;
          for (i = k = ref = start, ref1 = end; ref <= ref1 ? k <= ref1 : k >= ref1; i = ref <= ref1 ? ++k : --k) {
            switch (params.operation) {
              case 0:
                this.setNumberValueAtIndex(scope, i, roundFunc(source));
                break;
              case 1:
                this.setNumberValueAtIndex(scope, i, roundFunc(this.numberValueAtIndex(scope, i) + source));
                break;
              case 2:
                this.setNumberValueAtIndex(scope, i, roundFunc(this.numberValueAtIndex(scope, i) - source));
                break;
              case 3:
                this.setNumberValueAtIndex(scope, i, roundFunc(this.numberValueAtIndex(scope, i) * source));
                break;
              case 4:
                this.setNumberValueAtIndex(scope, i, roundFunc(this.numberValueAtIndex(scope, i) / source));
                break;
              case 5:
                this.setNumberValueAtIndex(scope, i, this.numberValueAtIndex(scope, i) % source);
            }
          }
          break;
        case 2:
          index = this.numberValueOf(params.targetReference) - 1;
          switch (params.operation) {
            case 0:
              this.setNumberValueAtIndex(params.targetScope, index, roundFunc(source), params.targetReferenceDomain);
              break;
            case 1:
              this.setNumberValueAtIndex(params.targetScope, index, roundFunc(this.numberValueAtIndex(params.targetScope, index, params.targetReferenceDomain) + source), params.targetReferenceDomain);
              break;
            case 2:
              this.setNumberValueAtIndex(params.targetScope, index, roundFunc(this.numberValueAtIndex(params.targetScope, index, params.targetReferenceDomain) - source), params.targetReferenceDomain);
              break;
            case 3:
              this.setNumberValueAtIndex(params.targetScope, index, roundFunc(this.numberValueAtIndex(params.targetScope, index, params.targetReferenceDomain) * source), params.targetReferenceDomain);
              break;
            case 4:
              this.setNumberValueAtIndex(params.targetScope, index, roundFunc(this.numberValueAtIndex(params.targetScope, index, params.targetReferenceDomain) / source), params.targetReferenceDomain);
              break;
            case 5:
              this.setNumberValueAtIndex(params.targetScope, index, this.numberValueAtIndex(params.targetScope, index, params.targetReferenceDomain) % source, params.targetReferenceDomain);
          }
      }
      return null;
    };


    /**
    * Shakes a game object.
    *
    * @method shakeObject
    * @param {gs.Object_Base} object - The game object to shake.
    * @return {Object} A params object containing additional info about the shake-animation.
     */

    Component_CommandInterpreter.prototype.shakeObject = function(object, params) {
      var duration, easing;
      duration = Math.max(Math.round(this.durationValueOf(params.duration)), 2);
      easing = gs.Easings.fromObject(params.easing);
      object.animator.shake({
        x: this.numberValueOf(params.range.x),
        y: this.numberValueOf(params.range.y)
      }, this.numberValueOf(params.speed) / 100, duration, easing);
      if (params.waitForCompletion && !(duration === 0 || this.isInstantSkip())) {
        this.isWaiting = true;
        return this.waitCounter = duration;
      }
    };


    /**
    * Lets the interpreter wait for the completion of a running operation like an animation, etc.
    *
    * @method waitForCompletion
    * @param {gs.Object_Base} object - The game object the operation is executed on. Can be <b>null</b>.
    * @return {Object} A params object containing additional info.
     */

    Component_CommandInterpreter.prototype.waitForCompletion = function(object, params) {
      var duration;
      duration = this.durationValueOf(params.duration);
      if (params.waitForCompletion && !(duration === 0 || this.isInstantSkip())) {
        this.isWaiting = true;
        return this.waitCounter = duration;
      }
    };


    /**
    * Erases a game object.
    *
    * @method eraseObject
    * @param {gs.Object_Base} object - The game object to erase.
    * @return {Object} A params object containing additional info.
     */

    Component_CommandInterpreter.prototype.eraseObject = function(object, params, callback) {
      var duration, easing;
      easing = gs.Easings.fromObject(params.easing);
      duration = this.durationValueOf(params.duration);
      object.animator.disappear(params.animation, easing, duration, (function(_this) {
        return function(sender) {
          sender.dispose();
          return typeof callback === "function" ? callback(sender) : void 0;
        };
      })(this));
      if (params.waitForCompletion && !(duration === 0 || this.isInstantSkip())) {
        this.isWaiting = true;
        return this.waitCounter = duration;
      }
    };


    /**
    * Shows a game object on screen.
    *
    * @method showObject
    * @param {gs.Object_Base} object - The game object to show.
    * @param {gs.Point} position - The position where the game object should be shown.
    * @param {Object} A params object containing additional info.
     */

    Component_CommandInterpreter.prototype.showObject = function(object, position, params) {
      var duration, easing, x, y;
      x = this.numberValueOf(position.x);
      y = this.numberValueOf(position.y);
      easing = gs.Easings.fromObject(params.easing);
      duration = this.durationValueOf(params.duration);
      object.animator.appear(x, y, params.animation, easing, duration);
      if (params.waitForCompletion && !(duration === 0 || this.isInstantSkip())) {
        this.isWaiting = true;
        return this.waitCounter = duration;
      }
    };


    /**
    * Moves a game object.
    *
    * @method moveObject
    * @param {gs.Object_Base} object - The game object to move.
    * @param {gs.Point} position - The position to move the game object to.
    * @param {Object} A params object containing additional info.
     */

    Component_CommandInterpreter.prototype.moveObject = function(object, position, params) {
      var bitmap, duration, easing, p, x, y, zoom;
      if (params.positionType === 0) {
        p = this.predefinedObjectPosition(params.predefinedPositionId, object, params);
        x = p.x;
        y = p.y;
      } else {
        x = this.numberValueOf(position.x);
        y = this.numberValueOf(position.y);
      }
      easing = gs.Easings.fromObject(params.easing);
      duration = this.durationValueOf(params.duration);
      zoom = object.zoom;
      if (object.anchor.x !== 0 && object.anchor.y !== 0) {
        bitmap = object.bitmap;
        if (bitmap != null) {
          x += (bitmap.width * zoom.x - bitmap.width) * object.anchor.x;
          y += (bitmap.height * zoom.y - bitmap.height) * object.anchor.y;
        }
      }
      object.animator.moveTo(x, y, duration, easing);
      if (params.waitForCompletion && !(duration === 0 || this.isInstantSkip())) {
        this.isWaiting = true;
        return this.waitCounter = duration;
      }
    };


    /**
    * Moves a game object along a path.
    *
    * @method moveObjectPath
    * @param {gs.Object_Base} object - The game object to move.
    * @param {Object} path - The path to move the game object along.
    * @param {Object} A params object containing additional info.
     */

    Component_CommandInterpreter.prototype.moveObjectPath = function(object, path, params) {
      var duration, easing, ref;
      easing = gs.Easings.fromObject(params.easing);
      duration = this.durationValueOf(params.duration);
      object.animator.movePath(path.data, params.loopType, duration, easing, (ref = path.effects) != null ? ref.data : void 0);
      if (params.waitForCompletion && !(duration === 0 || this.isInstantSkip())) {
        this.isWaiting = true;
        return this.waitCounter = duration;
      }
    };


    /**
    * Scrolls a scrollable game object along a path.
    *
    * @method scrollObjectPath
    * @param {gs.Object_Base} object - The game object to scroll.
    * @param {Object} path - The path to scroll the game object along.
    * @param {Object} A params object containing additional info.
     */

    Component_CommandInterpreter.prototype.scrollObjectPath = function(object, path, params) {
      var duration, easing;
      easing = gs.Easings.fromObject(params.easing);
      duration = this.durationValueOf(params.duration);
      object.animator.scrollPath(path, params.loopType, duration, easing);
      if (params.waitForCompletion && !(duration === 0 || this.isInstantSkip())) {
        this.isWaiting = true;
        return this.waitCounter = duration;
      }
    };


    /**
    * Zooms/Scales a game object.
    *
    * @method zoomObject
    * @param {gs.Object_Base} object - The game object to zoom.
    * @param {Object} A params object containing additional info.
     */

    Component_CommandInterpreter.prototype.zoomObject = function(object, params) {
      var duration, easing;
      easing = gs.Easings.fromObject(params.easing);
      duration = this.durationValueOf(params.duration);
      object.animator.zoomTo(this.numberValueOf(params.zooming.x) / 100, this.numberValueOf(params.zooming.y) / 100, duration, easing);
      if (params.waitForCompletion && !(duration === 0 || this.isInstantSkip())) {
        this.isWaiting = true;
        return this.waitCounter = duration;
      }
    };


    /**
    * Rotates a game object.
    *
    * @method rotateObject
    * @param {gs.Object_Base} object - The game object to rotate.
    * @param {Object} A params object containing additional info.
     */

    Component_CommandInterpreter.prototype.rotateObject = function(object, params) {
      var duration, easing;
      easing = gs.Easings.fromObject(params.easing);
      duration = this.durationValueOf(params.duration);
      easing = gs.Easings.fromObject(params.easing);
      object.animator.rotate(params.direction, this.numberValueOf(params.speed) / 100, duration, easing);
      if (params.waitForCompletion && !(duration === 0 || this.isInstantSkip())) {
        this.isWaiting = true;
        return this.waitCounter = duration;
      }
    };


    /**
    * Blends a game object.
    *
    * @method blendObject
    * @param {gs.Object_Base} object - The game object to blend.
    * @param {Object} A params object containing additional info.
     */

    Component_CommandInterpreter.prototype.blendObject = function(object, params) {
      var duration, easing;
      easing = gs.Easings.fromObject(params.easing);
      duration = this.durationValueOf(params.duration);
      object.animator.blendTo(this.numberValueOf(params.opacity), duration, easing);
      if (params.waitForCompletion && !(duration === 0 || this.isInstantSkip())) {
        this.isWaiting = true;
        return this.waitCounter = duration;
      }
    };


    /**
    * Executes a masking-effect on a game object..
    *
    * @method maskObject
    * @param {gs.Object_Base} object - The game object to execute a masking-effect on.
    * @param {Object} A params object containing additional info.
     */

    Component_CommandInterpreter.prototype.maskObject = function(object, params) {
      var duration, easing, mask, ref, ref1, ref2;
      easing = gs.Easings.fromObject(params.easing);
      if (params.mask.type === 0) {
        object.mask.type = 0;
        object.mask.ox = this.numberValueOf(params.mask.ox);
        object.mask.oy = this.numberValueOf(params.mask.oy);
        if (((ref = object.mask.source) != null ? ref.videoElement : void 0) != null) {
          object.mask.source.pause();
        }
        if (params.mask.sourceType === 0) {
          object.mask.source = ResourceManager.getBitmap("Graphics/Masks/" + ((ref1 = params.mask.graphic) != null ? ref1.name : void 0));
        } else {
          object.mask.source = ResourceManager.getVideo("Movies/" + ((ref2 = params.mask.video) != null ? ref2.name : void 0));
          if (object.mask.source) {
            object.mask.source.play();
            object.mask.source.loop = true;
          }
        }
      } else {
        duration = this.durationValueOf(params.duration);
        mask = Object.flatCopy(params.mask);
        mask.value = this.numberValueOf(mask.value);
        object.animator.maskTo(mask, duration, easing);
      }
      if (params.waitForCompletion && !(duration === 0 || this.isInstantSkip())) {
        this.isWaiting = true;
        return this.waitCounter = duration;
      }
    };


    /**
    * Tints a game object.
    *
    * @method tintObject
    * @param {gs.Object_Base} object - The game object to tint.
    * @param {Object} A params object containing additional info.
     */

    Component_CommandInterpreter.prototype.tintObject = function(object, params) {
      var duration, easing;
      duration = this.durationValueOf(params.duration);
      easing = gs.Easings.fromObject(params.easing);
      object.animator.tintTo(params.tone, duration, easing);
      if (params.waitForCompletion && !(duration === 0 || this.isInstantSkip())) {
        this.isWaiting = true;
        return this.waitCounter = duration;
      }
    };


    /**
    * Flashes a game object.
    *
    * @method flashObject
    * @param {gs.Object_Base} object - The game object to flash.
    * @param {Object} A params object containing additional info.
     */

    Component_CommandInterpreter.prototype.flashObject = function(object, params) {
      var duration;
      duration = this.durationValueOf(params.duration);
      object.animator.flash(new Color(params.color), duration);
      if (params.waitForCompletion && !(duration === 0 || this.isInstantSkip())) {
        this.isWaiting = true;
        return this.waitCounter = duration;
      }
    };


    /**
    * Cropes a game object.
    *
    * @method cropObject
    * @param {gs.Object_Base} object - The game object to crop.
    * @param {Object} A params object containing additional info.
     */

    Component_CommandInterpreter.prototype.cropObject = function(object, params) {
      object.srcRect.x = this.numberValueOf(params.x);
      object.srcRect.y = this.numberValueOf(params.y);
      object.srcRect.width = this.numberValueOf(params.width);
      object.srcRect.height = this.numberValueOf(params.height);
      object.dstRect.width = this.numberValueOf(params.width);
      return object.dstRect.height = this.numberValueOf(params.height);
    };


    /**
    * Sets the motion blur settings of a game object.
    *
    * @method objectMotionBlur
    * @param {gs.Object_Base} object - The game object to set the motion blur settings for.
    * @param {Object} A params object containing additional info.
     */

    Component_CommandInterpreter.prototype.objectMotionBlur = function(object, params) {
      return object.motionBlur.set(params.motionBlur);
    };


    /**
    * Enables an effect on a game object.
    *
    * @method objectEffect
    * @param {gs.Object_Base} object - The game object to execute a masking-effect on.
    * @param {Object} A params object containing additional info.
     */

    Component_CommandInterpreter.prototype.objectEffect = function(object, params) {
      var duration, easing, wobble;
      duration = this.durationValueOf(params.duration);
      easing = gs.Easings.fromObject(params.easing);
      switch (params.type) {
        case 0:
          object.animator.wobbleTo(params.wobble.power / 10000, params.wobble.speed / 100, duration, easing);
          wobble = object.effects.wobble;
          wobble.enabled = params.wobble.power > 0;
          wobble.vertical = params.wobble.orientation === 0 || params.wobble.orientation === 2;
          wobble.horizontal = params.wobble.orientation === 1 || params.wobble.orientation === 2;
          break;
        case 1:
          object.animator.blurTo(params.blur.power / 100, duration, easing);
          object.effects.blur.enabled = true;
          break;
        case 2:
          object.animator.pixelateTo(params.pixelate.size.width, params.pixelate.size.height, duration, easing);
          object.effects.pixelate.enabled = true;
      }
      if (params.waitForCompletion && duration !== 0) {
        this.isWaiting = true;
        return this.waitCounter = duration;
      }
    };


    /**
    * Executes an action like for a hotspot.
    *
    * @method executeAction
    * @param {Object} action - Action-Data.
    * @param {boolean} stateValue - In case of switch-binding, the switch is set to this value.
    * @param {number} bindValue - A number value which be put into the action's bind-value variable.
     */

    Component_CommandInterpreter.prototype.executeAction = function(action, stateValue, bindValue) {
      var domain, ref;
      switch (action.type) {
        case 0:
          if (action.labelIndex) {
            return this.pointer = action.labelIndex;
          } else {
            return this.jumpToLabel(action.label);
          }
          break;
        case 1:
          return this.callCommonEvent(action.commonEventId, null, this.isWaiting);
        case 2:
          domain = GameManager.variableStore.domain;
          return this.setBooleanValueTo(action["switch"], stateValue);
        case 3:
          return this.callScene((ref = action.scene) != null ? ref.uid : void 0);
        case 4:
          domain = GameManager.variableStore.domain;
          this.setNumberValueTo(action.bindValueVariable, bindValue);
          if (action.labelIndex) {
            return this.pointer = action.labelIndex;
          } else {
            return this.jumpToLabel(action.label);
          }
      }
    };


    /**
    * Calls a common event and returns the sub-interpreter for it.
    *
    * @method callCommonEvent
    * @param {number} id - The ID of the common event to call.
    * @param {Object} parameters - Optional common event parameters.
    * @param {boolean} wait - Indicates if the interpreter should be stay in waiting-mode even if the sub-interpreter is finished.
     */

    Component_CommandInterpreter.prototype.callCommonEvent = function(id, parameters, wait) {
      var commonEvent, ref;
      commonEvent = GameManager.commonEvents[id];
      if (commonEvent != null) {
        if (SceneManager.scene.commonEventContainer.subObjects.indexOf(commonEvent) === -1) {
          SceneManager.scene.commonEventContainer.addObject(commonEvent);
        }
        if ((ref = commonEvent.events) != null) {
          ref.on("finish", gs.CallBack("onCommonEventFinish", this), {
            waiting: wait
          });
        }
        this.subInterpreter = commonEvent.behavior.call(parameters || [], this.settings, this.context);
        commonEvent.behavior.update();
        if (this.subInterpreter != null) {
          this.isWaiting = true;
          this.subInterpreter.settings = this.settings;
          this.subInterpreter.start();
          return this.subInterpreter.update();
        }
      }
    };


    /**
    * Calls a scene and returns the sub-interpreter for it.
    *
    * @method callScene
    * @param {String} uid - The UID of the scene to call.
     */

    Component_CommandInterpreter.prototype.callScene = function(uid) {
      var object, sceneDocument;
      sceneDocument = DataManager.getDocument(uid);
      if (sceneDocument != null) {
        this.isWaiting = true;
        this.subInterpreter = new vn.Component_CallSceneInterpreter();
        object = {
          commands: sceneDocument.items.commands
        };
        this.subInterpreter.repeat = false;
        this.subInterpreter.context.set(sceneDocument.uid, sceneDocument);
        this.subInterpreter.object = object;
        this.subInterpreter.onFinish = gs.CallBack("onCallSceneFinish", this);
        this.subInterpreter.start();
        this.subInterpreter.settings = this.settings;
        return this.subInterpreter.update();
      }
    };


    /**
    * Calls a common event and returns the sub-interpreter for it.
    *
    * @method storeListValue
    * @param {number} id - The ID of the common event to call.
    * @param {Object} parameters - Optional common event parameters.
    * @param {boolean} wait - Indicates if the interpreter should be stay in waiting-mode even if the sub-interpreter is finished.
     */

    Component_CommandInterpreter.prototype.storeListValue = function(variable, list, value, valueType) {
      switch (valueType) {
        case 0:
          return this.setNumberValueTo(variable, (!isNaN(value) ? value : 0));
        case 1:
          return this.setBooleanValueTo(variable, (value ? 1 : 0));
        case 2:
          return this.setStringValueTo(variable, value.toString());
        case 3:
          return this.setListObjectTo(variable, (value.length != null ? value : []));
      }
    };


    /**
    * @method jumpToLabel
     */

    Component_CommandInterpreter.prototype.jumpToLabel = function(label) {
      var found, i, k, ref;
      if (!label) {
        return;
      }
      found = false;
      for (i = k = 0, ref = this.object.commands.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        if (this.object.commands[i].id === "gs.Label" && this.object.commands[i].params.name === label) {
          this.pointer = i;
          this.indent = this.object.commands[i].indent;
          found = true;
          break;
        }
      }
      if (found) {
        this.waitCounter = 0;
        return this.isWaiting = false;
      }
    };


    /**
    * Gets the current message box object depending on game mode (ADV or NVL).
    *
    * @method messageBoxObject
    * @return {gs.Object_Base} The message box object.
    * @protected
     */

    Component_CommandInterpreter.prototype.messageBoxObject = function(id) {
      if (SceneManager.scene.layout.visible) {
        return gs.ObjectManager.current.objectById(id || "messageBox");
      } else {
        return gs.ObjectManager.current.objectById(id || "nvlMessageBox");
      }
    };


    /**
    * Gets the current message object depending on game mode (ADV or NVL).
    *
    * @method messageObject
    * @return {ui.Object_Message} The message object.
    * @protected
     */

    Component_CommandInterpreter.prototype.messageObject = function() {
      if (SceneManager.scene.layout.visible) {
        return gs.ObjectManager.current.objectById("gameMessage_message");
      } else {
        return gs.ObjectManager.current.objectById("nvlGameMessage_message");
      }
    };


    /**
    * Gets the current message ID depending on game mode (ADV or NVL).
    *
    * @method messageObjectId
    * @return {string} The message object ID.
    * @protected
     */

    Component_CommandInterpreter.prototype.messageObjectId = function() {
      if (SceneManager.scene.layout.visible) {
        return "gameMessage_message";
      } else {
        return "nvlGameMessage_message";
      }
    };


    /**
    * Gets the current message settings.
    *
    * @method messageSettings
    * @return {Object} The message settings
    * @protected
     */

    Component_CommandInterpreter.prototype.messageSettings = function() {
      var message;
      message = this.targetMessage();
      return message.settings;
    };


    /**
    * Gets the current target message object where all message commands are executed on.
    *
    * @method targetMessage
    * @return {ui.Object_Message} The target message object.
    * @protected
     */

    Component_CommandInterpreter.prototype.targetMessage = function() {
      var message, ref, ref1, ref2, target;
      message = this.messageObject();
      target = this.settings.message.target;
      if (target != null) {
        switch (target.type) {
          case 0:
            message = (ref = gs.ObjectManager.current.objectById(target.id)) != null ? ref : this.messageObject();
            break;
          case 1:
            message = (ref1 = (ref2 = SceneManager.scene.messageAreas[target.id]) != null ? ref2.message : void 0) != null ? ref1 : this.messageObject();
        }
      }
      return message;
    };


    /**
    * Gets the current target message box containing the current target message.
    *
    * @method targetMessageBox
    * @return {ui.Object_UIElement} The target message box.
    * @protected
     */

    Component_CommandInterpreter.prototype.targetMessageBox = function() {
      var messageBox, ref, ref1, target;
      messageBox = this.messageObject();
      target = this.settings.message.target;
      if (target != null) {
        switch (target.type) {
          case 0:
            messageBox = (ref = gs.ObjectManager.current.objectById(target.id)) != null ? ref : this.messageObject();
            break;
          case 1:
            messageBox = (ref1 = gs.ObjectManager.current.objectById("customGameMessage_" + target.id)) != null ? ref1 : this.messageObject();
        }
      }
      return messageBox;
    };


    /**
    * Called after an input number dialog was accepted by the user. It takes the user's input and puts
    * it in the configured number variable.
    *
    * @method onInputNumberFinish
    * @return {Object} Event Object containing additional data like the number, etc.
    * @protected
     */

    Component_CommandInterpreter.prototype.onInputNumberFinish = function(e) {
      this.messageObject().behavior.clear();
      this.setNumberValueTo(this.waitingFor.inputNumber.variable, parseInt(ui.Component_FormulaHandler.fieldValue(e.sender, e.number)));
      this.isWaiting = false;
      this.waitingFor.inputNumber = null;
      return SceneManager.scene.inputNumberBox.dispose();
    };


    /**
    * Called after an input text dialog was accepted by the user. It takes the user's text input and puts
    * it in the configured string variable.
    *
    * @method onInputTextFinish
    * @return {Object} Event Object containing additional data like the text, etc.
    * @protected
     */

    Component_CommandInterpreter.prototype.onInputTextFinish = function(e) {
      this.messageObject().behavior.clear();
      this.setStringValueTo(this.waitingFor.inputText.variable, ui.Component_FormulaHandler.fieldValue(e.sender, e.text).replace(/_/g, ""));
      this.isWaiting = false;
      this.waitingFor.inputText = null;
      return SceneManager.scene.inputTextBox.dispose();
    };


    /**
    * Called after a choice was selected by the user. It jumps to the corresponding label
    * and also puts the choice into backlog.
    *
    * @method onChoiceAccept
    * @return {Object} Event Object containing additional data like the label, etc.
    * @protected
     */

    Component_CommandInterpreter.prototype.onChoiceAccept = function(e) {
      var duration, fading, messageObject, scene;
      scene = SceneManager.scene;
      scene.choiceTimer.behavior.stop();
      e.isSelected = true;
      delete e.sender;
      GameManager.backlog.push({
        character: {
          name: ""
        },
        message: "",
        choice: e,
        choices: scene.choices,
        isChoice: true
      });
      scene.choices = [];
      messageObject = this.messageObject();
      if (messageObject != null ? messageObject.visible : void 0) {
        this.isWaiting = true;
        fading = GameManager.tempSettings.messageFading;
        duration = GameManager.tempSettings.skip ? 0 : fading.duration;
        messageObject.animator.disappear(fading.animation, fading.easing, duration, (function(_this) {
          return function() {
            messageObject.behavior.clear();
            messageObject.visible = false;
            _this.isWaiting = false;
            _this.waitingFor.choice = null;
            return _this.executeAction(e.action, true);
          };
        })(this));
      } else {
        this.isWaiting = false;
        this.executeAction(e.action, true);
      }
      return scene.choiceWindow.dispose();
    };


    /**
    * Idle
    * @method commandIdle
    * @protected
     */

    Component_CommandInterpreter.prototype.commandIdle = function() {
      return this.interpreter.isWaiting = !this.interpreter.isInstantSkip();
    };


    /**
    * Start Timer
    * @method commandStartTimer
    * @protected
     */

    Component_CommandInterpreter.prototype.commandStartTimer = function() {
      var number, scene, timer, timers;
      scene = SceneManager.scene;
      timers = scene.timers;
      number = this.interpreter.numberValueOf(this.params.number);
      timer = timers[number];
      if (timer == null) {
        timer = new gs.Object_IntervalTimer();
        timers[number] = timer;
      }
      timer.events.offByOwner("elapsed", this.object);
      timer.events.on("elapsed", (function(_this) {
        return function(e) {
          var params;
          params = e.data.params;
          switch (params.action.type) {
            case 0:
              if (params.labelIndex != null) {
                return SceneManager.scene.interpreter.pointer = params.labelIndex;
              } else {
                return SceneManager.scene.interpreter.jumpToLabel(params.action.data.label);
              }
              break;
            case 1:
              return SceneManager.scene.interpreter.callCommonEvent(params.action.data.commonEventId, null, _this.interpreter.isWaiting);
          }
        };
      })(this), {
        params: this.params
      }, this.object);
      timer.behavior.interval = this.interpreter.durationValueOf(this.params.interval);
      return timer.behavior.start();
    };


    /**
    * Resume Timer
    * @method commandResumeTimer
    * @protected
     */

    Component_CommandInterpreter.prototype.commandResumeTimer = function() {
      var number, ref, timers;
      timers = SceneManager.scene.timers;
      number = this.interpreter.numberValueOf(this.params.number);
      return (ref = timers[number]) != null ? ref.behavior.resume() : void 0;
    };


    /**
    * Pauses Timer
    * @method commandPauseTimer
    * @protected
     */

    Component_CommandInterpreter.prototype.commandPauseTimer = function() {
      var number, ref, timers;
      timers = SceneManager.scene.timers;
      number = this.interpreter.numberValueOf(this.params.number);
      return (ref = timers[number]) != null ? ref.behavior.pause() : void 0;
    };


    /**
    * Stop Timer
    * @method commandStopTimer
    * @protected
     */

    Component_CommandInterpreter.prototype.commandStopTimer = function() {
      var number, ref, timers;
      timers = SceneManager.scene.timers;
      number = this.interpreter.numberValueOf(this.params.number);
      return (ref = timers[number]) != null ? ref.behavior.stop() : void 0;
    };


    /**
    * Wait
    * @method commandWait
    * @protected
     */

    Component_CommandInterpreter.prototype.commandWait = function() {
      var time;
      time = this.interpreter.durationValueOf(this.params.time);
      if ((time != null) && time > 0 && !this.interpreter.previewData) {
        this.interpreter.waitCounter = time;
        return this.interpreter.isWaiting = true;
      }
    };


    /**
    * Loop
    * @method commandLoop
    * @protected
     */

    Component_CommandInterpreter.prototype.commandLoop = function() {
      this.interpreter.loops[this.interpreter.indent] = this.interpreter.pointer;
      return this.interpreter.indent++;
    };


    /**
    * Break Loop
    * @method commandBreakLoop
    * @protected
     */

    Component_CommandInterpreter.prototype.commandBreakLoop = function() {
      var indent;
      indent = this.indent;
      while ((this.interpreter.loops[indent] == null) && indent > 0) {
        indent--;
      }
      this.interpreter.loops[indent] = null;
      return this.interpreter.indent = indent;
    };


    /**
    * @method commandListAdd
    * @protected
     */

    Component_CommandInterpreter.prototype.commandListAdd = function() {
      var list;
      list = this.interpreter.listObjectOf(this.params.listVariable);
      switch (this.params.valueType) {
        case 0:
          list.push(this.interpreter.numberValueOf(this.params.numberValue));
          break;
        case 1:
          list.push(this.interpreter.booleanValueOf(this.params.switchValue));
          break;
        case 2:
          list.push(this.interpreter.stringValueOf(this.params.stringValue));
          break;
        case 3:
          list.push(this.interpreter.listObjectOf(this.params.listValue));
      }
      return this.interpreter.setListObjectTo(this.params.listVariable, list);
    };


    /**
    * @method commandListPop
    * @protected
     */

    Component_CommandInterpreter.prototype.commandListPop = function() {
      var list, ref, value;
      list = this.interpreter.listObjectOf(this.params.listVariable);
      value = (ref = list.pop()) != null ? ref : 0;
      return this.interpreter.storeListValue(this.params.targetVariable, list, value, this.params.valueType);
    };


    /**
    * @method commandListShift
    * @protected
     */

    Component_CommandInterpreter.prototype.commandListShift = function() {
      var list, ref, value;
      list = this.interpreter.listObjectOf(this.params.listVariable);
      value = (ref = list.shift()) != null ? ref : 0;
      return this.interpreter.storeListValue(this.params.targetVariable, list, value, this.params.valueType);
    };


    /**
    * @method commandListIndexOf
    * @protected
     */

    Component_CommandInterpreter.prototype.commandListIndexOf = function() {
      var list, value;
      list = this.interpreter.listObjectOf(this.params.listVariable);
      value = -1;
      switch (this.params.valueType) {
        case 0:
          value = list.indexOf(this.interpreter.numberValueOf(this.params.numberValue));
          break;
        case 1:
          value = list.indexOf(this.interpreter.booleanValueOf(this.params.switchValue));
          break;
        case 2:
          value = list.indexOf(this.interpreter.stringValueOf(this.params.stringValue));
          break;
        case 3:
          value = list.indexOf(this.interpreter.listObjectOf(this.params.listValue));
      }
      return this.interpreter.setNumberValueTo(this.params.targetVariable, value);
    };


    /**
    * @method commandListClear
    * @protected
     */

    Component_CommandInterpreter.prototype.commandListClear = function() {
      var list;
      list = this.interpreter.listObjectOf(this.params.listVariable);
      return list.length = 0;
    };


    /**
    * @method commandListValueAt
    * @protected
     */

    Component_CommandInterpreter.prototype.commandListValueAt = function() {
      var index, list, ref, value;
      list = this.interpreter.listObjectOf(this.params.listVariable);
      index = this.interpreter.numberValueOf(this.params.index);
      if (index >= 0 && index < list.length) {
        value = (ref = list[index]) != null ? ref : 0;
        return this.interpreter.storeListValue(this.params.targetVariable, list, value, this.params.valueType);
      }
    };


    /**
    * @method commandListRemoveAt
    * @protected
     */

    Component_CommandInterpreter.prototype.commandListRemoveAt = function() {
      var index, list;
      list = this.interpreter.listObjectOf(this.params.listVariable);
      index = this.interpreter.numberValueOf(this.params.index);
      if (index >= 0 && index < list.length) {
        return list.splice(index, 1);
      }
    };


    /**
    * @method commandListInsertAt
    * @protected
     */

    Component_CommandInterpreter.prototype.commandListInsertAt = function() {
      var index, list;
      list = this.interpreter.listObjectOf(this.params.listVariable);
      index = this.interpreter.numberValueOf(this.params.index);
      if (index >= 0 && index < list.length) {
        switch (this.params.valueType) {
          case 0:
            list.splice(index, 0, this.interpreter.numberValueOf(this.params.numberValue));
            break;
          case 1:
            list.splice(index, 0, this.interpreter.booleanValueOf(this.params.switchValue));
            break;
          case 2:
            list.splice(index, 0, this.interpreter.stringValueOf(this.params.stringValue));
            break;
          case 3:
            list.splice(index, 0, this.interpreter.listObjectOf(this.params.listValue));
        }
        return this.interpreter.setListObjectTo(this.params.listVariable, list);
      }
    };


    /**
    * @method commandListSet
    * @protected
     */

    Component_CommandInterpreter.prototype.commandListSet = function() {
      var index, list;
      list = this.interpreter.listObjectOf(this.params.listVariable);
      index = this.interpreter.numberValueOf(this.params.index);
      if (index >= 0) {
        switch (this.params.valueType) {
          case 0:
            list[index] = this.interpreter.numberValueOf(this.params.numberValue);
            break;
          case 1:
            list[index] = this.interpreter.booleanValueOf(this.params.switchValue);
            break;
          case 2:
            list[index] = this.interpreter.stringValueOf(this.params.stringValue);
            break;
          case 3:
            list[index] = this.interpreter.listObjectOf(this.params.listValue);
        }
        return this.interpreter.setListObjectTo(this.params.listVariable, list);
      }
    };


    /**
    * @method commandListCopy
    * @protected
     */

    Component_CommandInterpreter.prototype.commandListCopy = function() {
      var copy, list;
      list = this.interpreter.listObjectOf(this.params.listVariable);
      copy = Object.deepCopy(list);
      return this.interpreter.setListObjectTo(this.params.targetVariable, copy);
    };


    /**
    * @method commandListLength
    * @protected
     */

    Component_CommandInterpreter.prototype.commandListLength = function() {
      var list;
      list = this.interpreter.listObjectOf(this.params.listVariable);
      return this.interpreter.setNumberValueTo(this.params.targetVariable, list.length);
    };


    /**
    * @method commandListJoin
    * @protected
     */

    Component_CommandInterpreter.prototype.commandListJoin = function() {
      var list, value;
      list = this.interpreter.listObjectOf(this.params.listVariable);
      value = this.params.order === 0 ? list.join(this.params.separator || "") : list.reverse().join(this.params.separator || "");
      return this.interpreter.setStringValueTo(this.params.targetVariable, value);
    };


    /**
    * @method commandListFromText
    * @protected
     */

    Component_CommandInterpreter.prototype.commandListFromText = function() {
      var list, separator, text;
      text = this.interpreter.stringValueOf(this.params.textVariable);
      separator = this.interpreter.stringValueOf(this.params.separator);
      list = text.split(separator);
      return this.interpreter.setListObjectTo(this.params.targetVariable, list);
    };


    /**
    * @method commandListShuffle
    * @protected
     */

    Component_CommandInterpreter.prototype.commandListShuffle = function() {
      var i, j, k, list, ref, results, tempi, tempj;
      list = this.interpreter.listObjectOf(this.params.listVariable);
      if (list.length === 0) {
        return;
      }
      results = [];
      for (i = k = ref = list.length - 1; ref <= 1 ? k <= 1 : k >= 1; i = ref <= 1 ? ++k : --k) {
        j = Math.floor(Math.random() * (i + 1));
        tempi = list[i];
        tempj = list[j];
        list[i] = tempj;
        results.push(list[j] = tempi);
      }
      return results;
    };


    /**
    * @method commandListSort
    * @protected
     */

    Component_CommandInterpreter.prototype.commandListSort = function() {
      var list;
      list = this.interpreter.listObjectOf(this.params.listVariable);
      if (list.length === 0) {
        return;
      }
      switch (this.params.sortOrder) {
        case 0:
          return list.sort(function(a, b) {
            if (a < b) {
              return -1;
            }
            if (a > b) {
              return 1;
            }
            return 0;
          });
        case 1:
          return list.sort(function(a, b) {
            if (a > b) {
              return -1;
            }
            if (a < b) {
              return 1;
            }
            return 0;
          });
      }
    };


    /**
    * @method commandResetVariables
    * @protected
     */

    Component_CommandInterpreter.prototype.commandResetVariables = function() {
      var range;
      switch (this.params.target) {
        case 0:
          range = null;
          break;
        case 1:
          range = this.params.range;
      }
      switch (this.params.scope) {
        case 0:
          if (this.params.scene) {
            return GameManager.variableStore.clearLocalVariables({
              id: this.params.scene.uid
            }, this.params.type, range);
          }
          break;
        case 1:
          return GameManager.variableStore.clearLocalVariables(null, this.params.type, range);
        case 2:
          return GameManager.variableStore.clearGlobalVariables(this.params.type, range);
        case 3:
          GameManager.variableStore.clearPersistentVariables(this.params.type, range);
          return GameManager.saveGlobalData();
      }
    };


    /**
    * @method commandChangeVariableDomain
    * @protected
     */

    Component_CommandInterpreter.prototype.commandChangeVariableDomain = function() {
      return GameManager.variableStore.changeDomain(this.interpreter.stringValueOf(this.params.domain));
    };


    /**
    * @method commandChangeDecimalVariables
    * @protected
     */

    Component_CommandInterpreter.prototype.commandChangeDecimalVariables = function() {
      return this.interpreter.changeDecimalVariables(this.params, this.params.roundMethod);
    };


    /**
    * @method commandChangeNumberVariables
    * @protected
     */

    Component_CommandInterpreter.prototype.commandChangeNumberVariables = function() {
      var diff, end, i, index, k, ref, ref1, scope, source, start;
      source = 0;
      switch (this.params.source) {
        case 0:
          source = this.interpreter.numberValueOf(this.params.sourceValue);
          break;
        case 1:
          start = this.interpreter.numberValueOf(this.params.sourceRandom.start);
          end = this.interpreter.numberValueOf(this.params.sourceRandom.end);
          diff = end - start;
          source = Math.floor(start + Math.random() * (diff + 1));
          break;
        case 2:
          source = this.interpreter.numberValueAtIndex(this.params.sourceScope, this.interpreter.numberValueOf(this.params.sourceReference) - 1, this.params.sourceReferenceDomain);
          break;
        case 3:
          source = this.interpreter.numberValueOfGameData(this.params.sourceValue1);
          break;
        case 4:
          source = this.interpreter.numberValueOfDatabaseData(this.params.sourceValue1);
      }
      switch (this.params.target) {
        case 0:
          switch (this.params.operation) {
            case 0:
              this.interpreter.setNumberValueTo(this.params.targetVariable, source);
              break;
            case 1:
              this.interpreter.setNumberValueTo(this.params.targetVariable, this.interpreter.numberValueOf(this.params.targetVariable) + source);
              break;
            case 2:
              this.interpreter.setNumberValueTo(this.params.targetVariable, this.interpreter.numberValueOf(this.params.targetVariable) - source);
              break;
            case 3:
              this.interpreter.setNumberValueTo(this.params.targetVariable, this.interpreter.numberValueOf(this.params.targetVariable) * source);
              break;
            case 4:
              this.interpreter.setNumberValueTo(this.params.targetVariable, Math.floor(this.interpreter.numberValueOf(this.params.targetVariable) / source));
              break;
            case 5:
              this.interpreter.setNumberValueTo(this.params.targetVariable, this.interpreter.numberValueOf(this.params.targetVariable) % source);
          }
          break;
        case 1:
          scope = this.params.targetScope;
          start = this.params.targetRange.start - 1;
          end = this.params.targetRange.end - 1;
          for (i = k = ref = start, ref1 = end; ref <= ref1 ? k <= ref1 : k >= ref1; i = ref <= ref1 ? ++k : --k) {
            switch (this.params.operation) {
              case 0:
                this.interpreter.setNumberValueAtIndex(scope, i, source);
                break;
              case 1:
                this.interpreter.setNumberValueAtIndex(scope, i, this.interpreter.numberValueAtIndex(scope, i) + source);
                break;
              case 2:
                this.interpreter.setNumberValueAtIndex(scope, i, this.interpreter.numberValueAtIndex(scope, i) - source);
                break;
              case 3:
                this.interpreter.setNumberValueAtIndex(scope, i, this.interpreter.numberValueAtIndex(scope, i) * source);
                break;
              case 4:
                this.interpreter.setNumberValueAtIndex(scope, i, Math.floor(this.interpreter.numberValueAtIndex(scope, i) / source));
                break;
              case 5:
                this.interpreter.setNumberValueAtIndex(scope, i, this.interpreter.numberValueAtIndex(scope, i) % source);
            }
          }
          break;
        case 2:
          index = this.interpreter.numberValueOf(this.params.targetReference) - 1;
          switch (this.params.operation) {
            case 0:
              this.interpreter.setNumberValueAtIndex(this.params.targetScope, index, source, this.params.targetReferenceDomain);
              break;
            case 1:
              this.interpreter.setNumberValueAtIndex(this.params.targetScope, index, this.interpreter.numberValueAtIndex(this.params.targetScope, index, this.params.targetReferenceDomain) + source, this.params.targetReferenceDomain);
              break;
            case 2:
              this.interpreter.setNumberValueAtIndex(this.params.targetScope, index, this.interpreter.numberValueAtIndex(this.params.targetScope, index, this.params.targetReferenceDomain) - source, this.params.targetReferenceDomain);
              break;
            case 3:
              this.interpreter.setNumberValueAtIndex(this.params.targetScope, index, this.interpreter.numberValueAtIndex(this.params.targetScope, index, this.params.targetReferenceDomain) * source, this.params.targetReferenceDomain);
              break;
            case 4:
              this.interpreter.setNumberValueAtIndex(this.params.targetScope, index, Math.floor(this.interpreter.numberValueAtIndex(this.params.targetScope, index, this.params.targetReferenceDomain) / source), this.params.targetReferenceDomain);
              break;
            case 5:
              this.interpreter.setNumberValueAtIndex(this.params.targetScope, index, this.interpreter.numberValueAtIndex(this.params.targetScope, index, this.params.targetReferenceDomain) % source, this.params.targetReferenceDomain);
          }
      }
      return null;
    };


    /**
    * @method commandChangeBooleanVariables
    * @protected
     */

    Component_CommandInterpreter.prototype.commandChangeBooleanVariables = function() {
      var i, index, k, ref, ref1, source, targetValue, variable;
      source = this.interpreter.booleanValueOf(this.params.value);
      switch (this.params.target) {
        case 0:
          if (this.params.value === 2) {
            targetValue = this.interpreter.booleanValueOf(this.params.targetVariable);
            this.interpreter.setBooleanValueTo(this.params.targetVariable, targetValue ? false : true);
          } else {
            this.interpreter.setBooleanValueTo(this.params.targetVariable, source);
          }
          break;
        case 1:
          variable = {
            index: 0,
            scope: this.params.targetRangeScope
          };
          for (i = k = ref = this.params.rangeStart - 1, ref1 = this.params.rangeEnd - 1; ref <= ref1 ? k <= ref1 : k >= ref1; i = ref <= ref1 ? ++k : --k) {
            variable.index = i;
            if (this.params.value === 2) {
              targetValue = this.interpreter.booleanValueOf(variable);
              this.interpreter.setBooleanValueTo(variable, targetValue ? false : true);
            } else {
              this.interpreter.setBooleanValueTo(variable, source);
            }
          }
          break;
        case 2:
          index = this.interpreter.numberValueOf(this.params.targetReference) - 1;
          this.interpreter.setBooleanValueAtIndex(this.params.targetRangeScope, index, source, this.params.targetReferenceDomain);
      }
      return null;
    };


    /**
    * @method commandChangeStringVariables
    * @protected
     */

    Component_CommandInterpreter.prototype.commandChangeStringVariables = function() {
      var ex, i, index, k, ref, ref1, source, targetValue, variable;
      source = "";
      switch (this.params.source) {
        case 0:
          source = lcs(this.params.textValue);
          break;
        case 1:
          source = this.interpreter.stringValueOf(this.params.sourceVariable);
          break;
        case 2:
          source = this.interpreter.stringValueOfDatabaseData(this.params.databaseData);
          break;
        case 2:
          try {
            source = eval(this.params.script);
          } catch (error) {
            ex = error;
            source = "ERR: " + ex.message;
          }
          break;
        default:
          source = lcs(this.params.textValue);
      }
      switch (this.params.target) {
        case 0:
          switch (this.params.operation) {
            case 0:
              this.interpreter.setStringValueTo(this.params.targetVariable, source);
              break;
            case 1:
              this.interpreter.setStringValueTo(this.params.targetVariable, this.interpreter.stringValueOf(this.params.targetVariable) + source);
              break;
            case 2:
              this.interpreter.setStringValueTo(this.params.targetVariable, this.interpreter.stringValueOf(this.params.targetVariable).toUpperCase());
              break;
            case 3:
              this.interpreter.setStringValueTo(this.params.targetVariable, this.interpreter.stringValueOf(this.params.targetVariable).toLowerCase());
          }
          break;
        case 1:
          variable = {
            index: 0,
            scope: this.params.targetRangeScope
          };
          for (i = k = ref = this.params.rangeStart - 1, ref1 = this.params.rangeEnd - 1; ref <= ref1 ? k <= ref1 : k >= ref1; i = ref <= ref1 ? ++k : --k) {
            variable.index = i;
            switch (this.params.operation) {
              case 0:
                this.interpreter.setStringValueTo(variable, source);
                break;
              case 1:
                this.interpreter.setStringValueTo(variable, this.interpreter.stringValueOf(variable) + source);
                break;
              case 2:
                this.interpreter.setStringValueTo(variable, this.interpreter.stringValueOf(variable).toUpperCase());
                break;
              case 3:
                this.interpreter.setStringValueTo(variable, this.interpreter.stringValueOf(variable).toLowerCase());
            }
          }
          break;
        case 2:
          index = this.interpreter.numberValueOf(this.params.targetReference) - 1;
          switch (this.params.operation) {
            case 0:
              this.interpreter.setStringValueAtIndex(this.params.targetRangeScope, index, source, this.params.targetReferenceDomain);
              break;
            case 1:
              targetValue = this.interpreter.stringValueAtIndex(this.params.targetRangeScope, index, this.params.targetReferenceDomain);
              this.interpreter.setStringValueAtIndex(this.params.targetRangeScope, index, targetValue + source, this.params.targetReferenceDomain);
              break;
            case 2:
              targetValue = this.interpreter.stringValueAtIndex(this.params.targetRangeScope, index, this.params.targetReferenceDomain);
              this.interpreter.setStringValueAtIndex(this.params.targetRangeScope, index, targetValue.toUpperCase(), this.params.targetReferenceDomain);
              break;
            case 3:
              targetValue = this.interpreter.stringValueAtIndex(this.params.targetRangeScope, index, this.params.targetReferenceDomain);
              this.interpreter.setStringValueTo(this.params.targetRangeScope, index, targetValue.toLowerCase(), this.params.targetReferenceDomain);
          }
      }
      return null;
    };


    /**
    * @method commandCheckSwitch
    * @protected
     */

    Component_CommandInterpreter.prototype.commandCheckSwitch = function() {
      var result;
      result = this.interpreter.booleanValueOf(this.params.targetVariable) && this.params.value;
      if (result) {
        return this.interpreter.pointer = this.params.labelIndex;
      }
    };


    /**
    * @method commandNumberCondition
    * @protected
     */

    Component_CommandInterpreter.prototype.commandNumberCondition = function() {
      var result;
      result = this.interpreter.compare(this.interpreter.numberValueOf(this.params.targetVariable), this.interpreter.numberValueOf(this.params.value), this.params.operation);
      this.interpreter.conditions[this.interpreter.indent] = result;
      if (result) {
        return this.interpreter.indent++;
      }
    };


    /**
    * @method commandCondition
    * @protected
     */

    Component_CommandInterpreter.prototype.commandCondition = function() {
      var result;
      switch (this.params.valueType) {
        case 0:
          result = this.interpreter.compare(this.interpreter.numberValueOf(this.params.variable), this.interpreter.numberValueOf(this.params.numberValue), this.params.operation);
          break;
        case 1:
          result = this.interpreter.compare(this.interpreter.booleanValueOf(this.params.variable), this.interpreter.booleanValueOf(this.params.switchValue), this.params.operation);
          break;
        case 2:
          result = this.interpreter.compare(lcs(this.interpreter.stringValueOf(this.params.variable)), lcs(this.interpreter.stringValueOf(this.params.textValue)), this.params.operation);
      }
      this.interpreter.conditions[this.interpreter.indent] = result;
      if (result) {
        return this.interpreter.indent++;
      }
    };


    /**
    * @method commandConditionElse
    * @protected
     */

    Component_CommandInterpreter.prototype.commandConditionElse = function() {
      if (!this.interpreter.conditions[this.interpreter.indent]) {
        return this.interpreter.indent++;
      }
    };


    /**
    * @method commandConditionElseIf
    * @protected
     */

    Component_CommandInterpreter.prototype.commandConditionElseIf = function() {
      if (!this.interpreter.conditions[this.interpreter.indent]) {
        return this.interpreter.commandCondition.call(this);
      }
    };


    /**
    * @method commandCheckNumberVariable
    * @protected
     */

    Component_CommandInterpreter.prototype.commandCheckNumberVariable = function() {
      var result;
      result = this.interpreter.compare(this.interpreter.numberValueOf(this.params.targetVariable), this.interpreter.numberValueOf(this.params.value), this.params.operation);
      if (result) {
        return this.interpreter.pointer = this.params.labelIndex;
      }
    };


    /**
    * @method commandCheckTextVariable
    * @protected
     */

    Component_CommandInterpreter.prototype.commandCheckTextVariable = function() {
      var result, text1, text2;
      result = false;
      text1 = this.interpreter.stringValueOf(this.params.targetVariable);
      text2 = this.interpreter.stringValueOf(this.params.value);
      switch (this.params.operation) {
        case 0:
          result = text1 === text2;
          break;
        case 1:
          result = text1 !== text2;
          break;
        case 2:
          result = text1.length > text2.length;
          break;
        case 3:
          result = text1.length >= text2.length;
          break;
        case 4:
          result = text1.length < text2.length;
          break;
        case 5:
          result = text1.length <= text2.length;
      }
      if (result) {
        return this.interpreter.pointer = this.params.labelIndex;
      }
    };


    /**
    * @method commandLabel
    * @protected
     */

    Component_CommandInterpreter.prototype.commandLabel = function() {};


    /**
    * @method commandJumpToLabel
    * @protected
     */

    Component_CommandInterpreter.prototype.commandJumpToLabel = function() {
      var label;
      label = this.params.labelIndex;
      if (label != null) {
        this.interpreter.pointer = label;
        return this.interpreter.indent = this.interpreter.object.commands[label].indent;
      } else {
        switch (this.params.target) {
          case "activeContext":
            return this.interpreter.jumpToLabel(this.interpreter.stringValueOf(this.params.name));
          case "activeScene":
            return SceneManager.scene.interpreter.jumpToLabel(this.interpreter.stringValueOf(this.params.name));
          default:
            return this.interpreter.jumpToLabel(this.interpreter.stringValueOf(this.params.name));
        }
      }
    };


    /**
    * @method commandClearMessage
    * @protected
     */

    Component_CommandInterpreter.prototype.commandClearMessage = function() {
      var duration, fading, flags, isLocked, messageObject, scene;
      scene = SceneManager.scene;
      messageObject = this.interpreter.targetMessage();
      if (messageObject == null) {
        return;
      }
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      duration = 0;
      fading = GameManager.tempSettings.messageFading;
      if (!GameManager.tempSettings.skip) {
        duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : fading.duration;
      }
      messageObject.animator.disappear(fading.animation, fading.easing, duration, gs.CallBack("onMessageADVClear", this.interpreter));
      this.interpreter.waitForCompletion(messageObject, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandMessageBoxDefaults
    * @protected
     */

    Component_CommandInterpreter.prototype.commandMessageBoxDefaults = function() {
      var defaults, flags, isLocked;
      defaults = GameManager.defaults.messageBox;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      if (!isLocked(flags.appearDuration)) {
        defaults.appearDuration = this.interpreter.durationValueOf(this.params.appearDuration);
      }
      if (!isLocked(flags.disappearDuration)) {
        defaults.disappearDuration = this.interpreter.durationValueOf(this.params.disappearDuration);
      }
      if (!isLocked(flags.zOrder)) {
        defaults.zOrder = this.interpreter.numberValueOf(this.params.zOrder);
      }
      if (!isLocked(flags["appearEasing.type"])) {
        defaults.appearEasing = this.params.appearEasing;
      }
      if (!isLocked(flags["appearAnimation.type"])) {
        defaults.appearAnimation = this.params.appearAnimation;
      }
      if (!isLocked(flags["disappearEasing.type"])) {
        defaults.disappearEasing = this.params.disappearEasing;
      }
      if (!isLocked(flags["disappearAnimation.type"])) {
        return defaults.disappearAnimation = this.params.disappearAnimation;
      }
    };


    /**
    * @method commandShowMessage
    * @protected
     */

    Component_CommandInterpreter.prototype.commandShowMessage = function() {
      var animation, character, defaults, duration, easing, expression, ref, scene, showMessage;
      scene = SceneManager.scene;
      scene.messageMode = vn.MessageMode.ADV;
      character = scene.characters.first((function(_this) {
        return function(v) {
          return !v.disposed && v.rid === _this.params.characterId;
        };
      })(this));
      showMessage = (function(_this) {
        return function() {
          var messageObject, ref, settings, voiceSettings;
          character = RecordManager.characters[_this.params.characterId];
          scene.layout.visible = true;
          messageObject = _this.interpreter.targetMessage();
          if (messageObject == null) {
            return;
          }
          scene.currentCharacter = character;
          messageObject.character = character;
          messageObject.opacity = 255;
          messageObject.events.offByOwner("callCommonEvent", _this.interpreter);
          messageObject.events.on("callCommonEvent", gs.CallBack("onCallCommonEvent", _this.interpreter), {
            params: _this.params
          }, _this.interpreter);
          messageObject.events.once("finish", gs.CallBack("onMessageADVFinish", _this.interpreter), {
            params: _this.params
          }, _this.interpreter);
          messageObject.events.once("waiting", gs.CallBack("onMessageADVWaiting", _this.interpreter), {
            params: _this.params
          }, _this.interpreter);
          if (messageObject.settings.useCharacterColor) {
            messageObject.message.showMessage(_this.interpreter, _this.params, character);
          } else {
            messageObject.message.showMessage(_this.interpreter, _this.params);
          }
          settings = GameManager.settings;
          voiceSettings = settings.voicesByCharacter[character.index];
          if ((_this.params.voice != null) && GameManager.settings.voiceEnabled && (!voiceSettings || voiceSettings > 0)) {
            if ((GameManager.settings.skipVoiceOnAction || !((ref = AudioManager.voice) != null ? ref.playing : void 0)) && !GameManager.tempSettings.skip) {
              messageObject.voice = _this.params.voice;
              return messageObject.behavior.voice = AudioManager.playVoice(_this.params.voice);
            }
          } else {
            return messageObject.behavior.voice = null;
          }
        };
      })(this);
      if ((this.params.expressionId != null) && (character != null)) {
        expression = RecordManager.characterExpressions[this.params.expressionId || 0];
        defaults = GameManager.defaults.character;
        duration = !gs.CommandFieldFlags.isLocked(this.params.fieldFlags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.expressionDuration;
        easing = gs.Easings.fromObject(defaults.changeEasing);
        animation = defaults.changeAnimation;
        character.behavior.changeExpression(expression, animation, easing, duration, (function(_this) {
          return function() {
            return showMessage();
          };
        })(this));
      } else {
        showMessage();
      }
      this.interpreter.isWaiting = ((ref = this.params.waitForCompletion) != null ? ref : true) && !(GameManager.tempSettings.skip && GameManager.tempSettings.skipTime === 0);
      return this.interpreter.waitingFor.messageADV = this.params;
    };


    /**
    * @method commandSetMessageArea
    * @protected
     */

    Component_CommandInterpreter.prototype.commandSetMessageArea = function() {
      var messageLayout, number, scene;
      scene = SceneManager.scene;
      number = this.interpreter.numberValueOf(this.params.number);
      if (scene.messageAreas[number]) {
        messageLayout = scene.messageAreas[number].layout;
        messageLayout.dstRect.x = this.params.box.x;
        messageLayout.dstRect.y = this.params.box.y;
        messageLayout.dstRect.width = this.params.box.size.width;
        messageLayout.dstRect.height = this.params.box.size.height;
        return messageLayout.needsUpdate = true;
      }
    };


    /**
    * @method commandMessageFading
    * @protected
     */

    Component_CommandInterpreter.prototype.commandMessageFading = function() {
      return GameManager.tempSettings.messageFading = {
        duration: this.interpreter.durationValueOf(this.params.duration),
        animation: this.params.animation,
        easing: gs.Easings.fromObject(this.params.easing)
      };
    };


    /**
    * @method commandMessageSettings
    * @protected
     */

    Component_CommandInterpreter.prototype.commandMessageSettings = function() {
      var flags, font, fontName, fontSize, isLocked, messageObject, messageSettings, ref, ref1, ref2, ref3, ref4, ref5;
      messageObject = this.interpreter.targetMessage();
      if (!messageObject) {
        return;
      }
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      messageSettings = this.interpreter.messageSettings();
      if (!isLocked(flags.autoErase)) {
        messageSettings.autoErase = this.params.autoErase;
      }
      if (!isLocked(flags.waitAtEnd)) {
        messageSettings.waitAtEnd = this.params.waitAtEnd;
      }
      if (!isLocked(flags.backlog)) {
        messageSettings.backlog = this.params.backlog;
      }
      if (!isLocked(flags.lineHeight)) {
        messageSettings.lineHeight = this.params.lineHeight;
      }
      if (!isLocked(flags.lineSpacing)) {
        messageSettings.lineSpacing = this.params.lineSpacing;
      }
      if (!isLocked(flags.linePadding)) {
        messageSettings.linePadding = this.params.linePadding;
      }
      if (!isLocked(flags.paragraphSpacing)) {
        messageSettings.paragraphSpacing = this.params.paragraphSpacing;
      }
      if (!isLocked(flags.useCharacterColor)) {
        messageSettings.useCharacterColor = this.params.useCharacterColor;
      }
      messageObject.textRenderer.minLineHeight = (ref = messageSettings.lineHeight) != null ? ref : 0;
      messageObject.textRenderer.lineSpacing = (ref1 = messageSettings.lineSpacing) != null ? ref1 : messageObject.textRenderer.lineSpacing;
      messageObject.textRenderer.padding = (ref2 = messageSettings.linePadding) != null ? ref2 : messageObject.textRenderer.padding;
      fontName = !isLocked(flags.font) ? this.params.font : messageObject.font.name;
      fontSize = !isLocked(flags.size) ? this.params.size : messageObject.font.size;
      font = messageObject.font;
      if (!isLocked(flags.font) || !isLocked(flags.size)) {
        messageObject.font = new Font(fontName, fontSize);
      }
      if (!isLocked(flags.bold)) {
        messageObject.font.bold = this.params.bold;
      }
      if (!isLocked(flags.italic)) {
        messageObject.font.italic = this.params.italic;
      }
      if (!isLocked(flags.smallCaps)) {
        messageObject.font.smallCaps = this.params.smallCaps;
      }
      if (!isLocked(flags.underline)) {
        messageObject.font.underline = this.params.underline;
      }
      if (!isLocked(flags.strikeThrough)) {
        messageObject.font.strikeThrough = this.params.strikeThrough;
      }
      if (!isLocked(flags.color)) {
        messageObject.font.color = new Color(this.params.color);
      }
      messageObject.font.color = (flags.color != null) && !isLocked(flags.color) ? new Color(this.params.color) : font.color;
      messageObject.font.border = (flags.outline != null) && !isLocked(flags.outline) ? this.params.outline : font.border;
      messageObject.font.borderColor = (flags.outlineColor != null) && !isLocked(flags.outlineColor) ? new Color(this.params.outlineColor) : new Color(font.borderColor);
      messageObject.font.borderSize = (flags.outlineSize != null) && !isLocked(flags.outlineSize) ? (ref3 = this.params.outlineSize) != null ? ref3 : 4 : font.borderSize;
      messageObject.font.shadow = (flags.shadow != null) && !isLocked(flags.shadow) ? this.params.shadow : font.shadow;
      messageObject.font.shadowColor = (flags.shadowColor != null) && !isLocked(flags.shadowColor) ? new Color(this.params.shadowColor) : new Color(font.shadowColor);
      messageObject.font.shadowOffsetX = (flags.shadowOffsetX != null) && !isLocked(flags.shadowOffsetX) ? (ref4 = this.params.shadowOffsetX) != null ? ref4 : 1 : font.shadowOffsetX;
      messageObject.font.shadowOffsetY = (flags.shadowOffsetY != null) && !isLocked(flags.shadowOffsetY) ? (ref5 = this.params.shadowOffsetY) != null ? ref5 : 1 : font.shadowOffsetY;
      if (isLocked(flags.bold)) {
        messageObject.font.bold = font.bold;
      }
      if (isLocked(flags.italic)) {
        messageObject.font.italic = font.italic;
      }
      if (isLocked(flags.smallCaps)) {
        return messageObject.font.smallCaps = font.smallCaps;
      }
    };


    /**
    * @method commandCreateMessageArea
    * @protected
     */

    Component_CommandInterpreter.prototype.commandCreateMessageArea = function() {
      var messageArea, number, scene;
      number = this.interpreter.numberValueOf(this.params.number);
      scene = SceneManager.scene;
      scene.behavior.changeMessageAreaDomain(this.params.numberDomain);
      if (!scene.messageAreas[number]) {
        messageArea = new gs.Object_MessageArea();
        messageArea.layout = ui.UIManager.createControlFromDescriptor({
          type: "ui.CustomGameMessage",
          id: "customGameMessage_" + number,
          params: {
            id: "customGameMessage_" + number
          }
        }, messageArea);
        messageArea.message = gs.ObjectManager.current.objectById("customGameMessage_" + number + "_message");
        messageArea.message.domain = this.params.numberDomain;
        messageArea.addObject(messageArea.layout);
        messageArea.layout.dstRect.x = this.params.box.x;
        messageArea.layout.dstRect.y = this.params.box.y;
        messageArea.layout.dstRect.width = this.params.box.size.width;
        messageArea.layout.dstRect.height = this.params.box.size.height;
        messageArea.layout.needsUpdate = true;
        return scene.messageAreas[number] = messageArea;
      }
    };


    /**
    * @method commandEraseMessageArea
    * @protected
     */

    Component_CommandInterpreter.prototype.commandEraseMessageArea = function() {
      var area, number, scene;
      number = this.interpreter.numberValueOf(this.params.number);
      scene = SceneManager.scene;
      scene.behavior.changeMessageAreaDomain(this.params.numberDomain);
      area = scene.messageAreas[number];
      if (area != null) {
        area.layout.dispose();
      }
      return scene.messageAreas[number] = null;
    };


    /**
    * @method commandSetTargetMessage
    * @protected
     */

    Component_CommandInterpreter.prototype.commandSetTargetMessage = function() {
      var message, ref, ref1, scene, target;
      message = this.interpreter.targetMessage();
      if (message != null) {
        message.textRenderer.isWaiting = false;
      }
      if (message != null) {
        message.behavior.isWaiting = false;
      }
      scene = SceneManager.scene;
      scene.behavior.changeMessageAreaDomain(this.params.numberDomain);
      target = {
        type: this.params.type,
        id: null
      };
      switch (this.params.type) {
        case 0:
          target.id = this.params.id;
          break;
        case 1:
          target.id = this.interpreter.numberValueOf(this.params.number);
      }
      this.interpreter.settings.message.target = target;
      if (this.params.clear) {
        if ((ref = this.interpreter.targetMessage()) != null) {
          ref.behavior.clear();
        }
      }
      return (ref1 = this.interpreter.targetMessage()) != null ? ref1.visible = true : void 0;
    };


    /**
    * @method commandBacklogVisibility
    * @protected
     */

    Component_CommandInterpreter.prototype.commandBacklogVisibility = function() {
      var control;
      if (this.params.visible) {
        control = gs.ObjectManager.current.objectById("backlogBox");
        if (control == null) {
          control = gs.ObjectManager.current.objectById("backlog");
        }
        if (control != null) {
          control.dispose();
        }
        if (this.params.backgroundVisible) {
          return control = SceneManager.scene.behavior.createControl(this, {
            descriptor: "ui.MessageBacklogBox"
          });
        } else {
          return control = SceneManager.scene.behavior.createControl(this, {
            descriptor: "ui.MessageBacklog"
          });
        }
      } else {
        control = gs.ObjectManager.current.objectById("backlogBox");
        if (control == null) {
          control = gs.ObjectManager.current.objectById("backlog");
        }
        if (control == null) {
          control = gs.ObjectManager.current.objectById("backlogScrollView");
        }
        return control != null ? control.dispose() : void 0;
      }
    };


    /**
    * @method commandMessageVisibility
    * @protected
     */

    Component_CommandInterpreter.prototype.commandMessageVisibility = function() {
      var animation, defaults, duration, easing, flags, isLocked, message;
      defaults = GameManager.defaults.messageBox;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      message = this.interpreter.targetMessage();
      if ((message == null) || this.params.visible === message.visible) {
        return;
      }
      if (this.params.visible) {
        duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.appearDuration;
        easing = !isLocked(flags["easing.type"]) ? gs.Easings.fromObject(this.params.easing) : gs.Easings.fromObject(defaults.appearEasing);
        animation = !isLocked(flags["animation.type"]) ? this.params.animation : defaults.appearAnimation;
        message.animator.appear(message.dstRect.x, message.dstRect.y, this.params.animation, easing, duration);
      } else {
        duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.disappearDuration;
        easing = !isLocked(flags["easing.type"]) ? gs.Easings.fromObject(this.params.easing) : gs.Easings.fromObject(defaults.disappearEasing);
        animation = !isLocked(flags["animation.type"]) ? this.params.animation : defaults.disappearAnimation;
        message.animator.disappear(animation, easing, duration, function() {
          return message.visible = false;
        });
      }
      message.update();
      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {
        this.interpreter.isWaiting = true;
        this.interpreter.waitCounter = duration;
      }
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandMessageBoxVisibility
    * @protected
     */

    Component_CommandInterpreter.prototype.commandMessageBoxVisibility = function() {
      var animation, defaults, duration, easing, flags, isLocked, messageBox, visible;
      defaults = GameManager.defaults.messageBox;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      messageBox = this.interpreter.messageBoxObject(this.interpreter.stringValueOf(this.params.id));
      visible = this.params.visible === 1;
      if ((messageBox == null) || visible === messageBox.visible) {
        return;
      }
      if (this.params.visible) {
        duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.appearDuration;
        easing = !isLocked(flags["easing.type"]) ? gs.Easings.fromObject(this.params.easing) : gs.Easings.fromObject(defaults.appearEasing);
        animation = !isLocked(flags["animation.type"]) ? this.params.animation : defaults.appearAnimation;
        messageBox.animator.appear(messageBox.dstRect.x, messageBox.dstRect.y, animation, easing, duration);
      } else {
        duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.disappearDuration;
        easing = !isLocked(flags["easing.type"]) ? gs.Easings.fromObject(this.params.easing) : gs.Easings.fromObject(defaults.disappearEasing);
        animation = !isLocked(flags["animation.type"]) ? this.params.animation : defaults.disappearAnimation;
        messageBox.animator.disappear(animation, easing, duration, function() {
          return messageBox.visible = false;
        });
      }
      messageBox.update();
      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {
        this.interpreter.isWaiting = true;
        this.interpreter.waitCounter = duration;
      }
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandUIAccess
    * @protected
     */

    Component_CommandInterpreter.prototype.commandUIAccess = function() {
      var flags, isLocked;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      if (!isLocked(flags.generalMenu)) {
        GameManager.tempSettings.menuAccess = this.interpreter.booleanValueOf(this.params.generalMenu);
      }
      if (!isLocked(flags.saveMenu)) {
        GameManager.tempSettings.saveMenuAccess = this.interpreter.booleanValueOf(this.params.saveMenu);
      }
      if (!isLocked(flags.loadMenu)) {
        GameManager.tempSettings.loadMenuAccess = this.interpreter.booleanValueOf(this.params.loadMenu);
      }
      if (!isLocked(flags.backlog)) {
        return GameManager.tempSettings.backlogAccess = this.interpreter.booleanValueOf(this.params.backlog);
      }
    };


    /**
    * @method commandUnlockCG
    * @protected
     */

    Component_CommandInterpreter.prototype.commandUnlockCG = function() {
      var cg;
      cg = RecordManager.cgGallery[this.interpreter.stringValueOf(this.params.cgId)];
      if (cg != null) {
        GameManager.globalData.cgGallery[cg.index] = {
          unlocked: true
        };
        return GameManager.saveGlobalData();
      }
    };


    /**
    * @method commandL2DMove
    * @protected
     */

    Component_CommandInterpreter.prototype.commandL2DMove = function() {
      var character, scene;
      scene = SceneManager.scene;
      character = scene.characters.first((function(_this) {
        return function(v) {
          return !v.disposed && v.rid === _this.params.characterId;
        };
      })(this));
      if (!character instanceof vn.Object_Live2DCharacter) {
        return;
      }
      this.interpreter.moveObject(character, this.params.position, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandL2DMotionGroup
    * @protected
     */

    Component_CommandInterpreter.prototype.commandL2DMotionGroup = function() {
      var character, motions, scene;
      scene = SceneManager.scene;
      character = scene.characters.first((function(_this) {
        return function(v) {
          return !v.disposed && v.rid === _this.params.characterId;
        };
      })(this));
      if (!character instanceof vn.Object_Live2DCharacter) {
        return;
      }
      character.motionGroup = {
        name: this.params.data.motionGroup,
        loop: this.params.loop,
        playType: this.params.playType
      };
      if (this.params.waitForCompletion && !this.params.loop) {
        motions = character.model.motionsByGroup[character.motionGroup.name];
        if (motions != null) {
          this.interpreter.isWaiting = true;
          this.interpreter.waitCounter = motions.sum(function(m) {
            return m.getDurationMSec() / 16.6;
          });
        }
      }
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandL2DMotion
    * @protected
     */

    Component_CommandInterpreter.prototype.commandL2DMotion = function() {
      var character, defaults, fadeInTime, flags, isLocked, motion, scene;
      defaults = GameManager.defaults.live2d;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      scene = SceneManager.scene;
      character = scene.characters.first((function(_this) {
        return function(v) {
          return !v.disposed && v.rid === _this.params.characterId;
        };
      })(this));
      if (!character instanceof vn.Object_Live2DCharacter) {
        return;
      }
      fadeInTime = !isLocked(flags.fadeInTime) ? this.params.fadeInTime : defaults.motionFadeInTime;
      character.motion = {
        name: this.params.data.motion,
        fadeInTime: fadeInTime,
        loop: this.params.loop
      };
      character.motionGroup = null;
      if (this.params.waitForCompletion && !this.params.loop) {
        motion = character.model.motions[character.motion.name];
        if (motion != null) {
          this.interpreter.isWaiting = true;
          this.interpreter.waitCounter = motion.getDurationMSec() / 16.6;
        }
      }
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandL2DExpression
    * @protected
     */

    Component_CommandInterpreter.prototype.commandL2DExpression = function() {
      var character, defaults, fadeInTime, flags, isLocked, scene;
      defaults = GameManager.defaults.live2d;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      scene = SceneManager.scene;
      character = scene.characters.first((function(_this) {
        return function(v) {
          return !v.disposed && v.rid === _this.params.characterId;
        };
      })(this));
      if (!character instanceof vn.Object_Live2DCharacter) {
        return;
      }
      fadeInTime = !isLocked(flags.fadeInTime) ? this.params.fadeInTime : defaults.expressionFadeInTime;
      character.expression = {
        name: this.params.data.expression,
        fadeInTime: fadeInTime
      };
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandL2DExitScene
    * @protected
     */

    Component_CommandInterpreter.prototype.commandL2DExitScene = function() {
      var defaults;
      defaults = GameManager.defaults.live2d;
      this.interpreter.commandCharacterExitScene.call(this, defaults);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandL2DSettings
    * @protected
     */

    Component_CommandInterpreter.prototype.commandL2DSettings = function() {
      var character, flags, isLocked, scene;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      scene = SceneManager.scene;
      character = scene.characters.first((function(_this) {
        return function(v) {
          return !v.disposed && v.rid === _this.params.characterId;
        };
      })(this));
      if (!(character != null ? character.visual.l2dObject : void 0)) {
        return;
      }
      if (!isLocked(flags.lipSyncSensitivity)) {
        character.visual.l2dObject.lipSyncSensitivity = this.interpreter.numberValueOf(this.params.lipSyncSensitivity);
      }
      if (!isLocked(flags.idleIntensity)) {
        character.visual.l2dObject.idleIntensity = this.interpreter.numberValueOf(this.params.idleIntensity);
      }
      if (!isLocked(flags.breathIntensity)) {
        character.visual.l2dObject.breathIntensity = this.interpreter.numberValueOf(this.params.breathIntensity);
      }
      if (!isLocked(flags["eyeBlink.enabled"])) {
        character.visual.l2dObject.eyeBlink.enabled = this.params.eyeBlink.enabled;
      }
      if (!isLocked(flags["eyeBlink.interval"])) {
        character.visual.l2dObject.eyeBlink.blinkIntervalMsec = this.interpreter.numberValueOf(this.params.eyeBlink.interval);
      }
      if (!isLocked(flags["eyeBlink.closedMotionTime"])) {
        character.visual.l2dObject.eyeBlink.closedMotionMsec = this.interpreter.numberValueOf(this.params.eyeBlink.closedMotionTime);
      }
      if (!isLocked(flags["eyeBlink.closingMotionTime"])) {
        character.visual.l2dObject.eyeBlink.closingMotionMsec = this.interpreter.numberValueOf(this.params.eyeBlink.closingMotionTime);
      }
      if (!isLocked(flags["eyeBlink.openingMotionTime"])) {
        character.visual.l2dObject.eyeBlink.openingMotionMsec = this.interpreter.numberValueOf(this.params.eyeBlink.openingMotionTime);
      }
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandL2DParameter
    * @protected
     */

    Component_CommandInterpreter.prototype.commandL2DParameter = function() {
      var character, duration, easing, scene;
      scene = SceneManager.scene;
      character = scene.characters.first((function(_this) {
        return function(v) {
          return !v.disposed && v.rid === _this.params.characterId;
        };
      })(this));
      if (!character instanceof vn.Object_Live2DCharacter) {
        return;
      }
      easing = gs.Easings.fromObject(this.params.easing);
      duration = this.interpreter.durationValueOf(this.params.duration);
      character.animator.l2dParameterTo(this.params.param.name, this.interpreter.numberValueOf(this.params.param.value), duration, easing);
      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {
        this.interpreter.isWaiting = true;
        this.interpreter.waitCounter = duration;
      }
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandL2DDefaults
    * @protected
     */

    Component_CommandInterpreter.prototype.commandL2DDefaults = function() {
      var defaults, flags, isLocked;
      defaults = GameManager.defaults.live2d;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      if (!isLocked(flags.appearDuration)) {
        defaults.appearDuration = this.interpreter.durationValueOf(this.params.appearDuration);
      }
      if (!isLocked(flags.disappearDuration)) {
        defaults.disappearDuration = this.interpreter.durationValueOf(this.params.disappearDuration);
      }
      if (!isLocked(flags.zOrder)) {
        defaults.zOrder = this.interpreter.numberValueOf(this.params.zOrder);
      }
      if (!isLocked(flags.motionFadeInTime)) {
        defaults.motionFadeInTime = this.interpreter.numberValueOf(this.params.motionFadeInTime);
      }
      if (!isLocked(flags["appearEasing.type"])) {
        defaults.appearEasing = this.params.appearEasing;
      }
      if (!isLocked(flags["appearAnimation.type"])) {
        defaults.appearAnimation = this.params.appearAnimation;
      }
      if (!isLocked(flags["disappearEasing.type"])) {
        defaults.disappearEasing = this.params.disappearEasing;
      }
      if (!isLocked(flags["disappearAnimation.type"])) {
        defaults.disappearAnimation = this.params.disappearAnimation;
      }
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandL2DJoinScene
    * @protected
     */

    Component_CommandInterpreter.prototype.commandL2DJoinScene = function() {
      var animation, character, defaults, duration, easing, flags, instant, isLocked, motionBlur, noAnim, origin, p, record, ref, ref1, ref2, ref3, ref4, ref5, scene, x, y, zIndex;
      defaults = GameManager.defaults.live2d;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      scene = SceneManager.scene;
      record = RecordManager.characters[this.interpreter.stringValueOf(this.params.characterId)];
      if (!record || scene.characters.first(function(v) {
        return !v.disposed && v.rid === record.index;
      })) {
        return;
      }
      if (this.params.positionType === 1) {
        x = this.params.position.x;
        y = this.params.position.y;
      } else if (this.params.positionType === 2) {
        x = this.interpreter.numberValueOf(this.params.position.x);
        y = this.interpreter.numberValueOf(this.params.position.y);
      }
      easing = !isLocked(flags["easing.type"]) ? gs.Easings.fromValues(this.interpreter.numberValueOf(this.params.easing.type), this.params.easing.inOut) : gs.Easings.fromObject(defaults.appearEasing);
      duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.appearDuration;
      zIndex = !isLocked(flags.zOrder) ? this.interpreter.numberValueOf(this.params.zOrder) : defaults.zOrder;
      animation = !isLocked(flags["animation.type"]) ? this.params.animation : defaults.appearAnimation;
      motionBlur = !isLocked(flags["motionBlur.enabled"]) ? this.params.motionBlur : defaults.motionBlur;
      origin = !isLocked(flags.origin) ? this.params.origin : defaults.origin;
      instant = duration === 0 || this.interpreter.isInstantSkip();
      noAnim = duration === 0 || GameManager.tempSettings.skip;
      if (this.params.waitForCompletion && !instant) {
        this.interpreter.isWaiting = true;
        this.interpreter.waitCounter = duration;
      }
      character = new vn.Object_Live2DCharacter(record);
      character.modelName = ((ref = this.params.model) != null ? ref.name : void 0) || "";
      character.model = ResourceManager.getLive2DModel("Live2D/" + character.modelName);
      if (character.model.motions) {
        character.motion = {
          name: "",
          fadeInTime: 0,
          loop: true
        };
      }
      character.dstRect.x = x;
      character.dstRect.y = y;
      character.anchor.x = !origin ? 0 : 0.5;
      character.anchor.y = !origin ? 0 : 0.5;
      character.blendMode = this.interpreter.numberValueOf(this.params.blendMode);
      character.zoom.x = this.params.position.zoom.d;
      character.zoom.y = this.params.position.zoom.d;
      character.zIndex = zIndex || 200;
      if ((ref1 = character.model) != null) {
        ref1.reset();
      }
      character.setup();
      character.visual.l2dObject.idleIntensity = (ref2 = record.idleIntensity) != null ? ref2 : 1.0;
      character.visual.l2dObject.breathIntensity = (ref3 = record.breathIntensity) != null ? ref3 : 1.0;
      character.visual.l2dObject.lipSyncSensitivity = (ref4 = record.lipSyncSensitivity) != null ? ref4 : 1.0;
      character.update();
      if (this.params.positionType === 0) {
        p = this.interpreter.predefinedObjectPosition(this.params.predefinedPositionId, character, this.params);
        character.dstRect.x = p.x;
        character.dstRect.y = p.y;
      }
      scene.behavior.addCharacter(character, noAnim, {
        animation: animation,
        duration: duration,
        easing: easing,
        motionBlur: motionBlur
      });
      if (((ref5 = this.params.viewport) != null ? ref5.type : void 0) === "ui") {
        character.viewport = Graphics.viewport;
      }
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandCharacterJoinScene
    * @protected
     */

    Component_CommandInterpreter.prototype.commandCharacterJoinScene = function() {
      var angle, animation, bitmap, character, characterId, defaults, duration, easing, expressionId, flags, instant, isLocked, mirror, motionBlur, noAnim, origin, p, record, ref, ref1, ref2, ref3, ref4, ref5, scene, x, y, zIndex, zoom;
      defaults = GameManager.defaults.character;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      scene = SceneManager.scene;
      characterId = this.interpreter.stringValueOf(this.params.characterId);
      expressionId = this.interpreter.stringValueOf(this.params.expressionId) || this.params.expressionId;
      record = RecordManager.characters[characterId];
      if (!record || scene.characters.first(function(v) {
        return !v.disposed && v.rid === record.index && !v.disposed;
      })) {
        return;
      }
      character = new vn.Object_Character(record, null, scene);
      character.expression = RecordManager.characterExpressions[expressionId != null ? expressionId : record.defaultExpressionId || 0];
      if ((ref = character.expression) != null ? (ref1 = ref.idle[0]) != null ? ref1.resource.name : void 0 : void 0) {
        bitmap = ResourceManager.getBitmap("Graphics/Characters/" + character.expression.idle[0].resource.name);
      }
      mirror = false;
      angle = 0;
      zoom = 1;
      if (this.params.positionType === 1) {
        x = this.interpreter.numberValueOf(this.params.position.x);
        y = this.interpreter.numberValueOf(this.params.position.y);
        mirror = this.params.position.horizontalFlip;
        angle = this.params.position.angle || 0;
        zoom = ((ref2 = this.params.position.data) != null ? ref2.zoom : void 0) || 1;
      } else if (this.params.positionType === 2) {
        x = this.interpreter.numberValueOf(this.params.position.x);
        y = this.interpreter.numberValueOf(this.params.position.y);
        mirror = false;
        angle = 0;
        zoom = 1;
      }
      easing = !isLocked(flags["easing.type"]) ? gs.Easings.fromValues(this.interpreter.numberValueOf(this.params.easing.type), this.params.easing.inOut) : gs.Easings.fromObject(defaults.appearEasing);
      duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.appearDuration;
      origin = !isLocked(flags.origin) ? this.params.origin : defaults.origin;
      zIndex = !isLocked(flags.zOrder) ? this.interpreter.numberValueOf(this.params.zOrder) : defaults.zOrder;
      animation = !isLocked(flags["animation.type"]) ? this.params.animation : defaults.appearAnimation;
      motionBlur = !isLocked(flags["motionBlur.enabled"]) ? this.params.motionBlur : defaults.motionBlur;
      instant = duration === 0 || this.interpreter.isInstantSkip();
      noAnim = duration === 0 || GameManager.tempSettings.skip;
      if (this.params.waitForCompletion && !instant) {
        this.interpreter.isWaiting = true;
        this.interpreter.waitCounter = duration;
      }
      if ((ref3 = character.expression) != null ? (ref4 = ref3.idle[0]) != null ? ref4.resource.name : void 0 : void 0) {
        bitmap = ResourceManager.getBitmap("Graphics/Characters/" + character.expression.idle[0].resource.name);
        if (origin === 1 && (bitmap != null)) {
          x += (bitmap.width * zoom - bitmap.width) / 2;
          y += (bitmap.height * zoom - bitmap.height) / 2;
        }
      }
      character.mirror = mirror;
      character.anchor.x = !origin ? 0 : 0.5;
      character.anchor.y = !origin ? 0 : 0.5;
      character.zoom.x = zoom;
      character.zoom.y = zoom;
      character.dstRect.x = x;
      character.dstRect.y = y;
      character.zIndex = zIndex || 200;
      character.blendMode = this.interpreter.numberValueOf(this.params.blendMode);
      character.angle = angle;
      character.setup();
      character.update();
      if (this.params.positionType === 0) {
        p = this.interpreter.predefinedObjectPosition(this.params.predefinedPositionId, character, this.params);
        character.dstRect.x = p.x;
        character.dstRect.y = p.y;
      }
      scene.behavior.addCharacter(character, noAnim, {
        animation: animation,
        duration: duration,
        easing: easing,
        motionBlur: motionBlur
      });
      if (((ref5 = this.params.viewport) != null ? ref5.type : void 0) === "ui") {
        character.viewport = Graphics.viewport;
      }
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandCharacterExitScene
    * @protected
     */

    Component_CommandInterpreter.prototype.commandCharacterExitScene = function(defaults) {
      var animation, character, characterId, duration, easing, flags, instant, isLocked, noAnim, scene;
      defaults = defaults || GameManager.defaults.character;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      characterId = this.interpreter.stringValueOf(this.params.characterId);
      scene = SceneManager.scene;
      character = scene.characters.first((function(_this) {
        return function(v) {
          return !v.disposed && v.rid === characterId;
        };
      })(this));
      easing = !isLocked(flags["easing.type"]) ? gs.Easings.fromValues(this.interpreter.numberValueOf(this.params.easing.type), this.params.easing.inOut) : gs.Easings.fromObject(defaults.disappearEasing);
      duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.disappearDuration;
      animation = !isLocked(flags["animation.type"]) ? this.params.animation : defaults.disappearAnimation;
      instant = duration === 0 || this.interpreter.isInstantSkip();
      noAnim = duration === 0 || GameManager.tempSettings.skip;
      if (this.params.waitForCompletion && !instant) {
        this.interpreter.isWaiting = true;
        this.interpreter.waitCounter = duration;
      }
      scene.behavior.removeCharacter(character, noAnim, {
        animation: animation,
        duration: duration,
        easing: easing
      });
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandCharacterChangeExpression
    * @protected
     */

    Component_CommandInterpreter.prototype.commandCharacterChangeExpression = function() {
      var animation, character, characterId, defaults, duration, easing, expression, flags, isLocked, scene;
      scene = SceneManager.scene;
      characterId = this.interpreter.stringValueOf(this.params.characterId);
      character = scene.characters.first((function(_this) {
        return function(v) {
          return !v.disposed && v.rid === characterId;
        };
      })(this));
      if (character == null) {
        return;
      }
      defaults = GameManager.defaults.character;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.expressionDuration;
      expression = RecordManager.characterExpressions[this.params.expressionId || 0];
      easing = !isLocked(flags["easing.type"]) ? gs.Easings.fromObject(this.params.easing) : gs.Easings.fromObject(defaults.changeEasing);
      animation = !isLocked(flags["animation.type"]) ? this.params.animation : defaults.changeAnimation;
      character.behavior.changeExpression(expression, this.params.animation, easing, duration);
      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {
        this.interpreter.isWaiting = true;
        this.interpreter.waitCounter = duration;
      }
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandCharacterSetParameter
    * @protected
     */

    Component_CommandInterpreter.prototype.commandCharacterSetParameter = function() {
      var params, value;
      params = GameManager.characterParams[this.interpreter.stringValueOf(this.params.characterId)];
      if ((params == null) || (this.params.param == null)) {
        return;
      }
      switch (this.params.valueType) {
        case 0:
          switch (this.params.param.type) {
            case 0:
              return params[this.params.param.name] = this.interpreter.numberValueOf(this.params.numberValue);
            case 1:
              return params[this.params.param.name] = this.interpreter.numberValueOf(this.params.numberValue) > 0;
            case 2:
              return params[this.params.param.name] = this.interpreter.numberValueOf(this.params.numberValue).toString();
          }
          break;
        case 1:
          switch (this.params.param.type) {
            case 0:
              value = this.interpreter.booleanValueOf(this.params.switchValue);
              return params[this.params.param.name] = value ? 1 : 0;
            case 1:
              return params[this.params.param.name] = this.interpreter.booleanValueOf(this.params.switchValue);
            case 2:
              value = this.interpreter.booleanValueOf(this.params.switchValue);
              return params[this.params.param.name] = value ? "ON" : "OFF";
          }
          break;
        case 2:
          switch (this.params.param.type) {
            case 0:
              value = this.interpreter.stringValueOf(this.params.textValue);
              return params[this.params.param.name] = value.length;
            case 1:
              return params[this.params.param.name] = this.interpreter.stringValueOf(this.params.textValue) === "ON";
            case 2:
              return params[this.params.param.name] = this.interpreter.stringValueOf(this.params.textValue);
          }
      }
    };


    /**
    * @method commandCharacterGetParameter
    * @protected
     */

    Component_CommandInterpreter.prototype.commandCharacterGetParameter = function() {
      var params, value;
      params = GameManager.characterParams[this.interpreter.stringValueOf(this.params.characterId)];
      if ((params == null) || (this.params.param == null)) {
        return;
      }
      value = params[this.params.param.name];
      switch (this.params.valueType) {
        case 0:
          switch (this.params.param.type) {
            case 0:
              return this.interpreter.setNumberValueTo(this.params.targetVariable, value);
            case 1:
              return this.interpreter.setNumberValueTo(this.params.targetVariable, value ? 1 : 0);
            case 2:
              return this.interpreter.setNumberValueTo(this.params.targetVariable, value != null ? value.length : 0);
          }
          break;
        case 1:
          switch (this.params.param.type) {
            case 0:
              return this.interpreter.setBooleanValueTo(this.params.targetVariable, value > 0);
            case 1:
              return this.interpreter.setBooleanValueTo(this.params.targetVariable, value);
            case 2:
              return this.interpreter.setBooleanValueTo(this.params.targetVariable, value === "ON");
          }
          break;
        case 2:
          switch (this.params.param.type) {
            case 0:
              return this.interpreter.setStringValueTo(this.params.targetVariable, value != null ? value.toString() : "");
            case 1:
              return this.interpreter.setStringValueTo(this.params.targetVariable, value ? "ON" : "OFF");
            case 2:
              return this.interpreter.setStringValueTo(this.params.targetVariable, value);
          }
      }
    };


    /**
    * @method commandCharacterMotionBlur
    * @protected
     */

    Component_CommandInterpreter.prototype.commandCharacterMotionBlur = function() {
      var character, characterId, scene;
      scene = SceneManager.scene;
      characterId = this.interpreter.stringValueOf(this.params.characterId);
      character = scene.characters.first((function(_this) {
        return function(v) {
          return !v.disposed && v.rid === characterId;
        };
      })(this));
      if (character == null) {
        return;
      }
      return character.motionBlur.set(this.params.motionBlur);
    };


    /**
    * @method commandCharacterDefaults
    * @protected
     */

    Component_CommandInterpreter.prototype.commandCharacterDefaults = function() {
      var defaults, flags, isLocked;
      defaults = GameManager.defaults.character;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      if (!isLocked(flags.appearDuration)) {
        defaults.appearDuration = this.interpreter.durationValueOf(this.params.appearDuration);
      }
      if (!isLocked(flags.disappearDuration)) {
        defaults.disappearDuration = this.interpreter.durationValueOf(this.params.disappearDuration);
      }
      if (!isLocked(flags.expressionDuration)) {
        defaults.expressionDuration = this.interpreter.durationValueOf(this.params.expressionDuration);
      }
      if (!isLocked(flags.zOrder)) {
        defaults.zOrder = this.interpreter.numberValueOf(this.params.zOrder);
      }
      if (!isLocked(flags["appearEasing.type"])) {
        defaults.appearEasing = this.params.appearEasing;
      }
      if (!isLocked(flags["appearAnimation.type"])) {
        defaults.appearAnimation = this.params.appearAnimation;
      }
      if (!isLocked(flags["disappearEasing.type"])) {
        defaults.disappearEasing = this.params.disappearEasing;
      }
      if (!isLocked(flags["disappearAnimation.type"])) {
        defaults.disappearAnimation = this.params.disappearAnimation;
      }
      if (!isLocked(flags["motionBlur.enabled"])) {
        defaults.motionBlur = this.params.motionBlur;
      }
      if (!isLocked(flags.origin)) {
        return defaults.origin = this.params.origin;
      }
    };


    /**
    * @method commandCharacterEffect
    * @protected
     */

    Component_CommandInterpreter.prototype.commandCharacterEffect = function() {
      var character, characterId, scene;
      scene = SceneManager.scene;
      characterId = this.interpreter.stringValueOf(this.params.characterId);
      character = scene.characters.first(function(c) {
        return !c.disposed && c.rid === characterId;
      });
      if (character == null) {
        return;
      }
      this.interpreter.objectEffect(character, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandFlashCharacter
    * @protected
     */

    Component_CommandInterpreter.prototype.commandFlashCharacter = function() {
      var character, characterId, duration, scene;
      scene = SceneManager.scene;
      characterId = this.interpreter.stringValueOf(this.params.characterId);
      character = scene.characters.first((function(_this) {
        return function(v) {
          return !v.disposed && v.rid === characterId;
        };
      })(this));
      if (!character) {
        return;
      }
      duration = this.interpreter.durationValueOf(this.params.duration);
      character.animator.flash(new Color(this.params.color), duration);
      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {
        this.interpreter.isWaiting = true;
        this.interpreter.waitCounter = duration;
      }
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandTintCharacter
    * @protected
     */

    Component_CommandInterpreter.prototype.commandTintCharacter = function() {
      var character, characterId, duration, easing, scene;
      scene = SceneManager.scene;
      characterId = this.interpreter.stringValueOf(this.params.characterId);
      character = scene.characters.first((function(_this) {
        return function(v) {
          return !v.disposed && v.rid === characterId;
        };
      })(this));
      easing = gs.Easings.fromValues(this.interpreter.numberValueOf(this.params.easing.type), this.params.easing.inOut);
      if (!character) {
        return;
      }
      duration = this.interpreter.durationValueOf(this.params.duration);
      character.animator.tintTo(this.params.tone, duration, easing);
      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {
        this.interpreter.isWaiting = true;
        this.interpreter.waitCounter = duration;
      }
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandZoomCharacter
    * @protected
     */

    Component_CommandInterpreter.prototype.commandZoomCharacter = function() {
      var character, characterId, scene;
      scene = SceneManager.scene;
      characterId = this.interpreter.stringValueOf(this.params.characterId);
      character = scene.characters.first((function(_this) {
        return function(v) {
          return !v.disposed && v.rid === characterId;
        };
      })(this));
      if (character == null) {
        return;
      }
      this.interpreter.zoomObject(character, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandRotateCharacter
    * @protected
     */

    Component_CommandInterpreter.prototype.commandRotateCharacter = function() {
      var character, characterId, scene;
      scene = SceneManager.scene;
      characterId = this.interpreter.stringValueOf(this.params.characterId);
      character = scene.characters.first((function(_this) {
        return function(v) {
          return !v.disposed && v.rid === characterId;
        };
      })(this));
      if (character == null) {
        return;
      }
      this.interpreter.rotateObject(character, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandBlendCharacter
    * @protected
     */

    Component_CommandInterpreter.prototype.commandBlendCharacter = function() {
      var character, characterId;
      characterId = this.interpreter.stringValueOf(this.params.characterId);
      character = SceneManager.scene.characters.first((function(_this) {
        return function(v) {
          return !v.disposed && v.rid === characterId;
        };
      })(this));
      if (character == null) {
        return;
      }
      this.interpreter.blendObject(character, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandShakeCharacter
    * @protected
     */

    Component_CommandInterpreter.prototype.commandShakeCharacter = function() {
      var character, characterId;
      characterId = this.interpreter.stringValueOf(this.params.characterId);
      character = SceneManager.scene.characters.first((function(_this) {
        return function(v) {
          return !v.disposed && v.rid === characterId;
        };
      })(this));
      if (character == null) {
        return;
      }
      this.interpreter.shakeObject(character, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandMaskCharacter
    * @protected
     */

    Component_CommandInterpreter.prototype.commandMaskCharacter = function() {
      var character, characterId, scene;
      scene = SceneManager.scene;
      characterId = this.interpreter.stringValueOf(this.params.characterId);
      character = scene.characters.first((function(_this) {
        return function(v) {
          return !v.disposed && v.rid === characterId;
        };
      })(this));
      if (character == null) {
        return;
      }
      this.interpreter.maskObject(character, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandMoveCharacter
    * @protected
     */

    Component_CommandInterpreter.prototype.commandMoveCharacter = function() {
      var character, characterId, scene;
      scene = SceneManager.scene;
      characterId = this.interpreter.stringValueOf(this.params.characterId);
      character = scene.characters.first((function(_this) {
        return function(v) {
          return !v.disposed && v.rid === characterId;
        };
      })(this));
      if (character == null) {
        return;
      }
      this.interpreter.moveObject(character, this.params.position, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandMoveCharacterPath
    * @protected
     */

    Component_CommandInterpreter.prototype.commandMoveCharacterPath = function() {
      var character, characterId, scene;
      scene = SceneManager.scene;
      characterId = this.interpreter.stringValueOf(this.params.characterId);
      character = scene.characters.first((function(_this) {
        return function(v) {
          return !v.disposed && v.rid === characterId;
        };
      })(this));
      if (character == null) {
        return;
      }
      this.interpreter.moveObjectPath(character, this.params.path, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandShakeBackground
    * @protected
     */

    Component_CommandInterpreter.prototype.commandShakeBackground = function() {
      var background;
      background = SceneManager.scene.backgrounds[this.interpreter.numberValueOf(this.params.layer)];
      if (background == null) {
        return;
      }
      this.interpreter.shakeObject(background, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandScrollBackground
    * @protected
     */

    Component_CommandInterpreter.prototype.commandScrollBackground = function() {
      var duration, easing, horizontalSpeed, layer, ref, scene, verticalSpeed;
      scene = SceneManager.scene;
      duration = this.interpreter.durationValueOf(this.params.duration);
      horizontalSpeed = this.interpreter.numberValueOf(this.params.horizontalSpeed);
      verticalSpeed = this.interpreter.numberValueOf(this.params.verticalSpeed);
      easing = gs.Easings.fromValues(this.interpreter.numberValueOf(this.params.easing.type), this.params.easing.inOut);
      layer = this.interpreter.numberValueOf(this.params.layer);
      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {
        this.interpreter.isWaiting = true;
        this.interpreter.waitCounter = duration;
      }
      if ((ref = scene.backgrounds[layer]) != null) {
        ref.animator.move(horizontalSpeed, verticalSpeed, duration, easing);
      }
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandScrollBackgroundTo
    * @protected
     */

    Component_CommandInterpreter.prototype.commandScrollBackgroundTo = function() {
      var background, duration, easing, layer, p, scene, x, y;
      scene = SceneManager.scene;
      duration = this.interpreter.durationValueOf(this.params.duration);
      x = this.interpreter.numberValueOf(this.params.background.location.x);
      y = this.interpreter.numberValueOf(this.params.background.location.y);
      easing = gs.Easings.fromValues(this.interpreter.numberValueOf(this.params.easing.type), this.params.easing.inOut);
      layer = this.interpreter.numberValueOf(this.params.layer);
      background = scene.backgrounds[layer];
      if (!background) {
        return;
      }
      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {
        this.interpreter.isWaiting = true;
        this.interpreter.waitCounter = duration;
      }
      if (this.params.positionType === 0) {
        p = this.interpreter.predefinedObjectPosition(this.params.predefinedPositionId, background, this.params);
        x = p.x;
        y = p.y;
      }
      background.animator.moveTo(x, y, duration, easing);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandScrollBackgroundPath
    * @protected
     */

    Component_CommandInterpreter.prototype.commandScrollBackgroundPath = function() {
      var background, scene;
      scene = SceneManager.scene;
      background = scene.backgrounds[this.interpreter.numberValueOf(this.params.layer)];
      if (background == null) {
        return;
      }
      this.interpreter.moveObjectPath(background, this.params.path, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandMaskBackground
    * @protected
     */

    Component_CommandInterpreter.prototype.commandMaskBackground = function() {
      var background, scene;
      scene = SceneManager.scene;
      background = scene.backgrounds[this.interpreter.numberValueOf(this.params.layer)];
      if (background == null) {
        return;
      }
      this.interpreter.maskObject(background, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandZoomBackground
    * @protected
     */

    Component_CommandInterpreter.prototype.commandZoomBackground = function() {
      var duration, easing, layer, ref, scene, x, y;
      scene = SceneManager.scene;
      duration = this.interpreter.durationValueOf(this.params.duration);
      x = this.interpreter.numberValueOf(this.params.zooming.x);
      y = this.interpreter.numberValueOf(this.params.zooming.y);
      easing = gs.Easings.fromValues(this.interpreter.numberValueOf(this.params.easing.type), this.params.easing.inOut);
      layer = this.interpreter.numberValueOf(this.params.layer);
      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {
        this.interpreter.isWaiting = true;
        this.interpreter.waitCounter = duration;
      }
      if ((ref = scene.backgrounds[layer]) != null) {
        ref.animator.zoomTo(x / 100, y / 100, duration, easing);
      }
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandRotateBackground
    * @protected
     */

    Component_CommandInterpreter.prototype.commandRotateBackground = function() {
      var background, scene;
      scene = SceneManager.scene;
      background = scene.backgrounds[this.interpreter.numberValueOf(this.params.layer)];
      if (background) {
        this.interpreter.rotateObject(background, this.params);
      }
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandTintBackground
    * @protected
     */

    Component_CommandInterpreter.prototype.commandTintBackground = function() {
      var background, duration, easing, layer, scene;
      scene = SceneManager.scene;
      layer = this.interpreter.numberValueOf(this.params.layer);
      background = scene.backgrounds[layer];
      if (background == null) {
        return;
      }
      duration = this.interpreter.durationValueOf(this.params.duration);
      easing = gs.Easings.fromObject(this.params.easing);
      background.animator.tintTo(this.params.tone, duration, easing);
      this.interpreter.waitForCompletion(background, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandBlendBackground
    * @protected
     */

    Component_CommandInterpreter.prototype.commandBlendBackground = function() {
      var background, layer;
      layer = this.interpreter.numberValueOf(this.params.layer);
      background = SceneManager.scene.backgrounds[layer];
      if (background == null) {
        return;
      }
      this.interpreter.blendObject(background, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandBackgroundEffect
    * @protected
     */

    Component_CommandInterpreter.prototype.commandBackgroundEffect = function() {
      var background, layer;
      layer = this.interpreter.numberValueOf(this.params.layer);
      background = SceneManager.scene.backgrounds[layer];
      if (background == null) {
        return;
      }
      this.interpreter.objectEffect(background, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandBackgroundDefaults
    * @protected
     */

    Component_CommandInterpreter.prototype.commandBackgroundDefaults = function() {
      var defaults, flags, isLocked;
      defaults = GameManager.defaults.background;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      if (!isLocked(flags.duration)) {
        defaults.duration = this.interpreter.durationValueOf(this.params.duration);
      }
      if (!isLocked(flags.zOrder)) {
        defaults.zOrder = this.interpreter.numberValueOf(this.params.zOrder);
      }
      if (!isLocked(flags["easing.type"])) {
        defaults.easing = this.params.easing;
      }
      if (!isLocked(flags["animation.type"])) {
        defaults.animation = this.params.animation;
      }
      if (!isLocked(flags.origin)) {
        defaults.origin = this.params.origin;
      }
      if (!isLocked(flags.loopHorizontal)) {
        defaults.loopHorizontal = this.params.loopHorizontal;
      }
      if (!isLocked(flags.loopVertical)) {
        return defaults.loopVertical = this.params.loopVertical;
      }
    };


    /**
    * @method commandBackgroundMotionBlur
    * @protected
     */

    Component_CommandInterpreter.prototype.commandBackgroundMotionBlur = function() {
      var background, layer;
      layer = this.interpreter.numberValueOf(this.params.layer);
      background = SceneManager.scene.backgrounds[layer];
      if (background == null) {
        return;
      }
      return background.motionBlur.set(this.params.motionBlur);
    };


    /**
    * @method commandChangeBackground
    * @protected
     */

    Component_CommandInterpreter.prototype.commandChangeBackground = function() {
      var animation, defaults, duration, easing, flags, isLocked, layer, loopH, loopV, origin, ref, scene, zIndex;
      defaults = GameManager.defaults.background;
      scene = SceneManager.scene;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.duration;
      loopH = !isLocked(flags.loopHorizontal) ? this.params.loopHorizontal : defaults.loopHorizontal;
      loopV = !isLocked(flags.loopVertical) ? this.params.loopVertical : defaults.loopVertical;
      animation = !isLocked(flags["animation.type"]) ? this.params.animation : defaults.animation;
      origin = !isLocked(flags.origin) ? this.params.origin : defaults.origin;
      zIndex = !isLocked(flags.zOrder) ? this.interpreter.numberValueOf(this.params.zOrder) : defaults.zOrder;
      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {
        this.interpreter.isWaiting = true;
        this.interpreter.waitCounter = duration;
      }
      easing = !isLocked(flags["easing.type"]) ? gs.Easings.fromObject(this.params.easing) : gs.Easings.fromObject(defaults.easing);
      layer = this.interpreter.numberValueOf(this.params.layer);
      scene.behavior.changeBackground(this.params.graphic, false, animation, easing, duration, 0, 0, layer, loopH, loopV);
      if (scene.backgrounds[layer]) {
        if (((ref = this.params.viewport) != null ? ref.type : void 0) === "ui") {
          scene.backgrounds[layer].viewport = Graphics.viewport;
        }
        scene.backgrounds[layer].anchor.x = origin === 0 ? 0 : 0.5;
        scene.backgrounds[layer].anchor.y = origin === 0 ? 0 : 0.5;
        scene.backgrounds[layer].blendMode = this.interpreter.numberValueOf(this.params.blendMode);
        scene.backgrounds[layer].zIndex = zIndex + layer;
        if (origin === 1) {
          scene.backgrounds[layer].dstRect.x = scene.backgrounds[layer].dstRect.x;
          scene.backgrounds[layer].dstRect.y = scene.backgrounds[layer].dstRect.y;
        }
        scene.backgrounds[layer].setup();
        scene.backgrounds[layer].update();
      }
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandCallScene
    * @protected
     */

    Component_CommandInterpreter.prototype.commandCallScene = function() {
      return this.interpreter.callScene(this.interpreter.stringValueOf(this.params.scene.uid || this.params.scene));
    };


    /**
    * @method commandChangeScene
    * @protected
     */

    Component_CommandInterpreter.prototype.commandChangeScene = function() {
      var flags, isLocked, k, len, len1, n, newScene, picture, ref, ref1, scene, uid, video;
      if (GameManager.inLivePreview) {
        return;
      }
      GameManager.tempSettings.skip = false;
      if (!this.params.savePrevious) {
        SceneManager.clear();
      }
      scene = SceneManager.scene;
      if (!this.params.erasePictures && !this.params.savePrevious) {
        scene.removeObject(scene.pictureContainer);
        ref = scene.pictures;
        for (k = 0, len = ref.length; k < len; k++) {
          picture = ref[k];
          if (picture) {
            ResourceManager.context.remove("Graphics/Pictures/" + picture.image);
          }
        }
      }
      if (!this.params.eraseTexts && !this.params.savePrevious) {
        scene.removeObject(scene.textContainer);
      }
      if (!this.params.eraseVideos && !this.params.savePrevious) {
        scene.removeObject(scene.videoContainer);
        ref1 = scene.videos;
        for (n = 0, len1 = ref1.length; n < len1; n++) {
          video = ref1[n];
          if (video) {
            ResourceManager.context.remove("Movies/" + video.video);
          }
        }
      }
      if (this.params.scene) {
        if (this.params.savePrevious) {
          GameManager.sceneData = {
            uid: uid = this.params.scene.uid,
            pictures: [],
            texts: [],
            videos: []
          };
        } else {
          GameManager.sceneData = {
            uid: uid = this.params.scene.uid,
            pictures: scene.pictureContainer.subObjectsByDomain,
            texts: scene.textContainer.subObjectsByDomain,
            videos: scene.videoContainer.subObjectsByDomain
          };
        }
        flags = this.params.fieldFlags || {};
        isLocked = gs.CommandFieldFlags.isLocked;
        newScene = new vn.Object_Scene();
        if (this.params.savePrevious) {
          newScene.sceneData = {
            uid: uid = this.params.scene.uid,
            pictures: [],
            texts: [],
            videos: [],
            backlog: GameManager.backlog
          };
        } else {
          newScene.sceneData = {
            uid: uid = this.params.scene.uid,
            pictures: scene.pictureContainer.subObjectsByDomain,
            texts: scene.textContainer.subObjectsByDomain,
            videos: scene.videoContainer.subObjectsByDomain
          };
        }
        SceneManager.switchTo(newScene, this.params.savePrevious, (function(_this) {
          return function() {
            return _this.interpreter.isWaiting = false;
          };
        })(this));
      } else {
        SceneManager.switchTo(null);
      }
      return this.interpreter.isWaiting = true;
    };


    /**
    * @method commandReturnToPreviousScene
    * @protected
     */

    Component_CommandInterpreter.prototype.commandReturnToPreviousScene = function() {
      if (GameManager.inLivePreview) {
        return;
      }
      SceneManager.returnToPrevious((function(_this) {
        return function() {
          return _this.interpreter.isWaiting = false;
        };
      })(this));
      return this.interpreter.isWaiting = true;
    };


    /**
    * @method commandSwitchToLayout
    * @protected
     */

    Component_CommandInterpreter.prototype.commandSwitchToLayout = function() {
      var scene;
      if (GameManager.inLivePreview) {
        return;
      }
      if (ui.UIManager.layouts[this.params.layout.name] != null) {
        scene = new gs.Object_Layout(this.params.layout.name);
        SceneManager.switchTo(scene, this.params.savePrevious, (function(_this) {
          return function() {
            return _this.interpreter.isWaiting = false;
          };
        })(this));
        return this.interpreter.isWaiting = true;
      }
    };


    /**
    * @method commandChangeTransition
    * @protected
     */

    Component_CommandInterpreter.prototype.commandChangeTransition = function() {
      var flags, isLocked;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      if (!isLocked(flags.duration)) {
        SceneManager.transitionData.duration = this.interpreter.durationValueOf(this.params.duration);
      }
      if (!isLocked(flags.graphic)) {
        SceneManager.transitionData.graphic = this.params.graphic;
      }
      if (!isLocked(flags.vague)) {
        return SceneManager.transitionData.vague = this.params.vague;
      }
    };


    /**
    * @method commandFreezeScreen
    * @protected
     */

    Component_CommandInterpreter.prototype.commandFreezeScreen = function() {
      return Graphics.freeze();
    };


    /**
    * @method commandScreenTransition
    * @protected
     */

    Component_CommandInterpreter.prototype.commandScreenTransition = function() {
      var bitmap, defaults, duration, flags, graphicName, isLocked, ref, ref1, vague;
      defaults = GameManager.defaults.scene;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      graphicName = !isLocked(flags.graphic) ? (ref = this.params.graphic) != null ? ref.name : void 0 : (ref1 = SceneManager.transitionData.graphic) != null ? ref1.name : void 0;
      if (graphicName) {
        bitmap = !isLocked(flags.graphic) ? ResourceManager.getBitmap("Graphics/Masks/" + graphicName) : ResourceManager.getBitmap("Graphics/Masks/" + graphicName);
      }
      vague = !isLocked(flags.vague) ? this.interpreter.numberValueOf(this.params.vague) : SceneManager.transitionData.vague;
      duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : SceneManager.transitionData.duration;
      this.interpreter.isWaiting = !GameManager.inLivePreview;
      this.interpreter.waitCounter = duration;
      return Graphics.transition(duration, bitmap, vague);
    };


    /**
    * @method commandShakeScreen
    * @protected
     */

    Component_CommandInterpreter.prototype.commandShakeScreen = function() {
      if (SceneManager.scene.viewport == null) {
        return;
      }
      this.interpreter.shakeObject(SceneManager.scene.viewport, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandTintScreen
    * @protected
     */

    Component_CommandInterpreter.prototype.commandTintScreen = function() {
      var duration;
      duration = this.interpreter.durationValueOf(this.params.duration);
      SceneManager.scene.viewport.animator.tintTo(new Tone(this.params.tone), duration, gs.Easings.EASE_LINEAR[0]);
      if (this.params.waitForCompletion && duration > 0) {
        this.interpreter.isWaiting = true;
        this.interpreter.waitCounter = duration;
      }
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandZoomScreen
    * @protected
     */

    Component_CommandInterpreter.prototype.commandZoomScreen = function() {
      var duration, easing, scene;
      easing = gs.Easings.fromObject(this.params.easing);
      duration = this.interpreter.durationValueOf(this.params.duration);
      scene = SceneManager.scene;
      SceneManager.scene.viewport.anchor.x = 0.5;
      SceneManager.scene.viewport.anchor.y = 0.5;
      SceneManager.scene.viewport.animator.zoomTo(this.interpreter.numberValueOf(this.params.zooming.x) / 100, this.interpreter.numberValueOf(this.params.zooming.y) / 100, duration, easing);
      this.interpreter.waitForCompletion(null, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandPanScreen
    * @protected
     */

    Component_CommandInterpreter.prototype.commandPanScreen = function() {
      var duration, easing, scene, viewport;
      scene = SceneManager.scene;
      duration = this.interpreter.durationValueOf(this.params.duration);
      easing = gs.Easings.fromObject(this.params.easing);
      this.interpreter.settings.screen.pan.x -= this.params.position.x;
      this.interpreter.settings.screen.pan.y -= this.params.position.y;
      viewport = SceneManager.scene.viewport;
      viewport.animator.scrollTo(-this.params.position.x + viewport.dstRect.x, -this.params.position.y + viewport.dstRect.y, duration, easing);
      this.interpreter.waitForCompletion(null, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandRotateScreen
    * @protected
     */

    Component_CommandInterpreter.prototype.commandRotateScreen = function() {
      var duration, easing, pan, scene;
      scene = SceneManager.scene;
      easing = gs.Easings.fromObject(this.params.easing);
      duration = this.interpreter.durationValueOf(this.params.duration);
      pan = this.interpreter.settings.screen.pan;
      SceneManager.scene.viewport.anchor.x = 0.5;
      SceneManager.scene.viewport.anchor.y = 0.5;
      SceneManager.scene.viewport.animator.rotate(this.params.direction, this.interpreter.numberValueOf(this.params.speed) / 100, duration, easing);
      this.interpreter.waitForCompletion(null, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandFlashScreen
    * @protected
     */

    Component_CommandInterpreter.prototype.commandFlashScreen = function() {
      var duration;
      duration = this.interpreter.durationValueOf(this.params.duration);
      SceneManager.scene.viewport.animator.flash(new Color(this.params.color), duration, gs.Easings.EASE_LINEAR[0]);
      if (this.params.waitForCompletion && duration !== 0) {
        this.interpreter.isWaiting = true;
        this.interpreter.waitCounter = duration;
      }
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandScreenEffect
    * @protected
     */

    Component_CommandInterpreter.prototype.commandScreenEffect = function() {
      var duration, easing, flags, isLocked, scene, viewport, wobble, zOrder;
      scene = SceneManager.scene;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      duration = this.interpreter.durationValueOf(this.params.duration);
      easing = gs.Easings.fromObject(this.params.easing);
      if (!gs.CommandFieldFlags.isLocked(flags.zOrder)) {
        zOrder = this.interpreter.numberValueOf(this.params.zOrder);
      } else {
        zOrder = SceneManager.scene.viewport.zIndex;
      }
      viewport = scene.viewportContainer.subObjects.first(function(v) {
        return v.zIndex === zOrder;
      });
      if (!viewport) {
        viewport = new gs.Object_Viewport();
        viewport.zIndex = zOrder;
        scene.viewportContainer.addObject(viewport);
      }
      switch (this.params.type) {
        case 0:
          viewport.animator.wobbleTo(this.params.wobble.power / 10000, this.params.wobble.speed / 100, duration, easing);
          wobble = viewport.effects.wobble;
          wobble.enabled = this.params.wobble.power > 0;
          wobble.vertical = this.params.wobble.orientation === 0 || this.params.wobble.orientation === 2;
          wobble.horizontal = this.params.wobble.orientation === 1 || this.params.wobble.orientation === 2;
          break;
        case 1:
          viewport.animator.blurTo(this.params.blur.power / 100, duration, easing);
          viewport.effects.blur.enabled = true;
          break;
        case 2:
          viewport.animator.pixelateTo(this.params.pixelate.size.width, this.params.pixelate.size.height, duration, easing);
          viewport.effects.pixelate.enabled = true;
      }
      if (this.params.waitForCompletion && duration !== 0) {
        this.interpreter.isWaiting = true;
        this.interpreter.waitCounter = duration;
      }
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandVideoDefaults
    * @protected
     */

    Component_CommandInterpreter.prototype.commandVideoDefaults = function() {
      var defaults, flags, isLocked;
      defaults = GameManager.defaults.video;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      if (!isLocked(flags.appearDuration)) {
        defaults.appearDuration = this.interpreter.durationValueOf(this.params.appearDuration);
      }
      if (!isLocked(flags.disappearDuration)) {
        defaults.disappearDuration = this.interpreter.durationValueOf(this.params.disappearDuration);
      }
      if (!isLocked(flags.zOrder)) {
        defaults.zOrder = this.interpreter.numberValueOf(this.params.zOrder);
      }
      if (!isLocked(flags["appearEasing.type"])) {
        defaults.appearEasing = this.params.appearEasing;
      }
      if (!isLocked(flags["appearAnimation.type"])) {
        defaults.appearAnimation = this.params.appearAnimation;
      }
      if (!isLocked(flags["disappearEasing.type"])) {
        defaults.disappearEasing = this.params.disappearEasing;
      }
      if (!isLocked(flags["disappearAnimation.type"])) {
        defaults.disappearAnimation = this.params.disappearAnimation;
      }
      if (!isLocked(flags["motionBlur.enabled"])) {
        defaults.motionBlur = this.params.motionBlur;
      }
      if (!isLocked(flags.origin)) {
        return defaults.origin = this.params.origin;
      }
    };


    /**
    * @method commandShowVideo
    * @protected
     */

    Component_CommandInterpreter.prototype.commandShowVideo = function() {
      var animation, defaults, duration, easing, flags, isLocked, number, origin, p, ref, ref1, ref2, scene, video, videos, x, y, zIndex;
      defaults = GameManager.defaults.video;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      scene = SceneManager.scene;
      scene.behavior.changeVideoDomain(this.params.numberDomain);
      number = this.interpreter.numberValueOf(this.params.number);
      videos = scene.videos;
      if (videos[number] == null) {
        videos[number] = new gs.Object_Video();
      }
      x = this.interpreter.numberValueOf(this.params.position.x);
      y = this.interpreter.numberValueOf(this.params.position.y);
      easing = !isLocked(flags["easing.type"]) ? gs.Easings.fromValues(this.interpreter.numberValueOf(this.params.easing.type), this.params.easing.inOut) : gs.Easings.fromObject(defaults.appearEasing);
      duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.appearDuration;
      origin = !isLocked(flags.origin) ? this.params.origin : defaults.origin;
      zIndex = !isLocked(flags.zOrder) ? this.interpreter.numberValueOf(this.params.zOrder) : defaults.zOrder;
      animation = !isLocked(flags["animation.type"]) ? this.params.animation : defaults.appearAnimation;
      video = videos[number];
      video.domain = this.params.numberDomain;
      video.video = (ref = this.params.video) != null ? ref.name : void 0;
      video.loop = (ref1 = this.params.loop) != null ? ref1 : true;
      video.dstRect.x = x;
      video.dstRect.y = y;
      video.blendMode = this.interpreter.numberValueOf(this.params.blendMode);
      video.anchor.x = origin === 0 ? 0 : 0.5;
      video.anchor.y = origin === 0 ? 0 : 0.5;
      video.zIndex = zIndex || (1000 + number);
      if (((ref2 = this.params.viewport) != null ? ref2.type : void 0) === "scene") {
        video.viewport = SceneManager.scene.behavior.viewport;
      }
      video.update();
      if (this.params.positionType === 0) {
        p = this.interpreter.predefinedObjectPosition(this.params.predefinedPositionId, video, this.params);
        video.dstRect.x = p.x;
        video.dstRect.y = p.y;
      }
      video.animator.appear(x, y, animation, easing, duration);
      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {
        this.interpreter.isWaiting = true;
        this.interpreter.waitCounter = duration;
      }
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandMoveVideo
    * @protected
     */

    Component_CommandInterpreter.prototype.commandMoveVideo = function() {
      var number, scene, video;
      scene = SceneManager.scene;
      scene.behavior.changeVideoDomain(this.params.numberDomain);
      number = this.interpreter.numberValueOf(this.params.number);
      video = scene.videos[number];
      if (video == null) {
        return;
      }
      this.interpreter.moveObject(video, this.params.picture.position, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandMoveVideoPath
    * @protected
     */

    Component_CommandInterpreter.prototype.commandMoveVideoPath = function() {
      var number, scene, video;
      scene = SceneManager.scene;
      scene.behavior.changeVideoDomain(this.params.numberDomain);
      number = this.interpreter.numberValueOf(this.params.number);
      video = scene.videos[number];
      if (video == null) {
        return;
      }
      this.interpreter.moveObjectPath(video, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandRotateVideo
    * @protected
     */

    Component_CommandInterpreter.prototype.commandRotateVideo = function() {
      var number, scene, video;
      scene = SceneManager.scene;
      scene.behavior.changeVideoDomain(this.params.numberDomain);
      number = this.interpreter.numberValueOf(this.params.number);
      video = scene.videos[number];
      if (video == null) {
        return;
      }
      this.interpreter.rotateObject(video, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandZoomVideo
    * @protected
     */

    Component_CommandInterpreter.prototype.commandZoomVideo = function() {
      var number, scene, video;
      scene = SceneManager.scene;
      scene.behavior.changeVideoDomain(this.params.numberDomain);
      number = this.interpreter.numberValueOf(this.params.number);
      video = scene.videos[number];
      if (video == null) {
        return;
      }
      this.interpreter.zoomObject(video, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandBlendVideo
    * @protected
     */

    Component_CommandInterpreter.prototype.commandBlendVideo = function() {
      var video;
      SceneManager.scene.behavior.changeVideoDomain(this.params.numberDomain);
      video = SceneManager.scene.videos[this.interpreter.numberValueOf(this.params.number)];
      if (video == null) {
        return;
      }
      this.interpreter.blendObject(video, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandTintVideo
    * @protected
     */

    Component_CommandInterpreter.prototype.commandTintVideo = function() {
      var number, scene, video;
      scene = SceneManager.scene;
      scene.behavior.changeVideoDomain(this.params.numberDomain);
      number = this.interpreter.numberValueOf(this.params.number);
      video = scene.videos[number];
      if (video == null) {
        return;
      }
      this.interpreter.tintObject(video, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandFlashVideo
    * @protected
     */

    Component_CommandInterpreter.prototype.commandFlashVideo = function() {
      var number, scene, video;
      scene = SceneManager.scene;
      scene.behavior.changeVideoDomain(this.params.numberDomain);
      number = this.interpreter.numberValueOf(this.params.number);
      video = scene.videos[number];
      if (video == null) {
        return;
      }
      this.interpreter.flashObject(video, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandCropVideo
    * @protected
     */

    Component_CommandInterpreter.prototype.commandCropVideo = function() {
      var number, scene, video;
      scene = SceneManager.scene;
      scene.behavior.changeVideoDomain(this.params.numberDomain);
      number = this.interpreter.numberValueOf(this.params.number);
      video = scene.videos[number];
      if (video == null) {
        return;
      }
      return this.interpreter.cropObject(video, this.params);
    };


    /**
    * @method commandVideoMotionBlur
    * @protected
     */

    Component_CommandInterpreter.prototype.commandVideoMotionBlur = function() {
      var number, scene, video;
      scene = SceneManager.scene;
      scene.behavior.changeVideoDomain(this.params.numberDomain);
      number = this.interpreter.numberValueOf(this.params.number);
      video = scene.videos[number];
      if (video == null) {
        return;
      }
      return this.interpreter.objectMotionBlur(video, this.params);
    };


    /**
    * @method commandMaskVideo
    * @protected
     */

    Component_CommandInterpreter.prototype.commandMaskVideo = function() {
      var number, scene, video;
      scene = SceneManager.scene;
      scene.behavior.changeVideoDomain(this.params.numberDomain);
      number = this.interpreter.numberValueOf(this.params.number);
      video = scene.videos[number];
      if (video == null) {
        return;
      }
      this.interpreter.maskObject(video, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandVideoEffect
    * @protected
     */

    Component_CommandInterpreter.prototype.commandVideoEffect = function() {
      var number, scene, video;
      scene = SceneManager.scene;
      scene.behavior.changeVideoDomain(this.params.numberDomain);
      number = this.interpreter.numberValueOf(this.params.number);
      video = scene.videos[number];
      if (video == null) {
        return;
      }
      this.interpreter.objectEffect(video, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandEraseVideo
    * @protected
     */

    Component_CommandInterpreter.prototype.commandEraseVideo = function() {
      var animation, defaults, duration, easing, flags, isLocked, number, scene, video;
      defaults = GameManager.defaults.video;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      scene = SceneManager.scene;
      scene.behavior.changeVideoDomain(this.params.numberDomain);
      number = this.interpreter.numberValueOf(this.params.number);
      video = scene.videos[number];
      if (video == null) {
        return;
      }
      easing = !isLocked(flags["easing.type"]) ? gs.Easings.fromValues(this.interpreter.numberValueOf(this.params.easing.type), this.params.easing.inOut) : gs.Easings.fromObject(defaults.disappearEasing);
      duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.disappearDuration;
      animation = !isLocked(flags["animation.type"]) ? this.params.animation : defaults.disappearAnimation;
      video.animator.disappear(animation, easing, duration, (function(_this) {
        return function(sender) {
          sender.dispose();
          scene.behavior.changeTextDomain(sender.domain);
          return scene.videos[number] = null;
        };
      })(this));
      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {
        this.interpreter.isWaiting = true;
        this.interpreter.waitCounter = duration;
      }
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandShowImageMap
    * @protected
     */

    Component_CommandInterpreter.prototype.commandShowImageMap = function() {
      var bitmap, flags, imageMap, isLocked, number, p, ref, ref1, ref2, ref3, ref4, ref5;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      SceneManager.scene.behavior.changePictureDomain(this.params.numberDomain);
      number = this.interpreter.numberValueOf(this.params.number);
      imageMap = SceneManager.scene.pictures[number];
      if (imageMap != null) {
        imageMap.dispose();
      }
      imageMap = new gs.Object_ImageMap();
      imageMap.visual.variableContext = this.interpreter.context;
      SceneManager.scene.pictures[number] = imageMap;
      bitmap = ResourceManager.getBitmap("Graphics/Pictures/" + ((ref = this.params.ground) != null ? ref.name : void 0));
      imageMap.dstRect.width = bitmap.width;
      imageMap.dstRect.height = bitmap.height;
      if (this.params.positionType === 0) {
        p = this.interpreter.predefinedObjectPosition(this.params.predefinedPositionId, imageMap, this.params);
        imageMap.dstRect.x = p.x;
        imageMap.dstRect.y = p.y;
      } else {
        imageMap.dstRect.x = this.interpreter.numberValueOf(this.params.position.x);
        imageMap.dstRect.y = this.interpreter.numberValueOf(this.params.position.y);
      }
      imageMap.anchor.x = this.params.origin === 1 ? 0.5 : 0;
      imageMap.anchor.y = this.params.origin === 1 ? 0.5 : 0;
      imageMap.zIndex = !isLocked(flags.zOrder) ? this.interpreter.numberValueOf(this.params.zOrder) : 700 + number;
      imageMap.blendMode = !isLocked(flags.blendMode) ? this.params.blendMode : 0;
      imageMap.hotspots = this.params.hotspots;
      imageMap.images = [(ref1 = this.params.ground) != null ? ref1.name : void 0, (ref2 = this.params.hover) != null ? ref2.name : void 0, (ref3 = this.params.unselected) != null ? ref3.name : void 0, (ref4 = this.params.selected) != null ? ref4.name : void 0, (ref5 = this.params.selectedHover) != null ? ref5.name : void 0];
      imageMap.events.on("jumpTo", gs.CallBack("onJumpTo", this.interpreter));
      imageMap.events.on("callCommonEvent", gs.CallBack("onCallCommonEvent", this.interpreter));
      imageMap.setup();
      imageMap.update();
      this.interpreter.showObject(imageMap, {
        x: 0,
        y: 0
      }, this.params);
      if (this.params.waitForCompletion) {
        this.interpreter.waitCounter = 0;
        this.interpreter.isWaiting = true;
      }
      imageMap.events.on("finish", (function(_this) {
        return function(sender) {
          return _this.interpreter.isWaiting = false;
        };
      })(this));
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandEraseImageMap
    * @protected
     */

    Component_CommandInterpreter.prototype.commandEraseImageMap = function() {
      var imageMap, number, scene;
      scene = SceneManager.scene;
      scene.behavior.changePictureDomain(this.params.numberDomain);
      number = this.interpreter.numberValueOf(this.params.number);
      imageMap = scene.pictures[number];
      if (imageMap == null) {
        return;
      }
      imageMap.events.emit("finish", imageMap);
      imageMap.visual.active = false;
      this.interpreter.eraseObject(imageMap, this.params, (function(_this) {
        return function(sender) {
          scene.behavior.changePictureDomain(sender.domain);
          return scene.pictures[number] = null;
        };
      })(this));
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandAddHotspot
    * @protected
     */

    Component_CommandInterpreter.prototype.commandAddHotspot = function() {
      var dragging, hotspot, hotspots, number, picture, ref, ref1, ref2, ref3, ref4, ref5, scene, text;
      scene = SceneManager.scene;
      scene.behavior.changeHotspotDomain(this.params.numberDomain);
      number = this.interpreter.numberValueOf(this.params.number);
      hotspots = scene.hotspots;
      if (hotspots[number] == null) {
        hotspots[number] = new gs.Object_Hotspot();
      }
      hotspot = hotspots[number];
      hotspot.domain = this.params.numberDomain;
      hotspot.data = {
        params: this.params,
        bindValue: this.interpreter.numberValueOf(this.params.actions.onDrag.bindValue)
      };
      switch (this.params.positionType) {
        case 0:
          hotspot.dstRect.x = this.params.box.x;
          hotspot.dstRect.y = this.params.box.y;
          hotspot.dstRect.width = this.params.box.size.width;
          hotspot.dstRect.height = this.params.box.size.height;
          break;
        case 1:
          hotspot.dstRect.x = this.interpreter.numberValueOf(this.params.box.x);
          hotspot.dstRect.y = this.interpreter.numberValueOf(this.params.box.y);
          hotspot.dstRect.width = this.interpreter.numberValueOf(this.params.box.size.width);
          hotspot.dstRect.height = this.interpreter.numberValueOf(this.params.box.size.height);
          break;
        case 2:
          picture = scene.pictures[this.interpreter.numberValueOf(this.params.pictureNumber)];
          if (picture != null) {
            hotspot.target = picture;
          }
          break;
        case 3:
          text = scene.texts[this.interpreter.numberValueOf(this.params.textNumber)];
          if (text != null) {
            hotspot.target = text;
          }
      }
      hotspot.behavior.shape = (ref = this.params.shape) != null ? ref : gs.HotspotShape.RECTANGLE;
      if (text != null) {
        hotspot.images = null;
      } else {
        hotspot.images = [((ref1 = this.params.baseGraphic) != null ? ref1.name : void 0) || this.interpreter.stringValueOf(this.params.baseGraphic) || (picture != null ? picture.image : void 0), ((ref2 = this.params.hoverGraphic) != null ? ref2.name : void 0) || this.interpreter.stringValueOf(this.params.hoverGraphic), ((ref3 = this.params.selectedGraphic) != null ? ref3.name : void 0) || this.interpreter.stringValueOf(this.params.selectedGraphic), ((ref4 = this.params.selectedHoverGraphic) != null ? ref4.name : void 0) || this.interpreter.stringValueOf(this.params.selectedHoverGraphic), ((ref5 = this.params.unselectedGraphic) != null ? ref5.name : void 0) || this.interpreter.stringValueOf(this.params.unselectedGraphic)];
      }
      if (this.params.actions.onClick.type !== 0 || this.params.actions.onClick.label) {
        hotspot.events.on("click", gs.CallBack("onHotspotClick", this.interpreter, {
          params: this.params,
          bindValue: this.interpreter.numberValueOf(this.params.actions.onClick.bindValue)
        }));
      }
      if (this.params.actions.onEnter.type !== 0 || this.params.actions.onEnter.label) {
        hotspot.events.on("enter", gs.CallBack("onHotspotEnter", this.interpreter, {
          params: this.params,
          bindValue: this.interpreter.numberValueOf(this.params.actions.onEnter.bindValue)
        }));
      }
      if (this.params.actions.onLeave.type !== 0 || this.params.actions.onLeave.label) {
        hotspot.events.on("leave", gs.CallBack("onHotspotLeave", this.interpreter, {
          params: this.params,
          bindValue: this.interpreter.numberValueOf(this.params.actions.onLeave.bindValue)
        }));
      }
      if (this.params.actions.onDrag.type !== 0 || this.params.actions.onDrag.label) {
        hotspot.events.on("dragStart", gs.CallBack("onHotspotDragStart", this.interpreter, {
          params: this.params,
          bindValue: this.interpreter.numberValueOf(this.params.actions.onDrag.bindValue)
        }));
        hotspot.events.on("drag", gs.CallBack("onHotspotDrag", this.interpreter, {
          params: this.params,
          bindValue: this.interpreter.numberValueOf(this.params.actions.onDrag.bindValue)
        }));
        hotspot.events.on("dragEnd", gs.CallBack("onHotspotDragEnd", this.interpreter, {
          params: this.params,
          bindValue: this.interpreter.numberValueOf(this.params.actions.onDrag.bindValue)
        }));
      }
      if (this.params.actions.onSelect.type !== 0 || this.params.actions.onSelect.label || this.params.actions.onDeselect.type !== 0 || this.params.actions.onDeselect.label) {
        hotspot.events.on("stateChanged", gs.CallBack("onHotspotStateChanged", this.interpreter, this.params));
      }
      if (this.params.dragging.enabled) {
        hotspot.events.on("dragEnd", gs.CallBack("onHotspotDrop", this.interpreter, {
          params: this.params,
          bindValue: this.interpreter.numberValueOf(this.params.actions.onDrag.bindValue)
        }));
      }
      if (this.params.actions.onDropReceive.type !== 0 || this.params.actions.onDropReceive.label) {
        hotspot.events.on("dropReceived", gs.CallBack("onHotspotDropReceived", this.interpreter, {
          params: this.params,
          bindValue: this.interpreter.numberValueOf(this.params.actions.onDrag.bindValue)
        }));
      }
      hotspot.selectable = true;
      if (this.params.dragging.enabled) {
        dragging = this.params.dragging;
        hotspot.draggable = {
          rect: new Rect(dragging.rect.x, dragging.rect.y, dragging.rect.size.width, dragging.rect.size.height),
          axisX: dragging.horizontal,
          axisY: dragging.vertical
        };
        hotspot.addComponent(new ui.Component_Draggable());
        hotspot.events.on("drag", (function(_this) {
          return function(e) {
            var drag;
            drag = e.sender.draggable;
            GameManager.variableStore.setupTempVariables(_this.interpreter.context);
            if (_this.params.dragging.horizontal) {
              return _this.interpreter.setNumberValueTo(_this.params.dragging.variable, Math.round((e.sender.dstRect.x - drag.rect.x) / (drag.rect.width - e.sender.dstRect.width) * 100));
            } else {
              return _this.interpreter.setNumberValueTo(_this.params.dragging.variable, Math.round((e.sender.dstRect.y - drag.rect.y) / (drag.rect.height - e.sender.dstRect.height) * 100));
            }
          };
        })(this));
      }
      return hotspot.setup();
    };


    /**
    * @method commandChangeHotspotState
    * @protected
     */

    Component_CommandInterpreter.prototype.commandChangeHotspotState = function() {
      var flags, hotspot, isLocked, number, scene;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      scene = SceneManager.scene;
      scene.behavior.changeHotspotDomain(this.params.numberDomain);
      number = this.interpreter.numberValueOf(this.params.number);
      hotspot = scene.hotspots[number];
      if (!hotspot) {
        return;
      }
      if (!isLocked(flags.selected)) {
        hotspot.behavior.selected = this.interpreter.booleanValueOf(this.params.selected);
      }
      if (!isLocked(flags.enabled)) {
        hotspot.behavior.enabled = this.interpreter.booleanValueOf(this.params.enabled);
      }
      hotspot.behavior.updateInput();
      return hotspot.behavior.updateImage();
    };


    /**
    * @method commandEraseHotspot
    * @protected
     */

    Component_CommandInterpreter.prototype.commandEraseHotspot = function() {
      var number, scene;
      scene = SceneManager.scene;
      scene.behavior.changeHotspotDomain(this.params.numberDomain);
      number = this.interpreter.numberValueOf(this.params.number);
      if (scene.hotspots[number] != null) {
        scene.hotspots[number].dispose();
        return scene.hotspotContainer.eraseObject(number);
      }
    };


    /**
    * @method commandChangeObjectDomain
    * @protected
     */

    Component_CommandInterpreter.prototype.commandChangeObjectDomain = function() {
      return SceneManager.scene.behavior.changeObjectDomain(this.interpreter.stringValueOf(this.params.domain));
    };


    /**
    * @method commandPictureDefaults
    * @protected
     */

    Component_CommandInterpreter.prototype.commandPictureDefaults = function() {
      var defaults, flags, isLocked;
      defaults = GameManager.defaults.picture;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      if (!isLocked(flags.appearDuration)) {
        defaults.appearDuration = this.interpreter.durationValueOf(this.params.appearDuration);
      }
      if (!isLocked(flags.disappearDuration)) {
        defaults.disappearDuration = this.interpreter.durationValueOf(this.params.disappearDuration);
      }
      if (!isLocked(flags.zOrder)) {
        defaults.zOrder = this.interpreter.numberValueOf(this.params.zOrder);
      }
      if (!isLocked(flags["appearEasing.type"])) {
        defaults.appearEasing = this.params.appearEasing;
      }
      if (!isLocked(flags["appearAnimation.type"])) {
        defaults.appearAnimation = this.params.appearAnimation;
      }
      if (!isLocked(flags["disappearEasing.type"])) {
        defaults.disappearEasing = this.params.disappearEasing;
      }
      if (!isLocked(flags["disappearAnimation.type"])) {
        defaults.disappearAnimation = this.params.disappearAnimation;
      }
      if (!isLocked(flags["motionBlur.enabled"])) {
        defaults.motionBlur = this.params.motionBlur;
      }
      if (!isLocked(flags.origin)) {
        return defaults.origin = this.params.origin;
      }
    };

    Component_CommandInterpreter.prototype.createPicture = function(graphic, params) {
      var animation, bitmap, defaults, duration, easing, flags, graphicName, isLocked, number, origin, picture, pictures, ref, ref1, ref2, ref3, ref4, ref5, ref6, scene, snapshot, x, y, zIndex;
      graphic = this.stringValueOf(graphic);
      graphicName = (graphic != null ? graphic.name : void 0) != null ? graphic.name : graphic;
      bitmap = ResourceManager.getBitmap("Graphics/Pictures/" + graphicName);
      if (bitmap && !bitmap.loaded) {
        return null;
      }
      defaults = GameManager.defaults.picture;
      flags = params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      scene = SceneManager.scene;
      number = this.numberValueOf(params.number);
      pictures = scene.pictures;
      picture = pictures[number];
      if (picture == null) {
        picture = new gs.Object_Picture(null, null, (ref = params.visual) != null ? ref.type : void 0);
        picture.domain = params.numberDomain;
        pictures[number] = picture;
        switch ((ref1 = params.visual) != null ? ref1.type : void 0) {
          case 1:
            picture.visual.looping.vertical = true;
            picture.visual.looping.horizontal = true;
            break;
          case 2:
            picture.frameThickness = params.visual.frame.thickness;
            picture.frameCornerSize = params.visual.frame.cornerSize;
            break;
          case 3:
            picture.visual.orientation = params.visual.threePartImage.orientation;
            break;
          case 4:
            picture.color = gs.Color.fromObject(params.visual.quad.color);
            break;
          case 5:
            snapshot = Graphics.snapshot();
            picture.bitmap = snapshot;
            picture.dstRect.width = snapshot.width;
            picture.dstRect.height = snapshot.height;
            picture.srcRect.set(0, 0, snapshot.width, snapshot.height);
        }
      } else {
        picture.bitmap = null;
      }
      x = this.numberValueOf(params.position.x);
      y = this.numberValueOf(params.position.y);
      picture = pictures[number];
      if (!picture.bitmap) {
        picture.image = graphicName;
      } else {
        picture.image = null;
      }
      bitmap = (ref2 = picture.bitmap) != null ? ref2 : ResourceManager.getBitmap("Graphics/Pictures/" + graphicName);
      easing = !isLocked(flags["easing.type"]) ? gs.Easings.fromValues(this.numberValueOf(params.easing.type), params.easing.inOut) : gs.Easings.fromObject(defaults.appearEasing);
      duration = !isLocked(flags.duration) ? this.durationValueOf(params.duration) : defaults.appearDuration;
      origin = !isLocked(flags.origin) ? params.origin : defaults.origin;
      zIndex = !isLocked(flags.zOrder) ? this.numberValueOf(params.zOrder) : defaults.zOrder;
      animation = !isLocked(flags["animation.type"]) ? params.animation : defaults.appearAnimation;
      picture.mirror = params.position.horizontalFlip;
      picture.angle = params.position.angle || 0;
      picture.zoom.x = ((ref3 = params.position.data) != null ? ref3.zoom : void 0) || 1;
      picture.zoom.y = ((ref4 = params.position.data) != null ? ref4.zoom : void 0) || 1;
      picture.blendMode = this.numberValueOf(params.blendMode);
      if (params.origin === 1 && (bitmap != null)) {
        x += (bitmap.width * picture.zoom.x - bitmap.width) / 2;
        y += (bitmap.height * picture.zoom.y - bitmap.height) / 2;
      }
      picture.dstRect.x = x;
      picture.dstRect.y = y;
      picture.anchor.x = origin === 1 ? 0.5 : 0;
      picture.anchor.y = origin === 1 ? 0.5 : 0;
      picture.zIndex = zIndex || (700 + number);
      if (((ref5 = params.viewport) != null ? ref5.type : void 0) === "scene") {
        picture.viewport = SceneManager.scene.behavior.viewport;
      }
      if (((ref6 = params.size) != null ? ref6.type : void 0) === 1) {
        picture.dstRect.width = this.numberValueOf(params.size.width);
        picture.dstRect.height = this.numberValueOf(params.size.height);
      }
      picture.update();
      return picture;
    };


    /**
    * @method commandShowPicture
    * @protected
     */

    Component_CommandInterpreter.prototype.commandShowPicture = function() {
      var animation, defaults, duration, easing, flags, isLocked, p, picture;
      SceneManager.scene.behavior.changePictureDomain(this.params.numberDomain || "");
      defaults = GameManager.defaults.picture;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      picture = this.interpreter.createPicture(this.params.graphic, this.params);
      if (!picture) {
        this.interpreter.pointer--;
        this.interpreter.isWaiting = true;
        this.interpreter.waitCounter = 1;
        return;
      }
      if (this.params.positionType === 0) {
        p = this.interpreter.predefinedObjectPosition(this.params.predefinedPositionId, picture, this.params);
        picture.dstRect.x = p.x;
        picture.dstRect.y = p.y;
      }
      easing = !isLocked(flags["easing.type"]) ? gs.Easings.fromValues(this.interpreter.numberValueOf(this.params.easing.type), this.params.easing.inOut) : gs.Easings.fromObject(defaults.appearEasing);
      duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.appearDuration;
      animation = !isLocked(flags["animation.type"]) ? this.params.animation : defaults.appearAnimation;
      picture.animator.appear(picture.dstRect.x, picture.dstRect.y, animation, easing, duration);
      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {
        this.interpreter.isWaiting = true;
        this.interpreter.waitCounter = duration;
      }
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandPlayPictureAnimation
    * @protected
     */

    Component_CommandInterpreter.prototype.commandPlayPictureAnimation = function() {
      var animation, bitmap, component, defaults, duration, easing, flags, isLocked, p, picture, record;
      SceneManager.scene.behavior.changePictureDomain(this.params.numberDomain || "");
      defaults = GameManager.defaults.picture;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      picture = null;
      easing = !isLocked(flags["easing.type"]) ? gs.Easings.fromValues(this.interpreter.numberValueOf(this.params.easing.type), this.params.easing.inOut) : gs.Easings.fromObject(defaults.appearEasing);
      duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.appearDuration;
      animation = !isLocked(flags["animation.type"]) ? this.params.animation : defaults.appearAnimation;
      if (this.params.animationId != null) {
        record = RecordManager.animations[this.params.animationId];
        if (record != null) {
          picture = this.interpreter.createPicture(record.graphic, this.params);
          component = picture.findComponent("Component_FrameAnimation");
          if (component != null) {
            component.refresh(record);
            component.start();
          } else {
            component = new gs.Component_FrameAnimation(record);
            picture.addComponent(component);
          }
          component.update();
          if (this.params.positionType === 0) {
            p = this.interpreter.predefinedObjectPosition(this.params.predefinedPositionId, picture, this.params);
            picture.dstRect.x = p.x;
            picture.dstRect.y = p.y;
          }
          picture.animator.appear(picture.dstRect.x, picture.dstRect.y, animation, easing, duration);
        }
      } else {
        picture = SceneManager.scene.pictures[this.interpreter.numberValueOf(this.params.number)];
        animation = picture != null ? picture.findComponent("Component_FrameAnimation") : void 0;
        if (animation != null) {
          picture.removeComponent(animation);
          bitmap = ResourceManager.getBitmap("Graphics/Animations/" + picture.image);
          if (bitmap != null) {
            picture.srcRect.set(0, 0, bitmap.width, bitmap.height);
            picture.dstRect.width = picture.srcRect.width;
            picture.dstRect.height = picture.srcRect.height;
          }
        }
      }
      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {
        this.interpreter.isWaiting = true;
        this.interpreter.waitCounter = duration;
      }
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandMovePicturePath
    * @protected
     */

    Component_CommandInterpreter.prototype.commandMovePicturePath = function() {
      var number, picture, scene;
      scene = SceneManager.scene;
      scene.behavior.changePictureDomain(this.params.numberDomain);
      number = this.interpreter.numberValueOf(this.params.number);
      picture = scene.pictures[number];
      if (picture == null) {
        return;
      }
      this.interpreter.moveObjectPath(picture, this.params.path, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandMovePicture
    * @protected
     */

    Component_CommandInterpreter.prototype.commandMovePicture = function() {
      var number, picture, scene;
      scene = SceneManager.scene;
      scene.behavior.changePictureDomain(this.params.numberDomain);
      number = this.interpreter.numberValueOf(this.params.number);
      picture = scene.pictures[number];
      if (picture == null) {
        return;
      }
      this.interpreter.moveObject(picture, this.params.picture.position, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandTintPicture
    * @protected
     */

    Component_CommandInterpreter.prototype.commandTintPicture = function() {
      var number, picture, scene;
      scene = SceneManager.scene;
      scene.behavior.changePictureDomain(this.params.numberDomain || "");
      number = this.interpreter.numberValueOf(this.params.number);
      picture = scene.pictures[number];
      if (picture == null) {
        return;
      }
      this.interpreter.tintObject(picture, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandFlashPicture
    * @protected
     */

    Component_CommandInterpreter.prototype.commandFlashPicture = function() {
      var number, picture, scene;
      scene = SceneManager.scene;
      scene.behavior.changePictureDomain(this.params.numberDomain || "");
      number = this.interpreter.numberValueOf(this.params.number);
      picture = scene.pictures[number];
      if (picture == null) {
        return;
      }
      this.interpreter.flashObject(picture, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandCropPicture
    * @protected
     */

    Component_CommandInterpreter.prototype.commandCropPicture = function() {
      var number, picture, scene;
      scene = SceneManager.scene;
      scene.behavior.changePictureDomain(this.params.numberDomain || "");
      number = this.interpreter.numberValueOf(this.params.number);
      picture = scene.pictures[number];
      if (picture == null) {
        return;
      }
      return this.interpreter.cropObject(picture, this.params);
    };


    /**
    * @method commandRotatePicture
    * @protected
     */

    Component_CommandInterpreter.prototype.commandRotatePicture = function() {
      var number, picture, scene;
      scene = SceneManager.scene;
      scene.behavior.changePictureDomain(this.params.numberDomain || "");
      number = this.interpreter.numberValueOf(this.params.number);
      picture = scene.pictures[number];
      if (picture == null) {
        return;
      }
      this.interpreter.rotateObject(picture, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandZoomPicture
    * @protected
     */

    Component_CommandInterpreter.prototype.commandZoomPicture = function() {
      var number, picture, scene;
      scene = SceneManager.scene;
      scene.behavior.changePictureDomain(this.params.numberDomain || "");
      number = this.interpreter.numberValueOf(this.params.number);
      picture = scene.pictures[number];
      if (picture == null) {
        return;
      }
      this.interpreter.zoomObject(picture, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandBlendPicture
    * @protected
     */

    Component_CommandInterpreter.prototype.commandBlendPicture = function() {
      var picture;
      SceneManager.scene.behavior.changePictureDomain(this.params.numberDomain || "");
      picture = SceneManager.scene.pictures[this.interpreter.numberValueOf(this.params.number)];
      if (picture == null) {
        return;
      }
      this.interpreter.blendObject(picture, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandShakePicture
    * @protected
     */

    Component_CommandInterpreter.prototype.commandShakePicture = function() {
      var picture;
      picture = SceneManager.scene.pictures[this.interpreter.numberValueOf(this.params.number)];
      if (picture == null) {
        return;
      }
      this.interpreter.shakeObject(picture, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandMaskPicture
    * @protected
     */

    Component_CommandInterpreter.prototype.commandMaskPicture = function() {
      var number, picture, scene;
      scene = SceneManager.scene;
      scene.behavior.changePictureDomain(this.params.numberDomain || "");
      number = this.interpreter.numberValueOf(this.params.number);
      picture = scene.pictures[number];
      if (picture == null) {
        return;
      }
      this.interpreter.maskObject(picture, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandPictureMotionBlur
    * @protected
     */

    Component_CommandInterpreter.prototype.commandPictureMotionBlur = function() {
      var number, picture, scene;
      scene = SceneManager.scene;
      scene.behavior.changePictureDomain(this.params.numberDomain || "");
      number = this.interpreter.numberValueOf(this.params.number);
      picture = scene.pictures[number];
      if (picture == null) {
        return;
      }
      this.interpreter.objectMotionBlur(picture, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandPictureEffect
    * @protected
     */

    Component_CommandInterpreter.prototype.commandPictureEffect = function() {
      var number, picture, scene;
      scene = SceneManager.scene;
      scene.behavior.changePictureDomain(this.params.numberDomain || "");
      number = this.interpreter.numberValueOf(this.params.number);
      picture = scene.pictures[number];
      if (picture == null) {
        return;
      }
      this.interpreter.objectEffect(picture, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandErasePicture
    * @protected
     */

    Component_CommandInterpreter.prototype.commandErasePicture = function() {
      var animation, defaults, duration, easing, flags, isLocked, number, picture, scene;
      defaults = GameManager.defaults.picture;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      scene = SceneManager.scene;
      scene.behavior.changePictureDomain(this.params.numberDomain || "");
      number = this.interpreter.numberValueOf(this.params.number);
      picture = scene.pictures[number];
      if (picture == null) {
        return;
      }
      easing = !isLocked(flags["easing.type"]) ? gs.Easings.fromValues(this.interpreter.numberValueOf(this.params.easing.type), this.params.easing.inOut) : gs.Easings.fromObject(defaults.disappearEasing);
      duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.disappearDuration;
      animation = !isLocked(flags["animation.type"]) ? this.params.animation : defaults.disappearAnimation;
      picture.animator.disappear(animation, easing, duration, (function(_this) {
        return function(sender) {
          sender.dispose();
          scene.behavior.changePictureDomain(sender.domain);
          return scene.pictures[number] = null;
        };
      })(this));
      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {
        this.interpreter.isWaiting = true;
        this.interpreter.waitCounter = duration;
      }
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandInputNumber
    * @protected
     */

    Component_CommandInterpreter.prototype.commandInputNumber = function() {
      var scene;
      scene = SceneManager.scene;
      this.interpreter.isWaiting = true;
      if (this.interpreter.isProcessingMessageInOtherContext()) {
        this.interpreter.waitForMessage();
        return;
      }
      if ((GameManager.settings.allowChoiceSkip || this.interpreter.preview) && GameManager.tempSettings.skip) {
        this.interpreter.isWaiting = false;
        this.interpreter.messageObject().behavior.clear();
        this.interpreter.setNumberValueTo(this.params.variable, 0);
        return;
      }
      $tempFields.digits = this.params.digits;
      scene.behavior.showInputNumber(this.params.digits, gs.CallBack("onInputNumberFinish", this.interpreter, this.params));
      this.interpreter.waitingFor.inputNumber = this.params;
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandChoiceTimer
    * @protected
     */

    Component_CommandInterpreter.prototype.commandChoiceTimer = function() {
      var scene;
      scene = SceneManager.scene;
      GameManager.tempFields.choiceTimer = scene.choiceTimer;
      GameManager.tempFields.choiceTimerVisible = this.params.visible;
      if (this.params.enabled) {
        scene.choiceTimer.behavior.seconds = this.interpreter.numberValueOf(this.params.seconds);
        scene.choiceTimer.behavior.minutes = this.interpreter.numberValueOf(this.params.minutes);
        scene.choiceTimer.behavior.start();
        return scene.choiceTimer.events.on("finish", (function(_this) {
          return function(sender) {
            var defaultChoice, ref;
            if (scene.choiceWindow && ((ref = scene.choices) != null ? ref.length : void 0) > 0) {
              defaultChoice = (scene.choices.first(function(c) {
                return c.isDefault;
              })) || scene.choices[0];
              return scene.choiceWindow.events.emit("selectionAccept", scene.choiceWindow, defaultChoice);
            }
          };
        })(this));
      } else {
        return scene.choiceTimer.stop();
      }
    };


    /**
    * @method commandShowChoices
    * @protected
     */

    Component_CommandInterpreter.prototype.commandShowChoices = function() {
      var choices, defaultChoice, messageObject, pointer, scene;
      scene = SceneManager.scene;
      pointer = this.interpreter.pointer;
      choices = scene.choices || [];
      if ((GameManager.settings.allowChoiceSkip || this.interpreter.previewData) && GameManager.tempSettings.skip) {
        messageObject = this.interpreter.messageObject();
        if (messageObject != null ? messageObject.visible : void 0) {
          messageObject.behavior.clear();
        }
        defaultChoice = (choices.first(function(c) {
          return c.isDefault;
        })) || choices[0];
        if (defaultChoice.action.labelIndex != null) {
          this.interpreter.pointer = defaultChoice.action.labelIndex;
        } else {
          this.interpreter.jumpToLabel(defaultChoice.action.label);
        }
        scene.choices = [];
      } else {
        if (choices.length > 0) {
          this.interpreter.isWaiting = true;
          scene.behavior.showChoices(gs.CallBack("onChoiceAccept", this.interpreter, {
            pointer: pointer,
            params: this.params
          }));
        }
      }
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandShowChoice
    * @protected
     */

    Component_CommandInterpreter.prototype.commandShowChoice = function() {
      var choices, command, commands, dstRect, index, pointer, scene;
      scene = SceneManager.scene;
      commands = this.interpreter.object.commands;
      command = null;
      index = 0;
      pointer = this.interpreter.pointer;
      choices = null;
      dstRect = null;
      switch (this.params.positionType) {
        case 0:
          dstRect = null;
          break;
        case 1:
          dstRect = new Rect(this.params.box.x, this.params.box.y, this.params.box.size.width, this.params.box.size.height);
      }
      if (!scene.choices) {
        scene.choices = [];
      }
      choices = scene.choices;
      return choices.push({
        dstRect: dstRect,
        text: this.params.text,
        index: index,
        action: this.params.action,
        isSelected: false,
        isDefault: this.params.defaultChoice,
        isEnabled: this.interpreter.booleanValueOf(this.params.enabled)
      });
    };


    /**
    * @method commandOpenMenu
    * @protected
     */

    Component_CommandInterpreter.prototype.commandOpenMenu = function() {
      SceneManager.switchTo(new gs.Object_Layout("menuLayout"), true);
      this.interpreter.waitCounter = 1;
      return this.interpreter.isWaiting = true;
    };


    /**
    * @method commandOpenLoadMenu
    * @protected
     */

    Component_CommandInterpreter.prototype.commandOpenLoadMenu = function() {
      SceneManager.switchTo(new gs.Object_Layout("loadMenuLayout"), true);
      this.interpreter.waitCounter = 1;
      return this.interpreter.isWaiting = true;
    };


    /**
    * @method commandOpenSaveMenu
    * @protected
     */

    Component_CommandInterpreter.prototype.commandOpenSaveMenu = function() {
      SceneManager.switchTo(new gs.Object_Layout("saveMenuLayout"), true);
      this.interpreter.waitCounter = 1;
      return this.interpreter.isWaiting = true;
    };


    /**
    * @method commandReturnToTitle
    * @protected
     */

    Component_CommandInterpreter.prototype.commandReturnToTitle = function() {
      SceneManager.clear();
      SceneManager.switchTo(new gs.Object_Layout("titleLayout"));
      this.interpreter.waitCounter = 1;
      return this.interpreter.isWaiting = true;
    };


    /**
    * @method commandPlayVideo
    * @protected
     */

    Component_CommandInterpreter.prototype.commandPlayVideo = function() {
      var ref, scene;
      if ((GameManager.inLivePreview || GameManager.settings.allowVideoSkip) && GameManager.tempSettings.skip) {
        return;
      }
      GameManager.tempSettings.skip = false;
      scene = SceneManager.scene;
      if (((ref = this.params.video) != null ? ref.name : void 0) != null) {
        scene.video = ResourceManager.getVideo("Movies/" + this.params.video.name);
        this.videoSprite = new Sprite(Graphics.viewport);
        this.videoSprite.srcRect = new Rect(0, 0, scene.video.width, scene.video.height);
        this.videoSprite.video = scene.video;
        this.videoSprite.zoomX = Graphics.width / scene.video.width;
        this.videoSprite.zoomY = Graphics.height / scene.video.height;
        this.videoSprite.z = 99999999;
        scene.video.onEnded = (function(_this) {
          return function() {
            _this.interpreter.isWaiting = false;
            _this.videoSprite.dispose();
            return scene.video = null;
          };
        })(this);
        scene.video.volume = this.params.volume / 100;
        scene.video.playbackRate = this.params.playbackRate / 100;
        this.interpreter.isWaiting = true;
        scene.video.play();
      }
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandAudioDefaults
    * @protected
     */

    Component_CommandInterpreter.prototype.commandAudioDefaults = function() {
      var defaults, flags, isLocked;
      defaults = GameManager.defaults.audio;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      if (!isLocked(flags.musicFadeInDuration)) {
        defaults.musicFadeInDuration = this.params.musicFadeInDuration;
      }
      if (!isLocked(flags.musicFadeOutDuration)) {
        defaults.musicFadeOutDuration = this.params.musicFadeOutDuration;
      }
      if (!isLocked(flags.musicVolume)) {
        defaults.musicVolume = this.params.musicVolume;
      }
      if (!isLocked(flags.musicPlaybackRate)) {
        defaults.musicPlaybackRate = this.params.musicPlaybackRate;
      }
      if (!isLocked(flags.soundVolume)) {
        defaults.soundVolume = this.params.soundVolume;
      }
      if (!isLocked(flags.soundPlaybackRate)) {
        defaults.soundPlaybackRate = this.params.soundPlaybackRate;
      }
      if (!isLocked(flags.voiceVolume)) {
        defaults.voiceVolume = this.params.voiceVolume;
      }
      if (!isLocked(flags.voicePlaybackRate)) {
        return defaults.voicePlaybackRate = this.params.voicePlaybackRate;
      }
    };


    /**
    * @method commandPlayMusic
    * @protected
     */

    Component_CommandInterpreter.prototype.commandPlayMusic = function() {
      var defaults, fadeDuration, flags, isLocked, music, playRange, playTime, playbackRate, volume;
      if (this.params.music == null) {
        return;
      }
      defaults = GameManager.defaults.audio;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      music = null;
      if (GameManager.settings.bgmEnabled) {
        fadeDuration = !isLocked(flags.fadeInDuration) ? this.params.fadeInDuration : defaults.musicFadeInDuration;
        volume = !isLocked(flags["music.volume"]) ? this.params.music.volume : defaults.musicVolume;
        playbackRate = !isLocked(flags["music.playbackRate"]) ? this.params.music.playbackRate : defaults.musicPlaybackRate;
        music = {
          name: this.params.music.name,
          volume: volume,
          playbackRate: playbackRate
        };
        if (this.params.playType === 1) {
          playTime = {
            min: this.params.playTime.min * 60,
            max: this.params.playTime.max * 60
          };
          playRange = {
            start: this.params.playRange.start * 60,
            end: this.params.playRange.end * 60
          };
          AudioManager.playMusicRandom(music, fadeDuration, this.params.layer || 0, playTime, playRange);
        } else {
          music = AudioManager.playMusic(this.params.music.name, volume, playbackRate, fadeDuration, this.params.layer || 0, this.params.loop);
        }
      }
      if (music && this.params.waitForCompletion && !this.params.loop) {
        this.interpreter.isWaiting = true;
        this.interpreter.waitCounter = Math.round(music.duration * Graphics.frameRate);
      }
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandStopMusic
    * @protected
     */

    Component_CommandInterpreter.prototype.commandStopMusic = function() {
      var defaults, fadeDuration, flags, isLocked;
      defaults = GameManager.defaults.audio;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      fadeDuration = !isLocked(flags.fadeOutDuration) ? this.params.fadeOutDuration : defaults.musicFadeOutDuration;
      AudioManager.stopMusic(fadeDuration, this.interpreter.numberValueOf(this.params.layer));
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandPauseMusic
    * @protected
     */

    Component_CommandInterpreter.prototype.commandPauseMusic = function() {
      var defaults, fadeDuration, flags, isLocked;
      defaults = GameManager.defaults.audio;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      fadeDuration = !isLocked(flags.fadeOutDuration) ? this.params.fadeOutDuration : defaults.musicFadeOutDuration;
      return AudioManager.stopMusic(fadeDuration, this.interpreter.numberValueOf(this.params.layer));
    };


    /**
    * @method commandResumeMusic
    * @protected
     */

    Component_CommandInterpreter.prototype.commandResumeMusic = function() {
      var defaults, fadeDuration, flags, isLocked;
      defaults = GameManager.defaults.audio;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      fadeDuration = !isLocked(flags.fadeInDuration) ? this.params.fadeInDuration : defaults.musicFadeInDuration;
      AudioManager.resumeMusic(fadeDuration, this.interpreter.numberValueOf(this.params.layer));
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandPlaySound
    * @protected
     */

    Component_CommandInterpreter.prototype.commandPlaySound = function() {
      var defaults, flags, isLocked, playbackRate, sound, volume;
      defaults = GameManager.defaults.audio;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      sound = null;
      if (GameManager.settings.soundEnabled && !GameManager.tempSettings.skip) {
        volume = !isLocked(flags["sound.volume"]) ? this.params.sound.volume : defaults.soundVolume;
        playbackRate = !isLocked(flags["sound.playbackRate"]) ? this.params.sound.playbackRate : defaults.soundPlaybackRate;
        sound = AudioManager.playSound(this.params.sound.name, volume, playbackRate, this.params.musicEffect, null, this.params.loop);
      }
      gs.GameNotifier.postMinorChange();
      if (sound && this.params.waitForCompletion && !this.params.loop) {
        this.interpreter.isWaiting = true;
        return this.interpreter.waitCounter = Math.round(sound.duration * Graphics.frameRate);
      }
    };


    /**
    * @method commandStopSound
    * @protected
     */

    Component_CommandInterpreter.prototype.commandStopSound = function() {
      AudioManager.stopSound(this.params.sound.name);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandEndCommonEvent
    * @protected
     */

    Component_CommandInterpreter.prototype.commandEndCommonEvent = function() {
      var event, eventId;
      eventId = this.interpreter.stringValueOf(this.params.commonEventId);
      event = GameManager.commonEvents[eventId];
      return event != null ? event.behavior.stop() : void 0;
    };


    /**
    * @method commandResumeCommonEvent
    * @protected
     */

    Component_CommandInterpreter.prototype.commandResumeCommonEvent = function() {
      var event, eventId;
      eventId = this.interpreter.stringValueOf(this.params.commonEventId);
      event = GameManager.commonEvents[eventId];
      return event != null ? event.behavior.resume() : void 0;
    };


    /**
    * @method commandCallCommonEvent
    * @protected
     */

    Component_CommandInterpreter.prototype.commandCallCommonEvent = function() {
      var eventId, list, params, scene;
      scene = SceneManager.scene;
      eventId = null;
      if (this.params.commonEventId.index != null) {
        eventId = this.interpreter.stringValueOf(this.params.commonEventId);
        list = this.interpreter.listObjectOf(this.params.parameters.values[0]);
        params = {
          values: list
        };
      } else {
        params = this.params.parameters;
        eventId = this.params.commonEventId;
      }
      return this.interpreter.callCommonEvent(eventId, params);
    };


    /**
    * @method commandChangeTextSettings
    * @protected
     */

    Component_CommandInterpreter.prototype.commandChangeTextSettings = function() {
      var flags, font, fontName, fontSize, isLocked, number, padding, ref, ref1, ref2, ref3, ref4, scene, textSprite, texts;
      scene = SceneManager.scene;
      scene.behavior.changeTextDomain(this.params.numberDomain);
      number = this.interpreter.numberValueOf(this.params.number);
      texts = scene.texts;
      if (texts[number] == null) {
        texts[number] = new gs.Object_Text();
        texts[number].visible = false;
      }
      textSprite = texts[number];
      padding = textSprite.behavior.padding;
      font = textSprite.font;
      fontName = textSprite.font.name;
      fontSize = textSprite.font.size;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      if (!isLocked(flags.lineSpacing)) {
        textSprite.textRenderer.lineSpacing = (ref = this.params.lineSpacing) != null ? ref : textSprite.textRenderer.lineSpacing;
      }
      if (!isLocked(flags.font)) {
        fontName = this.interpreter.stringValueOf(this.params.font);
      }
      if (!isLocked(flags.size)) {
        fontSize = this.interpreter.numberValueOf(this.params.size);
      }
      if (!isLocked(flags.font) || !isLocked(flags.size)) {
        textSprite.font = new Font(fontName, fontSize);
      }
      padding.left = !isLocked(flags["padding.0"]) ? (ref1 = this.params.padding) != null ? ref1[0] : void 0 : padding.left;
      padding.top = !isLocked(flags["padding.1"]) ? (ref2 = this.params.padding) != null ? ref2[1] : void 0 : padding.top;
      padding.right = !isLocked(flags["padding.2"]) ? (ref3 = this.params.padding) != null ? ref3[2] : void 0 : padding.right;
      padding.bottom = !isLocked(flags["padding.3"]) ? (ref4 = this.params.padding) != null ? ref4[3] : void 0 : padding.bottom;
      if (!isLocked(flags.bold)) {
        textSprite.font.bold = this.params.bold;
      }
      if (!isLocked(flags.italic)) {
        textSprite.font.italic = this.params.italic;
      }
      if (!isLocked(flags.smallCaps)) {
        textSprite.font.smallCaps = this.params.smallCaps;
      }
      if (!isLocked(flags.underline)) {
        textSprite.font.underline = this.params.underline;
      }
      if (!isLocked(flags.strikeThrough)) {
        textSprite.font.strikeThrough = this.params.strikeThrough;
      }
      textSprite.font.color = !isLocked(flags.color) ? new Color(this.params.color) : font.color;
      textSprite.font.border = !isLocked(flags.outline) ? this.params.outline : font.border;
      textSprite.font.borderColor = !isLocked(flags.outlineColor) ? new Color(this.params.outlineColor) : new Color(font.borderColor);
      textSprite.font.borderSize = !isLocked(flags.outlineSize) ? this.params.outlineSize : font.borderSize;
      textSprite.font.shadow = !isLocked(flags.shadow) ? this.params.shadow : font.shadow;
      textSprite.font.shadowColor = !isLocked(flags.shadowColor) ? new Color(this.params.shadowColor) : new Color(font.shadowColor);
      textSprite.font.shadowOffsetX = !isLocked(flags.shadowOffsetX) ? this.params.shadowOffsetX : font.shadowOffsetX;
      textSprite.font.shadowOffsetY = !isLocked(flags.shadowOffsetY) ? this.params.shadowOffsetY : font.shadowOffsetY;
      textSprite.behavior.refresh();
      return textSprite.update();
    };


    /**
    * @method commandChangeTextSettings
    * @protected
     */

    Component_CommandInterpreter.prototype.commandTextDefaults = function() {
      var defaults, flags, isLocked;
      defaults = GameManager.defaults.text;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      if (!isLocked(flags.appearDuration)) {
        defaults.appearDuration = this.interpreter.durationValueOf(this.params.appearDuration);
      }
      if (!isLocked(flags.disappearDuration)) {
        defaults.disappearDuration = this.interpreter.durationValueOf(this.params.disappearDuration);
      }
      if (!isLocked(flags.zOrder)) {
        defaults.zOrder = this.interpreter.numberValueOf(this.params.zOrder);
      }
      if (!isLocked(flags["appearEasing.type"])) {
        defaults.appearEasing = this.params.appearEasing;
      }
      if (!isLocked(flags["appearAnimation.type"])) {
        defaults.appearAnimation = this.params.appearAnimation;
      }
      if (!isLocked(flags["disappearEasing.type"])) {
        defaults.disappearEasing = this.params.disappearEasing;
      }
      if (!isLocked(flags["disappearAnimation.type"])) {
        defaults.disappearAnimation = this.params.disappearAnimation;
      }
      if (!isLocked(flags["motionBlur.enabled"])) {
        defaults.motionBlur = this.params.motionBlur;
      }
      if (!isLocked(flags.origin)) {
        return defaults.origin = this.params.origin;
      }
    };


    /**
    * @method commandShowText
    * @protected
     */

    Component_CommandInterpreter.prototype.commandShowText = function() {
      var animation, defaults, duration, easing, flags, isLocked, number, origin, p, positionAnchor, ref, scene, text, textObject, texts, x, y, zIndex;
      defaults = GameManager.defaults.text;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      scene = SceneManager.scene;
      scene.behavior.changeTextDomain(this.params.numberDomain);
      number = this.interpreter.numberValueOf(this.params.number);
      text = this.params.text;
      texts = scene.texts;
      if (texts[number] == null) {
        texts[number] = new gs.Object_Text();
      }
      x = this.interpreter.numberValueOf(this.params.position.x);
      y = this.interpreter.numberValueOf(this.params.position.y);
      textObject = texts[number];
      textObject.domain = this.params.numberDomain;
      easing = !isLocked(flags["easing.type"]) ? gs.Easings.fromValues(this.interpreter.numberValueOf(this.params.easing.type), this.params.easing.inOut) : gs.Easings.fromObject(defaults.appearEasing);
      duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.appearDuration;
      origin = !isLocked(flags.origin) ? this.params.origin : defaults.origin;
      zIndex = !isLocked(flags.zOrder) ? this.interpreter.numberValueOf(this.params.zOrder) : defaults.zOrder;
      animation = !isLocked(flags["animation.type"]) ? this.params.animation : defaults.appearAnimation;
      positionAnchor = !isLocked(flags.positionOrigin) ? this.interpreter.graphicAnchorPointsByConstant[this.params.positionOrigin] || new gs.Point(0, 0) : this.interpreter.graphicAnchorPointsByConstant[defaults.positionOrigin];
      textObject.text = text;
      textObject.dstRect.x = x;
      textObject.dstRect.y = y;
      textObject.blendMode = this.interpreter.numberValueOf(this.params.blendMode);
      textObject.anchor.x = origin === 0 ? 0 : 0.5;
      textObject.anchor.y = origin === 0 ? 0 : 0.5;
      textObject.positionAnchor.x = positionAnchor.x;
      textObject.positionAnchor.y = positionAnchor.y;
      textObject.zIndex = zIndex || (700 + number);
      textObject.sizeToFit = true;
      textObject.formatting = true;
      if (((ref = this.params.viewport) != null ? ref.type : void 0) === "scene") {
        textObject.viewport = SceneManager.scene.behavior.viewport;
      }
      textObject.update();
      if (this.params.positionType === 0) {
        p = this.interpreter.predefinedObjectPosition(this.params.predefinedPositionId, textObject, this.params);
        textObject.dstRect.x = p.x;
        textObject.dstRect.y = p.y;
      }
      textObject.animator.appear(x, y, animation, easing, duration);
      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {
        this.interpreter.isWaiting = true;
        this.interpreter.waitCounter = duration;
      }
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandTextMotionBlur
    * @protected
     */

    Component_CommandInterpreter.prototype.commandTextMotionBlur = function() {
      var number, scene, text;
      scene = SceneManager.scene;
      scene.behavior.changeTextDomain(this.params.numberDomain);
      number = this.interpreter.numberValueOf(this.params.number);
      text = scene.texts[number];
      if (text == null) {
        return;
      }
      return text.motionBlur.set(this.params.motionBlur);
    };


    /**
    * @method commandRefreshText
    * @protected
     */

    Component_CommandInterpreter.prototype.commandRefreshText = function() {
      var number, scene, texts;
      scene = SceneManager.scene;
      scene.behavior.changeTextDomain(this.params.numberDomain);
      number = this.interpreter.numberValueOf(this.params.number);
      texts = scene.texts;
      if (texts[number] == null) {
        return;
      }
      return texts[number].behavior.refresh(true);
    };


    /**
    * @method commandMoveText
    * @protected
     */

    Component_CommandInterpreter.prototype.commandMoveText = function() {
      var number, scene, text;
      scene = SceneManager.scene;
      scene.behavior.changeTextDomain(this.params.numberDomain);
      number = this.interpreter.numberValueOf(this.params.number);
      text = scene.texts[number];
      if (text == null) {
        return;
      }
      this.interpreter.moveObject(text, this.params.picture.position, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandMoveTextPath
    * @protected
     */

    Component_CommandInterpreter.prototype.commandMoveTextPath = function() {
      var number, scene, text;
      scene = SceneManager.scene;
      scene.behavior.changeTextDomain(this.params.numberDomain);
      number = this.interpreter.numberValueOf(this.params.number);
      text = scene.texts[number];
      if (text == null) {
        return;
      }
      this.interpreter.moveObjectPath(text, this.params.path, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandRotateText
    * @protected
     */

    Component_CommandInterpreter.prototype.commandRotateText = function() {
      var number, scene, text;
      scene = SceneManager.scene;
      scene.behavior.changeTextDomain(this.params.numberDomain);
      number = this.interpreter.numberValueOf(this.params.number);
      text = scene.texts[number];
      if (text == null) {
        return;
      }
      this.interpreter.rotateObject(text, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandZoomText
    * @protected
     */

    Component_CommandInterpreter.prototype.commandZoomText = function() {
      var number, scene, text;
      scene = SceneManager.scene;
      scene.behavior.changeTextDomain(this.params.numberDomain);
      number = this.interpreter.numberValueOf(this.params.number);
      text = scene.texts[number];
      if (text == null) {
        return;
      }
      this.interpreter.zoomObject(text, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandBlendText
    * @protected
     */

    Component_CommandInterpreter.prototype.commandBlendText = function() {
      var text;
      SceneManager.scene.behavior.changeTextDomain(this.params.numberDomain);
      text = SceneManager.scene.texts[this.interpreter.numberValueOf(this.params.number)];
      if (text == null) {
        return;
      }
      this.interpreter.blendObject(text, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandColorText
    * @protected
     */

    Component_CommandInterpreter.prototype.commandColorText = function() {
      var duration, easing, number, scene, text;
      scene = SceneManager.scene;
      scene.behavior.changeTextDomain(this.params.numberDomain);
      number = this.interpreter.numberValueOf(this.params.number);
      text = scene.texts[number];
      duration = this.interpreter.durationValueOf(this.params.duration);
      easing = gs.Easings.fromObject(this.params.easing);
      if (text != null) {
        text.animator.colorTo(new Color(this.params.color), duration, easing);
        if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {
          this.interpreter.isWaiting = true;
          this.interpreter.waitCounter = duration;
        }
      }
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandEraseText
    * @protected
     */

    Component_CommandInterpreter.prototype.commandEraseText = function() {
      var animation, defaults, duration, easing, flags, isLocked, number, scene, text;
      defaults = GameManager.defaults.text;
      flags = this.params.fieldFlags || {};
      isLocked = gs.CommandFieldFlags.isLocked;
      scene = SceneManager.scene;
      scene.behavior.changeTextDomain(this.params.numberDomain);
      number = this.interpreter.numberValueOf(this.params.number);
      text = scene.texts[number];
      if (text == null) {
        return;
      }
      easing = !isLocked(flags["easing.type"]) ? gs.Easings.fromValues(this.interpreter.numberValueOf(this.params.easing.type), this.params.easing.inOut) : gs.Easings.fromObject(defaults.disappearEasing);
      duration = !isLocked(flags.duration) ? this.interpreter.durationValueOf(this.params.duration) : defaults.disappearDuration;
      animation = !isLocked(flags["animation.type"]) ? this.params.animation : defaults.disappearAnimation;
      text.animator.disappear(animation, easing, duration, (function(_this) {
        return function(sender) {
          sender.dispose();
          scene.behavior.changeTextDomain(sender.domain);
          return scene.texts[number] = null;
        };
      })(this));
      if (this.params.waitForCompletion && !(duration === 0 || this.interpreter.isInstantSkip())) {
        this.interpreter.isWaiting = true;
        this.interpreter.waitCounter = duration;
      }
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandTextEffect
    * @protected
     */

    Component_CommandInterpreter.prototype.commandTextEffect = function() {
      var number, scene, text;
      scene = SceneManager.scene;
      scene.behavior.changeTextDomain(this.params.numberDomain);
      number = this.interpreter.numberValueOf(this.params.number);
      text = scene.texts[number];
      if (text == null) {
        return;
      }
      this.interpreter.objectEffect(text, this.params);
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandInputText
    * @protected
     */

    Component_CommandInterpreter.prototype.commandInputText = function() {
      var scene;
      scene = SceneManager.scene;
      scene.behavior.changeTextDomain(this.params.numberDomain);
      if ((GameManager.settings.allowChoiceSkip || this.interpreter.preview) && GameManager.tempSettings.skip) {
        this.interpreter.messageObject().behavior.clear();
        this.interpreter.setStringValueTo(this.params.variable, "");
        return;
      }
      this.interpreter.isWaiting = true;
      if (this.interpreter.isProcessingMessageInOtherContext()) {
        this.interpreter.waitForMessage();
        return;
      }
      $tempFields.letters = this.params.letters;
      scene.behavior.showInputText(this.params.letters, gs.CallBack("onInputTextFinish", this.interpreter, this.interpreter));
      this.interpreter.waitingFor.inputText = this.params;
      return gs.GameNotifier.postMinorChange();
    };


    /**
    * @method commandSavePersistentData
    * @protected
     */

    Component_CommandInterpreter.prototype.commandSavePersistentData = function() {
      return GameManager.saveGlobalData();
    };


    /**
    * @method commandSaveSettings
    * @protected
     */

    Component_CommandInterpreter.prototype.commandSaveSettings = function() {
      return GameManager.saveSettings();
    };


    /**
    * @method commandPrepareSaveGame
    * @protected
     */

    Component_CommandInterpreter.prototype.commandPrepareSaveGame = function() {
      if (this.interpreter.previewData != null) {
        return;
      }
      this.interpreter.pointer++;
      GameManager.prepareSaveGame(this.params.snapshot);
      return this.interpreter.pointer--;
    };


    /**
    * @method commandSaveGame
    * @protected
     */

    Component_CommandInterpreter.prototype.commandSaveGame = function() {
      var thumbHeight, thumbWidth;
      if (this.interpreter.previewData != null) {
        return;
      }
      thumbWidth = this.interpreter.numberValueOf(this.params.thumbWidth);
      thumbHeight = this.interpreter.numberValueOf(this.params.thumbHeight);
      return GameManager.save(this.interpreter.numberValueOf(this.params.slot) - 1, thumbWidth, thumbHeight);
    };


    /**
    * @method commandLoadGame
    * @protected
     */

    Component_CommandInterpreter.prototype.commandLoadGame = function() {
      if (this.interpreter.previewData != null) {
        return;
      }
      return GameManager.load(this.interpreter.numberValueOf(this.params.slot) - 1);
    };


    /**
    * @method commandWaitForInput
    * @protected
     */

    Component_CommandInterpreter.prototype.commandWaitForInput = function() {
      var f;
      if (this.interpreter.isInstantSkip()) {
        return;
      }
      gs.GlobalEventManager.offByOwner("mouseDown", this.interpreter.object);
      gs.GlobalEventManager.offByOwner("mouseUp", this.interpreter.object);
      gs.GlobalEventManager.offByOwner("keyDown", this.interpreter.object);
      gs.GlobalEventManager.offByOwner("keyUp", this.interpreter.object);
      f = (function(_this) {
        return function() {
          var executeAction, key;
          key = _this.interpreter.numberValueOf(_this.params.key);
          executeAction = false;
          if (Input.Mouse.isButton(_this.params.key)) {
            executeAction = Input.Mouse.buttons[_this.params.key] === _this.params.state;
          } else if (_this.params.key === 100) {
            if (Input.keyDown && _this.params.state === 1) {
              executeAction = true;
            }
            if (Input.keyUp && _this.params.state === 2) {
              executeAction = true;
            }
          } else if (_this.params.key === 101) {
            if (Input.Mouse.buttonDown && _this.params.state === 1) {
              executeAction = true;
            }
            if (Input.Mouse.buttonUp && _this.params.state === 2) {
              executeAction = true;
            }
          } else if (_this.params.key === 102) {
            if ((Input.keyDown || Input.Mouse.buttonDown) && _this.params.state === 1) {
              executeAction = true;
            }
            if ((Input.keyUp || Input.Mouse.buttonUp) && _this.params.state === 2) {
              executeAction = true;
            }
          } else {
            key = key > 100 ? key - 100 : key;
            executeAction = Input.keys[key] === _this.params.state;
          }
          if (executeAction) {
            _this.interpreter.isWaiting = false;
            gs.GlobalEventManager.offByOwner("mouseDown", _this.interpreter.object);
            gs.GlobalEventManager.offByOwner("mouseUp", _this.interpreter.object);
            gs.GlobalEventManager.offByOwner("keyDown", _this.interpreter.object);
            return gs.GlobalEventManager.offByOwner("keyUp", _this.interpreter.object);
          }
        };
      })(this);
      gs.GlobalEventManager.on("mouseDown", f, null, this.interpreter.object);
      gs.GlobalEventManager.on("mouseUp", f, null, this.interpreter.object);
      gs.GlobalEventManager.on("keyDown", f, null, this.interpreter.object);
      gs.GlobalEventManager.on("keyUp", f, null, this.interpreter.object);
      return this.interpreter.isWaiting = true;
    };


    /**
    * @method commandGetInputData
    * @protected
     */

    Component_CommandInterpreter.prototype.commandGetInputData = function() {
      var anyButton, anyInput, anyKey, code;
      switch (this.params.field) {
        case 0:
          return this.interpreter.setNumberValueTo(this.params.targetVariable, Input.keys[Input.A]);
        case 1:
          return this.interpreter.setNumberValueTo(this.params.targetVariable, Input.keys[Input.B]);
        case 2:
          return this.interpreter.setNumberValueTo(this.params.targetVariable, Input.keys[Input.X]);
        case 3:
          return this.interpreter.setNumberValueTo(this.params.targetVariable, Input.keys[Input.Y]);
        case 4:
          return this.interpreter.setNumberValueTo(this.params.targetVariable, Input.keys[Input.L]);
        case 5:
          return this.interpreter.setNumberValueTo(this.params.targetVariable, Input.keys[Input.R]);
        case 6:
          return this.interpreter.setNumberValueTo(this.params.targetVariable, Input.keys[Input.START]);
        case 7:
          return this.interpreter.setNumberValueTo(this.params.targetVariable, Input.keys[Input.SELECT]);
        case 8:
          return this.interpreter.setNumberValueTo(this.params.targetVariable, Input.Mouse.x);
        case 9:
          return this.interpreter.setNumberValueTo(this.params.targetVariable, Input.Mouse.y);
        case 10:
          return this.interpreter.setNumberValueTo(this.params.targetVariable, Input.Mouse.wheel);
        case 11:
          return this.interpreter.setNumberValueTo(this.params.targetVariable, Input.Mouse.buttons[Input.Mouse.LEFT]);
        case 12:
          return this.interpreter.setNumberValueTo(this.params.targetVariable, Input.Mouse.buttons[Input.Mouse.RIGHT]);
        case 13:
          return this.interpreter.setNumberValueTo(this.params.targetVariable, Input.Mouse.buttons[Input.Mouse.MIDDLE]);
        case 100:
          anyKey = 0;
          if (Input.keyDown) {
            anyKey = 1;
          }
          if (Input.keyUp) {
            anyKey = 2;
          }
          return this.interpreter.setNumberValueTo(this.params.targetVariable, anyKey);
        case 101:
          anyButton = 0;
          if (Input.Mouse.buttonDown) {
            anyButton = 1;
          }
          if (Input.Mouse.buttonUp) {
            anyButton = 2;
          }
          return this.interpreter.setNumberValueTo(this.params.targetVariable, anyButton);
        case 102:
          anyInput = 0;
          if (Input.Mouse.buttonDown || Input.keyDown) {
            anyInput = 1;
          }
          if (Input.Mouse.buttonUp || Input.keyUp) {
            anyInput = 2;
          }
          return this.interpreter.setNumberValueTo(this.params.targetVariable, anyInput);
        default:
          code = this.params.field - 100;
          return this.interpreter.setNumberValueTo(this.params.targetVariable, Input.keys[code]);
      }
    };


    /**
    * @method commandGetGameData
    * @protected
     */

    Component_CommandInterpreter.prototype.commandGetGameData = function() {
      var ref, ref1, settings, tempSettings;
      tempSettings = GameManager.tempSettings;
      settings = GameManager.settings;
      switch (this.params.field) {
        case 0:
          return this.interpreter.setStringValueTo(this.params.targetVariable, SceneManager.scene.sceneDocument.uid);
        case 1:
          return this.interpreter.setNumberValueTo(this.params.targetVariable, Math.round(Graphics.frameCount / 60));
        case 2:
          return this.interpreter.setNumberValueTo(this.params.targetVariable, Math.round(Graphics.frameCount / 60 / 60));
        case 3:
          return this.interpreter.setNumberValueTo(this.params.targetVariable, Math.round(Graphics.frameCount / 60 / 60 / 60));
        case 4:
          return this.interpreter.setNumberValueTo(this.params.targetVariable, new Date().getDate());
        case 5:
          return this.interpreter.setNumberValueTo(this.params.targetVariable, new Date().getDay());
        case 6:
          return this.interpreter.setNumberValueTo(this.params.targetVariable, new Date().getMonth());
        case 7:
          return this.interpreter.setNumberValueTo(this.params.targetVariable, new Date().getFullYear());
        case 8:
          return this.interpreter.setBooleanValueTo(this.params.targetVariable, settings.allowSkip);
        case 9:
          return this.interpreter.setBooleanValueTo(this.params.targetVariable, settings.allowSkipUnreadMessages);
        case 10:
          return this.interpreter.setNumberValueTo(this.params.targetVariable, settings.messageSpeed);
        case 11:
          return this.interpreter.setBooleanValueTo(this.params.targetVariable, settings.autoMessage.enabled);
        case 12:
          return this.interpreter.setNumberValueTo(this.params.targetVariable, settings.autoMessage.time);
        case 13:
          return this.interpreter.setBooleanValueTo(this.params.targetVariable, settings.autoMessage.waitForVoice);
        case 14:
          return this.interpreter.setBooleanValueTo(this.params.targetVariable, settings.autoMessage.stopOnAction);
        case 15:
          return this.interpreter.setBooleanValueTo(this.params.targetVariable, settings.timeMessageToVoice);
        case 16:
          return this.interpreter.setBooleanValueTo(this.params.targetVariable, settings.allowVideoSkip);
        case 17:
          return this.interpreter.setBooleanValueTo(this.params.targetVariable, settings.allowChoiceSkip);
        case 18:
          return this.interpreter.setBooleanValueTo(this.params.targetVariable, settings.skipVoiceOnAction);
        case 19:
          return this.interpreter.setBooleanValueTo(this.params.targetVariable, settings.fullScreen);
        case 20:
          return this.interpreter.setBooleanValueTo(this.params.targetVariable, settings.adjustAspectRatio);
        case 21:
          return this.interpreter.setBooleanValueTo(this.params.targetVariable, settings.confirmation);
        case 22:
          return this.interpreter.setNumberValueTo(this.params.targetVariable, settings.bgmVolume);
        case 23:
          return this.interpreter.setNumberValueTo(this.params.targetVariable, settings.voiceVolume);
        case 24:
          return this.interpreter.setNumberValueTo(this.params.targetVariable, settings.seVolume);
        case 25:
          return this.interpreter.setBooleanValueTo(this.params.targetVariable, settings.bgmEnabled);
        case 26:
          return this.interpreter.setBooleanValueTo(this.params.targetVariable, settings.voiceEnabled);
        case 27:
          return this.interpreter.setBooleanValueTo(this.params.targetVariable, settings.seEnabled);
        case 28:
          return this.interpreter.setStringValueTo(this.params.targetVariable, ((ref = LanguageManager.language) != null ? ref.code : void 0) || "");
        case 29:
          return this.interpreter.setStringValueTo(this.params.targetVariable, ((ref1 = LanguageManager.language) != null ? ref1.name : void 0) || "");
        case 30:
          return this.interpreter.setBooleanValueTo(this.params.targetVariable, GameManager.tempSettings.skip);
      }
    };


    /**
    * @method commandSetGameData
    * @protected
     */

    Component_CommandInterpreter.prototype.commandSetGameData = function() {
      var code, language, settings, tempSettings;
      tempSettings = GameManager.tempSettings;
      settings = GameManager.settings;
      switch (this.params.field) {
        case 0:
          return settings.allowSkip = this.interpreter.booleanValueOf(this.params.switchValue);
        case 1:
          return settings.allowSkipUnreadMessages = this.interpreter.booleanValueOf(this.params.switchValue);
        case 2:
          return settings.messageSpeed = this.interpreter.numberValueOf(this.params.decimalValue);
        case 3:
          return settings.autoMessage.enabled = this.interpreter.booleanValueOf(this.params.switchValue);
        case 4:
          return settings.autoMessage.time = this.interpreter.numberValueOf(this.params.numberValue);
        case 5:
          return settings.autoMessage.waitForVoice = this.interpreter.booleanValueOf(this.params.switchValue);
        case 6:
          return settings.autoMessage.stopOnAction = this.interpreter.booleanValueOf(this.params.switchValue);
        case 7:
          return settings.timeMessageToVoice = this.interpreter.booleanValueOf(this.params.switchValue);
        case 8:
          return settings.allowVideoSkip = this.interpreter.booleanValueOf(this.params.switchValue);
        case 9:
          return settings.allowChoiceSkip = this.interpreter.booleanValueOf(this.params.switchValue);
        case 10:
          return settings.skipVoiceOnAction = this.interpreter.booleanValueOf(this.params.switchValue);
        case 11:
          settings.fullScreen = this.interpreter.booleanValueOf(this.params.switchValue);
          if (settings.fullScreen) {
            return SceneManager.scene.behavior.enterFullScreen();
          } else {
            return SceneManager.scene.behavior.leaveFullScreen();
          }
          break;
        case 12:
          settings.adjustAspectRatio = this.interpreter.booleanValueOf(this.params.switchValue);
          Graphics.keepRatio = settings.adjustAspectRatio;
          return Graphics.onResize();
        case 13:
          return settings.confirmation = this.interpreter.booleanValueOf(this.params.switchValue);
        case 14:
          return settings.bgmVolume = this.interpreter.numberValueOf(this.params.numberValue);
        case 15:
          return settings.voiceVolume = this.interpreter.numberValueOf(this.params.numberValue);
        case 16:
          return settings.seVolume = this.interpreter.numberValueOf(this.params.numberValue);
        case 17:
          return settings.bgmEnabled = this.interpreter.booleanValueOf(this.params.switchValue);
        case 18:
          return settings.voiceEnabled = this.interpreter.booleanValueOf(this.params.switchValue);
        case 19:
          return settings.seEnabled = this.interpreter.booleanValueOf(this.params.switchValue);
        case 20:
          code = this.interpreter.stringValueOf(this.params.textValue);
          language = LanguageManager.languages.first((function(_this) {
            return function(l) {
              return l.code === code;
            };
          })(this));
          if (language) {
            return LanguageManager.selectLanguage(language);
          }
          break;
        case 21:
          return GameManager.tempSettings.skip = this.interpreter.booleanValueOf(this.params.switchValue);
      }
    };


    /**
    * @method commandGetObjectData
    * @protected
     */

    Component_CommandInterpreter.prototype.commandGetObjectData = function() {
      var area, characterId, field, object, ref, ref1, scene;
      scene = SceneManager.scene;
      switch (this.params.objectType) {
        case 0:
          scene.behavior.changePictureDomain(this.params.numberDomain);
          object = SceneManager.scene.pictures[this.interpreter.numberValueOf(this.params.number)];
          break;
        case 1:
          object = SceneManager.scene.backgrounds[this.interpreter.numberValueOf(this.params.layer)];
          break;
        case 2:
          scene.behavior.changeTextDomain(this.params.numberDomain);
          object = SceneManager.scene.texts[this.interpreter.numberValueOf(this.params.number)];
          break;
        case 3:
          scene.behavior.changeVideoDomain(this.params.numberDomain);
          object = SceneManager.scene.videos[this.interpreter.numberValueOf(this.params.number)];
          break;
        case 4:
          characterId = this.interpreter.stringValueOf(this.params.characterId);
          object = SceneManager.scene.characters.first((function(_this) {
            return function(v) {
              return !v.disposed && v.rid === characterId;
            };
          })(this));
          break;
        case 5:
          object = gs.ObjectManager.current.objectById("messageBox");
          break;
        case 6:
          scene.behavior.changeMessageAreaDomain(this.params.numberDomain);
          area = SceneManager.scene.messageAreas[this.interpreter.numberValueOf(this.params.number)];
          object = area != null ? area.layout : void 0;
          break;
        case 7:
          scene.behavior.changeHotspotDomain(this.params.numberDomain);
          object = SceneManager.scene.hotspots[this.interpreter.numberValueOf(this.params.number)];
      }
      field = this.params.field;
      if (this.params.objectType === 4) {
        switch (this.params.field) {
          case 0:
            this.interpreter.setStringValueTo(this.params.targetVariable, ((ref = RecordManager.characters[characterId]) != null ? ref.index : void 0) || "");
            break;
          case 1:
            this.interpreter.setStringValueTo(this.params.targetVariable, lcs((ref1 = RecordManager.characters[characterId]) != null ? ref1.name : void 0) || "");
        }
        field -= 2;
      }
      if (this.params.objectType === 6) {
        switch (field) {
          case 0:
            return this.interpreter.setNumberValueTo(this.params.targetVariable, object.dstRect.x);
          case 1:
            return this.interpreter.setNumberValueTo(this.params.targetVariable, object.dstRect.y);
          case 2:
            return this.interpreter.setNumberValueTo(this.params.targetVariable, object.zIndex);
          case 3:
            return this.interpreter.setNumberValueTo(this.params.targetVariable, object.opacity);
          case 4:
            return this.interpreter.setBooleanValueTo(this.params.targetVariable, object.visible);
        }
      } else if (object != null) {
        if (field >= 0) {
          switch (field) {
            case 0:
              switch (this.params.objectType) {
                case 2:
                  return this.interpreter.setStringValueTo(this.params.targetVariable, object.text || "");
                case 3:
                  return this.interpreter.setStringValueTo(this.params.targetVariable, object.video || "");
                default:
                  return this.interpreter.setStringValueTo(this.params.targetVariable, object.image || "");
              }
              break;
            case 1:
              return this.interpreter.setNumberValueTo(this.params.targetVariable, object.dstRect.x);
            case 2:
              return this.interpreter.setNumberValueTo(this.params.targetVariable, object.dstRect.y);
            case 3:
              return this.interpreter.setNumberValueTo(this.params.targetVariable, Math.round(object.anchor.x * 100));
            case 4:
              return this.interpreter.setNumberValueTo(this.params.targetVariable, Math.round(object.anchor.y * 100));
            case 5:
              return this.interpreter.setNumberValueTo(this.params.targetVariable, Math.round(object.zoom.x * 100));
            case 6:
              return this.interpreter.setNumberValueTo(this.params.targetVariable, Math.round(object.zoom.y * 100));
            case 7:
              return this.interpreter.setNumberValueTo(this.params.targetVariable, object.dstRect.width);
            case 8:
              return this.interpreter.setNumberValueTo(this.params.targetVariable, object.dstRect.height);
            case 9:
              return this.interpreter.setNumberValueTo(this.params.targetVariable, object.zIndex);
            case 10:
              return this.interpreter.setNumberValueTo(this.params.targetVariable, object.opacity);
            case 11:
              return this.interpreter.setNumberValueTo(this.params.targetVariable, object.angle);
            case 12:
              return this.interpreter.setBooleanValueTo(this.params.targetVariable, object.visible);
            case 13:
              return this.interpreter.setNumberValueTo(this.params.targetVariable, object.blendMode);
            case 14:
              return this.interpreter.setBooleanValueTo(this.params.targetVariable, object.mirror);
          }
        }
      }
    };


    /**
    * @method commandSetObjectData
    * @protected
     */

    Component_CommandInterpreter.prototype.commandSetObjectData = function() {
      var area, characterId, field, name, object, ref, scene;
      scene = SceneManager.scene;
      switch (this.params.objectType) {
        case 0:
          scene.behavior.changePictureDomain(this.params.numberDomain);
          object = SceneManager.scene.pictures[this.interpreter.numberValueOf(this.params.number)];
          break;
        case 1:
          object = SceneManager.scene.backgrounds[this.interpreter.numberValueOf(this.params.layer)];
          break;
        case 2:
          scene.behavior.changeTextDomain(this.params.numberDomain);
          object = SceneManager.scene.texts[this.interpreter.numberValueOf(this.params.number)];
          break;
        case 3:
          scene.behavior.changeVideoDomain(this.params.numberDomain);
          object = SceneManager.scene.videos[this.interpreter.numberValueOf(this.params.number)];
          break;
        case 4:
          characterId = this.interpreter.stringValueOf(this.params.characterId);
          object = SceneManager.scene.characters.first((function(_this) {
            return function(v) {
              return !v.disposed && v.rid === characterId;
            };
          })(this));
          break;
        case 5:
          object = gs.ObjectManager.current.objectById("messageBox");
          break;
        case 6:
          scene.behavior.changeMessageAreaDomain(this.params.numberDomain);
          area = SceneManager.scene.messageAreas[this.interpreter.numberValueOf(this.params.number)];
          object = area != null ? area.layout : void 0;
          break;
        case 7:
          scene.behavior.changeHotspotDomain(this.params.numberDomain);
          object = SceneManager.scene.hotspots[this.interpreter.numberValueOf(this.params.number)];
      }
      field = this.params.field;
      if (this.params.objectType === 4) {
        switch (field) {
          case 0:
            name = this.interpreter.stringValueOf(this.params.textValue);
            if (object != null) {
              object.name = name;
            }
            if ((ref = RecordManager.characters[characterId]) != null) {
              ref.name = name;
            }
        }
        field--;
      }
      if (this.params.objectType === 6) {
        switch (field) {
          case 0:
            return object.dstRect.x = this.interpreter.numberValueOf(this.params.numberValue);
          case 1:
            return object.dstRect.y = this.interpreter.numberValueOf(this.params.numberValue);
          case 2:
            return object.zIndex = this.interpreter.numberValueOf(this.params.numberValue);
          case 3:
            return object.opacity = this.interpreter.numberValueOf(this.params.numberValue);
          case 4:
            return object.visible = this.interpreter.booleanValueOf(this.params.switchValue);
        }
      } else if (object != null) {
        if (field >= 0) {
          switch (field) {
            case 0:
              switch (this.params.objectType) {
                case 2:
                  return object.text = this.interpreter.stringValueOf(this.params.textValue);
                case 3:
                  return object.video = this.interpreter.stringValueOf(this.params.textValue);
                default:
                  return object.image = this.interpreter.stringValueOf(this.params.textValue);
              }
              break;
            case 1:
              return object.dstRect.x = this.interpreter.numberValueOf(this.params.numberValue);
            case 2:
              return object.dstRect.y = this.interpreter.numberValueOf(this.params.numberValue);
            case 3:
              return object.anchor.x = this.interpreter.numberValueOf(this.params.numberValue) / 100;
            case 4:
              return object.anchor.y = this.interpreter.numberValueOf(this.params.numberValue) / 100;
            case 5:
              return object.zoom.x = this.interpreter.numberValueOf(this.params.numberValue) / 100;
            case 6:
              return object.zoom.y = this.interpreter.numberValueOf(this.params.numberValue) / 100;
            case 7:
              return object.zIndex = this.interpreter.numberValueOf(this.params.numberValue);
            case 8:
              return object.opacity = this.interpreter.numberValueOf(this.params.numberValue);
            case 9:
              return object.angle = this.interpreter.numberValueOf(this.params.numberValue);
            case 10:
              return object.visible = this.interpreter.booleanValueOf(this.params.switchValue);
            case 11:
              return object.blendMode = this.interpreter.numberValueOf(this.params.numberValue);
            case 12:
              return object.mirror = this.interpreter.booleanValueOf(this.params.switchValue);
          }
        }
      }
    };


    /**
    * @method commandChangeSounds
    * @protected
     */

    Component_CommandInterpreter.prototype.commandChangeSounds = function() {
      var fieldFlags, i, k, len, ref, results, sound, sounds;
      sounds = RecordManager.system.sounds;
      fieldFlags = this.params.fieldFlags || {};
      ref = this.params.sounds;
      results = [];
      for (i = k = 0, len = ref.length; k < len; i = ++k) {
        sound = ref[i];
        if (!gs.CommandFieldFlags.isLocked(fieldFlags["sounds." + i])) {
          results.push(sounds[i] = this.params.sounds[i]);
        } else {
          results.push(void 0);
        }
      }
      return results;
    };


    /**
    * @method commandChangeColors
    * @protected
     */

    Component_CommandInterpreter.prototype.commandChangeColors = function() {
      var color, colors, fieldFlags, i, k, len, ref, results;
      colors = RecordManager.system.colors;
      fieldFlags = this.params.fieldFlags || {};
      ref = this.params.colors;
      results = [];
      for (i = k = 0, len = ref.length; k < len; i = ++k) {
        color = ref[i];
        if (!gs.CommandFieldFlags.isLocked(fieldFlags["colors." + i])) {
          results.push(colors[i] = new gs.Color(this.params.colors[i]));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };


    /**
    * @method commandChangeScreenCursor
    * @protected
     */

    Component_CommandInterpreter.prototype.commandChangeScreenCursor = function() {
      var bitmap, ref;
      if (((ref = this.params.graphic) != null ? ref.name : void 0) != null) {
        bitmap = ResourceManager.getBitmap("Graphics/Pictures/" + this.params.graphic.name);
        return Graphics.setCursorBitmap(bitmap, this.params.hx, this.params.hy);
      } else {
        return Graphics.setCursorBitmap(null, 0, 0);
      }
    };


    /**
    * @method commandResetGlobalData
    * @protected
     */

    Component_CommandInterpreter.prototype.commandResetGlobalData = function() {
      return GameManager.resetGlobalData();
    };


    /**
    * @method commandScript
    * @protected
     */

    Component_CommandInterpreter.prototype.commandScript = function() {
      var ex;
      try {
        if (!this.params.scriptFunc) {
          this.params.scriptFunc = eval("(function(){" + this.params.script + "})");
        }
        return this.params.scriptFunc();
      } catch (error) {
        ex = error;
        return console.log(ex);
      }
    };

    return Component_CommandInterpreter;

  })(gs.Component);

  window.CommandInterpreter = Component_CommandInterpreter;

  gs.Component_CommandInterpreter = Component_CommandInterpreter;

}).call(this);
