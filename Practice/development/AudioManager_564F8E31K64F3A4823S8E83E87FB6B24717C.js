// Generated by CoffeeScript 1.12.7
(function() {
  var AudioManager;

  AudioManager = (function() {

    /**
    * Manages the audio playback of the game. 
    *
    * @module gs
    * @class AudioManager
    * @memberof gs
    * @constructor
     */
    function AudioManager() {

      /**
      * Stores all audio buffers.
      * @property buffers
      * @type gs.AudioBuffer[]
      * @protected
       */
      this.audioBuffers = [];

      /**
      * Stores all audio buffers by layer.
      * @property buffers
      * @type gs.AudioBuffer[]
      * @protected
       */
      this.audioBuffersByLayer = [];

      /**
      * Stores all audio buffer references for sounds.
      * @property soundReferences
      * @type gs.AudioBufferReference[]
      * @protected
       */
      this.soundReferences = {};

      /**
      * Current Music (Layer 0)
      * @property music
      * @type Object
      * @protected
       */
      this.music = null;

      /**
      * Current music volume.
      * @property musicVolume
      * @type number
      * @protected
       */
      this.musicVolume = 100;

      /**
      * Current sound volume.
      * @property soundVolume
      * @type number
      * @protected
       */
      this.soundVolume = 100;

      /**
      * Current voice volume.
      * @property voiceVolume
      * @type number
      * @protected
       */
      this.voiceVolume = 100;

      /**
      * General music volume
      * @property generalMusicVolume
      * @type number
      * @protected
       */
      this.generalMusicVolume = 100;

      /**
      * General sound volume
      * @property generalSoundVolume
      * @type number
      * @protected
       */
      this.generalSoundVolume = 100;

      /**
      * General voice volume
      * @property generalVoiceVolume
      * @type number
      * @protected
       */
      this.generalVoiceVolume = 100;

      /**
      * Stores audio layer info-data for each layer.
      * @property audioLayers
      * @type gs.AudioLayerInfo[]
      * @protected
       */
      this.audioLayers = [];
    }


    /**
    * Restores audio-playback from a specified array of audio layers.
    *
    * @method restore
    * @param {gs.AudioLayerInfo[]} layers - An array of audio layer info objects.
     */

    AudioManager.prototype.restore = function(layers) {
      var i, j, layer, len, results;
      this.audioLayers = layers;
      results = [];
      for (i = j = 0, len = layers.length; j < len; i = ++j) {
        layer = layers[i];
        if (layer && layer.playing) {
          if (layer.customData) {
            results.push(this.playMusicRandom(layer, layer.customData.fadeTime, i, layer.customData.playTime, layer.customData.playRange));
          } else {
            results.push(this.playMusic(layer, layer.fadeInTime, i));
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    };


    /**
    * Loads the specified music.
    *
    * @method loadMusic
    * @param {String} name - The name of the music to load.
     */

    AudioManager.prototype.loadMusic = function(name) {
      name = name != null ? name.name || name : name;
      if (name && name.length > 0) {
        return ResourceManager.getAudioStream("Audio/Music/" + name);
      }
    };


    /**
    * Loads the specified sound.
    *
    * @method loadSound
    * @param {String} name - The name of the sound to load.
     */

    AudioManager.prototype.loadSound = function(name) {
      name = name != null ? name.name || name : name;
      if (name && name.length > 0) {
        return ResourceManager.getAudioBuffer("Audio/Sounds/" + name);
      }
    };


    /**
    * Updates a randomly played audio buffer.
    *
    * @method updateRandomAudio
    * @param {gs.AudioBuffer} buffer - The audio buffer to update.
    * @protected
     */

    AudioManager.prototype.updateRandomAudio = function(buffer) {
      var currentTime, timeLeft;
      if (buffer.customData.startTimer > 0) {
        buffer.customData.startTimer--;
        if (buffer.customData.startTimer <= 0) {
          buffer.fadeInVolume = 1.0 / (buffer.customData.fadeTime || 1);
          buffer.fadeInTime = buffer.customData.fadeTime || 1;
          buffer.fadeOutTime = buffer.customData.fadeTime || 1;
          buffer.playTime = buffer.customData.playTime.min + Math.random() * (buffer.customData.playTime.max - buffer.customData.playTime.min);
          currentTime = buffer.currentTime;
          timeLeft = buffer.duration - currentTime;
          buffer.playTime = Math.min(timeLeft * 1000 / 16.6, buffer.playTime);
          return buffer.customData.startTimer = buffer.playTime + buffer.customData.playRange.start + Math.random() * (buffer.customData.playRange.end - buffer.customData.playRange.start);
        }
      }
    };


    /**
    * Updates all audio-buffers depending on the play-type.
    *
    * @method updateAudioBuffers
    * @protected
     */

    AudioManager.prototype.updateAudioBuffers = function() {
      var buffer, j, len, ref;
      ref = this.audioBuffers;
      for (j = 0, len = ref.length; j < len; j++) {
        buffer = ref[j];
        if (buffer != null) {
          if (buffer.customData.playType === 1) {
            this.updateRandomAudio(buffer);
          }
          if (GameManager.settings.bgmVolume !== this.generalMusicVolume) {
            buffer.volume = (this.musicVolume * GameManager.settings.bgmVolume / 100) / 100;
          }
          buffer.update();
        }
      }
      if (GameManager.settings.bgmVolume !== this.generalMusicVolume) {
        return this.generalMusicVolume = GameManager.settings.bgmVolume;
      }
    };


    /**
    * Updates all audio-buffers depending on the play-type.
    *
    * @method updateAudioBuffers
    * @protected
     */

    AudioManager.prototype.updateGeneralVolume = function() {
      var k, reference, results;
      if (GameManager.settings.seVolume !== this.generalSoundVolume || GameManager.settings.voiceVolume !== this.generalVoiceVolume) {
        this.generalSoundVolume = GameManager.settings.seVolume;
        this.generalVoiceVolume = GameManager.settings.voiceVolume;
        results = [];
        for (k in this.soundReferences) {
          results.push((function() {
            var j, len, ref, results1;
            ref = this.soundReferences[k];
            results1 = [];
            for (j = 0, len = ref.length; j < len; j++) {
              reference = ref[j];
              if (reference.voice) {
                results1.push(reference.volume = (this.voiceVolume * GameManager.settings.voiceVolume / 100) / 100);
              } else {
                results1.push(reference.volume = (this.soundVolume * GameManager.settings.seVolume / 100) / 100);
              }
            }
            return results1;
          }).call(this));
        }
        return results;
      }
    };


    /**
    * Updates the audio-playback.
    *
    * @method update
     */

    AudioManager.prototype.update = function() {
      this.updateAudioBuffers();
      return this.updateGeneralVolume();
    };


    /**
    * Changes the current music to the specified one.
    *
    * @method changeMusic
    * @param {Object} music - The music to play. If <b>null</b> the current music will stop playing.
     */

    AudioManager.prototype.changeMusic = function(music) {
      if ((music != null) && (music.name != null)) {
        if ((this.music != null) && this.music.name !== music.name) {
          return this.playMusic(music);
        } else if (this.music == null) {
          return this.playMusic(music);
        }
      } else {
        return this.stopMusic();
      }
    };


    /**
    * Prepares. 
    *
    * @method prepare
    * @param {Object} music - The music to play. If <b>null</b> the current music will stop playing.
     */

    AudioManager.prototype.prepare = function(path, volume, rate) {
      var buffer;
      buffer = ResourceManager.getAudioBuffer(path);
      if (buffer.decoded) {
        buffer.volume = volume != null ? volume / 100 : 1.0;
        buffer.playbackRate = rate != null ? rate / 100 : 1.0;
      } else {
        buffer.onFinishDecode = (function(_this) {
          return function(source) {
            source.volume = volume != null ? volume / 100 : 1.0;
            return source.playbackRate = rate != null ? rate / 100 : 1.0;
          };
        })(this);
        buffer.decode();
      }
      return buffer;
    };


    /**
    * Plays an audio resource.
    *
    * @method play
    * @param {String} path - The path to the audio resource.
    * @param {number} volume - The volume.
    * @param {number} rate - The playback rate.
    * @param {number} fadeInTime - The fade-in time in frames.
     */

    AudioManager.prototype.play = function(path, volume, rate, fadeInTime) {
      var buffer;
      buffer = ResourceManager.getAudioStream(path);
      if (buffer.decoded) {
        buffer.volume = volume != null ? volume / 100 : 1.0;
        buffer.playbackRate = rate != null ? rate / 100 : 1.0;
        if (GameManager.settings.bgmEnabled) {
          buffer.play(fadeInTime);
        }
      } else {
        buffer.onFinishDecode = (function(_this) {
          return function(source) {
            source.volume = volume != null ? volume / 100 : 1.0;
            source.playbackRate = rate != null ? rate / 100 : 1.0;
            if (GameManager.settings.bgmEnabled) {
              return source.play(fadeInTime);
            }
          };
        })(this);
        buffer.decode();
      }
      return buffer;
    };


    /**
    * Stops all sounds.
    *
    * @method stopAllSounds
     */

    AudioManager.prototype.stopAllSounds = function() {
      var k, reference, results;
      results = [];
      for (k in this.soundReferences) {
        results.push((function() {
          var j, len, ref, results1;
          ref = this.soundReferences[k];
          results1 = [];
          for (j = 0, len = ref.length; j < len; j++) {
            reference = ref[j];
            results1.push(reference != null ? reference.stop() : void 0);
          }
          return results1;
        }).call(this));
      }
      return results;
    };


    /**
    * Stops a sound and all references of it.
    *
    * @method stopSound
    * @param {String} name - The name of the sound to stop.
     */

    AudioManager.prototype.stopSound = function(name) {
      var j, len, ref, reference, results;
      if (this.soundReferences[name] != null) {
        ref = this.soundReferences[name];
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          reference = ref[j];
          results.push(reference.stop());
        }
        return results;
      }
    };


    /**
    * Stops a voice.
    *
    * @method stopVoice
    * @param {String} name - The name of the voice to stop.
     */

    AudioManager.prototype.stopVoice = function(name) {
      return this.stopSound(name);
    };


    /**
    * Stops all voices.
    *
    * @method stopAllVoices
     */

    AudioManager.prototype.stopAllVoices = function() {
      var k, reference, results;
      results = [];
      for (k in this.soundReferences) {
        results.push((function() {
          var j, len, ref, results1;
          ref = this.soundReferences[k];
          results1 = [];
          for (j = 0, len = ref.length; j < len; j++) {
            reference = ref[j];
            if (reference.voice) {
              results1.push(reference.stop());
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        }).call(this));
      }
      return results;
    };


    /**
    * Plays a voice.
    *
    * @method playVoice
    * @param {String} name - The name of the voice to play.
    * @param {number} volume - The voice volume.
    * @param {number} rate - The voice playback rate.
     */

    AudioManager.prototype.playVoice = function(name, volume, rate) {
      var ref, voice;
      voice = null;
      if (GameManager.settings.voiceEnabled && !((ref = $PARAMS.preview) != null ? ref.settings.voiceDisabled : void 0)) {
        voice = this.playSound(name != null ? name.name : void 0, volume || GameManager.defaults.audio.voiceVolume, rate || GameManager.defaults.audio.voicePlaybackRate, false, true);
      }
      return voice;
    };


    /**
    * Plays a sound.
    *
    * @method playSound
    * @param {String} name - The name of the sound to play.
    * @param {number} volume - The sound's volume.
    * @param {number} rate - The sound's playback rate.
    * @param {boolean} musicEffect - Indicates if the sound should be played as a music effect. In that case, the current music
    * at audio-layer will be paused until the sound finishes playing.
    * @param {boolean} voice - Indicates if the sound should be handled as a voice.
     */

    AudioManager.prototype.playSound = function(name, volume, rate, musicEffect, voice, loopSound) {
      var buffer, j, len, r, ref, ref1, reference;
      if ((ref = $PARAMS.preview) != null ? ref.settings.soundDisabled : void 0) {
        return;
      }
      if ((name == null) || (!voice && !GameManager.settings.soundEnabled)) {
        return;
      }
      if (name.name != null) {
        volume = name.volume;
        rate = name.playbackRate;
        name = name.name;
      }
      if (name.length === 0) {
        return;
      }
      if (musicEffect) {
        this.stopMusic();
      }
      if (this.soundReferences[name] == null) {
        this.soundReferences[name] = [];
      }
      volume = volume != null ? volume : 100;
      volume *= voice ? this.generalVoiceVolume / 100 : this.generalSoundVolume / 100;
      reference = null;
      ref1 = this.soundReferences[name];
      for (j = 0, len = ref1.length; j < len; j++) {
        r = ref1[j];
        if (!r.isPlaying) {
          reference = r;
          if (musicEffect) {
            reference.onEnd = (function(_this) {
              return function() {
                return _this.resumeMusic(40);
              };
            })(this);
          }
          reference.voice = voice;
          reference.volume = volume / 100;
          reference.playbackRate = rate / 100;
          reference.loop = loopSound;
          if (voice) {
            this.voice = reference;
          }
          reference.play();
          break;
        }
      }
      if (reference == null) {
        buffer = ResourceManager.getAudioBuffer("Audio/Sounds/" + name);
        if (buffer && buffer.loaded) {
          if (buffer.decoded) {
            reference = new GS.AudioBufferReference(buffer, voice);
            if (musicEffect) {
              reference.onEnd = (function(_this) {
                return function() {
                  return _this.resumeMusic(40);
                };
              })(this);
            }
            reference.volume = volume / 100;
            reference.playbackRate = rate / 100;
            reference.voice = voice;
            reference.loop = loopSound;
            reference.play();
            if (voice) {
              this.voice = reference;
            }
            this.soundReferences[name].push(reference);
          } else {
            buffer.name = name;
            buffer.onDecodeFinish = (function(_this) {
              return function(source) {
                reference = new GS.AudioBufferReference(source, voice);
                if (musicEffect) {
                  reference.onEnd = function() {
                    return _this.resumeMusic(40);
                  };
                }
                reference.voice = voice;
                reference.volume = volume / 100;
                reference.playbackRate = rate / 100;
                reference.loop = loopSound;
                if (voice) {
                  _this.voice = reference;
                }
                reference.play();
                return _this.soundReferences[source.name].push(reference);
              };
            })(this);
            buffer.decode();
          }
        }
      }
      return reference;
    };


    /**
    * Plays a music as a random music. A random music will fade-in and fade-out
    * at random times. That can be combined with other audio-layers to create a
    * much better looping of an audio track.
    *
    * @method playMusicRandom
    * @param {Object} music - The music to play.
    * @param {number} fadeTime - The time for a single fade-in/out in frames.
    * @param {number} layer - The audio layer to use.
    * @param {gs.Range} playTime - Play-Time range like 10s to 30s.
    * @param {gs.Range} playRange - Play-Range.
     */

    AudioManager.prototype.playMusicRandom = function(music, fadeTime, layer, playTime, playRange) {
      var musicBuffer, ref, volume;
      if ((ref = $PARAMS.preview) != null ? ref.settings.musicDisabled : void 0) {
        return;
      }
      layer = layer != null ? layer : 0;
      volume = music.volume != null ? music.volume : 100;
      volume = volume * (this.generalMusicVolume / 100);
      this.musicVolume = volume;
      this.disposeMusic(layer);
      if ((music.name != null) && music.name.length > 0) {
        musicBuffer = this.play("Audio/Music/" + music.name, volume, music.rate);
        musicBuffer.loop = true;
        musicBuffer.volume = 0;
        musicBuffer.duration = Math.round(musicBuffer.duration * 1000 / 16.6);
        musicBuffer.customData.playType = 1;
        musicBuffer.customData.playTime = playTime;
        if (playRange.end === 0) {
          musicBuffer.customData.playRange = {
            start: playRange.start,
            end: musicBuffer.duration
          };
        } else {
          musicBuffer.customData.playRange = playRange;
        }
        musicBuffer.customData.fadeTime = fadeTime;
        musicBuffer.customData.startTimer = Math.round(musicBuffer.customData.playRange.start + Math.random() * (musicBuffer.customData.playRange.end - musicBuffer.customData.playRange.start));
        if (!this.audioBuffers.contains(musicBuffer)) {
          this.audioBuffers.push(musicBuffer);
        }
        this.audioBuffersByLayer[layer] = musicBuffer;
        return this.audioLayers[layer] = {
          name: music.name,
          time: music.currentTime,
          volume: music.volume,
          rate: music.playbackRate,
          fadeInTime: fadeTime,
          customData: musicBuffer.customData
        };
      }
    };


    /**
    * Plays a music.
    *
    * @method playMusic
    * @param {string|Object} name - The music to play. Can be just a name or a music data-object.
    * @param {number} volume - The music's volume in percent.
    * @param {number} rate - The music's playback rate in percent.
    * @param {number} fadeInTime - The fade-in time.
    * @param {number} layer - The layer to play the music on.
    * @param {boolean} loop - Indicates if the music should be looped
     */

    AudioManager.prototype.playMusic = function(name, volume, rate, fadeInTime, layer, loopMusic) {
      var musicBuffer, ref;
      if ((ref = $PARAMS.preview) != null ? ref.settings.musicDisabled : void 0) {
        return;
      }
      if (loopMusic == null) {
        loopMusic = true;
      }
      if ((name != null) && (name.name != null)) {
        layer = layer != null ? layer : rate || 0;
        fadeInTime = volume;
        volume = name.volume;
        rate = name.playbackRate;
        name = name.name;
      } else {
        layer = layer != null ? layer : 0;
      }
      this.disposeMusic(layer);
      this.audioLayers[layer] = {
        name: name,
        volume: volume,
        rate: rate,
        fadeInTime: fadeInTime,
        playing: true
      };
      volume = volume != null ? volume : 100;
      volume = volume * (this.generalMusicVolume / 100);
      this.musicVolume = volume;
      if ((name != null) && name.length > 0) {
        this.music = {
          name: name
        };
        musicBuffer = this.play("Audio/Music/" + name, volume, rate, fadeInTime);
        musicBuffer.loop = loopMusic;
        if (!this.audioBuffers.contains(musicBuffer)) {
          this.audioBuffers.push(musicBuffer);
        }
        this.audioBuffersByLayer[layer] = musicBuffer;
      }
      return musicBuffer;
    };


    /**
    * Resumes a paused music.
    *
    * @method resumeMusic
    * @param {number} fadeInTime - The fade-in time in frames.
    * @param {number} layer - The audio layer to resume.
     */

    AudioManager.prototype.resumeMusic = function(fadeInTime, layer) {
      var ref;
      layer = layer != null ? layer : 0;
      if ((this.audioBuffersByLayer[layer] != null) && !this.audioBuffersByLayer[layer].isPlaying) {
        this.audioBuffersByLayer[layer].resume(fadeInTime);
        return (ref = this.audioLayers[layer]) != null ? ref.playing = true : void 0;
      }
    };


    /**
    * Stops a music.
    *
    * @method stopMusic
    * @param {number} fadeOutTime - The fade-out time in frames.
    * @param {number} layer - The audio layer to stop.
     */

    AudioManager.prototype.stopMusic = function(fadeOutTime, layer) {
      var ref, ref1, ref2;
      layer = layer != null ? layer : 0;
      if ((ref = this.audioBuffersByLayer[layer]) != null) {
        ref.stop(fadeOutTime);
      }
      if ((ref1 = this.audioBuffersByLayer[layer]) != null) {
        ref1.customData = {};
      }
      if ((ref2 = this.audioLayers[layer]) != null) {
        ref2.playing = false;
      }
      return this.music = null;
    };


    /**
    * Stops all music/audio layers.
    *
    * @method stopAllMusic
    * @param {number} fadeOutTime - The fade-out time in frames.
     */

    AudioManager.prototype.stopAllMusic = function(fadeOutTime) {
      var buffer, j, len, ref;
      ref = this.audioBuffers;
      for (j = 0, len = ref.length; j < len; j++) {
        buffer = ref[j];
        if (buffer != null) {
          buffer.stop(fadeOutTime);
          buffer.customData = {};
        }
      }
      return this.music = null;
    };

    AudioManager.prototype.dispose = function(context) {
      var buffer, data, j, layer, len, ref, results;
      data = context.resources.select(function(r) {
        return r.data;
      });
      ref = this.audioBuffersByLayer;
      results = [];
      for (layer = j = 0, len = ref.length; j < len; layer = ++j) {
        buffer = ref[layer];
        if (buffer && data.indexOf(buffer) !== -1) {
          buffer.dispose();
          this.audioBuffers.remove(buffer);
          this.audioBuffersByLayer[layer] = null;
          results.push(this.audioLayers[layer] = null);
        } else {
          results.push(void 0);
        }
      }
      return results;
    };


    /**
    * Disposes a music.
    *
    * @method disposeMusic
    * @param {number} layer - The audio layer of the music to dispose.
     */

    AudioManager.prototype.disposeMusic = function(layer) {
      layer = layer != null ? layer : 0;
      this.stopMusic(0, layer);
      this.audioBuffers.remove(this.audioBuffersByLayer[layer]);
      this.audioBuffersByLayer[layer] = null;
      return this.audioLayers[layer] = null;
    };

    return AudioManager;

  })();

  window.AudioManager = new AudioManager();

  gs.AudioManager = AudioManager;

}).call(this);
