// Generated by CoffeeScript 1.12.7
(function() {
  var Component_StackLayoutBehavior,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Component_StackLayoutBehavior = (function(superClass) {
    extend(Component_StackLayoutBehavior, superClass);


    /**
    * Turns a game object into a stack-layout and layouts all sub-objects
    * like stack vertically or horizontally. The game object needs a 
    * container-component.
    * <br>
    * The sub-objects in a stack-layout can be configured as resizable or
    * non-resizable(fixed-size). For example:<br>
    * <br>
    * Lets say we have a layout-size of 500px in width with three controls.<br>
    * <br>
    * | 80px | dynamic | 80px | <br>
    * <br>
    * Two controls have a fixed size of 80px and the middle-control has a
    * dynamic-size because it is configured to be resizable. In that case, 
    * the size of the resizable control would be 340px because that is the
    * free space left after subtracting the size(160px) of the fixed-size controls.<br>
    * <br>
    * In addition, each sub-object can have different alignment options.
    *
    * @module gs
    * @class Component_StackLayoutBehavior
    * @extends gs.Component_LayoutBehavior
    * @memberof gs
    * @constructor
     */

    function Component_StackLayoutBehavior(orientation) {
      Component_StackLayoutBehavior.__super__.constructor.apply(this, arguments);

      /**
      * The orientation of the stack-layout. Can be vertical or horizontal.
      * @property orientation
      * @type gs.Orientation
       */
      this.orientation = orientation || 0;

      /**
      * @property scrollOffsetX
      * @type number
      * @protected
       */
      this.scrollOffsetX = 0;

      /**
      * @property scrollOffsetY
      * @type number
      * @protected
       */
      this.scrollOffsetY = 0;

      /**
      * @property contentHeight
      * @type number
      * @protected
       */
      this.contentHeight = 0;

      /**
      * Control list-offset.
      * @property offset
      * @type number
      * @protected
       */
      this.offset = 0;

      /**
      * Count of controls to process.
      * @property contentHeight
      * @type number
      * @protected
       */
      this.count = 0;

      /**
      * Current x-coordinate. 
      * @property cx
      * @type number
      * @protected
       */
      this.cx = 0;

      /**
      * Current y-coordinate. 
      * @property cy
      * @type number
      * @protected
       */
      this.cy = 0;

      /**
      * Total size of all centered controls. 
      * @property centerSize
      * @type number
      * @protected
       */
      this.centerSize = 0;

      /**
      * Current x/y-coordinate for a centered control.
      * @property center
      * @type number
      * @protected
       */
      this.center = 0;

      /**
      * Current x/y-coordinate for a bottom/right aligned control.
      * @property bottom
      * @type number
      * @protected
       */
      this.bottom = 0;
      this.managementMode = 0;
    }


    /**
    * Initializes the layout.
    *
    * @method setup
     */

    Component_StackLayoutBehavior.prototype.setup = function() {
      this.update();
      if (this.object.scrollable) {
        return gs.GlobalEventManager.on("mouseWheel", (function(_this) {
          return function() {
            var r;
            r = _this.object.dstRect;
            if (Rect.contains(r.x, r.y, r.width, r.height, Input.Mouse.x - _this.object.origin.x, Input.Mouse.y - _this.object.origin.y)) {
              return _this.object.update();
            }
          };
        })(this));
      }
    };


    /**
    * Updates the layout depending on its orientation.
    *
    * @method update
     */

    Component_StackLayoutBehavior.prototype.update = function() {
      Component_StackLayoutBehavior.__super__.update.apply(this, arguments);
      if (this.orientation === 0) {
        return this.layoutHorizontal();
      } else {
        return this.layoutVertical();
      }
    };


    /**
    * Sizes the layout to fit its content
    *
    * @method sizeToFit
    * @return number The content size.
     */

    Component_StackLayoutBehavior.prototype.sizeToFit = function() {
      if (this.orientation === 0) {
        return this.sizeToFitHorizontal();
      } else {
        return this.sizeToFitVertical();
      }
    };


    /**
    * Sizes the horizontal-layout to fit its content
    *
    * @method sizeToFitHorizontal
     */

    Component_StackLayoutBehavior.prototype.sizeToFitHorizontal = function() {
      var control, i, j, rect, ref, ref1, results, x, y;
      x = 0;
      y = 0;
      rect = this.object.dstRect;
      if (this.object.sizeToFit) {
        results = [];
        for (i = j = ref = this.offset, ref1 = this.count; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
          control = this.object.subObjects[i];
          if (!control.alignment) {
            rect.width = Math.max(x + control.margin.left + control.dstRect.width + control.margin.right, rect.width || 0);
            x += control.margin.left + control.dstRect.width + control.margin.right;
          }
          if (!control.alignmentY) {
            results.push(rect.height = Math.max(y + control.margin.top + control.dstRect.height + control.margin.bottom, rect.height || 0));
          } else {
            results.push(void 0);
          }
        }
        return results;
      }
    };


    /**
    * Sizes the vertical-layout to fit its content
    *
    * @method sizeToFitVertical
     */

    Component_StackLayoutBehavior.prototype.sizeToFitVertical = function() {
      var control, j, len, rect, ref, results;
      rect = this.object.dstRect;
      if (this.object.sizeToFit) {
        ref = this.object.subObjects;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          control = ref[j];
          rect.width = Math.max(control.dstRect.x + control.dstRect.width + control.margin.right, rect.width || 1);
          results.push(rect.height = Math.max(control.dstRect.y + control.dstRect.height + control.margin.bottom, rect.height || 1));
        }
        return results;
      }
    };


    /**
    * Calculates the dynamic-size of a horizontal stack-layout. That size is used for
    * resizable-controls to let them fill all free space. It is calculated in the
    * following way:<br>
    * <br>
    * dynamic-size = sum-of-all-fixed-control-sizes / count-of-resizable-controls
    * <br>
    *
    * @method calculateDynamicSizeHorizontal
    * @return {number} The dynamic size.
    * @protected
     */

    Component_StackLayoutBehavior.prototype.calculateDynamicSizeHorizontal = function() {
      var control, dynamicCount, fixedSize, i, j, len, rect, ref;
      fixedSize = 0;
      dynamicCount = 0;
      rect = this.object.dstRect;
      ref = this.object.subObjects;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        control = ref[i];
        if (control.resizable && !control.sizeToFit) {
          dynamicCount++;
        } else {
          fixedSize += control.margin.left + control.dstRect.width + control.margin.right;
          if (control.alignmentX === 1) {
            this.centerSize += control.dstRect.width + control.margin.right;
          }
        }
      }
      return Math.round((rect.width - fixedSize) / dynamicCount);
    };


    /**
    * Calculates the dynamic-size of a vertical stack-layout. That size is used for
    * resizable-controls to let them fill all free space. It is calculated in the
    * following way:<br>
    * <br>
    * dynamic-size = sum-of-all-fixed-control-sizes / count-of-resizable-controls
    * <br>
    *
    * @method calculateDynamicSizeVertical
    * @return {number} The dynamic size.
    * @protected
     */

    Component_StackLayoutBehavior.prototype.calculateDynamicSizeVertical = function() {
      var control, dynamicCount, fixedSize, j, len, ref;
      fixedSize = 0;
      dynamicCount = 0;
      ref = this.object.subObjects;
      for (j = 0, len = ref.length; j < len; j++) {
        control = ref[j];
        if (control.resizable && !control.sizeToFit) {
          dynamicCount++;
        } else {
          fixedSize += control.dstRect.height;
          if (control.alignmentY === 1) {
            this.centerSize += control.dstRect.height + control.margin.bottom;
          }
        }
      }
      return Math.round((this.object.dstRect.height - fixedSize) / dynamicCount);
    };


    /**
    * Layouts the specified control as fixed-size control for a horizontal stack-layout. 
    *
    * @method updateControlRectFixedH
    * @param {gs.Object_Base} control The control to update.
    * @protected
     */

    Component_StackLayoutBehavior.prototype.updateControlRectFixedH = function(control) {
      var rect;
      rect = this.object.dstRect;
      if (control.alignmentX === 0) {
        this.cx += control.margin.left;
        control.dstRect.x = this.cx;
        this.cx += control.dstRect.width + control.margin.right;
      } else if (control.alignmentX === 2) {
        this.bottom += control.margin.right;
        control.dstRect.x = (rect.x + rect.width) - control.dstRect.width - this.bottom;
        this.bottom += control.dstRect.width + control.margin.left;
      } else if (control.alignmentX === 1) {
        control.dstRect.x = this.center + (rect.width - this.centerSize) / 2;
        this.center += control.dstRect.width + control.margin.right;
      }
      if (control.alignmentY === 1) {
        return control.dstRect.y = this.cy + Math.round((rect.height - (control.dstRect.height + control.margin.top + control.margin.bottom)) / 2);
      } else {
        return control.dstRect.y = this.cy + control.margin.top;
      }
    };


    /**
    * Layouts the specified control as fixed-size control for a vertical stack-layout. 
    *
    * @method updateControlRectFixedV
    * @param {gs.Object_Base} control The control to update.
    * @protected
     */

    Component_StackLayoutBehavior.prototype.updateControlRectFixedV = function(control) {
      var rect;
      rect = this.object.dstRect;
      if (control.alignmentY === 0) {
        this.cy += control.margin.top;
        control.dstRect.y = this.cy;
        this.cy += control.dstRect.height + control.margin.bottom;
        control.dstRect.x = this.cx + control.margin.left;
      } else if (control.alignmentY === 2) {
        this.bottom += control.margin.bottom;
        control.dstRect.y = rect.height - control.dstRect.height - this.bottom;
        this.bottom += control.dstRect.height + control.margin.top;
        control.dstRect.x = this.cx + control.margin.left;
      } else if (control.alignmentY === 1) {
        control.dstRect.y = this.center + (rect.height - this.centerSize) / 2;
        control.dstRect.x = this.cx + control.margin.left;
        this.center += control.dstRect.height + control.margin.bottom;
      }
      if (control.alignmentX === 1) {
        return control.dstRect.x = this.cx + Math.round((rect.width - control.dstRect.width) / 2);
      }
    };


    /**
    * Layouts the specified control as resizable-control for a horizontal stack-layout. 
    * That means the control will take up all free space after subtracting all 
    * fixed-size controls.
    *
    * @method updateControlRectResizableH
    * @param {gs.Object_Base} control The control to update.
    * @protected
     */

    Component_StackLayoutBehavior.prototype.updateControlRectResizableH = function(control) {
      var dynamicSize;
      dynamicSize = this.calculateDynamicSizeHorizontal();
      control.dstRect.y = control.margin.top;
      control.dstRect.height = this.object.dstRect.height - control.margin.bottom - control.margin.top;
      control.dstRect.x = this.cx + control.margin.left;
      control.dstRect.width = dynamicSize - control.margin.right - control.margin.left;
      return this.cx += dynamicSize;
    };


    /**
    * Layouts the specified control as resizable-control for a vertical stack-layout. 
    * That means the control will take up all free space after subtracting all 
    * fixed-size controls.
    *
    * @method updateControlRectResizableV
    * @param {gs.Object_Base} control The control to update.
    * @protected
     */

    Component_StackLayoutBehavior.prototype.updateControlRectResizableV = function(control) {
      var dynamicSize;
      dynamicSize = this.calculateDynamicSizeVertical();
      control.dstRect.x = control.margin.left;
      control.dstRect.width = this.object.dstRect.width - control.margin.right - control.margin.left;
      control.dstRect.y = this.cy + control.margin.top;
      control.dstRect.height = dynamicSize - control.margin.bottom - control.margin.top;
      return this.cy += dynamicSize;
    };


    /**
    * Updates a control.
    *
    * @method updateControl
    * @param {gs.Object_Base} control The control to update.
    * @protected
     */

    Component_StackLayoutBehavior.prototype.updateControl = function(control) {
      if (this.orientation === 1) {
        if (control.clipRect == null) {
          control.clipRect = this.object.clipRect;
        }
        if (true) {
          if (control.needsUpdate) {
            control.needsUpdate = false;
            control.update();
          }
          control.updated = true;
          return control.visible = true;
        } else {
          if (control.visible) {
            control.visible = false;
            return control.update();
          }
        }
      } else {
        return Component_StackLayoutBehavior.__super__.updateControl.call(this, control);
      }
    };


    /**
    * Layouts the sub-objects horizontally.
    *
    * @method layoutHorizontal
     */

    Component_StackLayoutBehavior.prototype.layoutHorizontal = function() {
      var control, i, ref;
      this.bottom = 0;
      this.center = 0;
      this.centerSize = 0;
      this.offset = this.object.listOffset || 0;
      this.count = this.object.subObjects.length;
      this.cx = 0;
      this.cy = 0;
      this.sizeToFitHorizontal();
      i = this.offset;
      while (i < this.object.subObjects.length) {
        control = this.object.subObjects[i];
        this.updateControl(control);
        if (control.disposed) {
          this.object.removeObject(control);
          i--;
        } else {
          if (control.resizable && !control.sizeToFit) {
            this.updateControlRectResizableH(control);
          } else {
            this.updateControlRectFixedH(control);
          }
        }
        i++;
      }
      if ((ref = this.object.clipRect) != null) {
        ref.set(this.object.dstRect.x + this.object.origin.x, this.object.dstRect.y + this.object.origin.y, this.object.dstRect.width, this.object.dstRect.height);
      }
      return null;
    };


    /**
    * Layouts the sub-objects vertically.
    *
    * @method layoutVertical
     */

    Component_StackLayoutBehavior.prototype.layoutVertical = function() {
      var control, currentY, i, ref;
      this.bottom = 0;
      this.center = 0;
      this.centerSize = 0;
      this.offset = this.object.listOffset || 0;
      this.count = this.object.subObjects.length;
      this.cx = 0;
      this.cy = 0;
      this.cy -= this.object.scrollOffsetY;
      i = this.offset;
      currentY = 0;
      while (i < this.object.subObjects.length) {
        control = this.object.subObjects[i];
        i++;
        if (!control) {
          continue;
        }
        this.updateControl(control);
        if (control.disposed) {
          this.object.removeObject(control);
          i--;
        } else {
          if (control.resizable && !control.sizeToFit) {
            this.updateControlRectResizableV(control);
          } else {
            this.updateControlRectFixedV(control);
          }
        }
      }
      this.sizeToFitVertical();
      if ((ref = this.object.clipRect) != null) {
        ref.set(this.object.dstRect.x + this.object.origin.x, this.object.dstRect.y + this.object.origin.y, this.object.dstRect.width, this.object.dstRect.height);
      }
      return null;
    };

    return Component_StackLayoutBehavior;

  })(gs.Component_LayoutBehavior);

  gs.Component_StackLayoutBehavior = Component_StackLayoutBehavior;

}).call(this);
