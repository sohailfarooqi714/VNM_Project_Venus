// Generated by CoffeeScript 1.12.7
(function() {
  var Component_InputHandler,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Component_InputHandler = (function(superClass) {
    extend(Component_InputHandler, superClass);


    /**
    * The input-handler component is an interface between the input-system
    * of the basic-engine and the game's event-system. In regular this
    * component is used only by game scene to allow its game objects to
    * receive input-events.
    *
    * Those input-events are necessary to solve the problem which game-object
    * responds to a user-action first by building a responder-chain.
    *
    * @module gs
    * @class Component_InputHandler
    * @extends gs.Component
    * @memberof gs
     */

    function Component_InputHandler() {

      /**
      * Indicates if all input events, such as mouse and keyboard event, should be blocked.
      *
      * @property blockInput
      * @type boolean
      * @default false
       */
      this.blockInput = false;
    }


    /**
    * Sets up event handlers.
    *
    * @method setup
     */

    Component_InputHandler.prototype.setup = function() {
      Component_InputHandler.__super__.setup.apply(this, arguments);
      gs.GlobalEventManager.on("uiAnimationStart", ((function(_this) {
        return function(e) {
          return _this.blockInput = true;
        };
      })(this)), null, this.object);
      return gs.GlobalEventManager.on("uiAnimationFinish", ((function(_this) {
        return function(e) {
          return _this.blockInput = false;
        };
      })(this)), null, this.object);
    };


    /**
    * Disposes the component and removes event handlers.
    *
    * @method dispose
     */

    Component_InputHandler.prototype.dispose = function() {
      Component_InputHandler.__super__.dispose.apply(this, arguments);
      gs.GlobalEventManager.offByOwner("uiAnimationStart", this.object);
      return gs.GlobalEventManager.offByOwner("uiAnimationFinish", this.object);
    };


    /**
    * Updates the component by checking the input-system and firing
    * an input-event if necessary.
    *
    * @method update
     */

    Component_InputHandler.prototype.update = function() {
      if (this.blockInput) {
        return;
      }
      if (Input.Mouse.moved) {
        gs.GlobalEventManager.emit("mouseMoved");
      }
      if (Input.Mouse.buttonDown) {
        gs.GlobalEventManager.emit("mouseDown");
      }
      if (Input.Mouse.buttonUp) {
        gs.GlobalEventManager.emit("mouseUp");
      }
      if (Input.keyDown) {
        gs.GlobalEventManager.emit("keyDown");
      }
      if (Input.keyUp) {
        gs.GlobalEventManager.emit("keyUp");
      }
      if (Input.Mouse.wheelChanged) {
        return gs.GlobalEventManager.emit("mouseWheel");
      }
    };

    return Component_InputHandler;

  })(gs.Component);

  gs.Component_InputHandler = Component_InputHandler;

}).call(this);
