// Generated by CoffeeScript 1.12.7
(function() {
  var Object_Scene,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Object_Scene = (function(superClass) {
    extend(Object_Scene, superClass);

    Object_Scene.accessors("visible", {
      set: function(v) {
        if (v !== this.visible_) {
          this.visible_ = v;
          this.needsUpdate = true;
          return this.fullRefresh();
        }
      },
      get: function() {
        return this.visible_ && (!this.parent || this.parent.visible);
      }
    });


    /**
    * A scene object manages a whole visual novel scene with backgrounds, characters,
    * messages, etc.
    *
    * @module vn
    * @class Object_Scene
    * @extends gs.Object_Base
    * @memberof vn
    * @constructor
     */

    function Object_Scene() {
      Object_Scene.__super__.constructor.call(this);

      /**
      * Indicates that the scene is still in prepare-state and not ready yet.
      * @property preparing
      * @type boolean
       */
      this.preparing = true;

      /**
      * The behavior-component for the VN scene specific behavior.
      * @property behavior
      * @type gs.Component_GameSceneBehavior
       */
      this.behavior = new vn.Component_GameSceneBehavior();

      /**
      * An interpreter to execute the commands of scene.
      * @property interpreter
      * @type gs.Component_CommandInterpreter
       */
      this.interpreter = new gs.Component_CommandInterpreter();

      /**
      * An event-emitter to emit events.
      * @property events
      * @type gs.Component_EventEmitter
       */
      this.events = new gs.Component_EventEmitter();

      /**
      * Contains all background objects of the scene.
      * @property backgroundContainer
      * @type gs.Object_Container
       */
      this.backgroundContainer = new gs.Object_DomainContainer(gs.ContainerDisposeBehavior.NULL);

      /**
      * Contains all character objects of the scene.
      * @property characterContainer
      * @type gs.Object_Container
       */
      this.characterContainer = new gs.Object_Container(gs.ContainerDisposeBehavior.REMOVE);

      /**
      * Contains all picture objects of the scene.
      * @property pictureContainer
      * @type gs.Object_Container
       */
      this.pictureContainer = new gs.Object_DomainContainer(gs.ContainerDisposeBehavior.NULL);

      /**
      * Contains all video objects of the scene.
      * @property videoContainer
      * @type gs.Object_Container
       */
      this.videoContainer = new gs.Object_DomainContainer(gs.ContainerDisposeBehavior.NULL);

      /**
      * Contains all text objects of the scene.
      * @property textContainer
      * @type gs.Object_Container
       */
      this.textContainer = new gs.Object_DomainContainer(gs.ContainerDisposeBehavior.NULL);

      /**
      * Contains all hotspot objects of the scene.
      * @property hotspotContainer
      * @type gs.Object_Container
       */
      this.hotspotContainer = new gs.Object_DomainContainer(gs.ContainerDisposeBehavior.NULL);

      /**
      * Contains all common events which are running parallel/auto to the scene.
      * @property commonEventContainer
      * @type gs.Object_Container
       */
      this.commonEventContainer = new gs.Object_Container(gs.ContainerDisposeBehavior.NULL);

      /**
      * Contains all viewports which are used to create multi-layered screen effects.
      * @property viewportContainer
      * @type gs.Object_Container
       */
      this.viewportContainer = new gs.Object_Container(gs.ContainerDisposeBehavior.REMOVE);

      /**
      * Contains all interval timers.
      * @property timerContainer
      * @type gs.Object_Container
       */
      this.timerContainer = new gs.Object_DomainContainer(gs.ContainerDisposeBehavior.NULL);

      /**
      * Contains all message areas of the scene.
      * @property messageAreaContainer
      * @type gs.Object_Container
       */
      this.messageAreaContainer = new gs.Object_DomainContainer(gs.ContainerDisposeBehavior.NULL);
      this.characterContainer.visible = true;

      /**
      * All picture objects as array. That is the same like accessing the <b>subObjects</b> of the
      * container object.
      * @property pictures
      * @type gs.Object_Picture[]
      * @readOnly
       */
      this.pictures = this.pictureContainer.subObjects;

      /**
      * All video objects as array. That is the same like accessing the <b>subObjects</b> of the
      * container object.
      * @property videos
      * @type gs.Object_Video[]
      * @readOnly
       */
      this.videos = this.videoContainer.subObjects;

      /**
      * All text objects as array. That is the same like accessing the <b>subObjects</b> of the
      * container object.
      * @property texts
      * @type gs.Object_Text[]
      * @readOnly
       */
      this.texts = this.textContainer.subObjects;

      /**
      * All character objects as array. That is the same like accessing the <b>subObjects</b> of the
      * container object.
      * @property characters
      * @type gs.Object_Character[]
      * @readOnly
       */
      this.characters = this.characterContainer.subObjects;

      /**
      * All backgrounds as array. That is the same like accessing the <b>subObjects</b> of the
      * container object.
      * @property backgrounds
      * @type gs.Object_Background[]
      * @readOnly
       */
      this.backgrounds = this.backgroundContainer.subObjects;

      /**
      * All hotspot objects as array. That is the same like accessing the <b>subObjects</b> of the
      * container object.
      * @property hotspots
      * @type gs.Object_Hotspot[]
      * @readOnly
       */
      this.hotspots = this.hotspotContainer.subObjects;

      /**
      * All interval timer objects as array. That is the same like accessing the <b>subObjects</b> of the
      * container object.
      * @property timers
      * @type gs.Object_IntervalTimer[]
      * @readOnly
       */
      this.timers = this.timerContainer.subObjects;

      /**
      * All message areas as array.
      * @property messageAreas
      * @type vn.MessageArea[]
      * @readOnly
       */
      this.messageAreas = this.messageAreaContainer.subObjects;

      /**
      * The current list of choices which should be displayed
      * on the screen. New choices are usually added using
      * Add Choice command in Scene Editor before all choices are
      * displayed via Show Choices command.
      * @property choices
      * @type vn.Choice[]
       */
      this.choices = [];

      /**
      * A timer object used for choices with time-limit.
      * @property choiceTimer
      * @type gs.Object_Timer
       */
      this.choiceTimer = new gs.Object_Timer();

      /**
      * Indicates if the UI layout is visible.
      * @property visible
      * @type boolean
       */
      this.visible = true;

      /**
      * @property visible_
      * @type boolean
      * @protected
       */
      this.visible_ = true;

      /**
      * The game settings.
      * @property settings
      * @type Object
       */
      this.settings = GameManager.settings;

      /**
      * Temporary settings like skip, etc.
      * @property tempSettings
      * @type Object
       */
      this.tempSettings = GameManager.tempSettings;

      /**
      * Contains all data necessary to construct the scene.
      * @property sceneData
      * @type Object
       */
      this.sceneData = GameManager.sceneData;
      this.addObject(this.backgroundContainer);
      this.addObject(this.characterContainer);
      this.addObject(this.pictureContainer);
      this.addObject(this.textContainer);
      this.addObject(this.videoContainer);
      this.addObject(this.hotspotContainer);
      this.addObject(this.viewportContainer);
      this.addObject(this.commonEventContainer);
      this.addObject(this.timerContainer);
      this.addObject(this.choiceTimer);
      this.addObject(this.messageAreaContainer);
      this.addComponent(new gs.Component_InputHandler());
      this.addComponent(this.behavior);
      this.addComponent(this.interpreter);
    }

    return Object_Scene;

  })(gs.Object_Base);

  vn.Object_Scene = Object_Scene;

}).call(this);
