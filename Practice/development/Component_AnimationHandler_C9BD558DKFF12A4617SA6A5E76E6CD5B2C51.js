// Generated by CoffeeScript 1.12.7
(function() {
  var Component_AnimationHandler,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Component_AnimationHandler = (function(superClass) {
    extend(Component_AnimationHandler, superClass);


    /**
    * An animation-handler component allows a UI game object to execute
    * a flow of animations. For more information about UI animations, see help-file.
    * 
    * @module ui
    * @class Component_AnimationHandler
    * @extends ui.Component_Handler
    * @memberof ui
    * @constructor
     */

    function Component_AnimationHandler() {
      Component_AnimationHandler.__super__.constructor.apply(this, arguments);

      /**
      * @property initialized
      * @type boolean
      * @protected
       */
      this.initialized = false;

      /**
      * @property waitCounter
      * @type number
      * @protected
       */
      this.waitCounter = 0;

      /**
      * @property pointer
      * @type number
      * @protected
       */
      this.pointer = 0;
    }


    /**
    * Initializes the animation-handler.
    * 
    * @method setup
     */

    Component_AnimationHandler.prototype.setup = function() {
      this.initialized = true;
      return null;
    };


    /**
    * Processes the animation targets and starts the animation on each
    * target object if possible.
    * 
    * @method processTargets
    * @param {Object} animation - The animation to start.
    * @param {gs.Object_Base[]} targets - An array of target objects.
    * @protected
     */

    Component_AnimationHandler.prototype.processTargets = function(animation, targets) {
      var j, len, ref, ref1, target;
      for (j = 0, len = targets.length; j < len; j++) {
        target = targets[j];
        if (animation.type != null) {
          target.visible = true;
          if (animation.components == null) {
            animation.components = [];
          }
          if (!this.object.animator) {
            this.object.animator = new gs.Component_Animator();
            this.object.addComponent(this.object.animator);
          }
          animation.components.push(this.object.animationExecutor.startAnimation(animation, animation.duration, target, this.object.animator));
          target.visible = true;
          animation.executed = !((ref = animation.repeat) != null ? ref : true);
        } else {
          animation.executed = !((ref1 = animation.repeat) != null ? ref1 : true);
        }
      }
      return null;
    };


    /**
    * Clears/Resets the specified animation if necessary.
    * 
    * @method clear
    * @param {Object} descriptor - The animation descriptor
    * @protected
     */

    Component_AnimationHandler.prototype.clear = function(descriptor) {
      var animation, component, j, k, len, len1, ref, ref1, target;
      descriptor.cleared = true;
      descriptor.pointer = 0;
      descriptor.waitCounter = 0;
      ref = descriptor.flow;
      for (j = 0, len = ref.length; j < len; j++) {
        animation = ref[j];
        if (animation.components) {
          ref1 = animation.components;
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            component = ref1[k];
            target = this.object;
            target.visible = true;
            animation.executed = false;
            if ((animation.field != null) && (animation.reset != null)) {
              ui.BindingHandler.resolveFieldPath(target, animation.field).set(target, ui.BindingHandler.fieldValue(target, animation.reset || 0));
            }
          }
          animation.components = [];
        }
      }
      this.object.needsFullUpdate = true;
      return null;
    };


    /**
    * Processes the animation flow.
    * 
    * @method processAnimations
    * @param {Object} descriptor - The animation-descriptor containing the animation-flow.
    * @protected
     */

    Component_AnimationHandler.prototype.processAnimations = function(descriptor) {
      var animation, targets;
      while (descriptor.pointer < descriptor.flow.length) {
        animation = descriptor.flow[descriptor.pointer];
        descriptor.pointer++;
        if (!animation.wait && animation.executed) {
          continue;
        }
        targets = animation.target != null ? ui.Component_FormulaHandler.fieldValue(this.object, animation.target) : this.object;
        targets = targets.length != null ? targets : [targets];
        descriptor.cleared = false;
        this.processTargets(animation, targets);
        if (animation.wait) {
          if (animation.type != null) {
            descriptor.waitCounter = animation.duration;
          } else {
            descriptor.waitCounter = animation.wait;
          }
          break;
        }
      }
      return null;
    };


    /**
    * Updates the animations.
    * 
    * @method updateAnimations
     */

    Component_AnimationHandler.prototype.updateAnimations = function() {
      var descriptor, i, j, len, ref, ref1;
      ref = this.object.animations;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        descriptor = ref[i];
        if (this.checkObject(descriptor)) {
          if (descriptor.waitCounter > 0) {
            descriptor.waitCounter--;
            continue;
          }
          if ((descriptor.pointer == null) || descriptor.pointer >= descriptor.flow.length) {
            descriptor.pointer = 0;
          }
          this.processAnimations(descriptor);
        } else if (!descriptor.cleared && ((ref1 = descriptor.clear) != null ? ref1 : true)) {
          this.clear(descriptor);
        }
      }
      return null;
    };


    /**
    * Updates the animation-handler.
    * 
    * @method update
     */

    Component_AnimationHandler.prototype.update = function() {
      this.object.needsUpdate = true;
      return this.updateAnimations();
    };

    return Component_AnimationHandler;

  })(ui.Component_Handler);

  ui.Component_AnimationHandler = Component_AnimationHandler;

}).call(this);
