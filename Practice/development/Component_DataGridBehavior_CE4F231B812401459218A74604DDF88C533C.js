// Generated by CoffeeScript 1.12.7
(function() {
  var Component_DataGridBehavior,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Component_DataGridBehavior = (function(superClass) {
    var DataSource, DataWrapper;

    extend(Component_DataGridBehavior, superClass);

    DataWrapper = (function() {
      function DataWrapper(data) {
        this.data = data;
        this.viewData = [true, false, false, true, false];
      }

      return DataWrapper;

    })();

    DataSource = (function() {
      function DataSource(source) {
        var i, k, ref;
        this.source = source || [];
        this.length = this.source.length;
        this.wrappedSource = new Array(this.source.length);
        for (i = k = 0, ref = this.wrappedSource.length; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
          this.wrappedSource[i] = null;
        }
      }

      DataSource.prototype.set = function(source) {
        var i, k, ref, results;
        this.source = source || [];
        this.length = this.source.length;
        this.wrappedSource = new Array(this.source.length);
        results = [];
        for (i = k = 0, ref = this.wrappedSource.length; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
          results.push(this.wrappedSource[i] = null);
        }
        return results;
      };

      DataSource.prototype.itemAt = function(index) {
        var item;
        item = this.wrappedSource[index];
        if (!item) {
          item = new DataWrapper(this.source[index]);
          this.wrappedSource[index] = item;
        }
        return item;
      };

      DataSource.prototype.setItemAt = function(index, data) {
        if (this.wrappedSource[index]) {
          this.wrappedSource[index].data = data;
        }
        return this.source[index] = data;
      };

      return DataSource;

    })();

    Component_DataGridBehavior.accessors("dataSource", {
      set: function(v) {
        if (v !== this.dataSource_.source) {
          this.dataSource_.set(v);
          return this.resize();
        }
      },
      get: function() {
        return this.dataSource_;
      }
    });


    /**
    * Called if this object instance is restored from a data-bundle. It can be used
    * re-assign event-handler, anonymous functions, etc.
    * 
    * @method onDataBundleRestore.
    * @param Object data - The data-bundle
    * @param gs.ObjectCodecContext context - The codec-context.
     */

    Component_DataGridBehavior.prototype.onDataBundleRestore = function(data, context) {
      return this.setupEventHandlers();
    };


    /**
    * The data-grid behavior component defines the logic for a data-grid. A data-grid
    * allows to display items from a associated data-source using a specified
    * item-template. Unlike a stack-layout, a data-grid is optimized to display even high amounts of items but they all
    * need to use the same item-template with same size.
    *
    * @module ui
    * @class Component_DataGridBehavior
    * @extends gs.Component_Visual
    * @memberof ui
    * @constructor
    * @params {Object} params - The params-object containing the data-grid settings.
     */

    function Component_DataGridBehavior(params) {
      Component_DataGridBehavior.__super__.constructor.call(this);
      this.params = params || {};

      /**
      * The item-template descriptor used for each item of the data-grid.
      * @property template
      * @type Object
       */
      this.template = this.params.template;

      /**
      * The data-source used for the data-grid. Can be an array or a formula.
      * @property dataSource
      * @type Object[]|string
       */
      this.dataSource_ = null;

      /**
      * Stores the item-objects needed for rendering. They are created from the item-template.
      * @property items
      * @protected
      * @type gs.Object_Base[]
       */
      this.items = this.params.items || [];

      /**
      * Numbers of columns.
      * @property columns
      * @type number
       */
      this.columns = this.params.columns || 1;

      /**
      * Indicates if the data-grid is initialized and ready for rendering.
      * @property initialized
      * @protected
      * @type boolean
       */
      this.initialized = false;

      /**
      * Defines a horizontal and vertical spacing between items.
      * @property spacing
      * @default [0, 10]        
      * @type number[]
       */
      this.spacing = this.params.spacing || [0, 0];
    }


    /**
    * Adds event-handlers for mouse/touch events
    *
    * @method setupEventHandlers
     */

    Component_DataGridBehavior.prototype.setupEventHandlers = function() {
      return gs.GlobalEventManager.on("mouseWheel", (function(_this) {
        return function() {
          var r;
          r = _this.object.dstRect;
          if (Rect.contains(r.x, r.y, r.width, r.height, Input.Mouse.x - _this.object.origin.x, Input.Mouse.y - _this.object.origin.y)) {
            return _this.updateScroll();
          }
        };
      })(this));
    };


    /**
    * Sets up the data-grid.
    *
    * @method setup
     */

    Component_DataGridBehavior.prototype.setup = function() {
      var item;
      if (this.object.dstRect.width === 1) {
        return;
      }
      this.initialized = true;
      if (!this.template.size) {
        item = ui.UIManager.createControlFromDescriptor(this.template.descriptor, this.object);
        item.index = 0;
        item.update();
        this.template.size = [item.dstRect.width, item.dstRect.height];
        item.dispose();
      }
      if (this.params.dataSource.exec) {
        this.dataSource_ = new DataSource(ui.Component_FormulaHandler.fieldValue(this.object, this.params.dataSource) || []);
      } else {
        this.dataSource_ = new DataSource(this.params.dataSource || []);
      }
      this.resize();
      this.setupEventHandlers();
      Component_DataGridBehavior.__super__.setup.call(this);
      return this.object.scrollableHeight = Math.max(0, this.object.contentHeight - this.object.dstRect.height);
    };


    /**
    * Scrolls to the end.
    *
    * @method scrollToEnd
     */

    Component_DataGridBehavior.prototype.scrollToEnd = function() {
      return this.object.scrollOffsetY = this.object.scrollableHeight;
    };


    /**
    * Updates scrolling.
    *
    * @method updateScroll
     */

    Component_DataGridBehavior.prototype.updateScroll = function() {
      this.object.scrollableHeight = Math.max(0, this.object.contentHeight - this.object.dstRect.height);
      if (Input.Mouse.wheel <= -1) {
        this.object.scrollOffsetY = Math.max(this.object.scrollOffsetY - Input.Mouse.wheelSpeed * 0.1, 0);
      }
      if (Input.Mouse.wheel >= 1) {
        this.object.scrollOffsetY = Math.min(this.object.scrollOffsetY - Input.Mouse.wheelSpeed * 0.1, this.object.scrollableHeight);
      }
      return this.object.scrollOffsetY = Math.max(Math.min(this.object.scrollOffsetY, this.object.scrollableHeight), 0);
    };


    /**
    * Resizes the data-grid and creates the necessary display objects from the data-grid template.
    *
    * @method resize
     */

    Component_DataGridBehavior.prototype.resize = function() {
      var height, index, item, itemsX, itemsY, k, l, len, m, ref, ref1, ref2, totalItemsY, width, x, y;
      width = this.object.dstRect.width;
      height = this.object.dstRect.height;
      itemsX = this.columns || 1;
      itemsY = Math.ceil((height - this.spacing[1]) / (this.template.size[1] + this.spacing[1])) + this.columns + 1;
      totalItemsY = Math.ceil(this.dataSource.length / this.columns);
      ref = this.items;
      for (k = 0, len = ref.length; k < len; k++) {
        item = ref[k];
        if (item != null) {
          item.dispose();
        }
      }
      this.items = [];
      for (y = l = 0, ref1 = itemsY; 0 <= ref1 ? l < ref1 : l > ref1; y = 0 <= ref1 ? ++l : --l) {
        for (x = m = 0, ref2 = itemsX; 0 <= ref2 ? m < ref2 : m > ref2; x = 0 <= ref2 ? ++m : --m) {
          index = y * itemsX + x;
          if (index < this.dataSource.length) {
            item = ui.UIManager.createControlFromDescriptor(this.template.descriptor, this.object);
            item.data[0] = this.dataSource.itemAt(index).data;
            item.dstRect.x = this.spacing[0] + x * (this.template.size[0] + this.spacing[0]);
            item.dstRect.y = this.spacing[1] + y * (this.template.size[1] + this.spacing[1]);
            item.dstRect.width = this.template.size[0];
            item.dstRect.height = this.template.size[1];
            item.index = index;
            item.ui.viewData = this.dataSource.itemAt(index).viewData;
            this.items[item.index] = item;
            this.object.addObject(item);
          }
        }
      }
      this.object.scrollableHeight = this.spacing[1] + totalItemsY * (this.template.size[1] + this.spacing[1]) - height;
      this.object.scrollOffsetY = 0;
      return this.object.contentHeight = this.spacing[1] + totalItemsY * (this.template.size[1] + this.spacing[1]);
    };

    Component_DataGridBehavior.prototype.itemAtIndex = function(index) {
      return this.items.first(function(item) {
        return item.index === index;
      });
    };

    Component_DataGridBehavior.prototype.indexForItem = function(item) {
      return item.index;
    };


    /**
    * Updates the data-grid.
    *
    * @method update
     */

    Component_DataGridBehavior.prototype.update = function() {
      var column, i, item, itemIndex, itemsY, j, k, offset, ref, ref1, results, row, scrollOffset;
      Component_DataGridBehavior.__super__.update.call(this);
      if (!this.initialized) {
        this.setup();
      }
      scrollOffset = this.object.scrollOffsetY;
      offset = Math.floor(scrollOffset / (this.template.size[1] + this.spacing[1])) * this.columns;
      i = offset;
      itemIndex = 0;
      itemsY = Math.ceil((this.object.dstRect.height - this.spacing[1]) / (this.template.size[1] + this.spacing[1])) * this.columns + this.columns + 1;
      while (i < Math.min(offset + itemsY, this.dataSource.length)) {
        row = Math.floor(i / this.columns);
        column = i % this.columns;
        item = this.items[itemIndex];
        if (item) {
          item.data[0] = this.dataSource.itemAt(i).data;
          if (this.object.clipRect) {
            item.clipRect = this.object.clipRect;
          }
          item.index = i;
          item.ui.viewData = this.dataSource.itemAt(i).viewData;
          item.dstRect.x = this.spacing[0] + column * (this.template.size[0] + this.spacing[0]);
          item.dstRect.y = this.spacing[1] + (row - (offset / this.columns)) * (this.template.size[1] + this.spacing[1]) + (-scrollOffset % (this.template.size[1] + this.spacing[1]));
          item.visible = true;
          item.update();
          item.update();
          itemIndex++;
        }
        i++;
      }
      results = [];
      for (j = k = ref = itemIndex, ref1 = this.items.length; ref <= ref1 ? k < ref1 : k > ref1; j = ref <= ref1 ? ++k : --k) {
        if (this.items[j]) {
          this.items[j].visible = false;
          results.push(this.items[j].update());
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    return Component_DataGridBehavior;

  })(gs.Component_Visual);

  ui.Component_DataGridBehavior = Component_DataGridBehavior;

}).call(this);
