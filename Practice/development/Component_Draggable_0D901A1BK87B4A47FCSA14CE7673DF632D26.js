// Generated by CoffeeScript 1.12.7
(function() {
  var Component_Draggable,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Component_Draggable = (function(superClass) {
    extend(Component_Draggable, superClass);


    /**
    * Called if this object instance is restored from a data-bundle. It can be used
    * re-assign event-handler, anonymous functions, etc.
    *
    * @method onDataBundleRestore.
    * @param Object data - The data-bundle
    * @param gs.ObjectCodecContext context - The codec-context.
     */

    Component_Draggable.prototype.onDataBundleRestore = function(data, context) {
      return this.setupEventHandlers();
    };


    /**
    * Makes a game object draggable using mouse/touch. The dragging can be
    * vertical, horizontal or both. It can be configured as pixel-wise or
    * step-wise dragging. For example: To create a slider for UI with
    * fixed steps, step-wise is useful while a pixel-wise dragging could
    * be used for a volume-slider.
    *
    * @module gs
    * @class Component_Draggable
    * @extends gs.Component
    * @memberof gs
    * @constructor
     */

    function Component_Draggable() {

      /**
      * Mouse/Pointer x coordinate
      * @property mx
      * @type number
       */
      this.mx = 0;

      /**
      * Mouse/Pointer y coordinate
      * @property my
      * @type number
       */
      this.my = 0;

      /**
      * Stepping in pixels.
      * @property stepSize
      * @type gs.Point
       */
      this.stepSize = {
        x: 0,
        y: 0
      };

      /**
      * Drag Area
      * @property rect
      * @type gs.Rect
       */
      this.rect = null;
    }


    /**
    * Adds event-handler for mouse/touch events to update the component only if
    * a user-action happened.
    *
    * @method setupEventHandlers
     */

    Component_Draggable.prototype.setupEventHandlers = function() {
      gs.GlobalEventManager.on("mouseMoved", ((function(_this) {
        return function(e) {
          var rect, ref, x, y;
          rect = (ref = _this.object.draggable) != null ? ref.rect : void 0;
          x = Input.Mouse.x - _this.object.origin.x;
          y = Input.Mouse.y - _this.object.origin.y;
          if (_this.object.dragging || rect.contains(x, y)) {
            _this.object.needsUpdate = true;
            return e.breakChain = true;
          }
        };
      })(this)), null, this.object);
      gs.GlobalEventManager.on("mouseDown", ((function(_this) {
        return function(e) {
          var rect, ref, x, y;
          rect = _this.object.dstRect;
          x = Input.Mouse.x - _this.object.origin.x;
          y = Input.Mouse.y - _this.object.origin.y;
          if (rect.contains(x, y)) {
            _this.object.dragging = true;
            _this.object.needsUpdate = true;
            if ((ref = _this.object.events) != null) {
              ref.emit("dragStart", _this.object);
            }
            return e.breakChain = true;
          }
        };
      })(this)), null, this.object);
      return gs.GlobalEventManager.on("mouseUp", ((function(_this) {
        return function(e) {
          if (_this.object.dragging) {
            _this.object.needsUpdate = true;
            return e.breakChain = true;
          }
        };
      })(this)), null, this.object);
    };


    /**
    * Initializes the component. Adds event-handler for mouse/touch events to
    * update the component only if a user-action happened.
    *
    * @method setup
     */

    Component_Draggable.prototype.setup = function() {
      return this.setupEventHandlers();
    };


    /**
    * Disposes the component.
    *
    * @method dispose
     */

    Component_Draggable.prototype.dispose = function() {
      Component_Draggable.__super__.dispose.apply(this, arguments);
      gs.GlobalEventManager.offByOwner("mouseDown", this.object);
      return gs.GlobalEventManager.offByOwner("mouseMoved", this.object);
    };


    /**
    * Updates the dragging-process on x-axis if configured.
    *
    * @method updateAxisX
    * @protected
     */

    Component_Draggable.prototype.updateAxisX = function() {
      var ref;
      if ((ref = this.object.draggable.axisX) != null ? ref : true) {
        if (this.object.dragging) {
          this.object.draggable.step = Math.round(Math.max(this.rect.x, Math.min(this.mx - this.object.dstRect.width / 2, this.rect.x + this.rect.width - this.object.dstRect.width)) / this.stepSize.x);
          return this.object.dstRect.x = this.object.draggable.step * this.stepSize.x;
        } else if (this.object.draggable.steps != null) {
          return this.object.dstRect.x = this.object.draggable.step * this.stepSize.x;
        }
      }
    };


    /**
    * Updates the dragging-process on y-axis if configured.
    *
    * @method updateAxisY
    * @protected
     */

    Component_Draggable.prototype.updateAxisY = function() {
      var ref;
      if ((ref = this.object.draggable.axisY) != null ? ref : true) {
        if (this.object.dragging) {
          this.object.draggable.step = Math.round(Math.max(this.rect.y, Math.min(this.my - this.object.dstRect.height / 2, this.rect.y + this.rect.height - this.object.dstRect.height)) / this.stepSize.y);
          return this.object.dstRect.y = this.object.draggable.step * this.stepSize.y;
        } else if (this.object.draggable.steps != null) {
          return this.object.dstRect.y = this.object.draggable.step * this.stepSize.y;
        }
      }
    };


    /**
    * Calculates the size of a single step if steps are configured for this
    * component. Otherwise the step-size 1-pixel.
    *
    * @method updateDragging
    * @protected
     */

    Component_Draggable.prototype.updateStepSize = function() {
      if (this.object.draggable.steps != null) {
        this.stepSize.x = (this.rect.width - this.object.dstRect.width) / (this.object.draggable.steps - 1);
        return this.stepSize.y = (this.rect.height - this.object.dstRect.height) / (this.object.draggable.steps - 1);
      } else {
        this.stepSize.x = 1;
        return this.stepSize.y = 1;
      }
    };


    /**
    * Updates the game object's dragging-state and fires a dragged-event
    * if necessary.
    *
    * @method updateDragging
    * @protected
     */

    Component_Draggable.prototype.updateDragging = function() {
      var ref, x, y;
      if (this.object.focusable && !this.object.ui.focused) {
        return;
      }
      x = Input.Mouse.x - this.object.origin.x;
      y = Input.Mouse.y - this.object.origin.y;
      if (this.object.dragging) {
        if (this.mx !== x || this.my !== y) {
          this.object.events.emit("drag", this.object);
        }
        if (Input.Mouse.buttons[Input.Mouse.LEFT] === 2 || Input.Mouse.buttons[Input.Mouse.LEFT] === 0) {
          this.object.dragging = false;
          if ((ref = this.object.events) != null) {
            ref.emit("dragEnd", this.object);
          }
        }
      }
      this.mx = x;
      return this.my = y;
    };


    /**
    * Updates the dragging-logic.
    *
    * @method update
     */

    Component_Draggable.prototype.update = function() {
      var ref;
      this.rect = ((ref = this.object.draggable) != null ? ref.rect : void 0) || this.object.dstRect;
      this.updateStepSize();
      this.updateDragging();
      this.updateAxisX();
      return this.updateAxisY();
    };

    return Component_Draggable;

  })(gs.Component);

  ui.Draggable = Component_Draggable;

  ui.Component_Draggable = Component_Draggable;

}).call(this);
