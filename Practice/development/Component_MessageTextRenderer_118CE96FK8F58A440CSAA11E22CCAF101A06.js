// Generated by CoffeeScript 1.12.7
(function() {
  var Component_MessageTextRenderer,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Component_MessageTextRenderer = (function(superClass) {
    extend(Component_MessageTextRenderer, superClass);

    Component_MessageTextRenderer.objectCodecBlackList = ["onLinkClick", "onBatchDisappear"];


    /**
    * Called if this object instance is restored from a data-bundle. It can be used
    * re-assign event-handler, anonymous functions, etc.
    *
    * @method onDataBundleRestore.
    * @param Object data - The data-bundle
    * @param gs.ObjectCodecContext context - The codec-context.
     */

    Component_MessageTextRenderer.prototype.onDataBundleRestore = function(data, context) {
      var bitmap, customObject, j, l, lastLine, len, len1, len2, line, lineWidth, m, message, n, ref, ref1, ref2;
      this.setupEventHandlers();
      l = 0;
      lastLine = null;
      ref = this.object.messages;
      for (j = 0, len = ref.length; j < len; j++) {
        message = ref[j];
        if (this.object.settings.useCharacterColor) {
          this.object.font.color = new gs.Color(message.character.textColor);
        }
        lineWidth = this.isRunningInMultiPartMode() ? (lastLine != null ? lastLine.width : void 0) || 0 : 0;
        this.lines = this.calculateLines(lcsm(message.text), true, lineWidth);
        ref1 = this.lines;
        for (m = 0, len1 = ref1.length; m < len1; m++) {
          line = ref1[m];
          bitmap = this.createBitmap(line);
          if (line === this.line) {
            this.drawLineContent(line, bitmap, this.charIndex + 1);
          } else {
            this.drawLineContent(line, bitmap, -1);
          }
          this.allSprites[l].bitmap = bitmap;
          lastLine = line;
          l++;
        }
      }
      ref2 = this.customObjects;
      for (n = 0, len2 = ref2.length; n < len2; n++) {
        customObject = ref2[n];
        SceneManager.scene.addObject(customObject);
      }
      return null;
    };


    /**
    *  A text-renderer component to render an animated and interactive message text using
    *  dimensions of the game object's destination-rectangle. The message is displayed
    *  using a sprite for each line instead of drawing to the game object's bitmap object.
    *
    *  @module gs
    *  @class Component_MessageTextRenderer
    *  @extends gs.Component_TextRenderer
    *  @memberof gs
    *  @constructor
     */

    function Component_MessageTextRenderer() {
      Component_MessageTextRenderer.__super__.constructor.apply(this, arguments);

      /**
      * An array containing all sprites of the current message.
      * @property sprites
      * @type gs.Sprite[]
      * @protected
       */
      this.sprites = [];

      /**
      * An array containing all sprites of all messages. In NVL mode
      * a page can contain multiple messages.
      * @property allSprites
      * @type gs.Sprite[]
      * @protected
       */
      this.allSprites = [];

      /**
      * An array containing all line-objects of the current message.
      * @property lines
      * @type gs.TextRendererLine[]
      * @readOnly
       */
      this.lines = null;

      /**
      * The line currently rendered.
      * @property line
      * @type number
      * @readOnly
       */
      this.line = 0;

      /**
      * The left and right padding per line.
      * @property padding
      * @type number
       */
      this.padding = 6;

      /**
      * The minimum height of the line currently rendered. If 0, the measured
      * height of the line will be used.
      * @property minLineHeight
      * @type number
       */
      this.minLineHeight = 0;

      /**
      * The spacing between text lines in pixels.
      * @property lineSpacing
      * @type number
       */
      this.lineSpacing = 2;

      /**
      * The line currently rendered.
      * @property currentLine
      * @type number
      * @protected
       */
      this.currentLine = 0;

      /**
      * The height of the line currently rendered.
      * @property currentLineHeight
      * @type number
      * @protected
       */
      this.currentLineHeight = 0;

      /**
      * Index of the current character to draw.
      * @property charIndex
      * @type number
      * @readOnly
       */
      this.charIndex = 0;

      /**
      * Position of the message caret. The caret is like an invisible
      * cursor pointing to the x/y coordinates of the last rendered character of
      * the message. That position can be used to display a waiting- or processing-animation for example.
      * @property caretPosition
      * @type gs.Point
      * @readOnly
       */
      this.caretPosition = new gs.Point();

      /**
      * Indicates that the a message is currently in progress.
      * @property isRunning
      * @type boolean
      * @readOnly
       */
      this.isRunning = false;

      /**
      * The current x-coordinate of the caret/cursor.
      * @property currentX
      * @type number
      * @readOnly
       */
      this.currentX = 0;

      /**
      * The current y-coordinate of the caret/cursor.
      * @property currentY
      * @type number
      * @readOnly
       */
      this.currentY = 0;

      /**
      * The current sprites used to display the current text-line/part.
      * @property currentSprite
      * @type gs.Sprite
      * @readOnly
       */
      this.currentSprite = null;

      /**
      * Indicates if the message-renderer is currently waiting like for a user-action.
      * @property isWaiting
      * @type boolean
      * @readOnly
       */
      this.isWaiting = false;

      /**
      * Indicates if the message-renderer is currently waiting for a key-press or mouse/touch action.
      * @property waitForKey
      * @type boolean
      * @readOnly
       */
      this.waitForKey = false;

      /**
      * Number of frames the message-renderer should wait before continue.
      * @property waitCounter
      * @type number
       */
      this.waitCounter = 0;

      /**
      * Speed of the message-drawing. The smaller the value, the faster the message is displayed.
      * @property speed
      * @type number
       */
      this.speed = 1;

      /**
      * Indicates if the message should be rendered immedialtely without any animation or delay.
      * @property drawImmediately
      * @type boolean
       */
      this.drawImmediately = false;

      /**
      * Indicates if the message should wait for a user-action or a certain amount of time
      * before finishing.
      * @property waitAtEnd
      * @type boolean
       */
      this.waitAtEnd = true;

      /**
      * The number of frames to wait before finishing a message.
      * before finishing.
      * @property waitAtEndTime
      * @type number
       */
      this.waitAtEndTime = 0;

      /**
      * Indicates if auto word-wrap should be used. Default is <b>true</b>
      * @property wordWrap
      * @type boolean
       */
      this.wordWrap = true;

      /**
      * Custom game objects which are alive until the current message is erased. Can be used to display
      * animated icons, etc.
      * @property customObjects
      * @type gs.Object_Base[]
       */
      this.customObjects = [];

      /**
      * A hashtable/dictionary object to store custom-data useful like for token-processing. The data must be
      * serializable.
      * @property customObjects
      * @type Object
       */
      this.customData = {};

      /**
      * A callback function called if the player clicks on a non-stylable link (LK text-code) to trigger
      * the specified common event.
      * @property onLinkClick
      * @type Function
       */
      this.onLinkClick = function(e) {
        var event, eventId;
        eventId = e.data.linkData.commonEventId;
        event = RecordManager.commonEvents[eventId];
        if (!event) {
          event = RecordManager.commonEvents.first((function(_this) {
            return function(x) {
              return x.name === eventId;
            };
          })(this));
          if (event) {
            eventId = event.index;
          }
        }
        if (!event) {
          return SceneManager.scene.interpreter.jumpToLabel(eventId);
        } else {
          return SceneManager.scene.interpreter.callCommonEvent(eventId, null, true);
        }
      };

      /**
      * A callback function called if a batched messsage has been faded out. It triggers the execution of
      * the next message.
      * @property onBatchDisappear
      * @type Function
       */
      this.onBatchDisappear = (function(_this) {
        return function(e) {
          _this.drawImmediately = false;
          _this.isWaiting = false;
          _this.object.opacity = 255;
          return _this.executeBatch();
        };
      })(this);
    }


    /**
    * Serializes the message text-renderer into a data-bundle.
    * @method toDataBundle
    * @return {Object} A data-bundle.
     */

    Component_MessageTextRenderer.prototype.toDataBundle = function() {
      var bundle, ignore, k;
      ignore = ["object", "font", "sprites", "allSprites", "currentSprite", "currentX"];
      bundle = {
        currentSpriteIndex: this.sprites.indexOf(this.currentSprite)
      };
      for (k in this) {
        if (ignore.indexOf(k) === -1) {
          bundle[k] = this[k];
        }
      }
      return bundle;
    };


    /**
    * Disposes the message text-renderer and all sprites used to display
    * the message.
    * @method dispose
     */

    Component_MessageTextRenderer.prototype.dispose = function() {
      var j, len, ref, ref1, results, sprite;
      Component_MessageTextRenderer.__super__.dispose.apply(this, arguments);
      this.disposeEventHandlers();
      ref = this.allSprites;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        sprite = ref[j];
        if ((ref1 = sprite.bitmap) != null) {
          ref1.dispose();
        }
        results.push(sprite.dispose());
      }
      return results;
    };


    /**
    * Removes all attached event handlers
    * the message.
    * @method disposeEventHandlers
     */

    Component_MessageTextRenderer.prototype.disposeEventHandlers = function() {
      gs.GlobalEventManager.offByOwner("mouseUp", this.object);
      return gs.GlobalEventManager.offByOwner("keyUp", this.object);
    };


    /**
    * Adds event-handlers for mouse/touch events
    *
    * @method setupEventHandlers
     */

    Component_MessageTextRenderer.prototype.setupEventHandlers = function() {
      gs.GlobalEventManager.offByOwner("mouseUp", this.object);
      gs.GlobalEventManager.offByOwner("keyUp", this.object);
      gs.GlobalEventManager.on("mouseUp", ((function(_this) {
        return function(e) {
          if (_this.object.findComponentByName("animation") || (GameManager.settings.autoMessage.enabled && !GameManager.settings.autoMessage.stopOnAction)) {
            return;
          }
          if (_this.isWaiting && !(_this.waitCounter > 0 || _this.waitForKey)) {
            e.breakChain = true;
            _this["continue"]();
          } else {
            e.breakChain = _this.isRunning;
            _this.drawImmediately = !_this.waitForKey;
            _this.waitCounter = 0;
            _this.waitForKey = false;
            _this.isWaiting = false;
          }
          if (_this.waitForKey) {
            if (Input.Mouse.buttons[Input.Mouse.LEFT] === 2) {
              e.breakChain = true;
              Input.clear();
              _this.waitForKey = false;
              return _this.isWaiting = false;
            }
          }
        };
      })(this)), null, this.object);
      return gs.GlobalEventManager.on("keyUp", ((function(_this) {
        return function(e) {
          if (Input.keys[Input.C] && (!_this.isWaiting || (_this.waitCounter > 0 || _this.waitForKey))) {
            _this.drawImmediately = !_this.waitForKey;
            _this.waitCounter = 0;
            _this.waitForKey = false;
            _this.isWaiting = false;
          }
          if (_this.isWaiting && !_this.waitForKey && !_this.waitCounter && Input.keys[Input.C]) {
            _this["continue"]();
          }
          if (_this.waitForKey) {
            if (Input.keys[Input.C]) {
              Input.clear();
              _this.waitForKey = false;
              return _this.isWaiting = false;
            }
          }
        };
      })(this)), null, this.object);
    };


    /**
    * Sets up the renderer. Registers necessary event handlers.
    * @method setup
     */

    Component_MessageTextRenderer.prototype.setup = function() {
      return this.setupEventHandlers();
    };


    /**
    * Restores the message text-renderer's state from a data-bundle.
    * @method restore
    * @param {Object} bundle - A data-bundle containing message text-renderer state.
     */

    Component_MessageTextRenderer.prototype.restore = function(bundle) {
      var k;
      for (k in bundle) {
        if (k === "currentSpriteIndex") {
          this.currentSprite = this.sprites[bundle.currentSpriteIndex];
        } else {
          this[k] = bundle[k];
        }
      }
      if (this.sprites.length > 0) {
        this.currentY = this.sprites.last().y - this.object.origin.y - this.object.dstRect.y;
        this.line = this.maxLines;
        this.isWaiting = this.isWaiting || this.isRunning;
      }
      return null;
    };


    /**
    * Continues message-processing if currently waiting.
    * @method continue
     */

    Component_MessageTextRenderer.prototype["continue"] = function() {
      var duration, fading, ref, ref1;
      this.isWaiting = false;
      if (this.line >= this.lines.length) {
        this.isRunning = false;
        return (ref = this.object.events) != null ? ref.emit("messageFinish", this) : void 0;
      } else {
        if ((ref1 = this.object.events) != null) {
          ref1.emit("messageBatch", this);
        }
        fading = GameManager.tempSettings.messageFading;
        duration = GameManager.tempSettings.skip ? 0 : fading.duration;
        return this.object.animator.disappear(fading.animation, fading.easing, duration, gs.CallBack("onBatchDisappear", this));
      }
    };


    /**
    * Updates the text-renderer.
    * @method update
     */

    Component_MessageTextRenderer.prototype.update = function() {
      var j, len, len1, m, object, ref, ref1, ref2, sprite;
      ref = this.allSprites;
      for (j = 0, len = ref.length; j < len; j++) {
        sprite = ref[j];
        sprite.opacity = this.object.opacity;
        sprite.visible = this.object.visible;
        sprite.ox = -this.object.offset.x;
        sprite.oy = -this.object.offset.y;
        sprite.mask.value = this.object.mask.value;
        sprite.mask.vague = this.object.mask.vague;
        sprite.mask.source = this.object.mask.source;
        sprite.mask.type = this.object.mask.type;
      }
      ref1 = this.customObjects;
      for (m = 0, len1 = ref1.length; m < len1; m++) {
        object = ref1[m];
        object.opacity = this.object.opacity;
        object.visible = this.object.visible;
      }
      if (!this.isRunning && this.waitCounter > 0) {
        this.waitCounter--;
        if (this.waitCounter === 0) {
          this["continue"]();
        }
        return;
      }
      if (this.object.visible && ((ref2 = this.lines) != null ? ref2.length : void 0) > 0) {
        this.updateLineWriting();
        this.updateWaitForKey();
        this.updateWaitCounter();
        return this.updateCaretPosition();
      }
    };


    /**
    * Indicates if its a batched messages.
    *
    * @method isBatched
    * @return If <b>true</b> it is a batched message. Otherwise <b>false</b>.
     */

    Component_MessageTextRenderer.prototype.isBatched = function() {
      return this.lines.length > this.maxLines;
    };


    /**
    * Indicates if the batch is still in progress and not done.
    *
    * @method isBatchInProgress
    * @return If <b>true</b> the batched message is still not done. Otherwise <b>false</b>
     */

    Component_MessageTextRenderer.prototype.isBatchInProgress = function() {
      return this.lines.length - this.line > this.maxLines;
    };


    /**
    * Indicates if the renderer runs in multi-part message mode which
    * means that a single message might be constructed from multiple drawFormattedText
    * calls.
    *
    * @method isRunningInMultiPartMode
    * @return If <b>true</b> the renderer runs in multi-part mode. Otherwise <b>false</b>.
     */

    Component_MessageTextRenderer.prototype.isRunningInMultiPartMode = function() {
      return !this.object.settings.autoErase && this.object.settings.paragraphSpacing <= 0;
    };


    /**
    * Starts displaying the next page of text if a message is too long to fit
    * into one message box.
    *
    * @method executeBatch
     */

    Component_MessageTextRenderer.prototype.executeBatch = function() {
      this.clearAllSprites();
      this.lines = this.lines.slice(this.line);
      this.line = 0;
      this.currentX = 0;
      this.currentY = 0;
      this.currentLineHeight = 0;
      this.tokenIndex = 0;
      this.charIndex = 0;
      this.token = this.lines[this.line].content[this.tokenIndex] || new gs.RendererToken(null, "");
      this.maxLines = this.calculateMaxLines(this.lines);
      this.lineAnimationCount = this.speed;
      this.sprites = this.createSprites(this.lines);
      this.allSprites = this.allSprites.concat(this.sprites);
      this.currentSprite = this.sprites[this.line];
      this.currentSprite.x = this.currentX + this.object.origin.x + this.object.dstRect.x;
      return this.drawNext();
    };


    /**
    * Calculates the duration(in frames) the message-renderer needs to display
    * the message.
    *
    * @method calculateDuration
    * @return {number} The duration in frames.
     */

    Component_MessageTextRenderer.prototype.calculateDuration = function() {
      var duration, j, len, len1, line, m, ref, ref1, token;
      duration = 0;
      if (this.lines != null) {
        ref = this.lines;
        for (j = 0, len = ref.length; j < len; j++) {
          line = ref[j];
          ref1 = line.content;
          for (m = 0, len1 = ref1.length; m < len1; m++) {
            token = ref1[m];
            if (token != null) {
              duration += this.calculateDurationForToken(token);
            }
          }
        }
      }
      return duration;
    };


    /**
    * Calculates the duration(in frames) the message-renderer needs to display
    * the specified line.
    *
    * @method calculateDurationForLine
    * @param {gs.RendererTextLine} line The line to calculate the duration for.
    * @return {number} The duration in frames.
     */

    Component_MessageTextRenderer.prototype.calculateDurationForLine = function(line) {
      var duration, j, len, ref, token;
      duration = 0;
      if (line) {
        ref = line.content;
        for (j = 0, len = ref.length; j < len; j++) {
          token = ref[j];
          if (token != null) {
            duration += this.calculateDurationForToken(token);
          }
        }
      }
      return duration;
    };


    /**
    * Calculates the duration(in frames) the message-renderer needs to process
    * the specified token.
    *
    * @method calculateDurationForToken
    * @param {string|Object} token - The token.
    * @return {number} The duration in frames.
     */

    Component_MessageTextRenderer.prototype.calculateDurationForToken = function(token) {
      var duration;
      duration = 0;
      if (token.code != null) {
        switch (token.code) {
          case "W":
            if (token.value !== "A") {
              duration = token.value / 1000 * Graphics.frameRate;
            }
        }
      } else {
        duration = token.value.length * this.speed;
      }
      return duration;
    };


    /**
    * Calculates the maximum of lines which can be displayed in one message.
    *
    * @method calculateMaxLines
    * @param {Array} lines - An array of line-objects.
    * @return {number} The number of displayable lines.
     */

    Component_MessageTextRenderer.prototype.calculateMaxLines = function(lines) {
      var height, j, len, line, result;
      height = 0;
      result = 0;
      for (j = 0, len = lines.length; j < len; j++) {
        line = lines[j];
        height += line.height + this.lineSpacing;
        if (this.currentY + height > this.object.dstRect.height) {
          break;
        }
        result++;
      }
      return Math.min(lines.length, result || 1);
    };


    /**
    * Displays the character or processes the next control-token.
    *
    * @method drawNext
     */

    Component_MessageTextRenderer.prototype.drawNext = function() {
      var lineSpacing, size, token;
      token = this.processToken();
      if ((token != null ? token.value.length : void 0) > 0) {
        this.char = this.token.value.charAt(this.charIndex);
        size = this.font.measureTextPlain(this.char);
        lineSpacing = this.lineSpacing;
        if (this.currentLine !== this.line) {
          this.currentLine = this.line;
          this.currentLineHeight = 0;
        }
        this.currentSprite.y = this.object.origin.y + this.object.dstRect.y + this.currentY;
        this.currentSprite.visible = true;
        this.drawLineContent(this.lines[this.line], this.currentSprite.bitmap, this.charIndex + 1);
        this.currentSprite.srcRect.width = this.currentSprite.bitmap.width;
        this.currentLineHeight = this.lines[this.line].height;
        return this.currentX = Math.min(this.lines[this.line].width, this.currentX + size.width);
      }
    };


    /**
    * Processes the next character/token of the message.
    * @method nextChar
    * @private
     */

    Component_MessageTextRenderer.prototype.nextChar = function() {
      var base, base1, results;
      results = [];
      while (true) {
        this.charIndex++;
        this.lineAnimationCount = this.speed;
        if ((this.token.code != null) || this.charIndex >= this.token.value.length) {
          if (typeof (base = this.token).onEnd === "function") {
            base.onEnd();
          }
          this.tokenIndex++;
          if (this.tokenIndex >= this.lines[this.line].content.length) {
            this.tokenIndex = 0;
            this.line++;
            this.currentSprite.srcRect.width = this.currentSprite.bitmap.width;
            this.currentSprite = this.sprites[this.line];
            if (this.currentSprite != null) {
              this.currentSprite.x = this.object.origin.x + this.object.dstRect.x;
            }
            if (this.line < this.maxLines) {
              this.currentY += (this.currentLineHeight || this.font.lineHeight) + this.lineSpacing * Graphics.scale;
              this.charIndex = 0;
              this.currentX = 0;
              this.token = this.lines[this.line].content[this.tokenIndex] || new gs.RendererToken(null, "");
            }
          } else {
            this.charIndex = 0;
            this.token = this.lines[this.line].content[this.tokenIndex] || new gs.RendererToken(null, "");
          }
          if (typeof (base1 = this.token).onStart === "function") {
            base1.onStart();
          }
        }
        if (!this.token || this.token.value !== "\n" || !this.lines[this.line]) {
          break;
        } else {
          results.push(void 0);
        }
      }
      return results;
    };


    /**
    * Finishes the message. Depending on the message configuration, the
    * message text-renderer will now wait for a user-action or a certain amount
    * of time.
    *
    * @method finish
     */

    Component_MessageTextRenderer.prototype.finish = function() {
      var ref, ref1, ref2;
      if (this.waitAtEnd) {
        this.isWaiting = true;
        return (ref = this.object.events) != null ? ref.emit("messageWaiting", this) : void 0;
      } else if (this.waitAtEndTime > 0) {
        this.waitCounter = this.waitAtEndTime;
        this.isWaiting = false;
        return (ref1 = this.object.events) != null ? ref1.emit("messageWaiting", this) : void 0;
      } else {
        if ((ref2 = this.object.events) != null) {
          ref2.emit("messageWaiting", this);
        }
        return this["continue"]();
      }
    };


    /**
    * Returns the position of the caret in pixels. The caret is like an invisible
    * cursor pointing to the x/y coordinates of the last rendered character of
    * the message. That position can be used to display a waiting- or processing-animation for example.
    *
    * @method updateCaretPosition
     */

    Component_MessageTextRenderer.prototype.updateCaretPosition = function() {
      this.caretPosition.x = this.currentX + this.padding;
      return this.caretPosition.y = this.currentY + this.currentLineHeight / 2;
    };


    /**
    * Updates the line writing.
    *
    * @method updateLineWriting
    * @private
     */

    Component_MessageTextRenderer.prototype.updateLineWriting = function() {
      if (this.isRunning && !this.isWaiting && !this.waitForKey && this.waitCounter <= 0) {
        if (this.lineAnimationCount <= 0) {
          while (true) {
            if (this.line < this.maxLines) {
              this.nextChar();
            }
            if (this.line >= this.maxLines) {
              this.finish();
            } else {
              this.drawNext();
            }
            if (!((this.token.code || this.lineAnimationCount <= 0 || this.drawImmediately) && !this.waitForKey && this.waitCounter <= 0 && this.isRunning && this.line < this.maxLines)) {
              break;
            }
          }
        }
        if (GameManager.tempSettings.skip) {
          return this.lineAnimationCount = 0;
        } else {
          return this.lineAnimationCount--;
        }
      }
    };


    /**
    * Updates wait-for-key state. If skipping is enabled, the text renderer will
    * not wait for key press.
    *
    * @method updateWaitForKey
    * @private
     */

    Component_MessageTextRenderer.prototype.updateWaitForKey = function() {
      if (this.waitForKey) {
        this.isWaiting = !GameManager.tempSettings.skip;
        return this.waitForKey = this.isWaiting;
      }
    };


    /**
    * Updates wait counter if the text renderer is waiting for a certain amount of time to pass. If skipping is enabled, the text renderer will
    * not wait for the actual amount of time and sets the wait-counter to 1 frame instead.
    *
    * @method updateWaitForKey
    * @private
     */

    Component_MessageTextRenderer.prototype.updateWaitCounter = function() {
      if (this.waitCounter > 0) {
        if (GameManager.tempSettings.skip) {
          this.waitCounter = 1;
        }
        this.isWaiting = true;
        this.waitCounter--;
        if (this.waitCounter <= 0) {
          this.isWaiting = false;
          if (this.line >= this.maxLines) {
            return this["continue"]();
          }
        }
      }
    };


    /**
    * Creates a token-object for a specified text-code.
    *
    * @method createToken
    * @param {string} code - The code/type of the text-code.
    * @param {string} value - The value of the text-code.
    * @return {Object} The token-object.
     */

    Component_MessageTextRenderer.prototype.createToken = function(code, value) {
      var data, i, j, ref, tokenObject;
      tokenObject = null;
      switch (code) {
        case "CE":
          data = value.split("/");
          value = data.shift();
          value = isNaN(value) ? value : parseInt(value);
          for (i = j = 0, ref = data; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            if (data[i].startsWith('"') && data[i].endsWith('"')) {
              data[i] = data[i].substring(1, data[i].length - 1);
            } else {
              data[i] = isNaN(data[i]) ? data[i] : parseFloat(data[i]);
            }
          }
          tokenObject = {
            code: code,
            value: value,
            values: data
          };
          break;
        default:
          tokenObject = Component_MessageTextRenderer.__super__.createToken.call(this, code, value);
      }
      return tokenObject;
    };


    /**
    * <p>Measures a control-token. If a token produces a visual result like displaying an icon then it must return the size taken by
    * the visual result. If the token has no visual result, <b>null</b> must be returned. This method is called for every token when the message is initialized.</p>
    *
    * <p>This method is not called while the message is running. For that case, see <i>processControlToken</i> method which is called
    * for every token while the message is running.</p>
    *
    * @param {Object} token - A control-token.
    * @return {gs.Size} The size of the area taken by the visual result of the token or <b>null</b> if the token has no visual result.
    * @method analyzeControlToken
    * @protected
     */

    Component_MessageTextRenderer.prototype.measureControlToken = function(token) {
      return Component_MessageTextRenderer.__super__.measureControlToken.call(this, token);
    };


    /**
    * <p>Draws the visual result of a token, like an icon for example, to the specified bitmap. This method is called for every token when the message is initialized and the sprites for each
    * text-line are created.</p>
    *
    * <p>This method is not called while the message is running. For that case, see <i>processControlToken</i> method which is called
    * for every token while the message is running.</p>
    *
    * @param {Object} token - A control-token.
    * @param {gs.Bitmap} bitmap - The bitmap used for the current text-line. Can be used to draw something on it like an icon, etc.
    * @param {number} offset - An x-offset for the draw-routine.
    * @param {number} length - Determines how many characters of the token should be drawn. Can be ignored for tokens
    * not drawing any characters.
    * @method drawControlToken
    * @protected
     */

    Component_MessageTextRenderer.prototype.drawControlToken = function(token, bitmap, offset, length) {
      var data, j, len, linkData, results;
      switch (token.code) {
        case "RT":
          return Component_MessageTextRenderer.__super__.drawControlToken.call(this, token, bitmap, offset, length);
        case "SLK":
          if (token.customData.offsetX == null) {
            token.customData.offsetX = offset;
          }
          if (this.customData.linkData) {
            linkData = this.customData.linkData[this.line];
            if (linkData) {
              results = [];
              for (j = 0, len = linkData.length; j < len; j++) {
                data = linkData[j];
                results.push(this.sprites[this.line].bitmap.clearRect(data.cx, 0, data.width, data.height));
              }
              return results;
            }
          }
      }
    };


    /**
    * Processes a control-token. A control-token is a token which influences
    * the text-rendering like changing the fonts color, size or style. Changes
    * will be automatically applied to the game object's font.
    *
    * For message text-renderer, a few additional control-tokens like
    * speed-change, waiting, etc. needs to be processed here.
    *
    * This method is called for each token while the message is initialized and
    * also while the message is running. See <i>formattingOnly</i> parameter.
    *
    * @param {Object} token - A control-token.
    * @param {boolean} formattingOnly - If <b>true</b> the message is initializing right now and only
    * format-tokens should be processed which is necessary for the message to calculated sizes correctly.
    * @return {Object} A new token which is processed next or <b>null</b>.
    * @method processControlToken
    * @protected
     */

    Component_MessageTextRenderer.prototype.processControlToken = function(token, formattingOnly) {
      var animation, bitmap, character, duration, easing, expression, line, linkData, linkStart, object, params, ref, ref1, result, sound, textTokens, values;
      if (formattingOnly) {
        return Component_MessageTextRenderer.__super__.processControlToken.call(this, token);
      }
      result = null;
      switch (token.code) {
        case "CR":
          character = RecordManager.charactersArray.first(function(c) {
            var ref;
            return ((ref = c.name.defaultText) != null ? ref : c.name) === token.value;
          });
          if (character) {
            SceneManager.scene.currentCharacter = character;
          }
          break;
        case "CE":
          params = {
            "values": token.values
          };
          if ((ref = this.object.events) != null) {
            ref.emit("callCommonEvent", this.object, {
              commonEventId: token.value,
              params: params,
              finish: false,
              waiting: true
            });
          }
          break;
        case "X":
          if (typeof token.value === "function") {
            token.value(this.object);
          }
          break;
        case "A":
          animation = RecordManager.animationsArray.first(function(a) {
            return a.name === token.value;
          });
          if (!animation) {
            animation = RecordManager.animations[token.value];
          }
          if ((animation != null ? animation.graphic.name : void 0) != null) {
            bitmap = ResourceManager.getBitmap("Graphics/Pictures/" + animation.graphic.name);
            object = new gs.Object_Animation(animation);
            this.addCustomObject(object);
            this.currentX += Math.round(bitmap.width / animation.framesX);
            this.currentSprite.srcRect.width += Math.round(bitmap.width / animation.framesX);
          }
          break;
        case "RT":
          if (token.rtSize.width > token.rbSize.width) {
            this.currentX += token.rtSize.width;
            this.font.set(this.getRubyTextFont(token));
          } else {
            this.currentX += token.rbSize.width;
          }
          break;
        case "LK":
          if (token.value === 'E') {
            object = new ui.Object_Hotspot();
            object.enabled = true;
            object.setup();
            this.addCustomObject(object);
            object.dstRect.x = this.object.dstRect.x + this.object.origin.x + this.customData.linkData.cx;
            object.dstRect.y = this.object.dstRect.y + this.object.origin.y + this.customData.linkData.cy;
            object.dstRect.width = this.currentX - this.customData.linkData.cx;
            object.dstRect.height = this.currentLineHeight;
            object.events.on("click", gs.CallBack("onLinkClick", this), {
              linkData: this.customData.linkData
            }, this);
          } else {
            this.customData.linkData = {
              cx: this.currentX,
              cy: this.currentY,
              commonEventId: token.value,
              tokenIndex: this.tokenIndex
            };
          }
          break;
        case "SLK":
          if (token.value === 'E') {
            linkData = this.customData.linkData[this.line].last();
            line = this.lines[this.line].content;
            linkStart = this.findToken(this.tokenIndex - 1, "SLK", -1, line);
            textTokens = this.findTokensBetween(linkData.tokenIndex, this.tokenIndex, null, line);
            linkData.cx = linkStart.customData.offsetX;
            linkData.width = this.currentX - linkData.cx + this.padding;
            linkData.height = this.currentSprite.bitmap.height;
            object = new ui.Object_Text();
            object.text = textTokens.select((function(_this) {
              return function(x) {
                return x.value;
              };
            })(this)).join("");
            object.formatting = false;
            object.wordWrap = false;
            object.ui = new ui.Component_UIBehavior();
            object.enabled = true;
            object.addComponent(object.ui);
            object.addComponent(new gs.Component_HotspotBehavior());
            object.behavior.padding.left = 0;
            object.behavior.padding.right = 0;
            object.dstRect.width = linkData.width;
            object.dstRect.height = linkData.height;
            if (linkData.styleIndex === -1) {
              ui.UIManager.addControlStyles(object, ["hyperlink"]);
            } else {
              ui.UIManager.addControlStyles(object, ["hyperlink-" + linkData.styleIndex]);
            }
            object.setup();
            this.addCustomObject(object);
            object.dstRect.x = this.currentSprite.x + linkData.cx;
            object.dstRect.y = this.object.dstRect.y + this.object.origin.y + linkData.cy;
            object.events.on("click", gs.CallBack("onLinkClick", this), {
              linkData: linkData
            }, this);
          } else {
            if (!this.customData.linkData) {
              this.customData.linkData = [];
            }
            if (!this.customData.linkData[this.line]) {
              this.customData.linkData[this.line] = [];
            }
            if ((ref1 = token.value) != null ? ref1.contains(",") : void 0) {
              values = token.value.split(",");
              this.customData.linkData[this.line].push({
                cx: this.currentX,
                cy: this.currentY,
                commonEventId: values[0],
                styleIndex: parseInt(values[1]),
                tokenIndex: this.tokenIndex
              });
            } else {
              this.customData.linkData[this.line].push({
                cx: this.currentY,
                cy: this.currentY,
                commonEventId: token.value,
                tokenIndex: this.tokenIndex,
                styleIndex: -1
              });
            }
          }
          break;
        case "E":
          expression = RecordManager.characterExpressionsArray.first(function(c) {
            var ref2;
            return ((ref2 = c.name.defaultText) != null ? ref2 : c.name) === token.value;
          });
          if (!expression) {
            expression = RecordManager.characterExpressions[token.value];
          }
          character = SceneManager.scene.currentCharacter;
          if ((expression != null) && ((character != null ? character.index : void 0) != null)) {
            duration = GameManager.defaults.character.expressionDuration;
            easing = gs.Easings.fromObject(GameManager.defaults.character.changeEasing);
            animation = GameManager.defaults.character.changeAnimation;
            object = SceneManager.scene.characters.first(function(c) {
              return c.rid === character.index;
            });
            if (object != null) {
              object.behavior.changeExpression(expression, animation, easing, duration);
            }
          }
          break;
        case "SP":
          sound = RecordManager.system.sounds[token.value - 1];
          AudioManager.playSound(sound);
          break;
        case "S":
          GameManager.settings.messageSpeed = token.value;
          break;
        case "W":
          this.drawImmediately = false;
          if (!GameManager.tempSettings.skip) {
            if (token.value === "A") {
              this.waitForKey = true;
            } else {
              this.waitCounter = Math.round(token.value / 1000 * Graphics.frameRate);
            }
          }
          break;
        case "WE":
          this.waitAtEnd = token.value === "Y";
          break;
        case "DI":
          this.drawImmediately = token.value === 1 || token.value === "Y";
          break;
        default:
          result = Component_MessageTextRenderer.__super__.processControlToken.call(this, token);
      }
      return result;
    };


    /**
    * Clears/Resets the text-renderer.
    *
    * @method clear
     */

    Component_MessageTextRenderer.prototype.clear = function() {
      var j, len, ref, ref1, ref2, sprite;
      this.charIndex = 0;
      this.currentX = 0;
      this.currentY = 0;
      this.line = 0;
      this.lines = [];
      this.clearCustomObjects();
      if ((ref = this.object.bitmap) != null) {
        ref.clear();
      }
      ref1 = this.allSprites;
      for (j = 0, len = ref1.length; j < len; j++) {
        sprite = ref1[j];
        sprite.dispose();
        if ((ref2 = sprite.bitmap) != null) {
          ref2.dispose();
        }
      }
      this.allSprites = [];
      return null;
    };


    /**
    * Clears/Disposes all sprites used to display the text-lines/parts.
    *
    * @method clearAllSprites
     */

    Component_MessageTextRenderer.prototype.clearAllSprites = function() {
      var j, len, ref, ref1, sprite;
      ref = this.allSprites;
      for (j = 0, len = ref.length; j < len; j++) {
        sprite = ref[j];
        sprite.dispose();
        if ((ref1 = sprite.bitmap) != null) {
          ref1.dispose();
        }
      }
      return null;
    };


    /**
    * Clears/Disposes the sprites used to display the text-lines/parts of the current/last message.
    *
    * @method clearSprites
     */

    Component_MessageTextRenderer.prototype.clearSprites = function() {
      var j, len, ref, ref1, sprite;
      ref = this.sprites;
      for (j = 0, len = ref.length; j < len; j++) {
        sprite = ref[j];
        sprite.dispose();
        if ((ref1 = sprite.bitmap) != null) {
          ref1.dispose();
        }
      }
      return null;
    };


    /**
    * Removes a game object from the message.
    *
    * @method removeCustomObject
    * @param object {gs.Object_Base} The game object to remove.
     */

    Component_MessageTextRenderer.prototype.removeCustomObject = function(object) {
      SceneManager.scene.removeObject(object);
      object.dispose();
      return this.customObjects.remove(object);
    };


    /**
    * Adds a game object to the message which is alive until the message is
    * erased. Can be used to display animationed-icons, etc. in a message.
    *
    * @method addCustomObject
    * @param object {gs.Object_Base} The game object to add.
     */

    Component_MessageTextRenderer.prototype.addCustomObject = function(object) {
      object.dstRect.x = this.object.dstRect.x + this.object.origin.x + this.currentX;
      object.dstRect.y = this.object.dstRect.y + this.object.origin.y + this.currentY;
      object.zIndex = this.object.zIndex + 1;
      object.update();
      SceneManager.scene.addObject(object);
      return this.customObjects.push(object);
    };


    /**
    * Clears the list of custom game objects. All game objects are disposed and removed
    * from the scene.
    *
    * @method clearCustomObjects
    * @param object {Object} The game object to add.
     */

    Component_MessageTextRenderer.prototype.clearCustomObjects = function() {
      var j, len, object, ref;
      ref = this.customObjects;
      for (j = 0, len = ref.length; j < len; j++) {
        object = ref[j];
        object.dispose();
        SceneManager.scene.removeObject(object);
      }
      return this.customObjects = [];
    };


    /**
    * Creates the bitmap for a specified line-object.
    *
    * @method createBitmap
    * @private
    * @param {Object} line - A line-object.
    * @return {Bitmap} A newly created bitmap containing the line-text.
     */

    Component_MessageTextRenderer.prototype.createBitmap = function(line) {
      var bitmap;
      this.font = this.object.font;
      bitmap = new Bitmap(this.object.dstRect.width, Math.max(this.minLineHeight, line.height));
      bitmap.font = this.font;
      return bitmap;
    };


    /**
    * Draws the line's content on the specified bitmap.
    *
    * @method drawLineContent
    * @protected
    * @param {Object} line - A line-object which should be drawn on the bitmap.
    * @param {gs.Bitmap} bitmap - The bitmap to draw the line's content on.
    * @param {number} length - Determines how many characters of the specified line should be drawn. You can
    * specify -1 to draw all characters.
     */

    Component_MessageTextRenderer.prototype.drawLineContent = function(line, bitmap, length) {
      var currentX, drawAll, i, j, len, ref, size, token, value;
      bitmap.clear();
      currentX = this.padding;
      drawAll = length === -1;
      ref = line.content;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        token = ref[i];
        if (i > this.tokenIndex && !drawAll) {
          break;
        }
        if (token.code != null) {
          size = this.measureControlToken(token, bitmap);
          this.drawControlToken(token, bitmap, currentX);
          if (size) {
            currentX += size.width;
          }
          this.processControlToken(token, true, line);
        } else if (token.value.length > 0) {
          token.applyFormat(this.font);
          value = token.value;
          if (!drawAll && this.tokenIndex === i && value.length > length) {
            value = value.substring(0, length);
          }
          if (value !== "\n") {
            size = this.font.measureTextPlain(value);
            bitmap.drawText(currentX, line.height - (size.height - this.font.descent) - line.descent, size.width, bitmap.height, value, 0, 0);
            currentX += size.width;
          }
        }
      }
      return line.contentWidth = currentX + this.font.measureTextPlain(" ").width;
    };


    /**
    * Creates the sprite for a specified line-object.
    *
    * @method createSprite
    * @private
    * @param {Object} line - A line-object.
    * @return {Sprite} A newly created sprite object containing the line-text as bitmap.
     */

    Component_MessageTextRenderer.prototype.createSprite = function(line) {
      var bitmap, sprite;
      bitmap = this.createBitmap(line);
      this.currentX = 0;
      this.waitCounter = 0;
      this.waitForKey = false;
      sprite = new Sprite(Graphics.viewport);
      sprite.bitmap = bitmap;
      sprite.visible = true;
      sprite.z = this.object.zIndex + 1;
      sprite.srcRect = new Rect(0, 0, 0, bitmap.height);
      return sprite;
    };


    /**
    * Creates the sprites for a specified array of line-objects.
    *
    * @method createSprites
    * @private
    * @see gs.Component_MessageTextRenderer.createSprite.
    * @param {Array} lines - An array of line-objects.
    * @return {Array} An array of sprites.
     */

    Component_MessageTextRenderer.prototype.createSprites = function(lines) {
      var i, j, len, line, result, sprite;
      this.fontSize = this.object.font.size;
      result = [];
      for (i = j = 0, len = lines.length; j < len; i = ++j) {
        line = lines[i];
        sprite = this.createSprite(line);
        result.push(sprite);
      }
      return result;
    };


    /**
    * Starts a new line.
    *
    * @method newLine
     */

    Component_MessageTextRenderer.prototype.newLine = function() {
      this.currentX = 0;
      return this.currentY += this.currentLineHeight + this.lineSpacing;
    };


    /**
    * Displays a formatted text immediately without any delays or animations. The
    * Component_TextRenderer.drawFormattedText method from the base-class cannot
    * be used here because it would render to the game object's bitmap object while
    * this method is rendering to the sprites.
    *
    * @method drawFormattedTextImmediately
    * @param {number} x - The x-coordinate of the text's position.
    * @param {number} y - The y-coordinate of the text's position.
    * @param {number} width - Deprecated. Can be null.
    * @param {number} height - Deprecated. Can be null.
    * @param {string} text - The text to draw.
    * @param {boolean} wordWrap - If wordWrap is set to true, line-breaks are automatically created.
     */

    Component_MessageTextRenderer.prototype.drawFormattedTextImmediately = function(x, y, width, height, text, wordWrap) {
      this.drawFormattedText(x, y, width, height, text, wordWrap);
      while (true) {
        this.nextChar();
        if (this.line >= this.maxLines) {
          this.isRunning = false;
        } else {
          this.drawNext();
        }
        if (!this.isRunning) {
          break;
        }
      }
      this.currentY += this.currentLineHeight + this.lineSpacing;
      return null;
    };


    /**
    * Starts the rendering-process for the message.
    *
    * @method drawFormattedText
    * @param {number} x - The x-coordinate of the text's position.
    * @param {number} y - The y-coordinate of the text's position.
    * @param {number} width - Deprecated. Can be null.
    * @param {number} height - Deprecated. Can be null.
    * @param {string} text - The text to draw.
    * @param {boolean} wordWrap - If wordWrap is set to true, line-breaks are automatically created.
     */

    Component_MessageTextRenderer.prototype.drawFormattedText = function(x, y, width, height, text, wordWrap) {
      var currentX, ref;
      text = text || " ";
      this.font.set(this.object.font);
      this.speed = 11 - Math.round(GameManager.settings.messageSpeed * 2.5);
      this.isRunning = true;
      this.drawImmediately = false;
      this.lineAnimationCount = this.speed;
      this.currentLineHeight = 0;
      this.isWaiting = false;
      this.waitForKey = false;
      this.charIndex = 0;
      this.token = null;
      this.tokenIndex = 0;
      this.message = text;
      this.line = 0;
      this.currentLine = this.line;
      currentX = this.currentX;
      this.lines = this.calculateLines(lcsm(this.message), wordWrap, this.currentX);
      this.sprites = this.createSprites(this.lines);
      this.allSprites = this.allSprites.concat(this.sprites);
      this.currentX = currentX;
      this.currentSprite = this.sprites[this.line];
      this.currentSprite.x = this.currentX + this.object.origin.x + this.object.dstRect.x;
      this.maxLines = this.calculateMaxLines(this.lines);
      this.token = ((ref = this.lines[this.line]) != null ? ref.content[this.tokenIndex] : void 0) || new gs.RendererToken(null, "");
      return this.start();
    };


    /**
    * Starts the message-rendering process.
    *
    * @method start
    * @protected
     */

    Component_MessageTextRenderer.prototype.start = function() {
      var ref;
      if (GameManager.tempSettings.skip && GameManager.tempSettings.skipTime === 0) {
        return this.instantSkip();
      } else if (this.maxLines === 0) {
        if (((ref = this.lines[0]) != null ? ref.content : void 0) === "") {
          return this.finish();
        } else {
          this.maxLines = 1;
          return this.drawNext();
        }
      } else {
        return this.drawNext();
      }
    };


    /**
    * Skips the current message and finishes the message-processing immediately. The message
    * tokens are processed but not rendered.
    *
    * @method instantSkip
     */

    Component_MessageTextRenderer.prototype.instantSkip = function() {
      var ref;
      while (true) {
        if (this.line < this.maxLines) {
          this.nextChar();
        }
        if (this.line >= this.maxLines) {
          break;
        } else {
          this.processToken();
        }
        if (!(this.isRunning && this.line < this.maxLines)) {
          break;
        }
      }
      if ((ref = this.object.events) != null) {
        ref.emit("messageWaiting", this);
      }
      return this["continue"]();
    };


    /**
    * Processes the current token.
    *
    * @method processToken
     */

    Component_MessageTextRenderer.prototype.processToken = function() {
      var base, token;
      token = null;
      if (this.token.code != null) {
        token = this.processControlToken(this.token, false);
        if (token != null) {
          this.token = token;
          if (typeof (base = this.token).onStart === "function") {
            base.onStart();
          }
        }
      } else {
        token = this.token;
      }
      return token;
    };

    return Component_MessageTextRenderer;

  })(gs.Component_TextRenderer);

  gs.Component_MessageTextRenderer = Component_MessageTextRenderer;

}).call(this);
