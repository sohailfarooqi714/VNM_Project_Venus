// Generated by CoffeeScript 1.12.7
(function() {
  var Component_Viewport,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Component_Viewport = (function(superClass) {
    extend(Component_Viewport, superClass);


    /**
    * A viewport component can contain multiple graphic objects and will automatically 
    * clip them if they move out of the viewport-rectangle. The area of a viewport
    * can also be tinted or colored. So to tint the whole for example, it enough
    * to create a viewport taking the whole screen-space and then setting the
    * tone or color property.
    *
    * @module gs
    * @class Component_Viewport
    * @extends gs.Component_Visual
    * @memberof gs
    * @constructor
    * @param {Viewport} [viewport=null] - A native viewport object used by the component. If null, the component create a new one.
     */

    function Component_Viewport(viewport) {
      Component_Viewport.__super__.constructor.call(this);

      /**
      * The native viewport-object.
      * @property viewport
      * @type gs.Viewport
      * @protected
       */
      this.viewport = viewport;

      /**
      * The visibility. If <b>false</b> the viewport and associated graphic objects are not rendered.
      * @property viewport
      * @type gs.Viewport
      * @protected
       */
      this.visible = true;
      this.scroll = new gs.Point(0, 0);
    }


    /**
    * Sets up the viewport.
    * @method setup
     */

    Component_Viewport.prototype.setup = function() {
      if (!this.viewport) {
        this.viewport = new gs.Viewport(0, 0, Graphics.width, Graphics.height);
      }
      return this.isSetup = true;
    };


    /**
    * Disposes the viewport and all associated graphic objects.
    * @method dispose
     */

    Component_Viewport.prototype.dispose = function() {
      return this.viewport.dispose();
    };


    /**
    * Updates the origin-point of the game object.
    * @method updateOrigin
     */

    Component_Viewport.prototype.updateOrigin = function() {};


    /**
    * Updates the padding.
    * @method updatePadding
     */

    Component_Viewport.prototype.updatePadding = function() {
      if (this.object.padding != null) {
        this.viewport.rect.x += this.object.padding.left;
        this.viewport.rect.y += this.object.padding.top;
        this.viewport.rect.width -= this.object.padding.left + this.object.padding.right;
        return this.viewport.rect.height -= this.object.padding.bottom + this.object.padding.bottom;
      }
    };


    /**
    * Updates the sprite properties from the game object properties.
    * @method update
     */

    Component_Viewport.prototype.updateProperties = function() {
      this.viewport.rect.x = this.object.dstRect.x;
      this.viewport.rect.y = this.object.dstRect.y;
      this.viewport.rect.width = this.object.dstRect.width;
      this.viewport.rect.height = this.object.dstRect.height;
      this.viewport.ox = this.scroll.x + this.object.offset.x;
      this.viewport.oy = this.scroll.y + this.object.offset.y;
      this.viewport.anchor.x = this.object.anchor.x;
      this.viewport.anchor.y = this.object.anchor.y;
      this.viewport.zoomX = this.object.zoom.x;
      this.viewport.zoomY = this.object.zoom.y;
      this.viewport.angle = this.object.angle;
      return this.viewport.z = (this.object.zIndex || 0) + (!this.object.parent ? 0 : this.object.parent.zIndex || 0);
    };


    /**
    * Updates the optional sprite properties from the game object properties.
    * @method updateOptionalProperties
     */

    Component_Viewport.prototype.updateOptionalProperties = function() {
      var ref, ref1;
      if (this.object.tone != null) {
        this.viewport.tone = this.object.tone;
      }
      if (this.object.color != null) {
        this.viewport.color = this.object.color;
      }
      if (this.object.effects != null) {
        this.viewport.effects = this.object.effects;
      }
      if (((ref = this.object.parent) != null ? ref.visible_ : void 0) != null) {
        return this.viewport.visible = this.object.visible;
      } else if (((ref1 = this.object.parent) != null ? ref1.visible : void 0) != null) {
        return this.viewport.visible = this.object.visible;
      } else {
        return this.viewport.visible = this.object.visible;
      }
    };


    /**
    * Updates the viewport.
    * @method update
     */

    Component_Viewport.prototype.update = function() {
      Component_Viewport.__super__.update.apply(this, arguments);
      if (!this.isSetup) {
        this.setup();
      }
      this.viewport.update();
      this.updatePadding();
      this.updateProperties();
      return this.updateOptionalProperties();
    };

    return Component_Viewport;

  })(gs.Component_Visual);

  gs.Component_Viewport = Component_Viewport;

}).call(this);
