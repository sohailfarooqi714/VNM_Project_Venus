// Generated by CoffeeScript 1.12.7
(function() {
  var Component_HotspotBehavior, HotspotShape,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  HotspotShape = (function() {
    function HotspotShape() {}

    HotspotShape.RECTANGLE = "rect";

    HotspotShape.PIXEL = "pixel";

    return HotspotShape;

  })();

  gs.HotspotShape = HotspotShape;

  Component_HotspotBehavior = (function(superClass) {
    extend(Component_HotspotBehavior, superClass);


    /**
    * Called if this object instance is restored from a data-bundle. It can be used
    * re-assign event-handler, anonymous functions, etc.
    *
    * @method onDataBundleRestore.
    * @param Object data - The data-bundle
    * @param gs.ObjectCodecContext context - The codec-context.
     */

    Component_HotspotBehavior.prototype.onDataBundleRestore = function(data, context) {
      return this.setupEventHandlers();
    };


    /**
    * Adds a hotspot-behavior to a game object. That allows a game object
    * to respond to mouse/touch actions by firing an action-event or changing
    * the game object's image.
    *
    * @module gs
    * @class Component_HotspotBehavior
    * @extends gs.Component
    * @memberof gs
    * @constructor
     */

    function Component_HotspotBehavior(params) {

      /**
      * The shape used to detect if a hotspot is clicked, hovered, etc.
      * @property shape
      * @type boolean
       */
      var ref;
      this.shape = gs.HotspotShape.RECTANGLE;

      /**
      * Indicates if the hotspot is selected.
      * @property selected
      * @type boolean
       */
      this.selected = false;

      /**
      * Indicates if the hotspot is enabled.
      * @property enabled
      * @type boolean
       */
      this.enabled = true;

      /**
      * @property imageHandling
      * @type number
      * @protected
       */
      this.imageHandling = 0;

      /**
      * Indicates if the mouse/touch pointer is inside the hotspot bounds.
      * @property contains
      * @type boolean
      * @protected
       */
      this.containsPointer = false;

      /**
      * Indicates if the action-button was pressed before.
      * @property buttonUp
      * @type boolean
      * @protected
       */
      this.buttonUp = false;

      /**
      * Indicates if the action-button is pressed.
      * @property buttonDown
      * @type boolean
      * @protected
       */
      this.buttonDown = false;

      /**
      * @property actionButtons
      * @type Object
      * @protected
       */
      this.actionButtons = {
        "left": Input.Mouse.BUTTON_LEFT,
        "right": Input.Mouse.BUTTON_RIGHT,
        "middle": Input.Mouse.BUTTON_MIDDLE
      };

      /**
      * The default action-button. By default the left-button is used.
      *
      * @property actionButton
      * @type number
       */
      this.actionButton = this.actionButtons[(ref = params != null ? params.actionButton : void 0) != null ? ref : "left"];

      /**
      * The sound played if the hotspot action is executed.
      * @property sound
      * @type Object
       */
      this.sound = params != null ? params.sound : void 0;

      /**
      * <p>The sounds played depending on the hotspot state.</p>
      * <ul>
      * <li>0 = Select Sound</li>
      * <li>1 = Unselect Sound</li>
      * </ul>
      * @property sounds
      * @type Object[]
       */
      this.sounds = (params != null ? params.sounds : void 0) || [];
    }


    /**
    * Gets the render-index of the object associated with the hotspot component. This
    * implementation is necessary to be able to act as an owner for gs.EventEmitter.on
    * event registration.
    *
    * @property rIndex
    * @type number
     */

    Component_HotspotBehavior.accessors("rIndex", {
      get: function() {
        return this.object.rIndex;
      }
    });


    /**
    * Sets up event handlers.
    *
    * @method setupEventHandlers
     */

    Component_HotspotBehavior.prototype.setupEventHandlers = function() {
      gs.GlobalEventManager.offByOwner("mouseUp", this);
      gs.GlobalEventManager.offByOwner("mouseMoved", this);
      gs.GlobalEventManager.on("hotspotDrop", ((function(_this) {
        return function(e) {
          var hotspot, j, len, rect, ref, results, scene;
          scene = SceneManager.scene;
          ref = scene.hotspots;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            hotspot = ref[j];
            rect = e.sender.dstRect;
            if ((hotspot != null) && hotspot !== e.sender && hotspot.dstRect.intersect(rect.x, rect.y, rect.width, rect.height)) {
              results.push(hotspot.events.emit("dropReceived", hotspot));
            } else {
              results.push(void 0);
            }
          }
          return results;
        };
      })(this)), null, this);
      gs.GlobalEventManager.on("mouseUp", ((function(_this) {
        return function(e) {
          var contains, mx, my;
          if (!_this.object.visible) {
            return;
          }
          mx = Input.Mouse.x - _this.object.origin.x;
          my = Input.Mouse.y - _this.object.origin.y;
          contains = Rect.contains(_this.object.dstRect.x, _this.object.dstRect.y, _this.object.dstRect.width, _this.object.dstRect.height, mx, my);
          if (contains) {
            contains = _this.checkShape(mx - _this.object.dstRect.x, my - _this.object.dstRect.y);
            if (contains) {
              _this.containsPointer = contains;
              _this.updateInput();
              _this.updateEvents();
              _this.object.needsUpdate = true;
              return e.breakChain = true;
            }
          }
        };
      })(this)), null, this);
      if (this.object.images || true) {
        return gs.GlobalEventManager.on("mouseMoved", ((function(_this) {
          return function(e) {
            var contains, mx, my;
            if (!_this.object.visible) {
              return;
            }
            contains = Rect.contains(_this.object.dstRect.x, _this.object.dstRect.y, _this.object.dstRect.width, _this.object.dstRect.height, Input.Mouse.x - _this.object.origin.x, Input.Mouse.y - _this.object.origin.y);
            if (contains) {
              mx = Input.Mouse.x - _this.object.origin.x;
              my = Input.Mouse.y - _this.object.origin.y;
              contains = _this.checkShape(mx - _this.object.dstRect.x, my - _this.object.dstRect.y);
            }
            if (_this.containsPointer !== contains) {
              _this.containsPointer = contains;
              _this.object.needsUpdate = true;
              if (contains) {
                _this.object.events.emit("enter", _this);
              } else {
                _this.object.events.emit("leave", _this);
              }
            }
            return _this.updateInput();
          };
        })(this)), null, this);
      }
    };


    /**
    * Initializes the hotspot component.
    *
    * @method setup
     */

    Component_HotspotBehavior.prototype.setup = function() {
      var i, j, len, ref, sound;
      Component_HotspotBehavior.__super__.setup.apply(this, arguments);
      this.sound = ui.Component_FormulaHandler.fieldValue(this.object, this.sound);
      if (this.sounds != null) {
        ref = this.sounds;
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          sound = ref[i];
          this.sounds[i] = ui.Component_FormulaHandler.fieldValue(this.object, sound);
        }
      } else {
        this.sounds = [];
      }
      return this.setupEventHandlers();
    };


    /**
    * Disposes the component.
    *
    * @method dispose
     */

    Component_HotspotBehavior.prototype.dispose = function() {
      Component_HotspotBehavior.__super__.dispose.apply(this, arguments);
      gs.GlobalEventManager.offByOwner("mouseUp", this);
      return gs.GlobalEventManager.offByOwner("mouseMoved", this);
    };


    /**
    * Checks if the specified point is inside of the hotspot's shape.
    *
    * @method checkShape
    * @param x - The x-coordinate of the point.
    * @param y - The y-coordinate of the point.
    * @return If <b>true</b> the point is inside of the hotspot's shape. Otherwise <b>false</b>.
     */

    Component_HotspotBehavior.prototype.checkShape = function(x, y) {
      var ref, result;
      result = true;
      switch (this.shape) {
        case gs.HotspotShape.PIXEL:
          if (this.object.bitmap) {
            result = this.object.bitmap.isPixelSet(x, y);
          } else {
            result = (ref = this.object.target) != null ? ref.bitmap.isPixelSet(x, y) : void 0;
          }
      }
      return result;
    };


    /**
    * Updates the image depending on the hotspot state.
    *
    * @method updateImage
    * @protected
     */

    Component_HotspotBehavior.prototype.updateImage = function() {
      var baseImage, object;
      object = this.object.target || this.object;
      if (this.object.images != null) {
        baseImage = this.enabled ? this.object.images[4] || this.object.images[0] : this.object.images[0];
        if (this.containsPointer) {
          if (this.object.selected || this.selected) {
            object.image = this.object.images[3] || this.object.images[2] || baseImage;
          } else {
            object.image = this.object.images[1] || baseImage;
          }
        } else {
          if (this.object.selected || this.selected) {
            object.image = this.object.images[2] || this.object.images[4] || baseImage;
          } else {
            object.image = baseImage;
          }
        }
        if (!object.image) {
          return object.bitmap = null;
        }
      }
    };


    /**
    * Updates the hotspot position and size from an other target game object. For example,
    * that is useful for adding a hotspot to an other moving game object.
    *
    * @method updateFromTarget
    * @protected
     */

    Component_HotspotBehavior.prototype.updateFromTarget = function() {
      if (this.object.target != null) {
        this.object.dstRect.x = this.object.target.dstRect.x;
        this.object.dstRect.y = this.object.target.dstRect.y;
        this.object.dstRect.width = this.object.target.dstRect.width;
        this.object.dstRect.height = this.object.target.dstRect.height;
        this.object.offset.x = this.object.target.offset.x;
        this.object.offset.y = this.object.target.offset.y;
        this.object.origin.x = this.object.target.origin.x;
        return this.object.origin.y = this.object.target.origin.y;
      }
    };


    /**
    * Updates the event-handling and fires necessary events.
    *
    * @method updateEvents
    * @protected
     */

    Component_HotspotBehavior.prototype.updateEvents = function() {
      var group, j, len, object;
      if (this.buttonUp && this.object.enabled && this.enabled && this.object.visible) {
        if (this.object.selectable) {
          group = gs.ObjectManager.current.objectsByGroup(this.object.group);
          for (j = 0, len = group.length; j < len; j++) {
            object = group[j];
            if (object !== this.object) {
              object.selected = false;
            }
          }
          if (this.object.group) {
            this.selected = true;
          } else {
            this.selected = !this.selected;
          }
          if (this.selected) {
            AudioManager.playSound(this.sounds[0] || this.sound);
          } else {
            AudioManager.playSound(this.sounds[1] || this.sound);
          }
          this.object.events.emit("click", this);
          return this.object.events.emit("stateChanged", this.object);
        } else {
          AudioManager.playSound(this.sounds[0] || this.sound);
          this.object.events.emit("click", this);
          return this.object.events.emit("action", this);
        }
      }
    };


    /**
    * Updates the game object's color depending on the state of the hotspot.
    *
    * @method updateColor
    * @protected
     */

    Component_HotspotBehavior.prototype.updateColor = function() {
      if (!this.object.enabled) {
        return this.object.color.set(0, 0, 0, 100);
      } else {
        return this.object.color.set(0, 0, 0, 0);
      }
    };


    /**
    * Stores current states of mouse/touch pointer and buttons.
    *
    * @method updateInput
    * @protected
     */

    Component_HotspotBehavior.prototype.updateInput = function() {
      this.buttonUp = Input.Mouse.buttons[this.actionButton] === 2 && this.containsPointer;
      return this.buttonDown = Input.Mouse.buttons[this.actionButton] === 1 && this.containsPointer;
    };


    /**
    * Updates the hotspot component.
    *
    * @method update
     */

    Component_HotspotBehavior.prototype.update = function() {
      if (!this.object.visible) {
        return;
      }
      this.updateColor();
      this.updateFromTarget();
      return this.updateImage();
    };

    return Component_HotspotBehavior;

  })(gs.Component);

  gs.Component_HotspotBehavior = Component_HotspotBehavior;

}).call(this);
