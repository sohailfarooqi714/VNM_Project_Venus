// Generated by CoffeeScript 1.12.7
(function() {
  var Component_GameSceneBehavior,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Component_GameSceneBehavior = (function(superClass) {
    extend(Component_GameSceneBehavior, superClass);


    /**
    * Defines the behavior of visual novel game scene.
    *
    * @module vn
    * @class Component_GameSceneBehavior
    * @extends gs.Component_LayoutSceneBehavior
    * @memberof vn
     */

    function Component_GameSceneBehavior() {
      Component_GameSceneBehavior.__super__.constructor.call(this);
      this.onAutoCommonEventStart = (function(_this) {
        return function() {
          _this.object.removeComponent(_this.object.interpreter);
          return _this.object.interpreter.stop();
        };
      })(this);
      this.onAutoCommonEventFinish = (function(_this) {
        return function() {
          if (!_this.object.components.contains(_this.object.interpreter)) {
            _this.object.addComponent(_this.object.interpreter);
          }
          return _this.object.interpreter.resume();
        };
      })(this);
      this.resourceContext = null;
      this.objectDomain = "";
    }


    /**
    * Initializes the scene.
    *
    * @method initialize
     */

    Component_GameSceneBehavior.prototype.initialize = function() {
      var ref, saveGame, sceneUid, sprite;
      if (SceneManager.previousScenes.length === 0) {
        gs.GlobalEventManager.clearExcept(this.object.commonEventContainer.subObjects);
      }
      this.resourceContext = ResourceManager.createContext();
      ResourceManager.context = this.resourceContext;
      Graphics.freeze();
      saveGame = GameManager.loadedSaveGame;
      sceneUid = null;
      if (saveGame) {
        sceneUid = saveGame.sceneUid;
        this.object.sceneData = saveGame.data;
      } else {
        sceneUid = ((ref = $PARAMS.preview) != null ? ref.scene.uid : void 0) || this.object.sceneData.uid || RecordManager.system.startInfo.scene.uid;
      }
      this.object.sceneDocument = DataManager.getDocument(sceneUid);
      if (this.object.sceneDocument && this.object.sceneDocument.items.type === "vn.scene") {
        this.object.chapter = DataManager.getDocument(this.object.sceneDocument.items.chapterUid);
        this.object.currentCharacter = {
          "name": ""
        };
        if (!GameManager.initialized) {
          GameManager.initialize();
        }
        GameManager.preloadCommonEvents();
        LanguageManager.loadBundles();
      } else {
        sprite = new gs.Sprite();
        sprite.bitmap = new gs.Bitmap(Graphics.width, 50);
        sprite.bitmap.drawText(0, 0, Graphics.width, 50, "No Start Scene selected", 1, 0);
        sprite.srcRect = new gs.Rect(0, 0, Graphics.width, 50);
        sprite.y = (Graphics.height - 50) / 2;
        sprite.z = 10000;
      }
      return this.setupScreen();
    };


    /**
    * Disposes the scene.
    *
    * @method dispose
     */

    Component_GameSceneBehavior.prototype.dispose = function() {
      var event, j, len, ref;
      ResourceManager.context = this.resourceContext;
      this.object.removeObject(this.object.commonEventContainer);
      this.show(false);
      ref = GameManager.commonEvents;
      for (j = 0, len = ref.length; j < len; j++) {
        event = ref[j];
        if (event) {
          event.events.offByOwner("start", this.object);
          event.events.offByOwner("finish", this.object);
        }
      }
      if (this.object.video) {
        this.object.video.dispose();
        this.object.video.onEnded();
      }
      return Component_GameSceneBehavior.__super__.dispose.call(this);
    };

    Component_GameSceneBehavior.prototype.changePictureDomain = function(domain) {
      this.object.pictureContainer.behavior.changeDomain(domain);
      return this.object.pictures = this.object.pictureContainer.subObjects;
    };

    Component_GameSceneBehavior.prototype.changeTextDomain = function(domain) {
      this.object.textContainer.behavior.changeDomain(domain);
      return this.object.texts = this.object.textContainer.subObjects;
    };

    Component_GameSceneBehavior.prototype.changeVideoDomain = function(domain) {
      this.object.videoContainer.behavior.changeDomain(domain);
      return this.object.videos = this.object.videoContainer.subObjects;
    };

    Component_GameSceneBehavior.prototype.changeHotspotDomain = function(domain) {
      this.object.hotspotContainer.behavior.changeDomain(domain);
      return this.object.hotspots = this.object.hotspotContainer.subObjects;
    };

    Component_GameSceneBehavior.prototype.changeMessageAreaDomain = function(domain) {
      this.object.messageAreaContainer.behavior.changeDomain(domain);
      return this.object.messageAreas = this.object.messageAreaContainer.subObjects;
    };


    /**
    * Shows/Hides the current scene. A hidden scene is no longer shown and executed
    * but all objects and data is still there and be shown again anytime.
    *
    * @method show
    * @param {boolean} visible - Indicates if the scene should be shown or hidden.
     */

    Component_GameSceneBehavior.prototype.show = function(visible) {
      var ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7;
      if (visible) {
        this.object.viewport = GameManager.sceneViewport;
      }
      window.$dataFields = this.dataFields;
      this.object.visible = visible;
      if ((ref = this.object.layout) != null) {
        ref.update();
      }
      this.object.pictureContainer.behavior.setVisible(visible);
      this.object.hotspotContainer.behavior.setVisible(visible);
      this.object.textContainer.behavior.setVisible(visible);
      this.object.videoContainer.behavior.setVisible(visible);
      this.object.messageAreaContainer.behavior.setVisible(visible);
      this.object.viewportContainer.behavior.setVisible(visible);
      this.object.characterContainer.behavior.setVisible(visible);
      this.object.backgroundContainer.behavior.setVisible(visible);
      if ((ref1 = this.viewport) != null) {
        ref1.visible = visible;
      }
      if ((ref2 = this.object.choiceWindow) != null) {
        ref2.visible = visible;
      }
      if ((ref3 = this.object.inputNumberBox) != null) {
        ref3.visible = visible;
      }
      if ((ref4 = this.object.inputTextBox) != null) {
        ref4.visible = visible;
      }
      if ((ref5 = this.object.inputTextBox) != null) {
        ref5.update();
      }
      if ((ref6 = this.object.inputNumberBox) != null) {
        ref6.update();
      }
      if ((ref7 = this.object.choiceWindow) != null) {
        ref7.update();
      }
      GameManager.tempSettings.skip = false;
      return this.setupCommonEvents();
    };


    /**
    * Sets up common event handling.
    *
    * @method setupCommonEvents
     */

    Component_GameSceneBehavior.prototype.setupCommonEvents = function() {
      var commonEvents, event, i, j, k, len, len1, ref, ref1, ref2, ref3;
      commonEvents = (ref = this.object.sceneData) != null ? ref.commonEvents : void 0;
      if (commonEvents) {
        for (i = j = 0, len = commonEvents.length; j < len; i = ++j) {
          event = commonEvents[i];
          if (event && this.object.commonEventContainer.subObjects.indexOf(event) === -1) {
            this.object.commonEventContainer.setObject(event, i);
            event.behavior.setupEventHandlers();
            if ((ref1 = event.interpreter) != null ? ref1.isRunning : void 0) {
              event.events.emit("start", event);
            }
          }
        }
      } else {
        ref2 = GameManager.commonEvents;
        for (i = k = 0, len1 = ref2.length; k < len1; i = ++k) {
          event = ref2[i];
          if (event && (event.record.startCondition === 1 || event.record.parallel) && this.object.commonEventContainer.subObjects.indexOf(event) === -1) {
            this.object.commonEventContainer.setObject(event, i);
            event.events.offByOwner("start", this.object);
            event.events.offByOwner("finish", this.object);
            if (!event.record.parallel) {
              event.events.on("start", gs.CallBack("onAutoCommonEventStart", this), null, this.object);
              event.events.on("finish", gs.CallBack("onAutoCommonEventFinish", this), null, this.object);
            }
            if ((ref3 = event.interpreter) != null ? ref3.isRunning : void 0) {
              event.events.emit("start", event);
            }
          }
        }
      }
      return null;
    };


    /**
    * Sets up main interpreter.
    *
    * @method setupInterpreter
    * @protected
     */

    Component_GameSceneBehavior.prototype.setupInterpreter = function() {
      this.object.commands = this.object.sceneDocument.items.commands;
      if (this.object.sceneData.interpreter) {
        this.object.removeComponent(this.object.interpreter);
        this.object.interpreter = this.object.sceneData.interpreter;
        this.object.addComponent(this.object.interpreter);
        this.object.interpreter.context.set(this.object.sceneDocument.uid, this.object);
        return this.object.interpreter.object = this.object;
      } else {
        this.object.interpreter.setup();
        this.object.interpreter.context.set(this.object.sceneDocument.uid, this.object);
        return this.object.interpreter.start();
      }
    };


    /**
    * Sets up characters and restores them from loaded save game if necessary.
    *
    * @method setupCharacters
    * @protected
     */

    Component_GameSceneBehavior.prototype.setupCharacters = function() {
      var c, i, j, len, ref;
      if (this.object.sceneData.characters != null) {
        ref = this.object.sceneData.characters;
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          c = ref[i];
          this.object.characterContainer.setObject(c, i);
        }
      }
      return this.object.currentCharacter = this.object.sceneData.currentCharacter || {
        name: ""
      };
    };


    /**
    * Sets up viewports and restores them from loaded save game if necessary.
    *
    * @method setupViewports
    * @protected
     */

    Component_GameSceneBehavior.prototype.setupViewports = function() {
      var i, j, len, ref, ref1, results, viewport, viewports;
      viewports = (ref = (ref1 = this.object.sceneData) != null ? ref1.viewports : void 0) != null ? ref : [];
      results = [];
      for (i = j = 0, len = viewports.length; j < len; i = ++j) {
        viewport = viewports[i];
        if (viewport) {
          results.push(this.object.viewportContainer.setObject(viewport, i));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };


    /**
    * Sets up backgrounds and restores them from loaded save game if necessary.
    *
    * @method setupBackgrounds
    * @protected
     */

    Component_GameSceneBehavior.prototype.setupBackgrounds = function() {
      var b, backgrounds, i, j, len, ref, ref1, results;
      backgrounds = (ref = (ref1 = this.object.sceneData) != null ? ref1.backgrounds : void 0) != null ? ref : [];
      results = [];
      for (i = j = 0, len = backgrounds.length; j < len; i = ++j) {
        b = backgrounds[i];
        results.push(this.object.backgroundContainer.setObject(b, i));
      }
      return results;
    };


    /**
    * Sets up pictures and restores them from loaded save game if necessary.
    *
    * @method setupPictures
    * @protected
     */

    Component_GameSceneBehavior.prototype.setupPictures = function() {
      var domain, i, path, picture, pictures, ref, ref1, results;
      pictures = (ref = (ref1 = this.object.sceneData) != null ? ref1.pictures : void 0) != null ? ref : {};
      results = [];
      for (domain in pictures) {
        this.object.pictureContainer.behavior.changeDomain(domain);
        if (pictures[domain]) {
          results.push((function() {
            var j, len, ref2, results1;
            ref2 = pictures[domain];
            results1 = [];
            for (i = j = 0, len = ref2.length; j < len; i = ++j) {
              picture = ref2[i];
              this.object.pictureContainer.setObject(picture, i);
              if (picture != null ? picture.image : void 0) {
                path = "Graphics/Pictures/" + picture.image;
                results1.push(this.resourceContext.add(path, ResourceManager.resourcesByPath[path]));
              } else {
                results1.push(void 0);
              }
            }
            return results1;
          }).call(this));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };


    /**
    * Sets up texts and restores them from loaded save game if necessary.
    *
    * @method setupTexts
    * @protected
     */

    Component_GameSceneBehavior.prototype.setupTexts = function() {
      var domain, i, ref, ref1, results, text, texts;
      texts = (ref = (ref1 = this.object.sceneData) != null ? ref1.texts : void 0) != null ? ref : {};
      results = [];
      for (domain in texts) {
        this.object.textContainer.behavior.changeDomain(domain);
        if (texts[domain]) {
          results.push((function() {
            var j, len, ref2, results1;
            ref2 = texts[domain];
            results1 = [];
            for (i = j = 0, len = ref2.length; j < len; i = ++j) {
              text = ref2[i];
              results1.push(this.object.textContainer.setObject(text, i));
            }
            return results1;
          }).call(this));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };


    /**
    * Sets up videos and restores them from loaded save game if necessary.
    *
    * @method setupVideos
    * @protected
     */

    Component_GameSceneBehavior.prototype.setupVideos = function() {
      var domain, i, path, ref, ref1, results, video, videos;
      videos = (ref = (ref1 = this.object.sceneData) != null ? ref1.videos : void 0) != null ? ref : {};
      results = [];
      for (domain in videos) {
        this.object.videoContainer.behavior.changeDomain(domain);
        if (videos[domain]) {
          results.push((function() {
            var j, len, ref2, results1;
            ref2 = videos[domain];
            results1 = [];
            for (i = j = 0, len = ref2.length; j < len; i = ++j) {
              video = ref2[i];
              if (video) {
                path = "Movies/" + video.video;
                this.resourceContext.add(path, ResourceManager.resourcesByPath[path]);
                video.visible = true;
                video.update();
              }
              results1.push(this.object.videoContainer.setObject(video, i));
            }
            return results1;
          }).call(this));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };


    /**
    * Sets up hotspots and restores them from loaded save game if necessary.
    *
    * @method setupHotspots
    * @protected
     */

    Component_GameSceneBehavior.prototype.setupHotspots = function() {
      var domain, hotspot, hotspots, i, ref, ref1, results;
      hotspots = (ref = (ref1 = this.object.sceneData) != null ? ref1.hotspots : void 0) != null ? ref : {};
      results = [];
      for (domain in hotspots) {
        this.object.hotspotContainer.behavior.changeDomain(domain);
        if (hotspots[domain]) {
          results.push((function() {
            var j, len, ref2, results1;
            ref2 = hotspots[domain];
            results1 = [];
            for (i = j = 0, len = ref2.length; j < len; i = ++j) {
              hotspot = ref2[i];
              results1.push(this.object.hotspotContainer.setObject(hotspot, i));
            }
            return results1;
          }).call(this));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };


    /**
    * Sets up layout.
    *
    * @method setupLayout
    * @protected
     */

    Component_GameSceneBehavior.prototype.setupLayout = function() {
      var advVisible, ref, ref1;
      this.dataFields = ui.UIManager.dataSources[ui.UiFactory.layouts.gameLayout.dataSource || "default"]();
      this.dataFields.scene = this.object;
      window.$dataFields = this.dataFields;
      advVisible = this.object.messageMode === vn.MessageMode.ADV;
      this.object.layout = ui.UiFactory.createFromDescriptor(ui.UiFactory.layouts.gameLayout, this.object);
      this.object.layout.visible = advVisible;
      $gameMessage_message.visible = advVisible;
      this.object.layout.ui.prepare();
      this.object.choices = ((ref = this.object.sceneData) != null ? ref.choices : void 0) || this.object.choices;
      if (((ref1 = this.object.choices) != null ? ref1.length : void 0) > 0) {
        this.showChoices(gs.CallBack("onChoiceAccept", this.object.interpreter, {
          pointer: this.object.interpreter.pointer,
          params: this.params
        }));
      }
      if (this.object.interpreter.waitingFor.inputNumber) {
        this.showInputNumber(GameManager.tempFields.digits, gs.CallBack("onInputNumberFinish", this.object.interpreter, this.object.interpreter));
      }
      if (this.object.interpreter.waitingFor.inputText) {
        return this.showInputText(GameManager.tempFields.letters, gs.CallBack("onInputTextFinish", this.object.interpreter, this.object.interpreter));
      }
    };


    /**
    * Sets up the main viewport / screen viewport.
    *
    * @method setupMainViewport
    * @protected
     */

    Component_GameSceneBehavior.prototype.setupMainViewport = function() {
      if (!this.object.sceneData.viewport) {
        GameManager.sceneViewport.removeComponent(GameManager.sceneViewport.visual);
        GameManager.sceneViewport.dispose();
        GameManager.sceneViewport = new gs.Object_Viewport(GameManager.sceneViewport.visual.viewport);
        this.viewport = GameManager.sceneViewport.visual.viewport;
        return this.object.viewport = GameManager.sceneViewport;
      } else {
        GameManager.sceneViewport.dispose();
        GameManager.sceneViewport = this.object.sceneData.viewport;
        this.object.viewport = this.object.sceneData.viewport;
        this.viewport = this.object.viewport.visual.viewport;
        return this.viewport.viewport = Graphics.viewport;
      }
    };


    /**
    * Sets up screen.
    *
    * @method setupScreen
    * @protected
     */

    Component_GameSceneBehavior.prototype.setupScreen = function() {
      if (this.object.sceneData.screen) {
        return this.object.viewport.restore(this.object.sceneData.screen);
      }
    };


    /**
    * Restores main interpreter from loaded save game.
    *
    * @method restoreInterpreter
    * @protected
     */

    Component_GameSceneBehavior.prototype.restoreInterpreter = function() {
      if (this.object.sceneData.interpreter) {
        return this.object.interpreter.restore();
      }
    };


    /**
    * Restores message box from loaded save game.
    *
    * @method restoreMessageBox
    * @protected
     */

    Component_GameSceneBehavior.prototype.restoreMessageBox = function() {
      var c, j, k, len, len1, message, messageBox, messageBoxes, messageObject, ref, ref1, results;
      messageBoxes = (ref = this.object.sceneData) != null ? ref.messageBoxes : void 0;
      if (messageBoxes) {
        results = [];
        for (j = 0, len = messageBoxes.length; j < len; j++) {
          messageBox = messageBoxes[j];
          messageObject = gs.ObjectManager.current.objectById(messageBox.id);
          messageObject.visible = messageBox.visible;
          if (messageBox.message) {
            messageBox.message.textRenderer.disposeEventHandlers();
            message = gs.ObjectManager.current.objectById(messageBox.message.id);
            message.textRenderer.dispose();
            Object.mixin(message, messageBox.message, ui.Object_Message.objectCodecBlackList.concat(["origin"]));
            ref1 = message.components;
            for (k = 0, len1 = ref1.length; k < len1; k++) {
              c = ref1[k];
              c.object = message;
            }
            results.push(message.textRenderer.setupEventHandlers());
          } else {
            results.push(void 0);
          }
        }
        return results;
      }
    };


    /**
    * Restores message from loaded save game.
    *
    * @method restoreMessages
    * @protected
     */

    Component_GameSceneBehavior.prototype.restoreMessages = function() {
      var area, c, domain, i, message, messageArea, messageAreas, messageLayout, ref, results;
      if ((ref = this.object.sceneData) != null ? ref.messageAreas : void 0) {
        results = [];
        for (domain in this.object.sceneData.messageAreas) {
          this.object.messageAreaContainer.behavior.changeDomain(domain);
          messageAreas = this.object.sceneData.messageAreas;
          if (messageAreas[domain]) {
            results.push((function() {
              var j, k, len, len1, ref1, ref2, results1;
              ref1 = messageAreas[domain];
              results1 = [];
              for (i = j = 0, len = ref1.length; j < len; i = ++j) {
                area = ref1[i];
                if (area) {
                  messageArea = new gs.Object_MessageArea();
                  messageLayout = ui.UIManager.createControlFromDescriptor({
                    type: "ui.CustomGameMessage",
                    id: "customGameMessage_" + i,
                    params: {
                      id: "customGameMessage_" + i
                    }
                  }, messageArea);
                  message = gs.ObjectManager.current.objectById("customGameMessage_" + i + "_message");
                  area.message.textRenderer.disposeEventHandlers();
                  message.textRenderer.dispose();
                  Object.mixin(message, area.message);
                  ref2 = message.components;
                  for (k = 0, len1 = ref2.length; k < len1; k++) {
                    c = ref2[k];
                    c.object = message;
                  }
                  messageLayout.dstRect.x = area.layout.dstRect.x;
                  messageLayout.dstRect.y = area.layout.dstRect.y;
                  messageLayout.dstRect.width = area.layout.dstRect.width;
                  messageLayout.dstRect.height = area.layout.dstRect.height;
                  messageLayout.needsUpdate = true;
                  message.textRenderer.setupEventHandlers();
                  messageLayout.update();
                  messageArea.message = message;
                  messageArea.layout = messageLayout;
                  messageArea.addObject(messageLayout);
                  results1.push(this.object.messageAreaContainer.setObject(messageArea, i));
                } else {
                  results1.push(void 0);
                }
              }
              return results1;
            }).call(this));
          } else {
            results.push(void 0);
          }
        }
        return results;
      }
    };


    /**
    * Restores audio-playback from loaded save game.
    *
    * @method restoreAudioPlayback
    * @protected
     */

    Component_GameSceneBehavior.prototype.restoreAudioPlayback = function() {
      var b, j, len, ref;
      if (this.object.sceneData.audio) {
        ref = this.object.sceneData.audio.audioBuffers;
        for (j = 0, len = ref.length; j < len; j++) {
          b = ref[j];
          AudioManager.audioBuffers.push(b);
        }
        AudioManager.audioBuffersByLayer = this.object.sceneData.audio.audioBuffersByLayer;
        AudioManager.audioLayers = this.object.sceneData.audio.audioLayers;
        return AudioManager.soundReferences = this.object.sceneData.audio.soundReferences;
      }
    };


    /**
    * Restores the scene objects from the current loaded save-game. If no save-game is
    * present in GameManager.loadedSaveGame, nothing will happen.
    *
    * @method restoreScene
    * @protected
     */

    Component_GameSceneBehavior.prototype.restoreScene = function() {
      var c, context, j, len, ref, ref1, saveGame;
      saveGame = GameManager.loadedSaveGame;
      if (saveGame) {
        context = new gs.ObjectCodecContext([Graphics.viewport, this.object, this], saveGame.encodedObjectStore, null);
        saveGame.data = gs.ObjectCodec.decode(saveGame.data, context);
        ref = saveGame.data.characterNames;
        for (j = 0, len = ref.length; j < len; j++) {
          c = ref[j];
          if (c) {
            if ((ref1 = RecordManager.characters[c.index]) != null) {
              ref1.name = c.name;
            }
          }
        }
        GameManager.restore(saveGame);
        gs.ObjectCodec.onRestore(saveGame.data, context);
        this.resourceContext.fromDataBundle(saveGame.data.resourceContext, ResourceManager.resourcesByPath);
        this.object.sceneData = saveGame.data;
        return Graphics.frameCount = saveGame.data.frameCount;
      }
    };


    /**
    * Prepares all data for the scene and loads the necessary graphic and audio resources.
    *
    * @method prepareData
    * @abstract
     */

    Component_GameSceneBehavior.prototype.prepareData = function() {
      GameManager.scene = this.object;
      gs.ObjectManager.current = this.objectManager;
      this.object.sceneData.uid = this.object.sceneDocument.uid;
      if (!ResourceLoader.loadEventCommandsData(this.object.sceneDocument.items.commands)) {
        ResourceLoader.loadEventCommandsGraphics(this.object.sceneDocument.items.commands);
        GameManager.backlog = this.object.sceneData.backlog || GameManager.sceneData.backlog || [];
        ResourceLoader.loadSystemSounds();
        ResourceLoader.loadSystemGraphics();
        ResourceLoader.loadUiTypesGraphics(ui.UiFactory.customTypes);
        ResourceLoader.loadUiLayoutGraphics(ui.UiFactory.layouts.gameLayout);
        if (this.dataFields != null) {
          ResourceLoader.loadUiDataFieldsGraphics(this.dataFields);
        }
        $tempFields.choiceTimer = this.object.choiceTimer;
        return GameManager.variableStore.setup({
          id: this.object.sceneDocument.uid
        });
      }
    };


    /**
    * Prepares all visual game object for the scene.
    *
    * @method prepareVisual
     */

    Component_GameSceneBehavior.prototype.prepareVisual = function() {
      var ref;
      if (this.object.layout) {
        return;
      }
      if (GameManager.tempFields.isExitingGame) {
        GameManager.tempFields.isExitingGame = false;
        gs.GameNotifier.postResetSceneChange(this.object.sceneDocument.items.name);
      } else {
        gs.GameNotifier.postSceneChange(this.object.sceneDocument.items.name);
      }
      this.restoreScene();
      this.object.messageMode = (ref = this.object.sceneData.messageMode) != null ? ref : vn.MessageMode.ADV;
      this.setupMainViewport();
      this.setupViewports();
      this.setupCharacters();
      this.setupBackgrounds();
      this.setupPictures();
      this.setupTexts();
      this.setupVideos();
      this.setupHotspots();
      this.setupInterpreter();
      this.setupLayout();
      this.setupCommonEvents();
      this.restoreMessageBox();
      this.restoreInterpreter();
      this.restoreMessages();
      this.restoreAudioPlayback();
      this.show(true);
      this.object.sceneData = {};
      GameManager.sceneData = {};
      Graphics.update();
      return this.transition({
        duration: 0
      });
    };


    /**
    * Adds a new character to the scene.
    *
    * @method addCharacter
    * @param {vn.Object_Character} character - The character to add.
    * @param {boolean} noAnimation - Indicates if the character should be added immediately witout any appear-animation.
    * @param {Object} animationData - Contains the appear-animation data -> { animation, easing, duration }.
     */

    Component_GameSceneBehavior.prototype.addCharacter = function(character, noAnimation, animationData) {
      if (!noAnimation) {
        character.motionBlur.set(animationData.motionBlur);
        if (animationData.duration > 0) {
          if (!noAnimation) {
            character.animator.appear(character.dstRect.x, character.dstRect.y, animationData.animation, animationData.easing, animationData.duration);
          }
        }
      }
      character.viewport = this.viewport;
      character.visible = true;
      return this.object.characterContainer.addObject(character);
    };


    /**
    * Removes a character from the scene.
    *
    * @method removeCharacter
    * @param {vn.Object_Character} character - The character to remove.
    * @param {boolean} noAnimation - Indicates if the character should be disposed immediately witout any disapear-animation.
    * @param {Object} animationData - Contains the disappear-animation data -> { animation, easing, duration }.
     */

    Component_GameSceneBehavior.prototype.removeCharacter = function(character, noAnimation, animationData) {
      if (!noAnimation) {
        return character != null ? character.animator.disappear(animationData.animation, animationData.easing, animationData.duration, function(sender) {
          return sender.dispose();
        }) : void 0;
      } else {
        return character != null ? character.dispose() : void 0;
      }
    };


    /**
    * Resumes the current scene if it has been paused.
    *
    * @method resumeScene
     */

    Component_GameSceneBehavior.prototype.resumeScene = function() {
      var message;
      this.object.pictureContainer.active = true;
      this.object.characterContainer.active = true;
      this.object.backgroundContainer.active = true;
      this.object.textContainer.active = true;
      this.object.hotspotContainer.active = true;
      this.object.videoContainer.active = true;
      message = gs.ObjectManager.current.objectById("gameMessage_message");
      return message.active = true;
    };


    /**
    * Pauses the current scene. A paused scene will not continue, messages, pictures, etc. will
    * stop until the scene resumes.
    *
    * @method pauseScene
     */

    Component_GameSceneBehavior.prototype.pauseScene = function() {
      var message;
      this.object.pictureContainer.active = false;
      this.object.characterContainer.active = false;
      this.object.backgroundContainer.active = false;
      this.object.textContainer.active = false;
      this.object.hotspotContainer.active = false;
      this.object.videoContainer.active = false;
      message = gs.ObjectManager.current.objectById("gameMessage_message");
      return message.active = false;
    };


    /**
    * Changes the visibility of the entire game UI like the message boxes, etc. to allows
    * the player to see the entire scene. Useful for CGs, etc.
    *
    * @param {boolean} visible - If <b>true</b>, the game UI will be visible. Otherwise it will be hidden.
    * @method changeUIVisibility
     */

    Component_GameSceneBehavior.prototype.changeUIVisibility = function(visible) {
      this.uiVisible = visible;
      return this.object.layout.visible = visible;
    };


    /**
    * Shows input-text box to let the user enter a text.
    *
    * @param {number} letters - The max. number of letters the user can enter.
    * @param {gs.Callback} callback - A callback function called if the input-text box has been accepted by the user.
    * @method showInputText
     */

    Component_GameSceneBehavior.prototype.showInputText = function(letters, callback) {
      var ref;
      if ((ref = this.object.inputTextBox) != null) {
        ref.dispose();
      }
      this.object.inputTextBox = ui.UiFactory.createControlFromDescriptor(ui.UiFactory.customTypes["ui.InputTextBox"], this.object.layout);
      this.object.inputTextBox.ui.prepare();
      return this.object.inputTextBox.events.on("accept", callback);
    };


    /**
    * Shows input-number box to let the user enter a number.
    *
    * @param {number} digits - The max. number of digits the user can enter.
    * @param {gs.Callback} callback - A callback function called if the input-number box has been accepted by the user.
    * @method showInputNumber
     */

    Component_GameSceneBehavior.prototype.showInputNumber = function(digits, callback) {
      var ref;
      if ((ref = this.object.inputNumberBox) != null) {
        ref.dispose();
      }
      this.object.inputNumberBox = ui.UiFactory.createControlFromDescriptor(ui.UiFactory.customTypes["ui.InputNumberBox"], this.object.layout);
      this.object.inputNumberBox.ui.prepare();
      return this.object.inputNumberBox.events.on("accept", callback);
    };


    /**
    * Shows choices to let the user pick a choice.
    *
    * @param {Object[]} choices - An array of choices
    * @param {gs.Callback} callback - A callback function called if a choice has been picked by the user.
    * @method showChoices
     */

    Component_GameSceneBehavior.prototype.showChoices = function(callback) {
      var ref, useFreeLayout;
      useFreeLayout = this.object.choices.where(function(x) {
        return x.dstRect != null;
      }).length > 0;
      if ((ref = this.object.choiceWindow) != null) {
        ref.dispose();
      }
      if (useFreeLayout) {
        this.object.choiceWindow = ui.UiFactory.createControlFromDescriptor(ui.UiFactory.customTypes["ui.FreeChoiceBox"], this.object.layout);
      } else {
        this.object.choiceWindow = ui.UiFactory.createControlFromDescriptor(ui.UiFactory.customTypes["ui.ChoiceBox"], this.object.layout);
      }
      this.object.choiceWindow.events.on("selectionAccept", callback);
      return this.object.choiceWindow.ui.prepare();
    };


    /**
    * Changes the background of the scene.
    *
    * @method changeBackground
    * @param {Object} background - The background graphic object -> { name }
    * @param {boolean} noAnimation - Indicates if the background should be changed immediately witout any change-animation.
    * @param {Object} animation - The appear/disappear animation to use.
    * @param {Object} easing - The easing of the change animation.
    * @param {number} duration - The duration of the change in frames.
    * @param {number} ox - The x-origin of the background.
    * @param {number} oy - The y-origin of the background.
    * @param {number} layer - The background-layer to change.
    * @param {boolean} loopHorizontal - Indicates if the background should be looped horizontally.
    * @param {boolean} loopVertical - Indicates if the background should be looped vertically.
     */

    Component_GameSceneBehavior.prototype.changeBackground = function(background, noAnimation, animation, easing, duration, ox, oy, layer, loopHorizontal, loopVertical) {
      var object, otherObject, ref, ref1;
      if (background != null) {
        otherObject = this.object.backgrounds[layer];
        object = new vn.Object_Background();
        object.image = background.name;
        object.origin.x = ox;
        object.origin.y = oy;
        object.viewport = this.viewport;
        object.visual.looping.vertical = false;
        object.visual.looping.horizontal = false;
        object.update();
        this.object.backgroundContainer.setObject(object, layer);
        duration = duration != null ? duration : 30;
        if (otherObject != null) {
          otherObject.zIndex = layer;
        }
        if (otherObject != null) {
          if ((ref = otherObject.animator.otherObject) != null) {
            ref.dispose();
          }
        }
        if (duration === 0) {
          if (otherObject != null) {
            otherObject.dispose();
          }
          object.visual.looping.vertical = loopVertical;
          return object.visual.looping.horizontal = loopHorizontal;
        } else {
          if (noAnimation) {
            object.visual.looping.vertical = loopVertical;
            return object.visual.looping.horizontal = loopHorizontal;
          } else {
            object.animator.otherObject = otherObject;
            return object.animator.appear(0, 0, animation, easing, duration, (function(_this) {
              return function(sender) {
                var ref1;
                sender.update();
                if ((ref1 = sender.animator.otherObject) != null) {
                  ref1.dispose();
                }
                sender.animator.otherObject = null;
                sender.visual.looping.vertical = loopVertical;
                return sender.visual.looping.horizontal = loopHorizontal;
              };
            })(this));
          }
        }
      } else {
        return (ref1 = this.object.backgrounds[layer]) != null ? ref1.animator.hide(duration, easing, (function(_this) {
          return function() {
            _this.object.backgrounds[layer].dispose();
            return _this.object.backgrounds[layer] = null;
          };
        })(this)) : void 0;
      }
    };


    /**
    * Skips all viewport animations except the main viewport animation.
    *
    * @method skipViewports
    * @protected
     */

    Component_GameSceneBehavior.prototype.skipViewports = function() {
      var component, j, k, len, len1, ref, viewport, viewports;
      viewports = this.object.viewportContainer.subObjects;
      for (j = 0, len = viewports.length; j < len; j++) {
        viewport = viewports[j];
        if (viewport) {
          ref = viewport.components;
          for (k = 0, len1 = ref.length; k < len1; k++) {
            component = ref[k];
            if (typeof component.skip === "function") {
              component.skip();
            }
          }
        }
      }
      return null;
    };


    /**
    * Skips all picture animations.
    *
    * @method skipPictures
    * @protected
     */

    Component_GameSceneBehavior.prototype.skipPictures = function() {
      var component, j, k, len, len1, picture, ref, ref1;
      ref = this.object.pictures;
      for (j = 0, len = ref.length; j < len; j++) {
        picture = ref[j];
        if (picture) {
          ref1 = picture.components;
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            component = ref1[k];
            if (typeof component.skip === "function") {
              component.skip();
            }
          }
        }
      }
      return null;
    };


    /**
    * Skips all text animations.
    *
    * @method skipTexts
    * @protected
     */

    Component_GameSceneBehavior.prototype.skipTexts = function() {
      var component, j, k, len, len1, ref, ref1, text;
      ref = this.object.texts;
      for (j = 0, len = ref.length; j < len; j++) {
        text = ref[j];
        if (text) {
          ref1 = text.components;
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            component = ref1[k];
            if (typeof component.skip === "function") {
              component.skip();
            }
          }
        }
      }
      return null;
    };


    /**
    * Skips all video animations but not the video-playback itself.
    *
    * @method skipVideos
    * @protected
     */

    Component_GameSceneBehavior.prototype.skipVideos = function() {
      var component, j, k, len, len1, ref, ref1, video;
      ref = this.object.videos;
      for (j = 0, len = ref.length; j < len; j++) {
        video = ref[j];
        if (video) {
          ref1 = video.components;
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            component = ref1[k];
            if (typeof component.skip === "function") {
              component.skip();
            }
          }
        }
      }
      return null;
    };


    /**
    * Skips all background animations.
    *
    * @method skipBackgrounds
    * @protected
     */

    Component_GameSceneBehavior.prototype.skipBackgrounds = function() {
      var background, component, j, k, len, len1, ref, ref1;
      ref = this.object.backgrounds;
      for (j = 0, len = ref.length; j < len; j++) {
        background = ref[j];
        if (background) {
          ref1 = background.components;
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            component = ref1[k];
            if (typeof component.skip === "function") {
              component.skip();
            }
          }
        }
      }
      return null;
    };


    /**
    * Skips all character animations
    *
    * @method skipCharacters
    * @protected
     */

    Component_GameSceneBehavior.prototype.skipCharacters = function() {
      var character, component, j, k, len, len1, ref, ref1;
      ref = this.object.characters;
      for (j = 0, len = ref.length; j < len; j++) {
        character = ref[j];
        if (character) {
          ref1 = character.components;
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            component = ref1[k];
            if (typeof component.skip === "function") {
              component.skip();
            }
          }
        }
      }
      return null;
    };


    /**
    * Skips the main viewport animation.
    *
    * @method skipMainViewport
    * @protected
     */

    Component_GameSceneBehavior.prototype.skipMainViewport = function() {
      var component, j, len, ref;
      ref = this.object.viewport.components;
      for (j = 0, len = ref.length; j < len; j++) {
        component = ref[j];
        if (typeof component.skip === "function") {
          component.skip();
        }
      }
      return null;
    };


    /**
    * Skips all animations of all message boxes defined in MESSAGE_BOX_IDS ui constant.
    *
    * @method skipMessageBoxes
    * @protected
     */

    Component_GameSceneBehavior.prototype.skipMessageBoxes = function() {
      var component, j, k, len, len1, messageBox, messageBoxId, ref, ref1;
      ref = gs.UIConstants.MESSAGE_BOX_IDS || ["messageBox", "nvlMessageBox"];
      for (j = 0, len = ref.length; j < len; j++) {
        messageBoxId = ref[j];
        messageBox = gs.ObjectManager.current.objectById(messageBoxId);
        if (messageBox.components) {
          ref1 = messageBox.components;
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            component = ref1[k];
            if (typeof component.skip === "function") {
              component.skip();
            }
          }
        }
      }
      return null;
    };


    /**
    * Skips all animations of all message areas.
    *
    * @method skipMessageAreas
    * @protected
     */

    Component_GameSceneBehavior.prototype.skipMessageAreas = function() {
      var component, j, k, l, len, len1, len2, len3, m, messageArea, msg, ref, ref1, ref2, ref3;
      ref = this.object.messageAreas;
      for (j = 0, len = ref.length; j < len; j++) {
        messageArea = ref[j];
        if (messageArea != null ? messageArea.message : void 0) {
          ref1 = messageArea.message.components;
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            component = ref1[k];
            if (typeof component.skip === "function") {
              component.skip();
            }
          }
        }
      }
      msg = gs.ObjectManager.current.objectById("gameMessage_message");
      if (msg) {
        ref2 = msg.components;
        for (l = 0, len2 = ref2.length; l < len2; l++) {
          component = ref2[l];
          if (typeof component.skip === "function") {
            component.skip();
          }
        }
      }
      msg = gs.ObjectManager.current.objectById("nvlGameMessage_message");
      if (msg) {
        ref3 = msg.components;
        for (m = 0, len3 = ref3.length; m < len3; m++) {
          component = ref3[m];
          if (typeof component.skip === "function") {
            component.skip();
          }
        }
      }
      return null;
    };


    /**
    * Skips the scene interpreter timer.
    *
    * @method skipInterpreter
    * @protected
     */

    Component_GameSceneBehavior.prototype.skipInterpreter = function() {
      if (this.object.interpreter.waitCounter > GameManager.tempSettings.skipTime) {
        this.object.interpreter.waitCounter = GameManager.tempSettings.skipTime;
        if (this.object.interpreter.waitCounter === 0) {
          return this.object.interpreter.isWaiting = false;
        }
      }
    };


    /**
    * Skips the interpreter timer of all common events.
    *
    * @method skipCommonEvents
    * @protected
     */

    Component_GameSceneBehavior.prototype.skipCommonEvents = function() {
      var event, events, j, len, results;
      events = this.object.commonEventContainer.subObjects;
      results = [];
      for (j = 0, len = events.length; j < len; j++) {
        event = events[j];
        if ((event != null ? event.interpreter : void 0) && event.interpreter.waitCounter > GameManager.tempSettings.skipTime) {
          event.interpreter.waitCounter = GameManager.tempSettings.skipTime;
          if (event.interpreter.waitCounter === 0) {
            results.push(event.interpreter.isWaiting = false);
          } else {
            results.push(void 0);
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    };


    /**
    * Skips the scene's content.
    *
    * @method skipContent
    * @protected
     */

    Component_GameSceneBehavior.prototype.skipContent = function() {
      this.skipPictures();
      this.skipTexts();
      this.skipVideos();
      this.skipBackgrounds();
      this.skipCharacters();
      this.skipMainViewport();
      this.skipViewports();
      this.skipMessageBoxes();
      this.skipMessageAreas();
      this.skipInterpreter();
      return this.skipCommonEvents();
    };


    /**
    * Checks for the shortcut to hide/show the game UI. By default, this is the space-key. You
    * can override this method to change the shortcut.
    *
    * @method updateUIVisibilityShortcut
    * @protected
     */

    Component_GameSceneBehavior.prototype.updateUIVisibilityShortcut = function() {
      if (!this.uiVisible && (Input.trigger(Input.C) || Input.Mouse.buttonDown)) {
        this.changeUIVisibility(!this.uiVisible);
      }
      if (Input.trigger(Input.KEY_SPACE)) {
        return this.changeUIVisibility(!this.uiVisible);
      }
    };


    /**
    * Checks for the shortcut to exit the game. By default, this is the escape-key. You
    * can override this method to change the shortcut.
    *
    * @method updateQuitShortcut
    * @protected
     */

    Component_GameSceneBehavior.prototype.updateQuitShortcut = function() {
      if (Input.trigger(Input.KEY_ESCAPE)) {
        return gs.Application.exit();
      }
    };


    /**
    * Checks for the shortcut to open the settings menu. By default, this is the s-key. You
    * can override this method to change the shortcut.
    *
    * @method updateSettingsShortcut
    * @protected
     */

    Component_GameSceneBehavior.prototype.updateSettingsShortcut = function() {
      if (GameManager.tempSettings.menuAccess && Input.trigger(Input.X)) {
        return SceneManager.switchTo(new gs.Object_Layout("settingsMenuLayout"), true);
      }
    };


    /**
    * Checks for the shortcut to open the settings menu. By default, this is the control-key. You
    * can override this method to change the shortcut.
    *
    * @method updateSkipShortcut
    * @protected
     */

    Component_GameSceneBehavior.prototype.updateSkipShortcut = function() {
      if (this.object.settings.allowSkip) {
        if (Input.keys[Input.KEY_CONTROL] === 1) {
          return GameManager.tempSettings.skip = true;
        } else if (Input.keys[Input.KEY_CONTROL] === 2) {
          return GameManager.tempSettings.skip = false;
        }
      }
    };


    /**
    * Checks for default keyboard shortcuts e.g space-key to hide the UI, etc.
    *
    * @method updateShortcuts
    * @protected
     */

    Component_GameSceneBehavior.prototype.updateShortcuts = function() {
      this.updateSettingsShortcut();
      this.updateQuitShortcut();
      this.updateUIVisibilityShortcut();
      return this.updateSkipShortcut();
    };


    /**
    * Updates the full screen video played via Play Movie command.
    *
    * @method updateVideo
     */

    Component_GameSceneBehavior.prototype.updateVideo = function() {
      if (this.object.video != null) {
        this.object.video.update();
        if (this.object.settings.allowVideoSkip && (Input.trigger(Input.C) || Input.Mouse.buttons[Input.Mouse.LEFT] === 2)) {
          this.object.video.stop();
        }
        return Input.clear();
      }
    };


    /**
    * Updates skipping if enabled.
    *
    * @method updateSkipping
     */

    Component_GameSceneBehavior.prototype.updateSkipping = function() {
      if (!this.object.settings.allowSkip) {
        this.object.tempSettings.skip = false;
      }
      if (GameManager.tempSettings.skip) {
        return this.skipContent();
      }
    };


    /**
    * Updates the scene's content.
    *
    * @method updateContent
     */

    Component_GameSceneBehavior.prototype.updateContent = function() {
      GameManager.scene = this.object;
      Graphics.viewport.update();
      this.object.viewport.update();
      this.updateSkipping();
      this.updateVideo();
      this.updateShortcuts();
      return Component_GameSceneBehavior.__super__.updateContent.call(this);
    };

    return Component_GameSceneBehavior;

  })(gs.Component_LayoutSceneBehavior);

  vn.Component_GameSceneBehavior = Component_GameSceneBehavior;

}).call(this);
