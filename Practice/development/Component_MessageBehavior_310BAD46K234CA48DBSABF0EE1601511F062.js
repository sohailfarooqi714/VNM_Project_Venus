// Generated by CoffeeScript 1.12.7

/**
* An enumeration of game message modes.
*
* ADV - Adventure Mode
* NVL - Novel Mode
*
* @typedef MessageMode
* @memberof vn
 */

(function() {
  var Component_MessageBehavior, MessageMode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  MessageMode = (function() {
    function MessageMode() {}

    MessageMode.ADV = 0;

    MessageMode.NVL = 1;

    return MessageMode;

  })();

  vn.MessageMode = MessageMode;

  Component_MessageBehavior = (function(superClass) {
    extend(Component_MessageBehavior, superClass);

    Component_MessageBehavior.objectCodecBlackList = ["onMessageWaiting", "onMessageFinish"];


    /**
    * Called if this object instance is restored from a data-bundle. It can be used
    * re-assign event-handler, anonymous functions, etc.
    * 
    * @method onDataBundleRestore.
    * @param Object data - The data-bundle
    * @param gs.ObjectCodecContext context - The codec-context.
     */

    Component_MessageBehavior.prototype.onDataBundleRestore = function(data, context) {
      this.tempSettings = GameManager.tempSettings;
      return this.setupEventHandlers();
    };


    /**
    * A behavior-component to define the behavior of a game-message.
    *
    * @module vn
    * @class Component_MessageBehavior
    * @extends gs.Component
    * @memberof vn
    * @constructor
     */

    function Component_MessageBehavior() {

      /**
      * Reference to temporary game settings.
      * @property settings
      * @type Object
      * @protected
       */
      this.tempSettings = GameManager.tempSettings;

      /**
      * Indicates if the message is currently waiting.
      * @property isWaiting
      * @type boolean
      * @readOnly
       */
      this.isWaiting = false;

      /**
      * Indicates if the message is currently running.
      * @property isRunning
      * @type boolean
      * @readOnly
       */
      this.isRunning = false;

      /**
      * Indicates if a voice is currently playing together with the message.
      * @property isVoicePlaying
      * @type boolean
      * @readOnly
       */
      this.isVoicePlaying = false;

      /**
      * Current message caret/cursor position.
      * @property caretPosition
      * @type gs.Point
      * @readOnly
       */
      this.caretPosition = new gs.Point(0, 0);

      /**
      * Current raw message text.
      * @property message
      * @type string
      * @readOnly
       */
      this.message = "";

      /**
      * All currently displayed raw messages.
      * @property messages
      * @type string[]
      * @readOnly
       */
      this.messages = [];

      /**
      * Voice associated with the current message.
      * @property voice
      * @type gs.AudioBufferReference
       */
      this.voice = null;

      /**
      * Indicates if current message is partial. DEPRECATED. Please do not use.
      * @property partial
      * @deprecated
      * @type boolean
      * @readOnly
       */
      this.partial = false;

      /**
      * Indicates if the message is currently waiting in live-preview.
      * @property waitingPreview
      * @type boolean
      * @readOnly
       */
      this.waitingPreview = false;

      /**
      * Indicates if the auto-message is enabled.
      * @property autoMessageEnabled
      * @type boolean
      * @readOnly
       */
      this.autoMessageEnabled = false;
      this.onMessageFinish = (function(_this) {
        return function(sender) {
          _this.object.events.emit("finish", _this);
          if (_this.object.settings.autoErase || _this.object.settings.paragraphSpacing > 0) {
            return _this.message = "";
          }
        };
      })(this);
      this.onMessageWaiting = (function(_this) {
        return function(sender) {
          if (!_this.object.textRenderer.isBatched() || !_this.object.textRenderer.isBatchInProgress()) {
            _this.object.textRenderer.waitAtEnd = !_this.partial;
            return _this.object.events.emit("waiting", _this);
          }
        };
      })(this);
    }


    /**
    * Reference to game settings.
    * @property settings
    * @type Object
    * @protected
     */

    Component_MessageBehavior.accessors("settings", {
      get: function() {
        return GameManager.settings;
      }

      /**
      * Adds event-handlers
      *
      * @method setupEventHandlers
       */
    });

    Component_MessageBehavior.prototype.setupEventHandlers = function() {
      this.object.events.offByOwner("messageFinish", this);
      this.object.events.offByOwner("messageWaiting", this);
      this.object.events.on("messageFinish", gs.CallBack("onMessageFinish", this), null, this);
      this.object.events.on("messageWaiting", gs.CallBack("onMessageWaiting", this), null, this);
      gs.GlobalEventManager.offByOwner("previewWaiting", this);
      gs.GlobalEventManager.offByOwner("previewRestart", this);
      gs.GlobalEventManager.on("previewWaiting", ((function(_this) {
        return function(sender) {
          return _this.waitingPreview = true;
        };
      })(this)), null, this);
      return gs.GlobalEventManager.on("previewRestart", ((function(_this) {
        return function(sender) {
          return _this.waitingPreview = false;
        };
      })(this)), null, this);
    };


    /**
    * Setup the component. Adds event handlers.
    *
    * @method setup
     */

    Component_MessageBehavior.prototype.setup = function() {
      return this.setupEventHandlers();
    };


    /**
    * Disposes the component.
    *
    * @method toDataBundle
     */

    Component_MessageBehavior.prototype.dispose = function() {
      Component_MessageBehavior.__super__.dispose.apply(this, arguments);
      gs.GlobalEventManager.offByOwner("previewWaiting", this);
      return gs.GlobalEventManager.offByOwner("previewRestart", this);
    };


    /**
    * Not implemented yet.
    *
    * @method toDataBundle
     */

    Component_MessageBehavior.prototype.toDataBundle = function() {};


    /**
    * Not implemented yet.
    *
    * @method restore
    * @param {Object} bundle - A data bundle.
     */

    Component_MessageBehavior.prototype.restore = function(bundle) {};


    /**
    * Action to show a game message.
    *
    * @method showMessage
    * @param {Object} sender - The sender of this action.
    * @param {Object} params - An object containing the necessary parameters.
     */

    Component_MessageBehavior.prototype.showMessage = function(sender, params) {
      gs.GameNotifier.postContextChange(lcsm(params.message));
      this.partial = params.partial;
      this.message += lcsm(params.message);
      this.addMessage(params.message, RecordManager.characters[params.characterId], this.object.messages.length > 0 && this.object.settings.paragraphSpacing > 0, !this.partial);
      if (this.object.textRenderer.isBatched()) {
        return this.object.textRenderer.waitAtEnd = true;
      } else {
        return this.object.textRenderer.waitAtEnd = !this.partial;
      }
    };


    /**
    * Deprecated. Not longer used.
    *
    * @method updateBitmap
     */

    Component_MessageBehavior.prototype.updateBitmap = function() {
      var ref;
      if (!this.object.bitmap || this.object.bitmap.width !== this.object.dstRect.width || this.object.bitmap.height !== this.object.dstRect.height) {
        if ((ref = this.object.bitmap) != null) {
          ref.dispose();
        }
        this.object.bitmap = new Bitmap(this.object.dstRect.width, this.object.dstRect.height);
        return this.object.bitmap.font = this.object.font;
      }
    };


    /**
    * Restores a NVL game message of an array of message-objects. That is
    * necessary to restore a NVL game message from a save-game.
    *
    * @method restoreMessages
    * @param {Array} messages - An array of messages to restore.
     */

    Component_MessageBehavior.prototype.restoreMessages = function(messages) {
      var i, len, message, ref, ref1;
      this.updateBitmap();
      this.clear();
      this.object.opacity = 255;
      this.object.srcRect = new Rect(0, 0, this.object.dstRect.width, this.object.dstRect.height);
      for (i = 0, len = messages.length; i < len; i++) {
        message = messages[i];
        this.object.font.color = new Color(((ref = message.character) != null ? ref.textColor : void 0) || Color.WHITE);
        this.object.textRenderer.drawFormattedTextImmediately(0, 0, this.object.dstRect.width, this.object.dstRect.height, lcsm((ref1 = message.text) != null ? ref1 : message), true);
      }
      return null;
    };


    /**
    * Adds a new message.
    * 
    * @method addMessage
    * @param {string} message - The message.
    * @param {Object} character - Database-Record of a character.
    * @param {boolean} newLine - Indicates if the message should make a line break.
     */

    Component_MessageBehavior.prototype.addMessage = function(message, character, newLine, waitAtEnd) {
      this.object.textRenderer.partialMessage = null;
      this.object.offset = {
        x: 0,
        y: 0
      };
      this.object.visible = true;
      this.object.messages.push({
        text: message,
        character: character
      });
      this.object.textRenderer.waitAtEnd = waitAtEnd;
      if (!this.object.settings.autoErase) {
        this.object.textRenderer.currentY += this.object.settings.paragraphSpacing;
      }
      if (newLine) {
        this.object.textRenderer.newLine();
      }
      this.updateBitmap();
      if ((character != null) && this.object.settings.useCharacterColor) {
        this.object.font.color = new Color((character != null ? character.textColor : void 0) || Color.WHITE);
      }
      this.object.opacity = 255;
      this.object.srcRect = new Rect(0, 0, this.object.dstRect.width, this.object.dstRect.height);
      this.update();
      return this.object.textRenderer.drawFormattedText(0, 0, this.object.dstRect.width, this.object.dstRect.height, message, true);
    };


    /**
    * Clears the game message by deleting/clearing all messages.
    *
    * @method clear
     */

    Component_MessageBehavior.prototype.clear = function() {
      this.object.textRenderer.clear();
      this.object.messages = [];
      return this.message = "";
    };


    /**
    * Closes the game message by making it invisible.
    *
    * @method close
     */

    Component_MessageBehavior.prototype.close = function() {
      return this.object.visible = false;
    };


    /**
    * Gets the duration of an associated voice or 0 if no voice is associated.
    *
    * @method voiceDuration
    * @return {number} The duration in frames.
     */

    Component_MessageBehavior.prototype.voiceDuration = function() {
      var duration;
      duration = 0;
      if ((this.voice != null) && (this.settings.autoMessage.waitForVoice || this.settings.timeMessageToVoice)) {
        duration = Math.round((this.voice.source.buffer.duration * (1.0 / this.voice.source.playbackRate.value)) * 1000 / 16.6);
      } else {
        duration = 0;
      }
      if (this.tempSettings.skip) {
        return 1;
      } else {
        return duration;
      }
    };


    /**
    * Gets the duration of rendering the game-message.
    *
    * @method messageDuration
    * @return {number} The duration in frames.
     */

    Component_MessageBehavior.prototype.messageDuration = function() {
      var duration;
      duration = this.object.textRenderer.calculateDuration();
      if (this.tempSettings.skip) {
        return 1;
      } else {
        return duration;
      }
    };


    /**
    * Gets the time between two messages in auto-read mode.
    *
    * @method autoMessageTime
    * @return {number} The time in frames.
     */

    Component_MessageBehavior.prototype.autoMessageTime = function() {
      if (this.tempSettings.skip) {
        return 1;
      } else {
        return Math.max(Math.round(this.settings.autoMessage.time * Graphics.frameRate), this.voiceDuration() - this.messageDuration());
      }
    };


    /**
    * Gets the current message speed.
    *
    * @method messageSpeed
    * @return {number} The message speed.
     */

    Component_MessageBehavior.prototype.messageSpeed = function() {
      return Math.max(11 - Math.round(GameManager.settings.messageSpeed * 2.5), 0);
    };


    /**
    * Checks if a mouse-button or key was pressed to continue with the message-rendering.
    *
    * @method actionTrigger
    * @return {boolean} If true, the an action-button or action-key is pressed.
     */

    Component_MessageBehavior.prototype.actionTrigger = function() {
      return (gs.ObjectManager.current.input && this.object.visible && this.object.dstRect.contains(Input.Mouse.x - this.object.origin.x, Input.Mouse.y - this.object.origin.y) && Input.Mouse.buttons[Input.Mouse.LEFT] === 2) || Input.trigger(Input.C);
    };

    Component_MessageBehavior.prototype.finish = function() {
      if ((this.object.voice != null) && GameManager.settings.skipVoiceOnAction) {
        return AudioManager.stopSound(this.object.voice.name);
      }
    };

    Component_MessageBehavior.prototype.erase = function() {
      var duration, fading;
      fading = GameManager.tempSettings.messageFading;
      duration = GameManager.tempSettings.skip ? 0 : fading.duration;
      return this.object.animator.disappear(fading.animation, fading.easing, duration, (function(_this) {
        return function() {
          SceneManager.scene.currentCharacter = {
            name: ""
          };
          _this.clear();
          return _this.object.visible = false;
        };
      })(this));
    };


    /**
    * FIXME: Deprecated? It is also a re-definition of gs.Component_Visual.updateOrigin.
    *
    * @method updateOrigin
     */

    Component_MessageBehavior.prototype.updateOrigin = function() {
      var ox, oy, p;
      ox = 0;
      oy = 0;
      if ((this.object.parent != null) && (this.object.parent.dstRect != null)) {
        p = this.object.parent;
        while ((p != null) && (p.dstRect != null)) {
          ox += p.dstRect.x;
          oy += p.dstRect.y;
          p = p.parent;
        }
      }
      this.object.origin.x = ox;
      return this.object.origin.y = oy;
    };


    /**
    * Updates the object. 
    *
    * @method updateObject
    * @private
     */

    Component_MessageBehavior.prototype.updateObject = function() {
      this.updateOrigin();
      if (this.tempSettings.skip && !this.waitingPreview) {
        return this.object.textRenderer.isWaiting = false;
      }
    };


    /**
    * Updates the message.
    *
    * @method updateMessage
    * @private
     */

    Component_MessageBehavior.prototype.updateMessage = function() {
      var ref;
      this.caretPosition = this.object.textRenderer.caretPosition;
      if (this.tempSettings.skip && (this.settings.allowSkipUnreadMessages || ((ref = GameManager.globalData.messages[this.message]) != null ? ref.read : void 0))) {
        this.object.textRenderer.drawImmediately = true;
        this.object.textRenderer.waitAtEnd = this.waitingPreview;
        return this.object.textRenderer.waitAtEndTime = 0;
      } else {
        this.updateSpeed();
        return this.updateAutoMessage();
      }
    };


    /**
    * Updates the speed of the message. That depends on game-settings if a message
    * is timed to its voice or not.
    *
    * @method updateSpeed
    * @private
     */

    Component_MessageBehavior.prototype.updateSpeed = function() {
      var voiceDuration;
      voiceDuration = this.voiceDuration();
      if (voiceDuration > 0 && this.settings.timeMessageToVoice) {
        return this.object.textRenderer.speed = voiceDuration / this.message.length;
      } else {
        return this.object.textRenderer.speed = this.messageSpeed();
      }
    };


    /**
    * Update auto-read mode.
    *
    * @method updateAutoMessage
    * @private
     */

    Component_MessageBehavior.prototype.updateAutoMessage = function() {
      if (this.settings.autoMessage.stopOnAction && this.actionTrigger()) {
        this.settings.autoMessage.enabled = false;
      }
      if (this.settings.autoMessage.enabled && !this.partial) {
        if (this.object.textRenderer.waitAtEnd) {
          this.object.textRenderer.isWaiting = false;
        }
        this.object.textRenderer.waitAtEndTime = this.autoMessageTime();
        this.object.textRenderer.waitAtEnd = false;
      } else if (this.autoMessageEnabled !== this.settings.autoMessage.enabled) {
        this.object.textRenderer.waitAtEnd = true;
        this.object.textRenderer.waitAtEndTime = 0;
      }
      return this.autoMessageEnabled = this.settings.autoMessage.enabled;
    };


    /*
    * Updates the game message behavior
    *
    * @method update
     */

    Component_MessageBehavior.prototype.update = function() {
      var ref, ref1, ref2, ref3, ref4, ref5;
      this.object.needsUpdate = true;
      this.updateObject();
      this.updateMessage();
      if (this.character !== this.object.character) {
        gs.GlobalEventManager.emit("talkingEnded", this, {
          character: this.character
        });
        this.character = this.object.character;
      }
      if (this.object.textRenderer.isWaiting !== this.isWaiting || this.object.textRenderer.isRunning !== this.isRunning || (((ref = this.voice) != null ? ref.playing : void 0) && (!((ref1 = this.object.character) != null ? ref1.timeTalkingToVoiceVolume : void 0) || this.voice.averageVolume > this.object.character.talkingVolume)) !== this.isVoicePlaying) {
        this.isWaiting = this.object.textRenderer.isWaiting;
        this.isRunning = this.object.textRenderer.isRunning;
        this.isVoicePlaying = ((ref2 = this.voice) != null ? ref2.playing : void 0) && (!((ref3 = this.object.character) != null ? ref3.timeTalkingToVoiceVolume : void 0) || this.voice.averageVolume > this.object.character.talkingVolume);
        if (!this.tempSettings.skip) {
          if ((ref4 = this.voice) != null ? ref4.playing : void 0) {
            if (!this.isVoicePlaying) {
              gs.GlobalEventManager.emit("talkingEnded", this, {
                character: this.object.character
              });
            } else {
              gs.GlobalEventManager.emit("talkingStarted", this, {
                character: this.object.character
              });
            }
          } else {
            if (this.isWaiting) {
              gs.GlobalEventManager.emit("talkingEnded", this, {
                character: this.object.character
              });
            } else if (this.isRunning) {
              gs.GlobalEventManager.emit("talkingStarted", this, {
                character: this.object.character
              });
            }
          }
        }
      }
      if ((this.object.layoutRect != null) && (((ref5 = this.object.parent) != null ? ref5.dstRect : void 0) != null)) {
        if (this.object.layoutRect.x) {
          this.object.dstRect.x = this.object.layoutRect.x(this.object.parent.dstRect.width);
        }
        if (this.object.layoutRect.y) {
          this.object.dstRect.y = this.object.layoutRect.y(this.object.parent.dstRect.height);
        }
        if (this.object.layoutRect.width) {
          this.object.dstRect.width = this.object.layoutRect.width(this.object.parent.dstRect.width);
        }
        if (this.object.layoutRect.height) {
          return this.object.dstRect.height = this.object.layoutRect.height(this.object.parent.dstRect.height);
        }
      }
    };

    return Component_MessageBehavior;

  })(gs.Component);

  vn.Component_MessageBehavior = Component_MessageBehavior;

}).call(this);
