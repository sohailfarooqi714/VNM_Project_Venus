// Generated by CoffeeScript 1.12.7
(function() {
  var Component_LayoutBehavior,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Component_LayoutBehavior = (function(superClass) {
    extend(Component_LayoutBehavior, superClass);


    /**
    * The base class of all layout-components. A layout-component is used
    * to layout assigned sub-objects in a specific way depending on the layout-type.
    * For example: A grid-layout layouts its sub-objects like a grid using rows
    * and columns. The game object needs a container-component.<br><br>
    *
    * A layout can also be configured as scrollable. In that case, layout's content
    * can be larger than the layout-bounds and is automatically clipped. The content
    * can be scrolled using mouse-wheel or touch-gesture.
    *
    * @module gs
    * @class Component_LayoutBehavior
    * @extends gs.Component
    * @memberof gs
    * @constructor
     */

    function Component_LayoutBehavior() {

      /**
      * Content size of the layout.
      * @property contentSize
      * @type gs.Size
      * @readOnly
       */
      this.contentSize = {
        width: 0,
        height: 0
      };
    }


    /**
    * Disposes the layout and all its sub-objects.
    *
    * @method dispose
     */

    Component_LayoutBehavior.prototype.dispose = function() {
      var control, i, len, ref, results;
      ref = this.object.controls;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        control = ref[i];
        results.push(control != null ? control.dispose() : void 0);
      }
      return results;
    };


    /**
    * Initializes the layout.
    *
    * @method setup
     */

    Component_LayoutBehavior.prototype.setup = function() {};


    /**
    * Sizes the layout to fit its content.
    *
    * @method sizeToFit
    * @abstract
     */

    Component_LayoutBehavior.prototype.sizeToFit = function() {};


    /**
    * Sort-Function to sort sub-objects by order-index.
    *
    * @method sort_
    * @protected
    * @param {gs.Object_Base} a Object A
    * @param {gs.Object_Base} b Object B
     */

    Component_LayoutBehavior.prototype.sort_ = function(a, b) {
      if (a.order > b.order) {
        return -1;
      } else if (a.order < b.order) {
        return 1;
      } else {
        return 0;
      }
    };


    /**
    * Updates a specified control.
    *
    * @method updateControl
    * @protected
    * @param {gs.Object_Base} control The control to update
     */

    Component_LayoutBehavior.prototype.updateControl = function(control) {
      this.object.rIndex = Math.max(this.object.rIndex, control.rIndex);
      if (control.updateBehavior === ui.UpdateBehavior.CONTINUOUS) {
        control.needsUpdate = true;
      }
      if (control.inheritProperties) {
        control.ui.enabled = this.object.ui.enabled;
        control.opacity = this.object.opacity;
        control.zoom = this.object.zoom;
        control.color = this.object.color;
        control.tone = this.object.tone;
        control.angle = this.object.angle;
        control.anchor.x = this.object.anchor.x;
        control.anchor.y = this.object.anchor.y;
      }
      if (control.needsUpdate) {
        control.needsUpdate = false;
        control.update();
        control.parent = this.object;
      }
      if (this.object.clipRect != null) {
        return control.clipRect = this.object.clipRect;
      }
    };


    /**
    * Updates the content size of the layout. Only works if scrolling is
    * enabled.
    *
    * @method updateContentSize
    * @protected
     */

    Component_LayoutBehavior.prototype.updateContentSize = function() {
      var control, i, len, ref;
      if (this.object.scrollable) {
        this.contentSize.width = 0;
        this.contentSize.height = 0;
        ref = this.object.controls;
        for (i = 0, len = ref.length; i < len; i++) {
          control = ref[i];
          if (control) {
            this.contentSize.width += control.margin.left + control.dstRect.width + control.margin.right;
            this.contentSize.height += control.margin.top + control.dstRect.height + control.margin.bottom;
          }
        }
        this.object.contentHeight = this.contentSize.height;
        return this.object.contentWidth = this.contentSize.width;
      }
    };


    /**
    * Updates scrolling.
    *
    * @method updateScroll
     */

    Component_LayoutBehavior.prototype.updateScroll = function() {
      if (this.object.scrollable) {
        this.object.scrollableHeight = Math.max(0, this.contentSize.height - this.object.dstRect.height);
        if (Input.Mouse.wheel <= -1) {
          this.object.scrollOffsetY = Math.max(this.object.scrollOffsetY - Input.Mouse.wheelSpeed * 0.1, 0);
        }
        if (Input.Mouse.wheel >= 1) {
          this.object.scrollOffsetY = Math.min(this.object.scrollOffsetY - Input.Mouse.wheelSpeed * 0.1, this.object.scrollableHeight);
        }
        return this.object.scrollOffsetY = Math.max(Math.min(this.object.scrollOffsetY, this.object.scrollableHeight), 0);
      }
    };


    /**
    * Updates the layout's content.
    *
    * @method updateContent
     */

    Component_LayoutBehavior.prototype.updateContent = function() {};


    /**
    * Updates the layout.
    *
    * @method update
     */

    Component_LayoutBehavior.prototype.update = function() {
      Component_LayoutBehavior.__super__.update.apply(this, arguments);
      this.updateContentSize();
      return this.updateScroll();
    };

    return Component_LayoutBehavior;

  })(gs.Component_Visual);

  gs.Component_LayoutBehavior = Component_LayoutBehavior;

}).call(this);
