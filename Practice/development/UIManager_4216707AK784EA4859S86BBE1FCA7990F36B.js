// Generated by CoffeeScript 1.12.7
(function() {
  var Formula, Space, Style, UIManager;

  Formula = (function() {

    /**
    * Encapsulates a UI formula. A formula can be used in UI layouts to define
    * property-bindings or to implement a specific behavior.
    *
    * @module ui
    * @class Formula
    * @memberof ui
    * @constructor
    * @param {Function} f - The formula-function. Defines the logic of the formula.
    * @param {Object} data - An optional data-object which can be accessed inside the formula-function.
    * @param {string} event - An optional event-name to define when the formula should be executed.
     */
    function Formula(f, data, event) {

      /**
      * Indicates if its the first time the formula is called.
      * @property onInitialize
      * @type boolean
       */
      var i, j, l, ref, ref1;
      this.onInitialize = true;

      /**
      * The formula-function.
      * @property exec_
      * @type Function
       */
      this.exec_ = f;

      /**
      * An optional data-object which can bes accessed inside the formula-function.
      * @property data
      * @type Object
       */
      this.data = data;

      /**
      * An optional event-name to define when the formula should be executed.
      * @property event
      * @type string
       */
      this.event = event;

      /**
      * An array of custom number-data which can be used for different purposes. The first element
      * is also used in onChange method to store the old value and check against the new one to detect a change.
      * @property numbers
      * @type number[]
       */
      this.numbers = new Array(10);
      for (i = j = 0, ref = this.numbers.length; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        this.numbers[i] = 0;
      }

      /**
      * An array of custom string-data which can be used for different purposes. The first element
      * is also used in onTextChange method to store the old value and check against the new one to detect a change.
      * @property strings
      * @type string[]
       */
      this.strings = new Array(10);
      for (i = l = 0, ref1 = this.strings.length; 0 <= ref1 ? l <= ref1 : l >= ref1; i = 0 <= ref1 ? ++l : --l) {
        this.strings[i] = "";
      }
    }


    /**
    * The formula-function. Its a wrapper-function before the first-time call was made.
    * @method exec
     */

    Formula.prototype.exec = function() {
      var r;
      this.exec = this.exec_;
      r = this.exec_.apply(this, arguments);
      this.onInitialize = false;
      return r;
    };


    /**
    * Checks if the specified number-value has changed since the last check. It uses
    * the first entry of the numbers-array to store the value and check against the new one.
    *
    * @method onChange
    * @param {number} numberValue - Number value to check.
     */

    Formula.prototype.onChange = function(numberValue) {
      var result;
      result = this.numbers[0] !== numberValue;
      this.numbers[0] = numberValue;
      return result;
    };


    /**
    * Checks if the specified text-value has changed since the last check. It uses
    * the first entry of the strings-array to store the value and check against the new one.
    *
    * @method onTextChange
    * @param {string} textValue - Text value to check.
     */

    Formula.prototype.onTextChange = function(textValue) {
      var result;
      result = this.strings[0] !== textValue;
      this.strings[0] = textValue;
      return result;
    };

    return Formula;

  })();

  ui.Formula = Formula;

  Space = (function() {

    /**
    * Describes a space inside or around something like a margin or padding.
    *
    * @module ui
    * @class Space
    * @memberof ui
    * @constructor
    * @param {number} left - Space at the left in pixels.
    * @param {number} top - Space at the top in pixels.
    * @param {number} right - Space at the right in pixels.
    * @param {number} bottom - Space at the bottom in pixels.
     */
    function Space(left, top, right, bottom) {

      /**
      * Space at the left in pixels.
      * @property left
      * @type number
       */
      this.left = left;

      /**
      * Space at the top in pixels.
      * @property top
      * @type number
       */
      this.top = top;

      /**
      * Space at the right in pixels.
      * @property right
      * @type number
       */
      this.right = right;

      /**
      * Space at the bottom in pixels.
      * @property bottom
      * @type number
       */
      this.bottom = bottom;
    }


    /**
    * Sets the coordinates of the space by copying them from a specified space.
    *
    * @method setFromObject
    * @param {Object} space - A space to copy.
     */

    Space.prototype.setFromObject = function(space) {
      this.left = space.left;
      this.top = space.top;
      this.right = space.right;
      return this.bottom = space.bottom;
    };


    /**
    * Sets the coordinates of the space.
    *
    * @method set
    * @param {number} left - Space at the left in pixels.
    * @param {number} top - Space at the top in pixels.
    * @param {number} right - Space at the right in pixels.
    * @param {number} bottom - Space at the bottom in pixels.
     */

    Space.prototype.set = function(left, top, right, bottom) {
      this.left = left;
      this.top = top;
      this.right = right;
      return this.bottom = bottom;
    };


    /**
    * Creates a new space object from an array of coordinates.
    *
    * @method fromArray
    * @static
    * @param {number[]} array - An array of coordinates (left, top right, bottom).
     */

    Space.fromArray = function(array) {
      return new ui.Space(array[0], array[1], array[2], array[3]);
    };

    return Space;

  })();

  ui.Space = Space;

  Style = (function() {

    /**
    * A UI style can applied to a UI object to modify it properties like color, image, etc. to give a certain "style" to it.
    *
    * @module ui
    * @class Style
    * @memberof ui
    * @constructor
    * @param {Object} descriptor - A style-descriptor to initialize the style from.
    * @param {number} id - A unique numeric ID to access the style through UIManager.stylesById collection.
    * @param {number} selector - A selector ID which controls under which conditions the styles will be applied.
     */
    function Style(descriptor, id, selector) {

      /**
      * ID number to quickly access this style and link to this style.
      * @property id
      * @type number
       */
      this.id = id;

      /**
      * Style-ID of target object. This style will only be applied on UI objects with that style ID which are
      * children of UI objects where this style is applied.
      * @property target
      * @type number
       */
      this.target = -1;

      /**
      * Selector-ID which controls under which conditions the style becomes active.
      * @property selector
      * @type number
       */
      this.selector = selector;

      /**
      * The font used for the text-display.
      * @default null
      * @property font
      * @type gs.Font
       */
      this.font = null;

      /**
      * The UI object's image used for visual presentation.
      * @property image
      * @type string
       */
      this.image = null;

      /**
      * The UI object's animations used for visual presentation.
      * @default null
      * @property animations
      * @type Object[]
       */
      this.animations = null;

      /**
      * The UI object's color.
      * @property color
      * @type gs.Color
       */
      this.color = null;

      /**
      * The UI object's tone.
      * @property tone
      * @type gs.Tone
       */
      this.tone = null;

      /**
      * The UI object's anchor-point. For example: An anchor-point with 0,0 places the object with its top-left corner
      * at its position but with an 0.5, 0.5 anchor-point the object is placed with its center. An anchor-point of 1,1
      * places the object with its lower-right corner.
      * @property anchor
      * @type gs.Point
       */
      this.anchor = null;

      /**
      * The UI object's zoom-setting for x and y axis.
      * @default new gs.Point(1.0, 1.0)
      * @property zoom
      * @type gs.Point
       */
      this.zoom = null;

      /**
      * The UI object's margin. The margin defines an extra space around the UI object. 
      * The default is { left: 0, top: 0, right: 0, bottom: 0 }.
      * @property margin
      * @type Object
       */
      this.margin = null;

      /**
      * The UI object's padding. The default is { left: 0, top: 0, right: 0, bottom: 0 }.
      * @property padding
      * @type Object
       */
      this.padding = null;

      /**
      * The UI object's mask for masking-effects.
      * @property mask
      * @type gs.Mask
       */
      this.mask = null;

      /**
      * The UI object's alignment.
      * @property alignment
      * @type ui.Alignment
       */
      this.alignment = -1;

      /**
      * The UI object's opacity to control transparency. For example: 0 = Transparent, 255 = Opaque, 128 = Semi-Transparent.
      * @property opacity
      * @type number
       */
      this.opacity = -1;

      /**
      * The object's clip-rect for visual presentation.
      * @default null
      * @property clipRect
      * @type gs.Rect
      * @protected
       */
      this.clipRect = null;

      /**
      * The corner-size of the frame.
      * @property frameCornerSize
      * @type number
       */
      this.frameCornerSize = -1;

      /**
      * The thickness of the frame.
      * @property frameThickness
      * @type number
       */
      this.frameThickness = -1;

      /**
      * The looping of the image.
      * @property looping
      * @type ui.Orientation
       */
      this.looping = null;

      /**
      * The object's z-index controls rendering-order/image-overlapping. An object with a smaller z-index is rendered
      * before an object with a larger index. For example: To make sure a game object is always on top of the screen, it
      * should have the largest z-index of all game objects.
      * @property zIndex
      * @type number
       */
      this.zIndex = -1;

      /**
      * The object's alignment on x-axis. Needs to be supported by layout.
      * @property alignmentX
      * @type number
       */
      this.alignmentX = -1;

      /**
      * The object's alignment on y-axis. Needs to be supported by layout.
      * @property alignmentY
      * @type number
       */
      this.alignmentY = -1;

      /**
      * The object's resize behavior.
      * @property resizable
      * @type boolean
       */
      this.resizable = null;

      /**
      * The original style descriptor.
      * @property descriptor
      * @type Object
       */
      this.descriptor = descriptor;
      if (descriptor) {
        this.setFromDescriptor(descriptor);
      }
    }


    /**
    * Initializes the style from a style-descriptor.
    *
    * @method setFromDescriptor
    * @param {Object} descriptor - The style-descriptor.
     */

    Style.prototype.setFromDescriptor = function(descriptor) {
      this.descriptor = descriptor;
      this.image = descriptor.image;
      if (descriptor.color) {
        this.color = gs.Color.fromArray(descriptor.color);
      }
      if (descriptor.tone) {
        this.tone = gs.Tone.fromArray(descriptor.tone);
      }
      if (descriptor.anchor) {
        this.anchor = new gs.Point(descriptor.anchor[0], descriptor.anchor[1]);
      }
      if (descriptor.zoom) {
        this.zoom = new gs.Point(descriptor.zoom[0], descriptor.zoom[1]);
      }
      if (descriptor.font) {
        this.setupFont(descriptor);
      }
      if (descriptor.clipRect) {
        this.clipRect = gs.Rect.fromArray(descriptor.clipRect);
      }
      if (descriptor.opacity >= 0) {
        this.opacity = descriptor.opacity;
      }
      if (descriptor.alignment >= 0) {
        this.alignment = descriptor.alignment;
      }
      if (descriptor.margin) {
        this.margin = ui.Space.fromArray(descriptor.margin);
      }
      if (descriptor.padding) {
        this.padding = ui.Space.fromArray(descriptor.padding);
      }
      this.animations = descriptor.animations;
      if (descriptor.frameCornerSize) {
        this.frameCornerSize = descriptor.frameCornerSize;
      }
      if (descriptor.frameThickness) {
        this.frameThickness = descriptor.frameThickness;
      }
      if (descriptor.frame) {
        this.frame = descriptor.frame;
      }
      if (descriptor.looping) {
        this.looping = descriptor.looping;
      }
      if (descriptor.resizable != null) {
        this.resizable = descriptor.resizable;
      }
      if (descriptor.zIndex) {
        this.zIndex = descriptor.zIndex;
      }
      if (descriptor.alignmentX) {
        this.alignmentX = ui.UIManager.alignments[descriptor.alignmentX];
      }
      if (descriptor.alignmentY) {
        return this.alignmentY = ui.UIManager.alignments[descriptor.alignmentY];
      }
    };

    Style.prototype.set = function(style) {
      this.image = style.image;
      this.color.setFromObject(style.color);
      this.tone.setFromObject(style.tone);
      this.anchor.set(style.anchor.x, style.anchor.y);
      this.zoom.set(style.zoom.x, style.zoom.y);
      if (style.font) {
        if (!this.font) {
          this.font = new gs.Font(style.font.name, style.font.size);
        }
        this.font.set(style.font);
      }
      if (style.clipRect) {
        if (!this.clipRect) {
          this.clipRect = new gs.Rect();
        }
        this.clipRect.setFromObject(style.clipRect);
      }
      this.opacity = style.opacitz;
      this.alignment = style.alignment;
      this.margin.setFromObject(style.margin);
      return this.padding.setFromObject(style.padding);
    };


    /**
    * Initializes font-data from a style-descriptor.
    *
    * @method setupFont
    * @param {Object} descriptor - The style-descriptor.
    * @protected
     */

    Style.prototype.setupFont = function(descriptor) {
      var ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9;
      if (descriptor.font) {
        if (!this.font) {
          this.font = new Font(descriptor.font.name, (ref = descriptor.font.size) != null ? ref : 0);
        } else {
          this.font.name = descriptor.font.name;
          this.font.size = (ref1 = descriptor.font.size) != null ? ref1 : 0;
        }
        this.font.bold = (ref2 = descriptor.font.bold) != null ? ref2 : this.font.bold;
        this.font.italic = (ref3 = descriptor.font.italic) != null ? ref3 : this.font.italic;
        this.font.smallCaps = (ref4 = descriptor.font.smallCaps) != null ? ref4 : this.font.smallCaps;
        this.font.underline = (ref5 = descriptor.font.underline) != null ? ref5 : this.font.underline;
        this.font.strikeThrough = (ref6 = descriptor.font.strikeThrough) != null ? ref6 : this.font.strikeThrough;
        if (descriptor.font.color != null) {
          this.font.color.setFromArray(descriptor.font.color);
        }
        if (descriptor.font.border != null) {
          this.font.border = (ref7 = descriptor.font.border) != null ? ref7 : false;
          this.font.borderSize = (ref8 = descriptor.font.borderSize) != null ? ref8 : 4;
          this.font.borderColor.set(0, 0, 0, 255);
        }
        if (descriptor.font.outline != null) {
          this.font.border = (ref9 = descriptor.font.outline) != null ? ref9 : false;
          this.font.borderSize = (ref10 = descriptor.font.outline.size) != null ? ref10 : 4;
          if (descriptor.font.outline.color != null) {
            return this.font.borderColor.setFromArray(descriptor.font.outline.color);
          } else {
            return this.font.borderColor.set(0, 0, 0, 255);
          }
        }
      }
    };


    /**
    * Applies the style to a UI object.
    *
    * @method apply
    * @param {ui.Object_UIElement} object - The UI object where the style should be applied to.
     */

    Style.prototype.apply = function(object) {
      var ref, ref1;
      if (!object.activeStyles.contains(this)) {
        object.activeStyles.push(this);
        if (this.font) {
          if ((ref = object.font) != null) {
            ref.set(this.font);
          }
        }
        if (this.color) {
          object.color.set(this.color);
        }
        if (this.tone) {
          if ((ref1 = object.tone) != null) {
            ref1.set(this.tone);
          }
        }
        if (this.image) {
          object.image = this.image;
        }
        if (this.anchor) {
          object.anchor.set(this.anchor.x, this.anchor.y);
        }
        if (this.zoom) {
          object.zoom.set(this.zoom.x, this.zoom.y);
        }
        if (this.padding) {
          object.padding.setFromObject(this.padding);
        }
        if (this.margin) {
          object.margin.setFromObject(this.margin);
        }
        if (this.opacity >= 0) {
          object.opacity = this.opacity;
        }
        if (this.alignment >= 0) {
          object.alignment = this.alignment;
        }
        if (this.frameThickness >= 0) {
          object.frameThickness = this.frameThickness;
        }
        if (this.frameCornerSize >= 0) {
          object.frameCornerSize = this.frameCornerSize;
        }
        if (this.mask) {
          object.mask.set(this.mask);
        }
        if (this.zIndex >= 0) {
          object.zIndex = this.zIndex;
        }
        if (this.alignmentX >= 0) {
          object.alignmentX = this.alignmentX;
        }
        if (this.alignmentY >= 0) {
          object.alignmentY = this.alignmentY;
        }
        if (this.resizable != null) {
          object.resizable = this.resizable;
        }
        this.applyLooping(object);
        return this.applyAnimations(object);
      }
    };


    /**
    * Applies the looping-data of the style to a UI object.
    *
    * @method applyLooping
    * @param {ui.Object_UIElement} object - The UI object where the looping-data should be applied to.
    * @protected
     */

    Style.prototype.applyLooping = function(object) {
      if (this.looping) {
        if (!object.visual.looping) {
          object.visual.dispose();
          object.removeComponent(object.visual);
          object.visual = new gs.Component_TilingSprite();
          object.addComponent(object.visual);
        }
        object.visual.looping.vertical = this.looping.vertical;
        return object.visual.looping.horizontal = this.looping.horizontal;
      }
    };


    /**
    * Applies the animation-data of the style to a UI object. This automatically adds an animation-handler
    * component(ui.Component_AnimationHandler) with the id "animationHandler" to the UI object if not already exists.
    *
    * @method applyAnimations
    * @param {ui.Object_UIElement} object - The UI object where the animation-data should be applied to.
    * @protected
     */

    Style.prototype.applyAnimations = function(object) {
      if (this.animations) {
        object.animations = Object.deepCopy(this.animations);
        if (!object.findComponentById("animationHandler")) {
          object.animationExecutor = new ui.Component_AnimationExecutor();
          object.addComponent(new ui.Component_AnimationHandler(), "animationHandler");
          return object.addComponent(object.animationExecutor, "animationExecutor");
        }
      }
    };


    /**
    * Reverts the changes from a UI object made by this style. However, this resets all styleable properties
    * were set by this style. So it is necessary to apply all other styles again, but that is already handles in
    * ui.Component_UIBehavior.
    *
    * @method revert
    * @param {ui.Object_UIElement} object - The UI object where the style should be reverted.
     */

    Style.prototype.revert = function(object) {
      var activeStyles, i1, j, j1, k1, l, l1, m1, n, o, p, q, ref, ref1, s, t, u, w, x, y, z;
      activeStyles = object.activeStyles;
      if (object.activeStyles.contains(this)) {
        object.activeStyles.remove(this);
        if (this.font) {
          object.font.set(gs.Fonts.TEXT);
          for (j = activeStyles.length - 1; j >= 0; j += -1) {
            s = activeStyles[j];
            if (s.font) {
              object.font.set(s.font);
              break;
            }
          }
        }
        if (this.color) {
          object.color.set(Color.WHITE);
          for (l = activeStyles.length - 1; l >= 0; l += -1) {
            s = activeStyles[l];
            if (s.color) {
              object.color.set(s.color);
              break;
            }
          }
        }
        if (this.tone) {
          if ((ref = object.tone) != null) {
            ref.set(0, 0, 0, 0);
          }
          for (n = activeStyles.length - 1; n >= 0; n += -1) {
            s = activeStyles[n];
            if (s.tone) {
              if ((ref1 = object.tone) != null) {
                ref1.set(s.tone);
              }
              break;
            }
          }
        }
        if (this.image) {
          object.image = null;
          for (o = activeStyles.length - 1; o >= 0; o += -1) {
            s = activeStyles[o];
            if (s.image) {
              object.image = s.image;
              break;
            }
          }
        }
        if (this.anchor) {
          object.anchor.set(0, 0);
          for (p = activeStyles.length - 1; p >= 0; p += -1) {
            s = activeStyles[p];
            if (s.anchor) {
              object.anchor.setFromObject(s.anchor);
              break;
            }
          }
        }
        if (this.zoom) {
          object.zoom.set(1.0, 1.0);
          for (q = activeStyles.length - 1; q >= 0; q += -1) {
            s = activeStyles[q];
            if (s.zoom) {
              object.zoom.setFromObject(s.zoom);
              break;
            }
          }
        }
        if (this.padding) {
          object.padding.set(0, 0, 0, 0);
          for (t = activeStyles.length - 1; t >= 0; t += -1) {
            s = activeStyles[t];
            if (s.padding) {
              object.padding.setFromObject(s.padding);
              break;
            }
          }
        }
        if (this.margin) {
          object.margin.set(0, 0, 0, 0);
          for (u = activeStyles.length - 1; u >= 0; u += -1) {
            s = activeStyles[u];
            if (s.margin) {
              object.margin.setFromObject(s.margin);
              break;
            }
          }
        }
        if (this.opacity >= 0) {
          object.opacity = 255;
          for (w = activeStyles.length - 1; w >= 0; w += -1) {
            s = activeStyles[w];
            if (s.opacity >= 0) {
              object.opacity = s.opacity;
              break;
            }
          }
        }
        if (this.alignment >= 0) {
          object.alignment = 0;
          for (x = activeStyles.length - 1; x >= 0; x += -1) {
            s = activeStyles[x];
            if (s.alignment >= 0) {
              object.alignment = s.alignment;
              break;
            }
          }
        }
        if (this.frameCornerSize >= 0) {
          object.frameCornerSize = 16;
          for (y = activeStyles.length - 1; y >= 0; y += -1) {
            s = activeStyles[y];
            if (s.frameCornerSize >= 0) {
              object.frameCornerSize = s.frameCornerSize;
              break;
            }
          }
        }
        if (this.frameThickness >= 0) {
          object.frameThickness = 16;
          for (z = activeStyles.length - 1; z >= 0; z += -1) {
            s = activeStyles[z];
            if (s.frameThickness >= 0) {
              object.frameThickness = s.frameThickness;
              break;
            }
          }
        }
        if (this.mask) {
          object.mask.set(null);
          for (i1 = activeStyles.length - 1; i1 >= 0; i1 += -1) {
            s = activeStyles[i1];
            if (s.mask) {
              object.mask.set(s.font);
              break;
            }
          }
        }
        if (this.zIndex >= 0) {
          object.zIndex = 0;
          for (j1 = activeStyles.length - 1; j1 >= 0; j1 += -1) {
            s = activeStyles[j1];
            if (s.zIndex >= 0) {
              object.zIndex = s.zIndex;
              break;
            }
          }
        }
        if (this.alignmentX >= 0) {
          object.alignmentX = 0;
          for (k1 = activeStyles.length - 1; k1 >= 0; k1 += -1) {
            s = activeStyles[k1];
            if (s.alignmentX >= 0) {
              object.alignmentX = s.alignmentX;
              break;
            }
          }
        }
        if (this.alignmentY >= 0) {
          object.alignmentY = 0;
          for (l1 = activeStyles.length - 1; l1 >= 0; l1 += -1) {
            s = activeStyles[l1];
            if (s.alignmentY >= 0) {
              object.alignmentY = s.alignmentY;
              break;
            }
          }
        }
        if (this.resizable != null) {
          object.resizable = false;
          for (m1 = activeStyles.length - 1; m1 >= 0; m1 += -1) {
            s = activeStyles[m1];
            if (s.resizable != null) {
              object.resizable = s.resizable;
              break;
            }
          }
        }
        this.revertAnimations(object);
        return this.revertLooping(object);
      }
    };


    /**
    * Reverts the animation-data changes applied to a UI object by this style.
    *
    * @method revertAnimations
    * @param {ui.Object_UIElement} object - The UI object where the animation-data changes should be reverted.
     */

    Style.prototype.revertAnimations = function(object) {
      var activeStyles, j, results, s;
      activeStyles = object.activeStyles;
      if (this.animations) {
        object.animations = null;
        results = [];
        for (j = activeStyles.length - 1; j >= 0; j += -1) {
          s = activeStyles[j];
          if (s.animations) {
            object.animations = Object.deepCopy(s.animations);
            if (!object.findComponentById("animationHandler")) {
              results.push(object.addComponent(new ui.Component_AnimationHandler(), "animationHandler"));
            } else {
              results.push(void 0);
            }
          } else {
            results.push(void 0);
          }
        }
        return results;
      }
    };


    /**
    * Reverts the looping-data changes applied to a UI object by this style.
    *
    * @method revertLooping
    * @param {ui.Object_UIElement} object - The UI object where the looping-data changes should be reverted.
     */

    Style.prototype.revertLooping = function(object) {
      var activeStyles, j, results, s;
      activeStyles = object.activeStyles;
      if (this.looping) {
        object.visual.looping.vertical = false;
        object.visual.looping.horizontal = false;
        results = [];
        for (j = activeStyles.length - 1; j >= 0; j += -1) {
          s = activeStyles[j];
          if (s.looping) {
            if (!object.visual.looping) {
              object.visual.dispose();
              object.removeComponent(object.visual);
              object.visual = new gs.Component_TilingSprite();
              object.addComponent(object.visual);
            }
            object.visual.looping.vertical = s.looping.vertical;
            results.push(object.visual.looping.horizontal = s.looping.horizontal);
          } else {
            results.push(void 0);
          }
        }
        return results;
      }
    };

    return Style;

  })();

  ui.Style = Style;

  UIManager = (function() {

    /**
    * Handles the creation of In Game UI elements. For more information about
    * In-Game UI see help file.
    *
    * @module ui
    * @class UIManager
    * @memberof ui
    * @constructor
     */
    function UIManager() {

      /**
      * Stores all registered UI layouts by name/id.
      * @property layouts
      * @type Object
       */
      this.layouts = {};

      /**
      * Stores all registered UI styles by name/id.
      * @property styles
      * @type Object
       */
      this.styles = {};

      /**
      * Stores all UI styles by number id.
      * @property stylesById
      * @type ui.Style[]
       */
      this.stylesById = new Array();

      /**
      * Stores all UI styles by style-name.
      * @property stylesByName
      * @type Object
       */
      this.stylesByName = {};

      /**
      * Stores all registered custom UI types/templates by name/id.
      * @property customTypes
      * @type Object
       */
      this.customTypes = {};

      /**
      * Stores all registered UI controllers by name/id.
      * @property customTypes
      * @type Object
       */
      this.controllers = {};

      /**
      * Stores all registered UI data sources by name/id.
      * @property customTypes
      * @type Object
       */
      this.dataSources = {};

      /**
      * Mapping to table to map alignment names to number values.
      * @property alignments
      * @type Object
      * @protected
       */
      this.alignments = {
        "left": 0,
        "top": 0,
        "center": 1,
        "bottom": 2,
        "right": 2,
        "0": 0,
        "1": 1,
        "2": 2
      };

      /**
      * Mapping to table to map blend-mode names to number values.
      * @property blendModes
      * @type Object
      * @protected
       */
      this.blendModes = {
        "normal": 0,
        "add": 1,
        "sub": 2
      };

      /**
      * Mapping to table to map selector names to number values.
      * @property selectors
      * @type Object
       */
      this.selectors = {
        normal: 0,
        hover: 1,
        selected: 2,
        enabled: 3,
        focused: 4
      };
      this.defaultPlaceholderParams = {};
    }


    /**
    * Sets up UI Manager, optimizes styles, etc.
    *
    * @method setup
     */

    UIManager.prototype.setup = function() {
      return this.setupStyles();
    };


    /**
    * Sets up the UI styles by wrapping them into ui.Style objects and optimizing the access.
    *
    * @method setupStyles
    * @protected
     */

    UIManager.prototype.setupStyles = function() {
      var id, k, ref, selector, selectorMap, subs;
      id = 0;
      selectorMap = this.selectors;
      for (k in this.styles) {
        subs = k.split(" ");
        selector = subs[0].split(":");
        if (selectorMap[selector[1]]) {
          this.stylesById[id] = new ui.Style(this.styles[k], id, selectorMap[selector[1]]);
        } else {
          this.stylesById[id] = new ui.Style(this.styles[k], id, 0);
        }
        if (!this.stylesByName[selector[0]]) {
          this.stylesByName[selector[0]] = [];
        }
        this.stylesByName[selector[0]].push(this.stylesById[id]);
        this.styles[k] = this.stylesById[id];
        id++;
      }
      for (k in this.styles) {
        subs = k.split(" ");
        if (subs.length > 1) {
          this.stylesByName[subs[1]].push(this.styles[k]);
          this.styles[k].target = (ref = this.styles[k.split(":")[0]]) != null ? ref.id : void 0;
        }
      }
      return null;
    };


    /**
    * Executes all placeholder formulas in the specified descriptor. The descriptor will be changed
    * and placeholder formulas are replaced with their evaluated result value.
    *
    * @method executePlaceholderFormulas
    * @param {Object} descriptor - The descriptor.
    * @param {Object} params - Object containing the placeholder params.
    * @protected
     */

    UIManager.prototype.executePlaceholderFormulas = function(descriptor, id, params) {
      var c, i, j, k, keys, l, len, len1, v;
      if (descriptor == null) {
        return;
      }
      keys = Object.keys(descriptor);
      for (j = 0, len = keys.length; j < len; j++) {
        k = keys[j];
        v = descriptor[k];
        if (v != null) {
          if (v instanceof Array) {
            for (c = l = 0, len1 = v.length; l < len1; c = ++l) {
              i = v[c];
              if (i != null) {
                if (typeof i === "object") {
                  this.executePlaceholderFormulas(i, id, params);
                } else if (c !== "exec" && typeof i === "function") {
                  window.p = params || this.defaultPlaceholderParams;
                  window.d = descriptor;
                  v[c] = i();
                }
              }
            }
          } else if (typeof v === "object") {
            this.executePlaceholderFormulas(v, id, params);
          } else if (k !== "exec_" && typeof v === "function") {
            window.p = params || this.defaultPlaceholderParams;
            window.d = descriptor;
            descriptor[k] = v();
          }
        }
      }
      return null;
    };


    /**
    * Creates a calculation for a specified expression.
    *
    * @method createCalcFunction
    * @param {String} expression - The expression to create a calculation function for.
    * @return {Function} The calculation function.
    * @protected
     */

    UIManager.prototype.createCalcFunction = function(expression) {
      expression = expression.replace(/([0-9]+)%/gm, "($1 / 100 * v)");
      return eval("(function(v){ return " + expression + "})");
    };


    /**
    * Creates an object from the specified object type. The type has the format
    * <namespace>.<typename> like vn.Component_Hotspot.
    *
    * @method createObject
    * @param {String} type - The type name.
    * @return {Object} The created object.
    * @protected
     */

    UIManager.prototype.createObject = function(type) {
      var subs;
      subs = type.split(".");
      return new window[subs[0]][subs[1]]();
    };


    /**
    * Creates an UI object from a specified UI descriptor.
    *
    * @method createFromDescriptor
    * @param {Object} descriptor - The UI object descriptor.
    * @param {gs.Object_UIElement} parent - The UI parent object. (A layout for example).
    * @return {gs.Object_UIElement} The created UI object.
     */

    UIManager.prototype.createFromDescriptor = function(descriptor, parent) {
      var control, k;
      control = null;
      for (k in this.controllers) {
        if (this.controllers[k].type != null) {
          this.controllers[k] = this.createObject(this.controllers[k].type);
        }
      }
      return this._createFromDescriptor(descriptor, parent);
    };


    /**
    * Creates an image button UI object.
    *
    * @method createImageButton
    * @param {Object} descriptor - The UI object descriptor.
    * @return {gs.Object_UIElement} The created image button UI object.
     */

    UIManager.prototype.createImageButton = function(descriptor) {
      var control;
      control = new ui.Object_Hotspot(descriptor.image, descriptor.imageHandling);
      control.behavior.sound = descriptor.sound;
      control.behavior.sounds = descriptor.sounds;
      control.image = descriptor.image;
      control.images = descriptor.images;
      if (descriptor.imageFolder != null) {
        control.imageFolder = descriptor.imageFolder;
      }
      if (descriptor.looping != null) {
        control.visual.dispose();
        control.removeComponent(control.visual);
        control.visual = new gs.Component_TilingSprite();
        control.addComponent(control.visual);
        control.visual.looping.vertical = descriptor.looping.vertical;
        control.visual.looping.horizontal = descriptor.looping.horizontal;
      }
      if (descriptor.color != null) {
        control.color = Color.fromArray(descriptor.color);
      }
      return control;
    };


    /**
    * Creates an image UI object.
    *
    * @method createImage
    * @param {Object} descriptor - The UI object descriptor.
    * @return {gs.Object_UIElement} The created image button UI object.
     */

    UIManager.prototype.createImage = function(descriptor) {
      var control;
      control = new ui.Object_Image(descriptor.image, descriptor.imageHandling);
      if (descriptor.imageFolder != null) {
        control.imageFolder = descriptor.imageFolder;
      }
      if (descriptor.looping != null) {
        control.visual.dispose();
        control.removeComponent(control.visual);
        control.visual = new gs.Component_TilingSprite();
        control.addComponent(control.visual);
        control.visual.looping.vertical = descriptor.looping.vertical;
        control.visual.looping.horizontal = descriptor.looping.horizontal;
      }
      if (descriptor.color != null) {
        control.color = Color.fromArray(descriptor.color);
      }
      return control;
    };


    /**
    * Creates an image map UI object.
    *
    * @method createImageMap
    * @param {Object} descriptor - The UI object descriptor.
    * @return {gs.Object_UIElement} The created image button UI object.
     */

    UIManager.prototype.createImageMap = function(descriptor) {
      var control;
      control = new ui.Object_ImageMap();
      control.hotspots = (descriptor.hotspots || []).select(function(h) {
        return {
          x: h.rect[0],
          y: h.rect[1],
          size: {
            width: h.rect[2],
            height: h.rect[3]
          },
          data: {
            action: 3,
            actions: h.actions
          }
        };
      });
      control.images = descriptor.images;
      control.insertComponent(new ui.Component_ActionHandler(), 1, "actionHandler");
      control.target = SceneManager.scene.behavior;
      control.visual.variableContext = new gs.InterpreterContext(SceneManager.scene.layoutName, SceneManager.scene);
      return control;
    };


    /**
    * Creates a video UI object.
    *
    * @method createVideo
    * @param {Object} descriptor - The UI object descriptor.
    * @return {gs.Object_UIElement} The created image button UI object.
     */

    UIManager.prototype.createVideo = function(descriptor) {
      var control, ref;
      control = new ui.Object_Video();
      control.video = descriptor.video;
      control.loop = (ref = descriptor.loop) != null ? ref : true;
      return control;
    };


    /**
    * Creates a panel UI object.
    *
    * @method createPanel
    * @param {Object} descriptor - The UI object descriptor.
    * @return {gs.Object_UIElement} The created image button UI object.
     */

    UIManager.prototype.createPanel = function(descriptor) {
      var control, ref;
      control = new ui.Object_Panel();
      control.modal = (ref = descriptor.modal) != null ? ref : false;
      if (descriptor.color != null) {
        control.color = Color.fromArray(descriptor.color);
      }
      return control;
    };


    /**
    * Creates a frame UI object.
    *
    * @method createFrame
    * @param {Object} descriptor - The UI object descriptor.
    * @return {gs.Object_UIElement} The created image button UI object.
     */

    UIManager.prototype.createFrame = function(descriptor) {
      var control;
      control = new ui.Object_Frame(descriptor.frameSkin);
      control.frameThickness = descriptor.frameThickness || 16;
      control.frameCornerSize = descriptor.frameCornerSize || 16;
      control.image = descriptor.image;
      control.images = descriptor.images;
      return control;
    };


    /**
    * Creates a three-part image UI object.
    *
    * @method createThreePartImage
    * @param {Object} descriptor - The UI object descriptor.
    * @return {gs.Object_UIElement} The created image button UI object.
     */

    UIManager.prototype.createThreePartImage = function(descriptor) {
      var control;
      control = new ui.Object_ThreePartImage(descriptor.frameSkin);
      control.firstPartSize = descriptor.firstPartSize || 16;
      control.middlePartSize = descriptor.middlePartSize || 1;
      control.lastPartSize = descriptor.lastPartSize || 16;
      control.image = descriptor.image;
      control.images = descriptor.images;
      return control;
    };


    /**
    * Creates a text UI object.
    *
    * @method createText
    * @param {Object} descriptor - The UI object descriptor.
    * @return {gs.Object_UIElement} The created image button UI object.
     */

    UIManager.prototype.createText = function(descriptor) {
      var control, ref;
      control = new ui.Object_Text();
      control.text = lcs(descriptor.text);
      control.sizeToFit = descriptor.sizeToFit;
      control.formatting = descriptor.formatting;
      control.wordWrap = (ref = descriptor.wordWrap) != null ? ref : false;
      control.behavior.format = descriptor.format;
      if (descriptor.textPadding) {
        control.behavior.padding = ui.Space.fromArray(descriptor.textPadding);
      }
      if (descriptor.resolvePlaceholders != null) {
        control.resolvePlaceholders = descriptor.resolvePlaceholders;
      }
      if (descriptor.color != null) {
        control.color = Color.fromArray(descriptor.color);
      }
      return control;
    };


    /**
    * Creates a free-layout UI object.
    *
    * @method createFreeLayout
    * @param {Object} descriptor - The UI object descriptor.
    * @return {gs.Object_UIElement} The created image button UI object.
     */

    UIManager.prototype.createFreeLayout = function(descriptor) {
      var control;
      if (descriptor.frame != null) {
        control = new ui.Object_FreeLayout(descriptor.frame[0] || 0, descriptor.frame[1] || 0, descriptor.frame[2] || 1, descriptor.frame[3] || 1);
      } else {
        control = new ui.Object_FreeLayout(0, 0, 1, 1);
      }
      control.sizeToFit = descriptor.sizeToFit;
      return control;
    };


    /**
    * Creates a stack-layout UI object.
    *
    * @method createStackLayout
    * @param {Object} descriptor - The UI object descriptor.
    * @return {gs.Object_UIElement} The created image button UI object.
     */

    UIManager.prototype.createStackLayout = function(descriptor) {
      var control;
      if (descriptor.frame != null) {
        control = new ui.Object_StackLayout(descriptor.frame[0] || 0, descriptor.frame[1] || 0, descriptor.frame[2] || 1, descriptor.frame[3] || 1, descriptor.orientation);
      } else {
        control = new ui.Object_StackLayout(0, 0, 1, 1, descriptor.orientation);
      }
      control.sizeToFit = descriptor.sizeToFit;
      return control;
    };


    /**
    * Creates a spread-layout UI object.
    *
    * @method createSpreadLayout
    * @param {Object} descriptor - The UI object descriptor.
    * @return {gs.Object_UIElement} The created image button UI object.
     */

    UIManager.prototype.createSpreadLayout = function(descriptor) {
      var control;
      if (descriptor.frame != null) {
        control = new ui.Object_SpreadLayout(descriptor.frame[0] || 0, descriptor.frame[1] || 0, descriptor.frame[2] || 1, descriptor.frame[3] || 1, descriptor.orientation);
      } else {
        control = new ui.Object_SpreadLayout(0, 0, 1, 1, descriptor.orientation);
      }
      return control;
    };


    /**
    * Creates a grid-layout UI object.
    *
    * @method createGridLayout
    * @param {Object} descriptor - The UI object descriptor.
    * @return {gs.Object_UIElement} The created image button UI object.
     */

    UIManager.prototype.createGridLayout = function(descriptor) {
      var control;
      if (descriptor.frame != null) {
        control = new ui.Object_GridLayout(descriptor.frame[0], descriptor.frame[1], descriptor.frame[2], descriptor.frame[3], descriptor.rows, descriptor.columns, descriptor.template);
      } else {
        control = new ui.Object_GridLayout(0, 0, 1, 1, descriptor.rows, descriptor.columns, descriptor.template);
      }
      control.cellSpacing = descriptor.cellSpacing || [0, 0, 0, 0];
      control.sizeToFit = descriptor.sizeToFit;
      return control;
    };


    /**
    * Creates a message UI object.
    *
    * @method createMessage
    * @param {Object} descriptor - The UI object descriptor.
    * @return {gs.Object_UIElement} The created image button UI object.
     */

    UIManager.prototype.createMessage = function(descriptor) {
      var control;
      control = new ui.Object_Message();
      return control;
    };


    /**
    * Creates a data-grid UI object.
    *
    * @method createDataGrid
    * @param {Object} descriptor - The UI object descriptor.
    * @return {gs.Object_UIElement} The created image button UI object.
     */

    UIManager.prototype.createDataGrid = function(descriptor) {
      var control;
      control = new ui.Object_DataGrid(descriptor);
      return control;
    };


    /**
    * Creates an UI object depending on the object-type of the specified UI descriptor.
    *
    * @method createControl
    * @param {Object} descriptor - The UI object descriptor.
    * @return {gs.Object_UIElement} The created UI object.
    * @protected
     */

    UIManager.prototype.createControl = function(descriptor) {
      var control;
      control = null;
      switch (descriptor.type) {
        case "ui.ImageButton":
          control = this.createImageButton(descriptor);
          break;
        case "ui.Image":
          control = this.createImage(descriptor);
          break;
        case "ui.ImageMap":
          control = this.createImageMap(descriptor);
          break;
        case "ui.Video":
          control = this.createVideo(descriptor);
          break;
        case "ui.Panel":
          control = this.createPanel(descriptor);
          break;
        case "ui.Frame":
          control = this.createFrame(descriptor);
          break;
        case "ui.ThreePartImage":
          control = this.createThreePartImage(descriptor);
          break;
        case "ui.Text":
          control = this.createText(descriptor);
          break;
        case "ui.Message":
          control = this.createMessage(descriptor);
          break;
        case "ui.DataGrid":
          control = this.createDataGrid(descriptor);
          break;
        case "ui.FreeLayout":
          control = this.createFreeLayout(descriptor);
          break;
        case "ui.StackLayout":
          control = this.createStackLayout(descriptor);
          break;
        case "ui.SpreadLayout":
          control = this.createSpreadLayout(descriptor);
          break;
        case "ui.GridLayout":
          control = this.createGridLayout(descriptor);
      }
      return control;
    };

    UIManager.prototype.createLayoutRect = function(frame, control) {
      var ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7;
      if (!control.layoutRect) {
        control.layoutRect = new ui.LayoutRect();
      }
      control.layoutRect.set(0, 0, 0, 0);
      if (frame != null) {
        if (((ref = frame[0]) != null ? ref.length : void 0) != null) {
          control.layoutRect.x = this.createCalcFunction(frame[0]);
          control.dstRect.x = 0;
        } else {
          control.dstRect.x = (ref1 = descriptor.frame[0]) != null ? ref1 : control.dstRect.x;
        }
        if (((ref2 = frame[1]) != null ? ref2.length : void 0) != null) {
          control.layoutRect.y = this.createCalcFunction(frame[1]);
          control.dstRect.y = 0;
        } else {
          control.dstRect.y = (ref3 = frame[1]) != null ? ref3 : control.dstRect.y;
        }
        if (((ref4 = frame[2]) != null ? ref4.length : void 0) != null) {
          control.layoutRect.width = this.createCalcFunction(frame[2]);
          control.dstRect.width = 1;
        } else {
          control.dstRect.width = (ref5 = frame[2]) != null ? ref5 : control.dstRect.width;
        }
        if (((ref6 = frame[3]) != null ? ref6.length : void 0) != null) {
          control.layoutRect.height = this.createCalcFunction(frame[3]);
          return control.dstRect.height = 1;
        } else {
          return control.dstRect.height = (ref7 = frame[3]) != null ? ref7 : control.dstRect.height;
        }
      }
    };


    /**
    * Adds the styles defined in an array of style-names to the specified control.
    *
    * @method addControlStyles
    * @param {Object} control - The control to add the styles to.
    * @param {string[]} styles - Array of style-names to add.
     */

    UIManager.prototype.addControlStyles = function(control, styles) {
      var j, len, results, style, styleName;
      results = [];
      for (j = 0, len = styles.length; j < len; j++) {
        styleName = styles[j];
        if (this.stylesByName[styleName] != null) {
          results.push((function() {
            var l, len1, ref, results1;
            ref = this.stylesByName[styleName];
            results1 = [];
            for (l = 0, len1 = ref.length; l < len1; l++) {
              style = ref[l];
              control.styles.push(style);
              if (style.target === -1 && style.selector === 0) {
                results1.push(style.apply(control));
              } else {
                results1.push(void 0);
              }
            }
            return results1;
          }).call(this));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };


    /**
    * Creates an UI object from a specified UI descriptor. This method is called
    * recursively for all child-descriptors.
    *
    * @method createControlFromDescriptor
    * @param {Object} descriptor - The UI object descriptor.
    * @param {gs.Object_UIElement} parent - The UI parent object. (A layout for example).
    * @param {number} index - The index.
    * @return {gs.Object_UIElement} The created UI object.
    * @protected
     */

    UIManager.prototype.createControlFromDescriptor = function(descriptor, parent, index) {
      var action, actions, bindings, c, child, childControl, component, control, controls, customFields, data, formulas, i, isNumber, item, j, l, len, len1, len2, len3, m, n, o, p, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref18, ref19, ref2, ref20, ref21, ref22, ref23, ref24, ref25, ref26, ref27, ref3, ref4, ref5, ref6, ref7, ref8, ref9, style, target, type, typeName, valid;
      control = null;
      if (descriptor.style != null) {
        descriptor.styles = [descriptor.style];
        delete descriptor.style;
      }
      descriptor = Object.deepCopy(descriptor);
      this.executePlaceholderFormulas(descriptor, descriptor.id, descriptor.params);
      control = this.createControl(descriptor);
      if (control == null) {
        type = Object.deepCopy(this.customTypes[descriptor.type]);
        this.executePlaceholderFormulas(type, descriptor.id, descriptor.params);
        typeName = type.type;
        customFields = type.customFields;
        bindings = type.bindings;
        formulas = type.formulas;
        actions = type.actions;
        if (type.style != null) {
          type.styles = [type.style];
          type.style = null;
        }
        Object.mixin(type, descriptor);
        if (customFields != null) {
          Object.mixin(type.customFields, customFields);
        }
        if ((bindings != null) && bindings !== type.bindings) {
          type.bindings = type.bindings.concat(bindings);
        }
        if ((formulas != null) && formulas !== type.formulas) {
          type.formulas = type.formulas.concat(formulas);
        }
        if ((actions != null) && actions !== type.actions) {
          type.actions = actions.concat(type.actions);
        }
        type.type = typeName;
        return this.createControlFromDescriptor(type, parent);
      } else if (parent != null) {
        parent.addObject(control);
        control.index = index;
      } else {
        gs.ObjectManager.current.addObject(control);
      }
      control.ui = new ui.Component_UIBehavior();
      control.addComponent(control.ui);
      control.params = descriptor.params;
      if (descriptor.updateBehavior === "continuous") {
        control.updateBehavior = ui.UpdateBehavior.CONTINUOUS;
      }
      if (descriptor.inheritProperties) {
        control.inheritProperties = true;
      }
      if (descriptor.font != null) {
        control.font = new Font(descriptor.font.name, descriptor.font.size);
        control.font.bold = (ref = descriptor.font.bold) != null ? ref : control.font.bold;
        control.font.italic = (ref1 = descriptor.font.italic) != null ? ref1 : control.font.italic;
        control.font.smallCaps = (ref2 = descriptor.font.smallCaps) != null ? ref2 : control.font.smallCaps;
        control.font.underline = (ref3 = descriptor.font.underline) != null ? ref3 : control.font.underline;
        control.font.strikeThrough = (ref4 = descriptor.font.strikeThrough) != null ? ref4 : control.font.strikeThrough;
        if (descriptor.font.color != null) {
          control.font.color = Color.fromArray(descriptor.font.color);
        }
        if (descriptor.font.border != null) {
          control.font.border = (ref5 = descriptor.font.border) != null ? ref5 : false;
          control.font.borderSize = (ref6 = descriptor.font.borderSize) != null ? ref6 : 4;
          control.font.borderColor = new Color(0, 0, 0);
        }
        if (descriptor.font.outline != null) {
          control.font.border = (ref7 = descriptor.font.outline) != null ? ref7 : false;
          control.font.borderSize = (ref8 = descriptor.font.outline.size) != null ? ref8 : 4;
          if (descriptor.font.outline.color != null) {
            control.font.borderColor = Color.fromArray(descriptor.font.outline.color);
          } else {
            control.font.borderColor = new Color(0, 0, 0);
          }
        }
      }
      if (descriptor.components != null) {
        ref9 = descriptor.components;
        for (j = 0, len = ref9.length; j < len; j++) {
          c = ref9[j];
          m = c.module || "gs";
          component = new window[m][c.type](c.params);
          control.addComponent(component, c.id);
          control[c.id] = component;
        }
      }
      control.focusable = (ref10 = descriptor.focusable) != null ? ref10 : control.focusable;
      if (descriptor.nextKeyObject) {
        control.ui.nextKeyObjectId = descriptor.nextKeyObject;
      }
      if (descriptor.initialFocus) {
        control.ui.focus();
      }
      actions = Object.deepCopy(descriptor.action != null ? [descriptor.action] : descriptor.actions);
      if (actions != null) {
        for (l = 0, len1 = actions.length; l < len1; l++) {
          action = actions[l];
          if (action != null) {
            action.event = (ref11 = action.event) != null ? ref11 : "onAccept";
            if (action.target == null) {
              target = this.controllers != null ? this.controllers[descriptor.target] : controller;
              action.target = target || SceneManager.scene.behavior;
            }
          }
        }
        control.actions = actions;
        if (!control.findComponentById("actionHandler")) {
          control.insertComponent(new ui.Component_ActionHandler(), 1, "actionHandler");
        }
      }
      if (descriptor.id != null) {
        control.id = descriptor.id;
        gs.ObjectManager.current.setObjectById(control, control.id);
      }
      control.descriptor = descriptor;
      control.layoutRect = new Rect();
      control.layoutRect.set(0, 0, 0, 0);
      if (descriptor.frame != null) {
        if (((ref12 = descriptor.frame[0]) != null ? ref12.length : void 0) != null) {
          control.layoutRect.x = this.createCalcFunction(descriptor.frame[0]);
          control.dstRect.x = 0;
        } else {
          control.dstRect.x = (ref13 = descriptor.frame[0]) != null ? ref13 : control.dstRect.x;
        }
        if (((ref14 = descriptor.frame[1]) != null ? ref14.length : void 0) != null) {
          control.layoutRect.y = this.createCalcFunction(descriptor.frame[1]);
          control.dstRect.y = 0;
        } else {
          control.dstRect.y = (ref15 = descriptor.frame[1]) != null ? ref15 : control.dstRect.y;
        }
        if (((ref16 = descriptor.frame[2]) != null ? ref16.length : void 0) != null) {
          control.layoutRect.width = this.createCalcFunction(descriptor.frame[2]);
          control.dstRect.width = 1;
        } else {
          control.dstRect.width = (ref17 = descriptor.frame[2]) != null ? ref17 : control.dstRect.width;
        }
        if (((ref18 = descriptor.frame[3]) != null ? ref18.length : void 0) != null) {
          control.layoutRect.height = this.createCalcFunction(descriptor.frame[3]);
          control.dstRect.height = 1;
        } else {
          control.dstRect.height = (ref19 = descriptor.frame[3]) != null ? ref19 : control.dstRect.height;
        }
      }
      if (descriptor.sizeToParent != null) {
        control.sizeToParent = descriptor.sizeToParent;
      }
      if (descriptor.blendMode != null) {
        control.blendMode = this.blendModes[descriptor.blendMode];
      }
      if (descriptor.anchor != null) {
        control.anchor.set(descriptor.anchor[0], descriptor.anchor[1]);
      }
      control.opacity = (ref20 = descriptor.opacity) != null ? ref20 : 255;
      if (descriptor.minimumSize != null) {
        control.minimumSize = {
          width: descriptor.minimumSize[0],
          height: descriptor.minimumSize[1]
        };
      }
      if (descriptor.resizable != null) {
        control.resizable = descriptor.resizable;
      }
      if (descriptor.scrollable != null) {
        control.scrollable = descriptor.scrollable;
      }
      if (descriptor.fixedSize != null) {
        control.fixedSize = descriptor.fixedSize;
      }
      if (descriptor.draggable != null) {
        control.draggable = descriptor.draggable;
        control.draggable.step = 0;
        if (control.draggable.rect != null) {
          control.draggable.rect = Rect.fromArray(control.draggable.rect);
        }
        control.addComponent(new ui.Component_Draggable());
      }
      if (descriptor.bindings != null) {
        control.bindings = descriptor.bindings;
        control.insertComponent(new ui.Component_BindingHandler(), 0);
      }
      if (descriptor.formulas != null) {
        control.formulas = descriptor.formulas;
        control.insertComponent(new ui.Component_FormulaHandler(), 0);
      }
      control.dataField = descriptor.dataField;
      control.enabled = (ref21 = descriptor.enabled) != null ? ref21 : true;
      if (descriptor.selectable != null) {
        control.selectable = descriptor.selectable;
      }
      if (descriptor.group != null) {
        control.group = descriptor.group;
        gs.ObjectManager.current.addToGroup(control, control.group);
      }
      if (descriptor.customFields != null) {
        control.customFields = Object.deepCopy(descriptor.customFields);
      }
      if (descriptor.margin != null) {
        control.margin.left = descriptor.margin[0];
        control.margin.top = descriptor.margin[1];
        control.margin.right = descriptor.margin[2];
        control.margin.bottom = descriptor.margin[3];
      }
      if (descriptor.padding != null) {
        control.padding.left = descriptor.padding[0];
        control.padding.top = descriptor.padding[1];
        control.padding.right = descriptor.padding[2];
        control.padding.bottom = descriptor.padding[3];
      }
      if (descriptor.alignment != null) {
        control.alignment = this.alignments[descriptor.alignment];
      }
      control.alignmentY = this.alignments[descriptor.alignmentY || 0];
      control.alignmentX = this.alignments[descriptor.alignmentX || 0];
      control.zIndex = descriptor.zIndex || 0;
      control.order = descriptor.order || 0;
      control.chainOrder = ((ref22 = descriptor.chainOrder) != null ? ref22 : descriptor.zOrder) + ((parent != null ? parent.chainOrder : void 0) || 0);
      if (descriptor.zoom != null) {
        control.zoom = {
          x: descriptor.zoom[0] / 100,
          y: descriptor.zoom[1] / 100
        };
      }
      if (descriptor.visible != null) {
        control.visible = descriptor.visible;
      }
      if (descriptor.clipRect) {
        control.clipRect = new Rect(control.dstRect.x, control.dstRect.y, control.dstRect.width, control.dstRect.height);
      }
      if (descriptor.styles != null) {
        this.addControlStyles(control, descriptor.styles);
      }
      if (descriptor.template != null) {
        control.behavior.managementMode = ui.LayoutManagementMode.fromString(descriptor.managementMode);
        data = ui.Component_FormulaHandler.fieldValue(control, control.dataField);
        isNumber = typeof data === "number";
        if (data != null) {
          for (i = n = 0, ref23 = (ref24 = data.length) != null ? ref24 : data; 0 <= ref23 ? n < ref23 : n > ref23; i = 0 <= ref23 ? ++n : --n) {
            if ((data[i] != null) || isNumber) {
              valid = true;
              if ((descriptor.dataFilter != null) && !isNumber) {
                valid = ui.Component_Handler.checkCondition(data[i], descriptor.dataFilter);
              }
              if (valid || isNumber) {
                child = this.createControlFromDescriptor(descriptor.template, control, i);
                if ((ref25 = data[i]) != null ? ref25.dstRect : void 0) {
                  child.dstRect = ui.UIElementRectangle.fromRect(child, data[i].dstRect);
                }
                if ((child.clipRect == null) && (control.clipRect != null)) {
                  child.clipRect = control.clipRect;
                }
                control.addObject(child);
                child.index = i;
                child.order = ((ref26 = data.length) != null ? ref26 : data) - i;
                control.controls.push(child);
              }
            }
          }
        }
      }
      if (descriptor.controls && descriptor.controls.exec) {
        controls = ui.Component_FormulaHandler.fieldValue(descriptor, descriptor.controls);
      } else {
        controls = descriptor.controls;
      }
      if (controls != null) {
        for (i = o = 0, len2 = controls.length; o < len2; i = ++o) {
          item = controls[i];
          childControl = this._createFromDescriptor(item, control, i);
          if ((childControl.clipRect == null) && (control.clipRect != null)) {
            childControl.clipRect = control.clipRect;
          }
          childControl.index = i;
          childControl.origin.x = control.origin.x + control.dstRect.x;
          childControl.origin.y = control.origin.y + control.dstRect.y;
          control.addObject(childControl);
          control.controls.push(childControl);
        }
      }
      if (control.styles && control.parentsByStyle) {
        parent = control.parent;
        while (parent) {
          if (parent.styles) {
            ref27 = parent.styles;
            for (p = 0, len3 = ref27.length; p < len3; p++) {
              style = ref27[p];
              if (!control.parentsByStyle[style.id]) {
                control.parentsByStyle[style.id] = [];
              }
              control.parentsByStyle[style.id].push(parent);
            }
          }
          parent = parent.parent;
        }
      }
      if (descriptor.animations != null) {
        control.animations = Object.deepCopy(descriptor.animations);
        control.animationExecutor = new ui.Component_AnimationExecutor();
        control.addComponent(control.animationExecutor);
        control.addComponent(new ui.Component_AnimationHandler());
      }
      control.ui.updateStyle();
      control.setup();
      return control;
    };


    /**
    * Creates an UI object from a specified UI descriptor.
    *
    * @method _createFromDescriptor
    * @param {Object} descriptor - The UI object descriptor.
    * @param {gs.Object_UIElement} parent - The UI parent object. (A layout for example).
    * @return {gs.Object_UIElement} The created UI object.
    * @protected
     */

    UIManager.prototype._createFromDescriptor = function(descriptor, parent, index) {
      var control, controller;
      control = this.createControlFromDescriptor(descriptor, parent, index);
      if (descriptor.controller != null) {
        controller = this.controllers[descriptor.controller];
        control.controller = controller;
        control.addComponent(controller);
      }
      return control;
    };

    UIManager.prototype.createLayoutFromDescriptor = function(descriptor, parent, index) {
      return this._createFromDescriptor(descriptor, parent, index);
    };

    return UIManager;

  })();

  Graphics.width = $PARAMS.resolution.width;

  Graphics.height = $PARAMS.resolution.height;

  ui.UiFactory = new UIManager();

  ui.UIManager = ui.UiFactory;

}).call(this);
