// Generated by CoffeeScript 1.12.7
(function() {
  var Component_TextRenderer, RendererTextLine, RendererToken,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  RendererTextLine = (function() {

    /**
    * Stores a text line.
    *
    * @module gs.RendererTextLine
    * @class RendererTextLine
    * @memberof gs.RendererTextLine
    * @constructor
     */
    function RendererTextLine() {

      /*
      * The width of the line in pixels.
      * @property width
      * @type number
      * @protected
       */
      this.width = 0;

      /*
      * The height of the line in pixels.
      * @property width
      * @type number
      * @protected
       */
      this.height = 0;

      /*
      * The descent of the line in pixels.
      * @property descent
      * @type number
      * @protected
       */
      this.descent = 0;

      /*
      * The content of the line as token objects.
      * @property content
      * @type Object[]
      * @protected
       */
      this.content = [];
    }

    return RendererTextLine;

  })();

  gs.RendererTextLine = RendererTextLine;

  RendererToken = (function() {

    /**
    * Stores a token.
    *
    * @module gs
    * @class RendererToken
    * @memberof gs
    * @constructor
     */
    function RendererToken(code, value, font) {

      /*
      * The value of the token. That value depends on the token type. For text-tokens, it stores
      * the actual text.
      * @property content
      * @type string
       */
      this.value = value;

      /*
      * The code describes what kind of token it is. For example, if the code is "Y" it means it is a
      * style-token. If the code is <b>null</b>, it means it is a text-token.
      * @property code
      * @type string
       */
      this.code = code;

      /*
      * The format stores the font-style properties of the token like if it is italic, bold, etc. It can be <b>null</b>.
      * @property format
      * @type Object
       */
      this.format = null;

      /*
      * A plain object to store custom data within the token.
      * @property customData
      * @type Object
       */
      this.customData = {};
      if (font != null) {
        this.takeFormat(font);
      }
    }


    /**
    * Takes the style from the specified font and stores it into the format-property. The token will
    * will be rendered with that style then.
    *
    * @method takeFormat
    * @param {gs.Font} font - The font to take the style from.
     */

    RendererToken.prototype.takeFormat = function(font) {
      return this.format = font.toDataBundle();
    };


    /**
    * Applies the format-style of the token on the specified font. The font will have the style from
    * then token then.
    *
    * @method applyFormat
    * @param {gs.Font} font - The font to apply the format-style on.
     */

    RendererToken.prototype.applyFormat = function(font) {
      return font.set(this.format);
    };

    return RendererToken;

  })();

  gs.RendererToken = RendererToken;

  Component_TextRenderer = (function(superClass) {
    extend(Component_TextRenderer, superClass);


    /**
    * A text-renderer component allow to draw plain or formatted text on a
    * game object's bitmap. For formatted text, different text-codes can be
    * used to add formatting or define a placeholder.<br><br>
    *
    * A text-code uses the following syntax:<br><br>
    *
    * {code:value} <- Single Value<br />
    * {code:value1,value2,...} <- Multiple Values<br><br>
    *
    * Example:<br><br>
    *
    * "This is {Y:I}a Text{Y:N}" <- "a Text" will be italic here.<br>
    * "The value is {GN:1}" <- "{GN:1}" will be replaced for the value of the global number variable 0001.<br><br>
    *
    * For a list of all available text-codes with examples, just take a look into the offical help-file.
    *
    * @module gs
    * @class Component_TextRenderer
    * @extends gs.Component
    * @memberof gs
    * @constructor
     */

    function Component_TextRenderer() {
      Component_TextRenderer.__super__.constructor.apply(this, arguments);

      /**
      * @property currentX
      * @type number
      * @protected
       */
      this.currentX = 0;

      /**
      * @property currentY
      * @type number
      * @protected
       */
      this.currentY = 0;

      /**
      * @property currentLineHeight
      * @type number
      * @protected
       */
      this.currentLineHeight = 0;

      /**
      * @property font
      * @type gs.Font
      * @protected
       */
      this.font = new Font("Times New Roman", 22);

      /**
      * @property spaceSize
      * @type number
      * @protected
       */
      this.spaceSize = 0;

      /**
      * @property fontSize
      * @type number
      * @protected
       */
      this.fontSize = 0;

      /**
      * The left and right padding per line.
      * @property padding
      * @type number
       */
      this.padding = 0;

      /**
      * The spacing between text lines in pixels.
      * @property lineSpacing
      * @type number
       */
      this.lineSpacing = 0;
    }


    /**
    * Creates the token-object for a list-placeholder. A list-placeholder
    * allows to insert a value from a list-variable.
    *
    * @method createListToken
    * @param {Array} list - The list.
    * @param {Array} values - The values of the list-placeholder text-code.
    * @return {string} The token-object.
     */

    Component_TextRenderer.prototype.createListToken = function(list, values) {
      var index;
      index = 0;
      if (values[1] != null) {
        values = values[1].split(":");
        index = values[0];
        if (values[0] === "G") {
          index = GameManager.variableStore.numbers[parseInt(values[1]) - 1];
        } else if (values[0] === "P") {
          index = GameManager.variableStore.persistentNumbers[parseInt(values[1]) - 1];
        } else if (values[0] === "L") {
          index = GameManager.variableStore.numberValueOf({
            scope: 0,
            index: parseInt(values[1]) - 1
          });
        }
      }
      return "" + list[index];
    };


    /**
    * Parses and returns the variable identifier which is an array containing
    * the optional domain name and the variable index as: [domain, index].
    *
    * @method parseVariableIdentifier
    * @param {string} identifier - The variable identifier e.g. com.degica.vnm.default.1 or com.degica.vnm.default.VarName
    * @param {string} type - The variable type to parse: number, string, boolean or list
    * @param {string} type - The scope of the variable to parse: 0 = local, 1 = global, 2 = persistent.
    * @return {Array} An array containing two values as: [domain, index]. If the identifier doesn't contain a domain-string, the domain will be 0 (default).
     */

    Component_TextRenderer.prototype.parseVariableIdentifier = function(identifier, type, scope) {
      var index, result;
      result = [0, identifier];
      if (isNaN(identifier)) {
        index = identifier.lastIndexOf(".");
        if (index !== -1) {
          result[0] = identifier.substring(0, index);
          result[1] = identifier.substring(index + 1);
          if (isNaN(result[1])) {
            result[1] = GameManager.variableStore.indexOfVariable(result[1], type, scope, result[0]) + 1;
          } else {
            result[1] = parseInt(result[1]);
          }
        } else {
          result[1] = GameManager.variableStore.indexOfVariable(result[1], type, scope, result[0]) + 1;
        }
      } else {
        result[1] = parseInt(result[1]);
      }
      return result;
    };


    /**
    * Creates a token-object for a specified text-code.
    *
    * @method createToken
    * @param {string} code - The code/type of the text-code.
    * @param {string} value - The value of the text-code.
    * @return {Object} The token-object.
     */

    Component_TextRenderer.prototype.createToken = function(code, value) {
      var format, listIdentifier, macro, pair, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, tokenObject, values;
      tokenObject = null;
      value = isNaN(value) ? value : parseInt(value);
      switch (code) {
        case "SZ":
          tokenObject = new gs.RendererToken(code, value);
          this.font.size = tokenObject.value || this.fontSize;
          this.spaceSize = this.font.measureTextPlain(" ");
          break;
        case "Y":
          tokenObject = {
            code: code,
            value: value
          };
          switch (value) {
            case "U":
              this.font.underline = true;
              break;
            case "S":
              this.font.strikeThrough = true;
              break;
            case "I":
              this.font.italic = true;
              break;
            case "B":
              this.font.bold = true;
              break;
            case "C":
              this.font.smallCaps = true;
              break;
            case "NU":
              this.font.underline = false;
              break;
            case "NS":
              this.font.strikeThrough = false;
              break;
            case "NI":
              this.font.italic = false;
              break;
            case "NB":
              this.font.bold = false;
              break;
            case "NC":
              this.font.smallCaps = false;
              break;
            case "N":
              this.font.underline = false;
              this.font.strikeThrough = false;
              this.font.italic = false;
              this.font.bold = false;
              this.font.smallCaps = false;
          }
          this.spaceSize = this.font.measureTextPlain(" ");
          break;
        case "C":
          tokenObject = new gs.RendererToken(code, value);
          if (isNaN(value)) {
            this.font.color = gs.Color.fromHex(value);
          } else if (value <= 0) {
            this.font.color = Font.defaultColor;
          } else {
            this.font.color = gs.Color.fromObject(RecordManager.system.colors[value - 1] || Font.defaultColor);
          }
          break;
        case "GN":
          values = isNaN(value) ? value.split(",") : [value];
          if (values[1]) {
            format = values[1];
            values = this.parseVariableIdentifier(values[0], "number", 1);
            tokenObject = sprintf("%" + format + "d", GameManager.variableStore.numbersByDomain[values[0] || 0][values[1] - 1] || 0);
          } else {
            values = this.parseVariableIdentifier(values[0], "number", 1);
            tokenObject = (GameManager.variableStore.numbersByDomain[values[0] || 0][values[1] - 1] || 0).toString();
          }
          break;
        case "GT":
          values = this.parseVariableIdentifier(value, "string", 1);
          tokenObject = GameManager.variableStore.stringsByDomain[values[0] || 0][values[1] - 1] || "";
          tokenObject = tokenObject.split(/\{([A-z]+):([^\{\}]+)\}|(\n)/gm);
          if (tokenObject.length > 1) {
            tokenObject.pop();
          } else {
            tokenObject = (ref = tokenObject[0]) != null ? ref : "";
          }
          break;
        case "GS":
          values = this.parseVariableIdentifier(value, "boolean", 1);
          tokenObject = (GameManager.variableStore.booleansByDomain[values[0] || 0][values[1] - 1] || false).toString();
          break;
        case "GL":
          values = value.split(",");
          listIdentifier = this.parseVariableIdentifier(values[0], "list", 1);
          tokenObject = this.createListToken(GameManager.variableStore.listsByDomain[listIdentifier[0]][listIdentifier[1] - 1] || [], values);
          break;
        case "PN":
          values = isNaN(value) ? value.split(",") : [value];
          if (values[1]) {
            format = values[1];
            values = this.parseVariableIdentifier(values[0], "number", 2);
            tokenObject = sprintf("%" + format + "d", ((ref1 = GameManager.variableStore.persistentNumbers[values[0]]) != null ? ref1[values[1] - 1] : void 0) || 0);
          } else {
            values = this.parseVariableIdentifier(values[0], "number", 2);
            tokenObject = (((ref2 = GameManager.variableStore.persistentNumbersByDomain[values[0] || 0]) != null ? ref2[values[1] - 1] : void 0) || 0).toString();
          }
          break;
        case "PT":
          values = this.parseVariableIdentifier(value, "string", 2);
          tokenObject = ((ref3 = GameManager.variableStore.persistentStringsByDomain[values[0]]) != null ? ref3[values[1] - 1] : void 0) || "";
          tokenObject = tokenObject.split(/\{([A-z]+):([^\{\}]+)\}|(\n)/gm);
          if (tokenObject.length > 1) {
            tokenObject.pop();
          } else {
            tokenObject = (ref4 = tokenObject[0]) != null ? ref4 : "";
          }
          break;
        case "PS":
          values = this.parseVariableIdentifier(value, "boolean", 2);
          tokenObject = (((ref5 = GameManager.variableStore.persistentBooleansByDomain[values[0]]) != null ? ref5[values[1] - 1] : void 0) || false).toString();
          break;
        case "PL":
          values = value.split(",");
          listIdentifier = this.parseVariableIdentifier(values[0], "list", 2);
          tokenObject = this.createListToken(((ref6 = GameManager.variableStore.persistentListsByDomain[listIdentifier[0]]) != null ? ref6[listIdentifier[1] - 1] : void 0) || [], values);
          break;
        case "LN":
          values = isNaN(value) ? value.split(",") : [value];
          if (values[1]) {
            format = values[1];
            values = this.parseVariableIdentifier(values[0], "number", 0);
            tokenObject = sprintf("%" + format + "d", GameManager.variableStore.numberValueOf({
              scope: 0,
              index: values[1] - 1
            }) || 0);
          } else {
            values = this.parseVariableIdentifier(values[0], "number", 0);
            tokenObject = (GameManager.variableStore.numberValueOf({
              scope: 0,
              index: values[1] - 1
            }) || 0).toString();
          }
          break;
        case "LT":
          values = this.parseVariableIdentifier(value, "string", 0);
          tokenObject = (GameManager.variableStore.stringValueOf({
            scope: 0,
            index: values[1] - 1
          }) || "").toString();
          tokenObject = tokenObject.split(/\{([A-z]+):([^\{\}]+)\}|(\n)/gm);
          if (tokenObject.length > 1) {
            tokenObject.pop();
          } else {
            tokenObject = (ref7 = tokenObject[0]) != null ? ref7 : "";
          }
          break;
        case "LS":
          values = this.parseVariableIdentifier(value, "boolean", 0);
          tokenObject = (GameManager.variableStore.booleanValueOf({
            scope: 0,
            index: values[1] - 1
          }) || false).toString();
          break;
        case "LL":
          values = value.split(",");
          listIdentifier = this.parseVariableIdentifier(values[0], "list", 0);
          tokenObject = this.createListToken(GameManager.variableStore.listObjectOf({
            scope: 0,
            index: listIdentifier[1] - 1
          }) || [], values);
          break;
        case "N":
          tokenObject = (RecordManager.characters[value] != null ? lcs(RecordManager.characters[value].name) : "");
          break;
        case "RT":
          pair = value.split("/");
          tokenObject = {
            code: code,
            rtStyleId: (ref8 = pair[2]) != null ? ref8 : 0,
            rb: pair[0],
            rt: pair[1],
            rbSize: {
              width: 0,
              height: 0
            },
            rtSize: {
              width: 0,
              height: 0
            }
          };
          break;
        case "M":
          macro = RecordManager.system.textMacros.first(function(m) {
            return m.name === value;
          });
          if (macro) {
            if (macro.type === 0) {
              tokenObject = macro.content.split(/\{([A-z]+):([^\{\}]+)\}|(\n)/gm);
              tokenObject.pop();
            } else if (macro.type === 1) {
              if (!macro.contentFunc) {
                macro.contentFunc = eval("(function(object, value){ " + macro.content + " })");
              }
              tokenObject = macro.contentFunc(this.object, value);
              tokenObject = tokenObject.split(/\{([A-z]+):([^\{\}]+)\}|(\n)/gm);
              if (tokenObject.length > 1) {
                tokenObject.pop();
              }
            } else {
              if (!macro.contentFunc) {
                macro.contentFunc = eval("(function(object){ " + macro.content + " })");
              }
              tokenObject = new gs.RendererToken("X", macro.contentFunc);
            }
          } else {
            tokenObject = "";
          }
          break;
        default:
          tokenObject = new gs.RendererToken(code, value);
      }
      return tokenObject;
    };


    /**
    * <p>Gets the correct font for the specified ruby-text token.</p>
    *
    * @param {Object} token - A ruby-text token.
    * @return {gs.Font} The font for the ruby-text which is shown above the original text.
    * @method getRubyTextFont
     */

    Component_TextRenderer.prototype.getRubyTextFont = function(token) {
      var font, ref, style;
      style = null;
      font = null;
      if (token.rtStyleId) {
        style = ui.UIManager.styles["rubyText-" + token.rtStyleId];
      }
      if (!style) {
        style = ui.UIManager.styles["rubyText"];
      }
      font = (ref = style != null ? style.font : void 0) != null ? ref : this.font;
      font.size = font.size || this.font.size / 2;
      return font;
    };


    /**
    * <p>Measures a control-token. If a token produces a visual result like displaying an icon then it must return the size taken by
    * the visual result. If the token has no visual result, <b>null</b> must be returned. This method is called for every token when the message is initialized.</p>
    *
    * @param {Object} token - A control-token.
    * @return {gs.Size} The size of the area taken by the visual result of the token or <b>null</b> if the token has no visual result.
    * @method measureControlToken
    * @protected
     */

    Component_TextRenderer.prototype.measureControlToken = function(token) {
      var animation, font, fs, imageBitmap, size;
      size = null;
      switch (token.code) {
        case "A":
          animation = RecordManager.animations[Math.max(token.value - 1, 0)];
          if ((animation != null ? animation.graphic.name : void 0) != null) {
            imageBitmap = ResourceManager.getBitmap("Graphics/Pictures/" + animation.graphic.name);
            if (imageBitmap != null) {
              size = {
                width: Math.round(imageBitmap.width / animation.framesX),
                height: Math.round(imageBitmap.height / animation.framesY)
              };
            }
          }
          break;
        case "RT":
          font = this.getRubyTextFont(token);
          fs = font.size;
          font.size = font.size || this.font.size / 2;
          token.rbSize = this.font.measureTextPlain(token.rb);
          token.rtSize = font.measureTextPlain(token.rt);
          font.size = fs;
          size = {
            width: Math.max(token.rbSize.width, token.rtSize.width),
            height: token.rbSize.height + token.rtSize.height
          };
      }
      return size;
    };


    /**
    * <p>Draws the visual result of a token, like an icon for example, to the specified bitmap. This method is called for every token while the text is rendered.</p>
    *
    * @param {Object} token - A control-token.
    * @param {gs.Bitmap} bitmap - The bitmap used for the current text-line. Can be used to draw something on it like an icon, etc.
    * @param {number} offset - An x-offset for the draw-routine.
    * @method drawControlToken
    * @protected
     */

    Component_TextRenderer.prototype.drawControlToken = function(token, bitmap, offset) {
      var animation, font, fs, imageBitmap, rect, ref, ref1, style;
      switch (token.code) {
        case "A":
          animation = RecordManager.animations[Math.max(token.value - 1, 0)];
          if ((animation != null ? animation.graphic.name : void 0) != null) {
            imageBitmap = ResourceManager.getBitmap("Graphics/Pictures/" + animation.graphic.name);
            if (imageBitmap != null) {
              rect = new gs.Rect(0, 0, Math.round(imageBitmap.width / animation.framesX), Math.round(imageBitmap.height / animation.framesY));
              return bitmap.blt(offset, this.currentY, imageBitmap, rect);
            }
          }
          break;
        case "RT":
          style = null;
          if (token.rtStyleId) {
            style = ui.UIManager.styles["rubyText-" + token.rtStyleId];
          }
          if (!style) {
            style = ui.UIManager.styles["rubyText"];
          }
          font = (ref = style != null ? style.font : void 0) != null ? ref : this.object.font;
          fs = font.size;
          font.size = font.size || this.object.font.size / 2;
          if (style && !((ref1 = style.descriptor.font) != null ? ref1.color : void 0)) {
            font.color.set(this.object.font.color);
          }
          bitmap.font = font;
          bitmap.drawText(offset, bitmap.font.descent, Math.max(token.rbSize.width, token.rtSize.width), bitmap.height, token.rt, 1, 0);
          bitmap.font = this.object.font;
          font.size = fs;
          return bitmap.drawText(offset, token.rtSize.height, Math.max(token.rbSize.width, token.rtSize.width), bitmap.height, token.rb, 1, 0);
      }
    };


    /**
    * Splits up the specified token using a japanese word-wrap technique.
    *
    * @method wordWrapJapanese
    * @param {Object} token - The token to split up.
    * @param {gs.RendererTextLine} line - The current line.
    * @param {number} width - The width of the current line.
    * @param {number} height - The height of the current line.
    * @param {gs.RendererTextLine[]} - An array of lines. If the token is split up into multiple lines, all new
    * lines are added to this result array.
    * @return {gs.RendererTextLine} The current line, that may be the same as the <b>line</b> parameters but if new lines
    * are created it has to be the last new created line.
     */

    Component_TextRenderer.prototype.wordWrapJapanese = function(token, line, width, height, result) {
      var ch, depth, depthLevel, descent, endOfLine, i, j, lastCharacterIndex, moved, noSplit, size, startOfLine;
      startOfLine = '—…‥〳〴〵。.・、:;, ?!‼⁇⁈⁉‐゠–〜)]｝〕〉》」』】〙〗〟’"｠»ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻';
      endOfLine = '([｛〔〈《「『【〘〖〝‘"｟«';
      noSplit = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789０１２３４５６７８９—…‥〳〴〵';
      descent = this.font.descent;
      size = this.font.measureTextPlain(token);
      depth = 8;
      depthLevel = 0;
      i = 0;
      j = 0;
      lastCharacterIndex = 0;
      if (size.width > this.object.dstRect.width - this.spaceSize.width * 3 - this.padding * 2) {
        while (i < token.length) {
          ch = token[i];
          size = this.font.measureTextPlain(ch);
          width += size.width;
          moved = false;
          if (width > this.object.dstRect.width - this.padding * 2) {
            depthLevel = 0;
            j = i;
            while (true) {
              moved = false;
              while (j > 0 && startOfLine.indexOf(token[j]) !== -1) {
                j--;
                moved = true;
              }
              while (j > 0 && endOfLine.indexOf(token[j - 1]) !== -1) {
                j--;
                moved = true;
              }
              while (j > 0 && noSplit.indexOf(token[j - 1]) !== -1) {
                j--;
                moved = true;
              }
              if (j === 0 && moved) {
                break;
              } else {
                i = j;
              }
              depthLevel++;
              if (depthLevel >= depth || !moved) {
                break;
              }
            }
            line.content.push(new gs.RendererToken(null, token.substring(lastCharacterIndex, i), this.font));
            lastCharacterIndex = i;
            line.height = Math.max(height, this.font.lineHeight);
            line.width = width - size.width;
            line.descent = descent;
            descent = this.font.descent;
            height = size.height;
            result.push(line);
            line = new gs.RendererTextLine();
            width = width - (width - size.width);
          }
          i++;
        }
      } else {
        line.content.push(new gs.RendererToken(null, token, this.font));
        line.height = Math.max(height, this.font.lineHeight);
        line.width = width + size.width;
        line.descent = descent;
      }
      height = Math.max(height, this.font.lineHeight);
      if (lastCharacterIndex !== i) {
        line.content.push(new gs.RendererToken(null, token.substring(lastCharacterIndex, i), this.font));
        line.width = width;
        line.height = Math.max(height, line.height);
        line.descent = descent;
      }
      return line;
    };


    /**
    * Does not word-wrapping at all. It just adds the text token to the line as is.
    *
    * @method wordWrapNone
    * @param {Object} token - The token to split up.
    * @param {gs.RendererTextLine} line - The current line.
    * @param {number} width - The width of the current line.
    * @param {number} height - The height of the current line.
    * @param {gs.RendererTextLine[]} - An array of lines. If the token is split up into multiple lines, all new
    * lines are added to this result array.
    * @return {gs.RendererTextLine} The current line, that may be the same as the <b>line</b> parameters but if new lines
    * are created it has to be the last new created line.
     */

    Component_TextRenderer.prototype.wordWrapNone = function(token, line, width, height, result) {
      var size;
      size = this.font.measureTextPlain(token);
      height = Math.max(size.height, height || this.font.lineHeight);
      if (token.length > 0) {
        width += size.width;
        line.width = width;
        line.height = Math.max(height, line.height);
        line.descent = this.font.descent;
        line.content.push(new gs.RendererToken(null, token));
      }
      return line;
    };


    /**
    * Splits up the specified token using a space-based word-wrap technique.
    *
    * @method wordWrapSpaceBased
    * @param {Object} token - The token to split up.
    * @param {gs.RendererTextLine} line - The current line.
    * @param {number} width - The width of the current line.
    * @param {number} height - The height of the current line.
    * @param {gs.RendererTextLine[]} - An array of lines. If the token is split up into multiple lines, all new
    * lines are added to this result array.
    * @return {gs.RendererTextLine} The current line, that may be the same as the <b>line</b> parameters but if new lines
    * are created it has to be the last new created line.
     */

    Component_TextRenderer.prototype.wordWrapSpaceBased = function(token, line, width, height, result) {
      var currentWords, descent, i, k, len, size, word, words;
      currentWords = [];
      words = token.split(" ");
      descent = this.font.descent;
      this.spaceSize = this.font.measureTextPlain(" ");
      for (i = k = 0, len = words.length; k < len; i = ++k) {
        word = words[i];
        size = this.font.measureTextPlain(word);
        width += size.width + this.spaceSize.width;
        if (width > this.object.dstRect.width - this.padding * 2) {
          token = new gs.RendererToken(null, currentWords.join(" "));
          token.takeFormat(this.font);
          line.content.push(token);
          line.height = Math.max(height, line.height);
          line.width = width - size.width;
          line.descent = Math.max(line.descent, descent);
          descent = Math.max(descent, this.font.descent);
          height = size.height;
          result.push(line);
          line = new gs.RendererTextLine();
          currentWords = [word];
          width = width - (width - size.width);
        } else {
          currentWords.push(word);
        }
        height = Math.max(height, this.font.lineHeight);
      }
      if (currentWords.length > 0) {
        token = new gs.RendererToken(null, currentWords.join(" "));
        token.takeFormat(this.font);
        line.content.push(token);
        line.width = width;
        line.height = Math.max(height, line.height);
        line.descent = Math.max(descent, line.descent);
      }
      return line;
    };


    /**
    * Splits up the specified token using a word-wrap technique. The kind of word-wrap technique
    * depends on the selected language. You can overwrite this method in derived classes to implement your
    * own custom word-wrap techniques.
    *
    * @method executeWordWrap
    * @param {Object} token - The token to split up.
    * @param {gs.RendererTextLine} line - The current line.
    * @param {number} width - The width of the current line.
    * @param {number} height - The height of the current line.
    * @param {gs.RendererTextLine[]} - An array of lines. If the token is split up into multiple lines, all new
    * lines are added to this result array.
    * @return {gs.RendererTextLine} The current line, that may be the same as the <b>line</b> parameters but if new lines
    * are created it has to be the last new created line.
     */

    Component_TextRenderer.prototype.executeWordWrap = function(token, line, width, height, result, wordWrap) {
      if (wordWrap) {
        switch (LanguageManager.language.wordWrap) {
          case "spaceBased":
            return this.wordWrapSpaceBased(token, line, width, height, result);
          case "japanese":
            return this.wordWrapJapanese(token, line, width, height, result);
        }
      } else {
        return this.wordWrapNone(token, line, width, height, result);
      }
    };


    /**
    * Creates an a of line-objects. Each line-object is a list of token-objects.
    * A token-object can be just a string or an object containing more information
    * about how to process the token at runtime.
    *
    * A line-object also contains additional information like the width and height
    * of the line(in pixels).
    *
    * If the wordWrap param is set, line-breaks are automatically created if a line
    * doesn't fit into the width of the game object's bitmap.
    *
    * @method calculateLines
    * @param {string} message - A message creating the line-objects for.
    * @param {boolean} wordWrap - If wordWrap is set to true, line-breaks are automatically created.
    * @param {number} [firstLineWidth=0] - The current width of the first line.
    * @return {Array} An array of line-objects.
     */

    Component_TextRenderer.prototype.calculateLines = function(message, wordWrap, firstLineWidth) {
      var bold, currentWords, descent, height, italic, line, result, size, smallCaps, strikeThrough, t, token, tokenObject, tokens, underline, width;
      result = [];
      line = new gs.RendererTextLine();
      width = firstLineWidth || 0;
      height = 0;
      descent = this.font.descent;
      currentWords = [];
      size = null;
      this.spaceSize = this.font.measureChar(" ");
      this.fontSize = this.font.size;
      tokens = message.split(/\{([A-z]+):([^\{\}]+)\}|(\n)/gm);
      token = null;
      t = 0;
      underline = this.font.underline;
      strikeThrough = this.font.strikeThrough;
      italic = this.font.italic;
      bold = this.font.bold;
      smallCaps = this.font.smallCaps;
      while (t < tokens.length) {
        token = tokens[t];
        if (t % 4 !== 0) {
          if (token != null) {
            tokenObject = this.createToken(token, tokens[t + 1]);
            if (tokenObject.push != null) {
              Array.prototype.splice.apply(tokens, [t + 3, 0].concat(tokenObject));
            } else if (tokenObject.code == null) {
              tokens[t + 3] = tokenObject + tokens[t + 3];
            } else {
              size = this.measureControlToken(tokenObject);
              if (size) {
                width += size.width;
                height = Math.max(height, size.height);
              }
              line.content.push(tokenObject);
            }
          } else {
            line.height = height || this.font.lineHeight;
            line.width = width;
            line.descent = descent;
            result.push(line);
            line = new gs.RendererTextLine();
            line.content.push(new gs.RendererToken(null, "\n", this.font));
            width = 0;
            height = 0;
            descent = this.font.descent;
          }
          t += 2;
        } else if (token.length > 0) {
          line = this.executeWordWrap(token, line, width, height, result, wordWrap);
          width = line.width;
          height = line.height;
          descent = line.descent;
        }
        t++;
      }
      if (line.content.length > 0 || result.length === 0) {
        line.height = height;
        line.width = width;
        line.descent = descent;
        result.push(line);
      }
      this.font.size = this.fontSize;
      this.font.underline = underline;
      this.font.strikeThrough = strikeThrough;
      this.font.italic = italic;
      this.font.bold = bold;
      this.font.smallCaps = smallCaps;
      return result;
    };


    /**
    * Measures the dimensions of formatted lines in pixels. The result is not
    * pixel-perfect.
    *
    * @method measureFormattedLines
    * @param {gs.RendererTextLine[]} lines - An array of text lines to measure.
    * @param {boolean} wordWrap - If wordWrap is set to true, automatically created line-breaks will be calculated.
    * @result {Object} An object containing the width and height of the text.
     */

    Component_TextRenderer.prototype.measureFormattedLines = function(lines, wordWrap) {
      var k, len, line, size;
      size = {
        width: 0,
        height: 0
      };
      for (k = 0, len = lines.length; k < len; k++) {
        line = lines[k];
        size.width = Math.max(line.width + 2, size.width);
        size.height += line.height + this.lineSpacing;
      }
      size.height -= this.lineSpacing;
      return size;
    };


    /**
    * Measures the dimensions of a formatted text in pixels. The result is not
    * pixel-perfect.
    *
    * @method measureFormattedText
    * @param {string} text - The text to measure.
    * @param {boolean} wordWrap - If wordWrap is set to true, automatically created line-breaks will be calculated.
    * @result {Object} An object containing the width and height of the text.
     */

    Component_TextRenderer.prototype.measureFormattedText = function(text, wordWrap) {
      var lines, size;
      this.font.set(this.object.font);
      size = null;
      lines = this.calculateLines(text, wordWrap);
      size = this.measureFormattedLines(lines, wordWrap);
      return size;
    };


    /**
    * Measures the dimensions of a plain text in pixels. Formatting and
    * word-wrapping are not supported.
    *
    * @method measureText
    * @param {string} text - The text to measure.
    * @result {Object} An object containing the width and height of the text.
     */

    Component_TextRenderer.prototype.measureText = function(text) {
      var k, len, line, lineSize, lines, size;
      size = {
        width: 0,
        height: 0
      };
      lines = text.toString().split("\n");
      for (k = 0, len = lines.length; k < len; k++) {
        line = lines[k];
        lineSize = this.object.font.measureText(text);
        size.width = Math.max(size.width, lineSize.width);
        size.height += this.object.font.lineHeight + this.lineSpacing;
      }
      size.height -= this.lineSpacing;
      return size;
    };


    /**
    * Searches for a token in a list of tokens and returns the first match.
    *
    * @method findToken
    * @param {number} startIndex - The index in the list of tokens where the search will start.
    * @param {string} code - The code of the token to search for.
    * @param {number} direction - The search direction, can be forward(1) or backward(-1).
    * @param {Object[]} tokens - The list of tokens to search.
    * @result {Object} The first token which matches the specified code or <b>null</b> if the token cannot be found.
     */

    Component_TextRenderer.prototype.findToken = function(startIndex, code, direction, tokens) {
      var i, t, token;
      token = null;
      i = startIndex;
      if (direction === -1) {
        while (i >= 0) {
          t = tokens[i];
          if (t.code === code) {
            token = t;
            break;
          }
          i--;
        }
      }
      return token;
    };


    /**
    * Searches for a specific kind of tokens between a start and an end token.
    *
    * @method findTokensBetween
    * @param {number} startIndex - The index where the search will start.
    * @param {number} endIndex - The index where the search will end.
    * @param {string} code - The code of the token-type to search for.
    * @param {Object[]} tokens - The list of tokens to search.
    * @result {Object[]} List of tokens matching the specified code. Its an empty list if no tokens were found.
     */

    Component_TextRenderer.prototype.findTokensBetween = function(startIndex, endIndex, code, tokens) {
      var e, result, s, token;
      result = [];
      s = startIndex;
      e = endIndex;
      while (s < e) {
        token = tokens[s];
        if (token.code == code) {
          result.push(token);
        }
        s++;
      }
      return result;
    };


    /**
    * Processes a control-token. A control-token is a token which influences
    * the text-rendering like changing the fonts color, size or style.
    *
    * Changes will be automatically applied to the game object's font.
    *
    * @method processControlToken
    * @param {Object} token - A control-token.
    * @return {Object} An object which can contain additional info needed for processing.
     */

    Component_TextRenderer.prototype.processControlToken = function(token) {
      var result;
      result = null;
      switch (token.code) {
        case "SZ":
          this.object.font.size = token.value || this.fontSize;
          break;
        case "C":
          if (isNaN(token.value)) {
            this.object.font.color = gs.Color.fromHex(token.value);
          } else if (token.value <= 0) {
            this.object.font.color = Font.defaultColor;
          } else {
            this.object.font.color = RecordManager.system.colors[token.value - 1] || Font.defaultColor;
          }
          break;
        case "Y":
          switch (token.value) {
            case "U":
              this.object.font.underline = true;
              break;
            case "S":
              this.object.font.strikeThrough = true;
              break;
            case "I":
              this.object.font.italic = true;
              break;
            case "B":
              this.object.font.bold = true;
              break;
            case "C":
              this.object.font.smallCaps = true;
              break;
            case "NU":
              this.object.font.underline = false;
              break;
            case "NS":
              this.object.font.strikeThrough = false;
              break;
            case "NI":
              this.object.font.underline = false;
              break;
            case "NB":
              this.object.font.bold = false;
              break;
            case "NC":
              this.object.font.smallCaps = false;
              break;
            case "N":
              this.object.font.underline = false;
              this.object.font.strikeThrough = false;
              this.object.font.italic = false;
              this.object.font.bold = false;
              this.object.font.smallCaps = false;
          }
      }
      return result;
    };


    /**
    * Draws a plain text. Formatting and word-wrapping are not supported.
    *
    * @method drawText
    * @param {number} x - The x-coordinate of the text's position.
    * @param {number} y - The y-coordinate of the text's position.
    * @param {number} width - Deprecated. Can be null.
    * @param {number} height - Deprecated. Can be null.
    * @param {string} text - The text to draw.
     */

    Component_TextRenderer.prototype.drawText = function(pl, pt, pr, pb, text) {
      var font, height, i, k, len, line, lines, size;
      lines = text.toString().split("\n");
      font = this.object.font;
      height = font.lineHeight;
      for (i = k = 0, len = lines.length; k < len; i = ++k) {
        line = lines[i];
        size = font.measureText(line);
        this.object.bitmap.drawText(pl, i * height + pt, size.width + pr + pl, height + pt + pb, line, 0, 0);
      }
      return null;
    };


    /**
    * Draws an array of formatted text lines.
    * If the wordWrap param is set, line-breaks are automatically created if a line
    * doesn't fit into the width of the game object's bitmap.
    *
    * @method drawFormattedLines
    * @param {number} pl - The left-padding of the text's position.
    * @param {number} pt - The top-padding of the text's position.
    * @param {number} pr - The right-padding of the text's position.
    * @param {number} pb - The bottom-padding of the text's position.
    * @param {gs.RendererTextLine[]} lines - An array of lines to draw.
    * @param {boolean} wordWrap - If wordWrap is set to true, line-breaks are automatically created.
     */

    Component_TextRenderer.prototype.drawFormattedLines = function(pl, pt, pr, pb, lines, wordWrap) {
      var font, height, k, l, len, len1, line, ref, size, token;
      this.currentX = pl;
      this.currentY = pt;
      this.currentLineHeight = 0;
      for (k = 0, len = lines.length; k < len; k++) {
        line = lines[k];
        ref = line.content;
        for (l = 0, len1 = ref.length; l < len1; l++) {
          token = ref[l];
          if (token.code != null) {
            this.processControlToken(token);
            size = this.measureControlToken(token);
            if (size) {
              this.drawControlToken(token, this.object.bitmap, this.currentX);
              this.currentX += size.width;
            }
          } else if (token.value.length > 0) {
            font = this.object.font;
            height = line.height;
            if (token.value !== "\n") {
              size = font.measureTextPlain(token.value);
              this.object.bitmap.drawText(this.currentX, this.currentY + height - size.height + font.descent - line.descent, size.width + pl + pr, height + pt + pb, token.value, 0, 0);
              this.currentX += size.width;
            }
            this.currentLineHeight = Math.max(this.currentLineHeight, height);
          }
        }
        this.currentY += (this.currentLineHeight || this.object.font.lineHeight) + this.lineSpacing;
        this.currentX = pl;
        this.currentLineHeight = 0;
      }
      return null;
    };


    /**
    * Draws a formatted text.
    * If the wordWrap param is set, line-breaks are automatically created if a line
    * doesn't fit into the width of the game object's bitmap.
    *
    * @method drawFormattedText
    * @param {number} x - The x-coordinate of the text's position.
    * @param {number} y - The y-coordinate of the text's position.
    * @param {number} width - Deprecated. Can be null.
    * @param {number} height - Deprecated. Can be null.
    * @param {string} text - The text to draw.
    * @param {boolean} wordWrap - If wordWrap is set to true, line-breaks are automatically created.
    * @return {gs.RendererTextLine[]} The drawn text lines.
     */

    Component_TextRenderer.prototype.drawFormattedText = function(pl, pt, pr, pb, text, wordWrap) {
      var lines;
      lines = this.calculateLines(text.toString(), wordWrap);
      this.drawFormattedLines(pl, pt, pr, pb, lines, wordWrap);
      return lines;
    };

    return Component_TextRenderer;

  })(gs.Component);

  gs.Component_TextRenderer = Component_TextRenderer;

}).call(this);
