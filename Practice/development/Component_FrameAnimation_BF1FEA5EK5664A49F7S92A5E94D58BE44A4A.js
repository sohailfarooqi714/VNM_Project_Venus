// Generated by CoffeeScript 1.12.7
(function() {
  var Component_FrameAnimation,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Component_FrameAnimation = (function(superClass) {
    extend(Component_FrameAnimation, superClass);


    /**
    * Executes a classic image-frame animation defined in Database. The image in regular
    * contains multiple sub-images (frames) which are then animated
    * by modifying the <b>srcRect</b> property of the game object.
    *
    * @module gs
    * @class Component_FrameAnimation
    * @extends gs.Component_Animation
    * @memberof gs
    * @constructor
    * @param {Object} record - The animation database-record.
     */

    function Component_FrameAnimation(record) {
      Component_FrameAnimation.__super__.constructor.apply(this, arguments);

      /**
      * The database record.
      * @property record
      * @type Object
       */
      this.record = null;

      /**
      * The name of the animation defined in Database.
      * @property name
      * @type string
       */
      this.name = null;

      /**
      * The amount of frames on x-axis.
      * @property framesX
      * @type number
       */
      this.framesX = 1;

      /**
      * The amount of frames on y-axis.
      * @property framesY
      * @type number
       */
      this.framesY = 1;

      /**
      * The frame-range to animation like only Frame 4 - 6 for example.
      * @property frameRange
      * @type gs.Range
       */
      this.frameRange = {
        start: 0,
        end: 0
      };

      /**
      * The frame-range used if the animation gets repeated.
      * @property repetitionFrameRange
      * @type gs.Range
       */
      this.repetitionFrameRange = this.frameRange;

      /**
      * The amount of frames to animate.
      * @property frameCount
      * @type number
      * @protected
       */
      this.frameCount = 1;

      /**
      * The graphic used as image for the animation.
      * @property graphic
      * @type Object
       */
      this.graphic = null;

      /**
      * Indicates if the animation repeats.
      * @property repeat
      * @type boolean
       */
      this.repeat = false;

      /**
      * The position of the animation on the target-object.
      * @property framesY
      * @type gs.AnimationPosition
       */
      this.position = 0;

      /**
      * The duration of a single frame.
      * @property frameDuration
      * @type number
      * @protected
       */
      this.frameDuration = 10;

      /**
      * A frame-counter needed for animation-process.
      * @property frameDuration
      * @type number
      * @protected
       */
      this.frameCounter = 0;

      /**
      * The duration of the animation.
      * @property frameDuration
      * @type number
       */
      this.duration = 10;

      /**
      * Indicates if the animation is currently running.
      * @property isRunning
      * @type boolean
       */
      this.isRunning = false;

      /**
      * Stores frame/pattern-offset.
      * @property patternOffset
      * @type number
      * @protected
       */
      this.patternOffset = this.frameRange.start;

      /**
      * Stores current frame/pattern
      * @property patternOffset
      * @type number
      * @protected
       */
      this.pattern = this.patternOffset;

      /**
      * Indicates if its still the first run of the animation.
      * @property firstRun
      * @type boolean
      * @protected
       */
      this.firstRun = true;
      if (record != null) {
        this.refresh(record);
        this.start();
      }
    }


    /**
    * Serializes the frame-animation into a data-bundle.
    *
    * @method toDataBundle
     */

    Component_FrameAnimation.prototype.toDataBundle = function() {
      return {
        name: this.name,
        framesX: this.framesX,
        framesY: this.framesY,
        frameRange: this.frameRange,
        repetitionFrameRange: this.repetitionFrameRange,
        frameCount: this.frameCount,
        graphic: this.graphic,
        repeat: this.repeat,
        position: this.position,
        frameDuration: this.frameDuration,
        frameCounter: this.frameCounter,
        duration: this.duration,
        isRunning: this.isRunning,
        patternOffset: this.patternOffset,
        pattern: this.pattern,
        firstRun: this.firstRun
      };
    };


    /**
    * Refreshes the animation from the specified database-record.
    *
    * @method refresh
    * @param {Object} record - The animation database-record.
     */

    Component_FrameAnimation.prototype.refresh = function(record) {

      /**
      * The images to animate through.
      * @property images
      * @type string[]
       */
      this.name = record.name;
      this.framesX = record.framesX || 1;
      this.framesY = record.framesY || 1;
      this.frameRange = {
        start: Math.min(record.frameRange.start, record.frameRange.end),
        end: Math.max(record.frameRange.start, record.frameRange.end)
      };
      this.repetitionFrameRange = record.useRepetitionFrameRange && (record.repetitionFrameRange != null) ? record.repetitionFrameRange : this.frameRange;
      this.frameCount = (this.frameRange.end - this.frameRange.start) + 1;
      this.graphic = record.graphic;
      this.repeat = record.repeat || false;
      this.position = record.position;
      this.frameDuration = record.duration != null ? Math.round(record.duration / this.frameCount) : 10;
      this.frameCounter = 0;
      this.duration = record.duration || 10;
      this.isRunning = false;
      this.patternOffset = this.frameRange.start;
      this.pattern = this.patternOffset;
      return this.firstRun = true;
    };


    /**
    * Starts the frame-animation.
    *
    * @method start
     */

    Component_FrameAnimation.prototype.start = function(callback) {
      this.callback = callback;
      this.isRunning = true;
      this.firstRun = true;
      this.frameCounter = 0;
      this.frameCount = (this.frameRange.end - this.frameRange.start) + 1;
      this.frameDuration = Math.round(this.duration / this.frameCount);
      return this.patternOffset = this.frameRange.start - 1;
    };


    /**
    * Updates the frame-animation.
    *
    * @method update
     */

    Component_FrameAnimation.prototype.update = function() {
      var bitmap, column, frameHeight, frameWidth, row;
      Component_FrameAnimation.__super__.update.apply(this, arguments);
      if (!this.isRunning) {
        return;
      }
      if (this.frameCounter >= this.duration) {
        if (this.repeat) {
          this.firstRun = false;
          this.frameCounter = 0;
          this.frameCount = (this.repetitionFrameRange.end - this.repetitionFrameRange.start) + 1;
          this.frameDuration = Math.ceil(this.duration / this.frameCount);
          this.patternOffset = this.repetitionFrameRange.start - 1;
        } else {
          this.isRunning = false;
          if (typeof this.onFinish === "function") {
            this.onFinish(this);
          }
          if (typeof this.callback === "function") {
            this.callback(this.object, this);
          }
          return;
        }
      }
      this.pattern = this.patternOffset + Math.floor(this.frameCounter / this.frameDuration);
      this.frameCounter++;
      if (this.object != null) {
        bitmap = this.object.bitmap || ResourceManager.getBitmap((this.object.imageFolder || "Graphics/Pictures") + "/" + this.object.image);
        if (bitmap != null) {
          frameWidth = Math.floor(bitmap.width / this.framesX);
          frameHeight = Math.floor(bitmap.height / this.framesY);
          column = this.pattern % this.framesX;
          row = Math.floor(this.pattern / this.framesX);
          this.object.srcRect.set(column * frameWidth, row * frameHeight, frameWidth, frameHeight);
          this.object.dstRect.width = this.object.srcRect.width;
          return this.object.dstRect.height = this.object.srcRect.height;
        }
      }
    };

    return Component_FrameAnimation;

  })(gs.Component_Animation);

  window.Component_FrameAnimation = Component_FrameAnimation;

  gs.Component_FrameAnimation = Component_FrameAnimation;

}).call(this);
