// Generated by CoffeeScript 1.12.7
(function() {
  var Component_ActionHandler,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Component_ActionHandler = (function(superClass) {
    extend(Component_ActionHandler, superClass);


    /**
    * Called if this object instance is restored from a data-bundle. It can be used
    * re-assign event-handler, anonymous functions, etc.
    * 
    * @method onDataBundleRestore.
    * @param Object data - The data-bundle
    * @param gs.ObjectCodecContext context - The codec-context.
     */

    Component_ActionHandler.prototype.onDataBundleRestore = function(data, context) {
      return this.setupEventHandlers();
    };


    /**
    * An action-handler component allows a UI game object to execute
    * actions. An action can be a method-call of a component or of the scene which
    * always takes two parameters: Sender and Params. For more info about
    * UI actions, see help-file.
    * 
    * @module ui
    * @class Component_ActionHandler
    * @extends ui.Component_Handler
    * @memberof ui
    * @constructor
     */

    function Component_ActionHandler() {

      /**
      * @property initialized
      * @type boolean
      * @protected
       */
      this.initialized = false;

      /**
      * Counter for delayed/timed actions.
      * @property waitCounter
      * @type number
      * @protected
       */
      this.waitCounter = 0;

      /**
      * Indicates if the mouse/touch pointer is inside the UI object's bounds.
      * @property contains
      * @type boolean
      * @protected
       */
      this.containsPointer = false;
    }


    /**
    * Disposes the component.
    *
    * @method dispose
     */

    Component_ActionHandler.prototype.dispose = function() {
      Component_ActionHandler.__super__.dispose.apply(this, arguments);
      gs.GlobalEventManager.offByOwner("keyUp", this.object);
      gs.GlobalEventManager.offByOwner("mouseUp", this.object);
      return gs.GlobalEventManager.offByOwner("mouseMoved", this.object);
    };


    /**
    * Adds event-handler for mouse/touch events to update the component only if 
    * a user-action happened.
    *
    * @method setupEventHandlers
     */

    Component_ActionHandler.prototype.setupEventHandlers = function() {
      var ref;
      gs.GlobalEventManager.offByOwner("keyUp", this.object);
      gs.GlobalEventManager.offByOwner("mouseUp", this.object);
      gs.GlobalEventManager.offByOwner("mouseMoved", this.object);
      if (this.object.focusable) {
        gs.GlobalEventManager.on("keyUp", ((function(_this) {
          return function(e) {
            if (Input.release(Input.KEY_RETURN) && _this.object.ui.focused) {
              _this.object.needsUpdate = true;
              return _this.executeActions();
            }
          };
        })(this)), null, this.object);
      }
      gs.GlobalEventManager.on("mouseUp", ((function(_this) {
        return function(e) {
          var action, actions, contains, exec, i, len;
          contains = Rect.contains(_this.object.dstRect.x, _this.object.dstRect.y, _this.object.dstRect.width, _this.object.dstRect.height, Input.Mouse.x - _this.object.origin.x, Input.Mouse.y - _this.object.origin.y);
          if (contains) {
            exec = false;
            actions = actions || _this.object.actions;
            if (actions != null) {
              for (i = 0, len = actions.length; i < len; i++) {
                action = actions[i];
                exec = _this.checkAction(action) && !_this.checkActionWait(action);
                if (exec) {
                  break;
                }
              }
            }
            if (exec) {
              e.breakChain = true;
              _this.executeActions();
            }
            return _this.object.needsUpdate = true;
          }
        };
      })(this)), null, this.object);
      if ((ref = this.object.actions) != null ? ref.first(function(a) {
        return a && (a.event === "onMouseEnter" || a.event === "onMouseLeave" || a.event === "onMouseHover");
      }) : void 0) {
        gs.GlobalEventManager.on("mouseMoved", ((function(_this) {
          return function(e) {
            var contains;
            contains = Rect.contains(_this.object.dstRect.x, _this.object.dstRect.y, _this.object.dstRect.width, _this.object.dstRect.height, Input.Mouse.x - _this.object.origin.x, Input.Mouse.y - _this.object.origin.y);
            if (_this.containsPointer !== contains) {
              _this.containsPointer = contains;
              return _this.object.needsUpdate = true;
            }
          };
        })(this)), null, this.object);
      }
      return this.object.events.on("action", (function(_this) {
        return function(e) {
          if (e.actions || e.action) {
            return _this.executeAction(e.actions != null ? e.actions[0] : e.action);
          }
        };
      })(this));
    };


    /**
    * Sets up associated actions. Each action is validated and specific default values for the action-target
    * and other options are set if not specified.
    *
    * @method setupActions
     */

    Component_ActionHandler.prototype.setupActions = function() {
      var action, component, i, len, ref, results, target, targets;
      if (this.object.actions != null) {
        ref = this.object.actions;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          action = ref[i];
          if (!action) {
            continue;
          }
          if (!action.event) {
            action.event = "onAction";
          }
          if (action.wait != null) {
            continue;
          }
          if (action.target == null) {
            action.target = this.object.controller;
          }
          if (typeof action.target === "string") {
            if (action.target.contains(".")) {
              action.target = ui.Component_FormulaHandler.fieldValue(this.object, action.target);
            }
            targets = action.target.split(".");
            target = gs.ObjectManager.current.objectById(targets[0]);
            if (target != null) {
              component = target.findComponentById(targets[1]);
              if (component == null) {
                target = target.components.where(function(v) {
                  return typeof v[action.name] === "function";
                }).first();
              } else {
                target = component;
              }
            } else {
              target = this.object;
            }
            action.target = target;
          }
          if (action.condition != null) {
            action.conditions = [action.condition];
            results.push(delete action.condition);
          } else {
            results.push(void 0);
          }
        }
        return results;
      }
    };


    /**
    * Initializes the action-handler.
    * 
    * @method setup
     */

    Component_ActionHandler.prototype.setup = function() {
      this.initialized = true;
      this.setupEventHandlers();
      return this.setupActions();
    };


    /**
    * Updates the action-handler.
    * 
    * @method update
     */

    Component_ActionHandler.prototype.update = function() {};

    Component_ActionHandler.prototype.checkAction = function(action) {
      return ((action != null ? action.event : void 0) || (action != null ? action.events : void 0)) && this.checkObject(action);
    };

    Component_ActionHandler.prototype.checkActionWait = function(action) {
      var result;
      result = false;
      if ((action.wait != null) && action.wait > 0) {
        this.waitCounter = action.wait;
        action.wait = 0;
        result = true;
      }
      return result;
    };

    Component_ActionHandler.prototype.updateActionTarget = function(action) {
      var component, target, targets;
      if (action.target == null) {
        action.target = this.object.controller;
      }
      if (action.target.exec || typeof action.target === "string") {
        if (action.target.exec) {
          action.target = ui.Component_FormulaHandler.fieldValue(this.object, action.target);
        }
        targets = action.target.split(".");
        target = gs.ObjectManager.current.objectById(targets[0]);
        if (target != null) {
          component = target.findComponentById(targets[1]);
          if (component == null) {
            target = target.components.where(function(v) {
              return typeof v[action.name] === "function";
            }).first();
          } else {
            target = component;
          }
        } else {
          target = this.object;
        }
        return action.target = target;
      }
    };

    Component_ActionHandler.prototype.canExecuteActions = function() {
      return this.waitCounter <= 0 && this.object.ui.enabled && this.object.visible;
    };


    /**
    * Executes the specified actions. A single action is only executed if
    * all assigned events and conditions are true.
    * 
    * @method executeActions
    * @return If <b>true</b> there was at least one action executed. Otherwise <b>false</b>
     */

    Component_ActionHandler.prototype.executeActions = function(actions) {
      var action, i, len, result;
      if (!this.canExecuteActions()) {
        return;
      }
      result = false;
      actions = actions || this.object.actions;
      if (actions != null) {
        for (i = 0, len = actions.length; i < len; i++) {
          action = actions[i];
          if (!this.checkAction(action)) {
            continue;
          }
          if (this.checkActionWait(action)) {
            break;
          }
          this.updateActionTarget(action);
          this.executeAction(action);
          result = true;
        }
      }
      return result;
    };


    /**
    * Executes the specified action if all assigned events and conditions
    * are true.
    * 
    * @method executeAction
    * @param {Object} action The action to execute.
     */

    Component_ActionHandler.prototype.executeAction = function(action) {
      var name, target;
      target = action.target || this.object.target;
      if (target != null) {
        if (action.sound) {
          AudioManager.playSound(action.sound);
        }
        return typeof target[name = action.name] === "function" ? target[name](this.object, action.params) : void 0;
      }
    };

    return Component_ActionHandler;

  })(ui.Component_Handler);

  ui.Component_ActionHandler = Component_ActionHandler;

}).call(this);
