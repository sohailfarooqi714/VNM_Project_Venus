// Generated by CoffeeScript 1.12.7
(function() {
  var Component_ImageMap,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Component_ImageMap = (function(superClass) {
    extend(Component_ImageMap, superClass);


    /**
    * Called if this object instance is restored from a data-bundle. It can be used
    * re-assign event-handler, anonymous functions, etc.
    *
    * @method onDataBundleRestore.
    * @param Object data - The data-bundle
    * @param gs.ObjectCodecContext context - The codec-context.
     */

    Component_ImageMap.prototype.onDataBundleRestore = function(data, context) {
      var bitmap, ground;
      this.setupEventHandlers();
      this.object.addObject(this.ground);
      bitmap = ResourceManager.getBitmap("Graphics/Pictures/" + this.object.images[0]);
      ground = new gs.Bitmap(bitmap.width, bitmap.height);
      ground.blt(0, 0, bitmap, new Rect(0, 0, bitmap.width, bitmap.height));
      this.ground.bitmap = ground;
      return this.setupHotspots(this.hotspots);
    };


    /**
    * A component which turns a game object into an interactive image-map.
    *
    * @module gs
    * @class Component_ImageMap
    * @extends gs.Component_Visual
    * @memberof gs
     */

    function Component_ImageMap() {
      Component_ImageMap.__super__.constructor.apply(this, arguments);

      /**
      * The ground/base image.
      * @property ground
      * @type gs.Object_Picture
      * @default null
       */
      this.ground = null;

      /**
      * An array of different hotspots.
      * @property hotspots
      * @type gs.Object_Picture[]
      * @default null
       */
      this.hotspots = null;

      /**
      * The variable context used if a hotspot needs to deal with local variables.
      * @property variableContext
      * @type Object
      * @default null
       */
      this.variableContext = null;

      /**
      * Indicates if the image-map is active. An in-active image-map doesn't respond
      * to any input-event. Hover effects are still working.
      * @property active
      * @type boolean
      * @default yes
       */
      this.active = true;
    }


    /**
    * Adds event-handler for mouse/touch events to update the component only if
    * a user-action happened.
    *
    * @method setupEventHandlers
     */

    Component_ImageMap.prototype.setupEventHandlers = function() {
      gs.GlobalEventManager.offByOwner("mouseUp", this.object);
      return gs.GlobalEventManager.on("mouseUp", ((function(_this) {
        return function(e) {
          var contains, hotspot, j, len, ref, results;
          contains = Rect.contains(_this.object.dstRect.x, _this.object.dstRect.y, _this.object.dstRect.width, _this.object.dstRect.height, Input.Mouse.x - _this.object.origin.x, Input.Mouse.y - _this.object.origin.y);
          if (contains && _this.active) {
            ref = _this.hotspots;
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              hotspot = ref[j];
              if (_this.checkHotspotAction(hotspot)) {
                e.breakChain = true;
                if (hotspot.data.bindToSwitch) {
                  hotspot.selected = !hotspot.selected;
                }
                results.push(_this.executeHotspotAction(hotspot));
              } else {
                results.push(void 0);
              }
            }
            return results;
          }
        };
      })(this)), null, this.object);
    };


    /**
    * Initializes the image-map. Creates the background and hotspots.
    *
    * @method setup
     */

    Component_ImageMap.prototype.setup = function() {
      var bitmap, ground;
      this.setupEventHandlers();
      this.object.rIndex = 11000;
      if (this.object.images[0]) {
        bitmap = ResourceManager.getBitmap("Graphics/Pictures/" + this.object.images[0]);
        if (bitmap.loaded) {
          bitmap.makeMutable();
          ground = new gs.Bitmap(bitmap.width, bitmap.height);
          ground.blt(0, 0, bitmap, new Rect(0, 0, bitmap.width, bitmap.height));
        }
      }
      this.ground = new gs.Object_Picture();
      this.ground.bitmap = ground;
      this.ground.image = null;
      this.ground.zIndex = this.object.zIndex;
      this.ground.imageHandling = gs.ImageHandling.CUSTOM_SIZE;
      this.object.addObject(this.ground);
      this.setupHotspots();
      if (ground != null) {
        this.ground.srcRect.set(0, 0, ground.width, ground.height);
        this.ground.dstRect.width = ground.width;
        this.ground.dstRect.height = ground.height;
      }
      this.ground.update();
      this.object.dstRect.width = this.ground.dstRect.width;
      return this.object.dstRect.height = this.ground.dstRect.height;
    };


    /**
    * Sets up the hotspots on the image-map. Each hotspot is a gs.Object_ImageMapHotspot
    * object.
    *
    * @method setupHotspots
     */

    Component_ImageMap.prototype.setupHotspots = function(hotspots) {
      return this.hotspots = this.object.hotspots.select((function(_this) {
        return function(v, i) {
          var picture, ref, ref1, ref2, ref3, ref4;
          if ((ref = _this.ground.bitmap) != null) {
            ref.clearRect(v.x, v.y, v.size.width, v.size.height);
          }
          picture = new gs.Object_ImageMapHotspot();
          picture.fixedSize = true;
          picture.srcRect = new Rect(v.x, v.y, v.size.width, v.size.height);
          picture.dstRect = new Rect(v.x, v.y, v.size.width, v.size.height);
          picture.imageHandling = gs.ImageHandling.CUSTOM_SIZE;
          picture.zIndex = _this.object.zIndex + 1;
          picture.selected = (ref1 = hotspots != null ? (ref2 = hotspots[i]) != null ? ref2.selected : void 0 : void 0) != null ? ref1 : false;
          picture.hovered = false;
          picture.enabled = (ref3 = hotspots != null ? (ref4 = hotspots[i]) != null ? ref4.enabled : void 0 : void 0) != null ? ref3 : true;
          picture.actions = v.data.actions;
          picture.data = v.data;
          picture.commonEventId = v.commonEventId;
          picture.anchor.set(0.5, 0.5);
          _this.object.addObject(picture);
          return picture;
        };
      })(this));
    };


    /**
    * Initializes the image-map. Frees ground image.
    *
    * @method dispose
     */

    Component_ImageMap.prototype.dispose = function() {
      var ref;
      Component_ImageMap.__super__.dispose.apply(this, arguments);
      gs.GlobalEventManager.offByOwner("mouseUp", this.object);
      return (ref = this.ground.bitmap) != null ? ref.dispose() : void 0;
    };


    /**
    * Executes a hotspot's associated action. Depending on the configuration a hotspot
    * can trigger a common-event or turn on a switch for example.
    *
    * @method executeHotspotAction
    * @param {gs.Object_Picture} hotspot - The hotspot where the image should be updated.
    * @protected
     */

    Component_ImageMap.prototype.executeHotspotAction = function(hotspot) {
      var domain, ref, ref1, ref2, ref3;
      GameManager.variableStore.setupTempVariables(this.variableContext);
      if (hotspot.data.bindToSwitch) {
        domain = GameManager.variableStore.domain;
        GameManager.variableStore.setBooleanValueTo(hotspot.data["switch"], hotspot.selected);
      }
      if (hotspot.data.bindValueTo) {
        domain = GameManager.variableStore.domain;
        GameManager.variableStore.setNumberValueTo(hotspot.data.bindValueVariable, hotspot.data.bindValue);
      }
      AudioManager.playSound(hotspot.data.onClickSound);
      switch (hotspot.data.action) {
        case 1:
          if ((ref = this.object.events) != null) {
            ref.emit("jumpTo", this.object, {
              label: hotspot.data.label
            });
          }
          break;
        case 2:
          if ((ref1 = this.object.events) != null) {
            ref1.emit("callCommonEvent", this.object, {
              commonEventId: hotspot.data.commonEventId,
              finish: hotspot.data.finish
            });
          }
          break;
        case 3:
          if ((ref2 = this.object.events) != null) {
            ref2.emit("action", this.object, {
              actions: hotspot.data.actions
            });
          }
      }
      if (hotspot.data.finish) {
        return (ref3 = this.object.events) != null ? ref3.emit("finish", this.object) : void 0;
      }
    };


    /**
    * Checks if a hotspot's associated action needs to be executed. Depending on the configuration a hotspot
    * can trigger a common-event or turn on a switch for example.
    *
    * @method updateHotspotAction
    * @param {gs.Object_Picture} hotspot - The hotspot where the image should be updated.
    * @return {boolean} If <b>true</b> the hotspot's action needs to be executed. Otherwise <b>false</b>.
    * @protected
     */

    Component_ImageMap.prototype.checkHotspotAction = function(hotspot) {
      var hovered, result;
      result = false;
      hovered = hotspot.dstRect.contains(Input.Mouse.x - hotspot.origin.x, Input.Mouse.y - hotspot.origin.y);
      if (hovered && hotspot.enabled && Input.Mouse.buttons[Input.Mouse.LEFT] === 2) {
        result = true;
      }
      return result;
    };


    /**
    * Updates a hotspot's image. Depending on the state the image of a hotspot can
    * change for example if the mouse hovers over a hotspot.
    *
    * @method updateHotspotImage
    * @param {gs.Object_Picture} hotspot - The hotspot where the image should be updated.
    * @param {boolean} hovered - Indicates if the hotspot is hovered by mouse/touch cursor.
    * @protected
     */

    Component_ImageMap.prototype.updateHotspotImage = function(hotspot, hovered) {
      var baseImage;
      baseImage = hotspot.enabled ? this.object.images[2] || this.object.images[0] : this.object.images[0];
      if (hovered && hotspot.enabled) {
        if (hotspot.selected) {
          return hotspot.image = this.object.images[4] || this.object.images[1] || baseImage;
        } else {
          return hotspot.image = this.object.images[1] || baseImage;
        }
      } else {
        if (hotspot.selected) {
          return hotspot.image = this.object.images[3] || baseImage;
        } else {
          return hotspot.image = baseImage;
        }
      }
    };


    /**
    * Updates a hotspot.
    *
    * @method updateHotspot
    * @param {gs.Object_Picture} hotspot - The hotspot to update.
    * @protected
     */

    Component_ImageMap.prototype.updateHotspot = function(hotspot) {
      var hovered;
      hotspot.visible = this.object.visible;
      hotspot.opacity = this.object.opacity;
      hotspot.tone.setFromObject(this.object.tone);
      hotspot.color.setFromObject(this.object.color);
      if (hotspot.data.bindEnabledState) {
        GameManager.variableStore.setupTempVariables(this.variableContext);
        hotspot.enabled = GameManager.variableStore.booleanValueOf(hotspot.data.enabledSwitch);
      }
      if (hotspot.data.bindToSwitch) {
        GameManager.variableStore.setupTempVariables(this.variableContext);
        hotspot.selected = GameManager.variableStore.booleanValueOf(hotspot.data["switch"]);
      }
      hovered = hotspot.dstRect.contains(Input.Mouse.x - hotspot.origin.x, Input.Mouse.y - hotspot.origin.y);
      if (hovered !== hotspot.hovered) {
        hotspot.hovered = hovered;
        if (hovered) {
          AudioManager.playSound(hotspot.data.onHoverSound);
        }
      }
      this.updateHotspotImage(hotspot, hovered);
      return hotspot.update();
    };


    /**
    * Updates the ground-image.
    *
    * @method updateGround
    * @protected
     */

    Component_ImageMap.prototype.updateGround = function() {
      this.ground.visible = this.object.visible;
      this.ground.opacity = this.object.opacity;
      this.ground.anchor.x = 0.5;
      this.ground.anchor.y = 0.5;
      this.ground.tone.setFromObject(this.object.tone);
      this.ground.color.setFromObject(this.object.color);
      return this.ground.update();
    };


    /**
    * Updates the image-map's ground and all hotspots.
    *
    * @method update
     */

    Component_ImageMap.prototype.update = function() {
      var hotspot, j, len, ref;
      Component_ImageMap.__super__.update.call(this);
      this.updateGround();
      ref = this.hotspots;
      for (j = 0, len = ref.length; j < len; j++) {
        hotspot = ref[j];
        this.updateHotspot(hotspot);
      }
      return null;
    };

    return Component_ImageMap;

  })(gs.Component_Visual);

  gs.Component_ImageMap = Component_ImageMap;

}).call(this);
