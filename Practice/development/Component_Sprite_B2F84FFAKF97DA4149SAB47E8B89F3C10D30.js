// Generated by CoffeeScript 1.12.7
(function() {
  var AnimationTypes, Component_Sprite,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Component_Sprite = (function(superClass) {
    extend(Component_Sprite, superClass);


    /**
    * Called if this object instance is restored from a data-bundle. It can be used
    * re-assign event-handler, anonymous functions, etc.
    * 
    * @method onDataBundleRestore.
    * @param Object data - The data-bundle
    * @param gs.ObjectCodecContext context - The codec-context.
     */

    Component_Sprite.prototype.onDataBundleRestore = function(data, context) {
      return this.setupEventHandlers();
    };


    /**
    * A sprite component to display an object on screen. It can be managed or
    * unmanaged. A managed sprite is automatically added to the graphics-system
    * and rendered every frame until it gets disposed. An unmanaged sprite needs
    * to be added and removed manually.
    *
    * @module gs
    * @class Component_Sprite
    * @extends gs.Component_Visual
    * @memberof gs
    * @constructor
    * @param {boolean} managed - Indicates if the sprite is managed by the graphics system.
     */

    function Component_Sprite(managed) {
      Component_Sprite.__super__.constructor.call(this);

      /**
      * The native sprite object to display the game object on screen.
      *
      * @property sprite
      * @type Sprite
      * @protected
       */
      this.sprite = null;

      /**
      * The name of the image to display.
      *
      * @property image
      * @type string
      * @protected
       */
      this.image = null;

      /**
      * The name of the video to display.
      *
      * @property video
      * @type string
      * @protected
       */
      this.video = null;

      /**
      * The name of the folder from where the image should be loaded.
      *
      * @property image
      * @type string
      * @protected
       */
      this.imageFolder = "Graphics/Pictures";

      /**
      * The visibility. If <b>false</b>, the sprite is not rendered.
      *
      * @property visible
      * @type boolean
      * @protected
       */
      this.visible = false;

      /**
      * Indicates if the image is loaded.
      *
      * @property imageLoaded
      * @type boolean
      * @protected
       */
      this.imageLoaded = false;
    }


    /**
    * Disposes the sprite. If the sprite is managed, it will be automatically
    * removed from the graphics system and viewport.
    * @method dispose
     */

    Component_Sprite.prototype.dispose = function() {
      var ref, ref1;
      Component_Sprite.__super__.dispose.apply(this, arguments);
      if (this.sprite) {
        this.sprite.dispose();
        if (this.sprite.video) {
          this.sprite.video.stop();
        }
        if (!this.sprite.managed) {
          if ((ref = this.sprite.viewport) != null) {
            ref.removeGraphicObject(this.sprite);
          }
          return (ref1 = Graphics.viewport) != null ? ref1.removeGraphicObject(this.sprite) : void 0;
        }
      }
    };


    /**
    * Adds event-handlers for mouse/touch events
    *
    * @method setupEventHandlers
     */

    Component_Sprite.prototype.setupEventHandlers = function() {
      return this.sprite.onIndexChange = (function(_this) {
        return function() {
          _this.object.rIndex = _this.sprite.index;
          return _this.object.needsUpdate = true;
        };
      })(this);
    };


    /**
    * Setup the sprite. 
    * @method setupSprite
     */

    Component_Sprite.prototype.setupSprite = function() {
      if (!this.sprite) {
        return this.sprite = new gs.Sprite(Graphics.viewport, typeof managed !== "undefined" && managed !== null ? managed : true);
      }
    };


    /**
    * Setup the sprite component. This method is automatically called by the
    * system.
    * @method setup
     */

    Component_Sprite.prototype.setup = function() {
      this.isSetup = true;
      this.setupSprite();
      this.setupEventHandlers();
      return this.update();
    };


    /**
    * Updates the source- and destination-rectangle of the game object so that
    * the associated bitmap fits in. The imageHandling property controls how
    * the rectangles are resized.
    * @method updateRect
     */

    Component_Sprite.prototype.updateRect = function() {
      if (this.sprite.bitmap != null) {
        if (!this.object.imageHandling) {
          this.object.srcRect = new Rect(0, 0, this.sprite.bitmap.width, this.sprite.bitmap.height);
          if (!this.object.fixedSize) {
            this.object.dstRect.width = this.object.srcRect.width;
            return this.object.dstRect.height = this.object.srcRect.height;
          }
        } else if (this.object.imageHandling === 1) {
          this.object.srcRect = new Rect(0, 0, this.sprite.bitmap.width, this.sprite.bitmap.height / 2);
          if (!this.object.fixedSize) {
            this.object.dstRect.width = this.object.srcRect.width;
            return this.object.dstRect.height = this.object.srcRect.height;
          }
        } else if (this.object.imageHandling === 2) {
          if (!this.object.fixedSize) {
            this.object.dstRect.width = this.object.srcRect.width;
            return this.object.dstRect.height = this.object.srcRect.height;
          }
        }
      }
    };


    /**
    * Updates the bitmap object from the associated image name. The imageFolder
    * property controls from which resource-folder the image will be loaded.
    * @method updateBitmap
     */

    Component_Sprite.prototype.updateBitmap = function() {
      this.imageLoaded = false;
      this.image = this.object.image;
      if (this.object.image.startsWith("data:") || this.object.image.startsWith("$")) {
        this.sprite.bitmap = ResourceManager.getBitmap(this.object.image);
      } else {
        this.sprite.bitmap = ResourceManager.getBitmap((this.object.imageFolder || this.imageFolder) + "/" + this.object.image);
      }
      if (this.sprite.bitmap != null) {
        if (!this.imageLoaded) {
          this.imageLoaded = this.sprite.bitmap.loaded;
        } else {
          delete this.sprite.bitmap.loaded_;
        }
      }
      return this.object.bitmap = this.sprite.bitmap;
    };


    /**
    * Updates the video object from the associated video name. It also updates
    * the video-rendering process.
    * @method updateVideo
     */

    Component_Sprite.prototype.updateVideo = function() {
      var ref, ref1;
      if (this.object.video !== this.videoName) {
        this.videoName = this.object.video;
        this.sprite.video = ResourceManager.getVideo("Movies/" + this.object.video);
        if (this.sprite.video != null) {
          if ((ref = $PARAMS.preview) != null ? ref.settings.musicDisabled : void 0) {
            this.sprite.video.volume = 0;
          }
          this.sprite.video.loop = this.object.loop;
          this.sprite.video.play();
          this.object.srcRect = new Rect(0, 0, this.sprite.video.width, this.sprite.video.height);
          if (!this.object.fixedSize) {
            this.object.dstRect = new Rect(this.object.dstRect.x, this.object.dstRect.y, this.sprite.video.width, this.sprite.video.height);
          }
        }
      }
      return (ref1 = this.sprite.video) != null ? ref1.update() : void 0;
    };


    /**
    * Updates the image if the game object has the image-property set.
    * @method updateImage
     */

    Component_Sprite.prototype.updateImage = function() {
      var ref;
      if (this.object.image != null) {
        if (this.object.image !== this.image || (!this.imageLoaded && ((ref = this.sprite.bitmap) != null ? ref.loaded : void 0))) {
          this.updateBitmap();
          return this.updateRect();
        }
      } else if (this.object.bitmap != null) {
        return this.sprite.bitmap = this.object.bitmap;
      } else if ((this.object.video != null) || this.videoName !== this.object.video) {
        return this.updateVideo();
      } else {
        this.image = null;
        this.object.bitmap = null;
        return this.sprite.bitmap = null;
      }
    };


    /**
    * If the sprite is unmanaged, this method will update the visibility of the
    * sprite. If the sprite leaves the viewport, it will be removed to save 
    * performance and automatically added back to the viewport if it enters
    * the viewport.
    * @method updateVisibility
     */

    Component_Sprite.prototype.updateVisibility = function() {
      var visible;
      if (!this.sprite.managed) {
        visible = Rect.intersect(this.object.dstRect.x + this.object.origin.x, this.object.dstRect.y + this.object.origin.y, this.object.dstRect.width, this.object.dstRect.height, 0, 0, Graphics.width, Graphics.height);
        if (visible && !this.visible) {
          (this.object.viewport || Graphics.viewport).addGraphicObject(this.sprite);
          this.visible = true;
        }
        if (!visible && this.visible) {
          (this.object.viewport || Graphics.viewport).removeGraphicObject(this.sprite);
          return this.visible = false;
        }
      }
    };


    /**
    * Updates the padding.
    * @method updatePadding
     */

    Component_Sprite.prototype.updatePadding = function() {
      if (this.object.padding != null) {
        this.sprite.x += this.object.padding.left;
        this.sprite.y += this.object.padding.top;
        this.sprite.zoomX -= (this.object.padding.left + this.object.padding.right) / this.object.srcRect.width;
        return this.sprite.zoomY -= (this.object.padding.bottom + this.object.padding.bottom) / this.object.srcRect.height;
      }
    };


    /**
    * Updates the sprite properties from the game object properties.
    * @method updateProperties
     */

    Component_Sprite.prototype.updateProperties = function() {
      var ref, ref1;
      this.sprite.width = this.object.dstRect.width;
      this.sprite.height = this.object.dstRect.height;
      this.sprite.x = this.object.dstRect.x;
      this.sprite.y = this.object.dstRect.y;
      this.sprite.mask = (ref = this.object.mask) != null ? ref : this.mask;
      this.sprite.angle = this.object.angle || 0;
      this.sprite.opacity = (ref1 = this.object.opacity) != null ? ref1 : 255;
      this.sprite.clipRect = this.object.clipRect;
      this.sprite.srcRect = this.object.srcRect;
      this.sprite.blendingMode = this.object.blendMode || 0;
      this.sprite.mirror = this.object.mirror;
      this.sprite.visible = this.object.visible && (!this.object.parent || (this.object.parent.visible == null) || this.object.parent.visible);
      this.sprite.ox = -this.object.origin.x;
      this.sprite.oy = -this.object.origin.y;
      return this.sprite.z = (this.object.zIndex || 0) + (!this.object.parent ? 0 : this.object.parent.zIndex || 0);
    };


    /**
    * Updates the optional sprite properties from the game object properties.
    * @method updateOptionalProperties
     */

    Component_Sprite.prototype.updateOptionalProperties = function() {
      if (this.object.tone != null) {
        this.sprite.tone = this.object.tone;
      }
      if (this.object.color != null) {
        this.sprite.color = this.object.color;
      }
      if (this.object.viewport != null) {
        this.sprite.viewport = this.object.viewport;
      }
      if (this.object.effects != null) {
        this.sprite.effects = this.object.effects;
      }
      if (this.object.anchor != null) {
        this.sprite.anchor.x = this.object.anchor.x;
        this.sprite.anchor.y = this.object.anchor.y;
      }
      if (this.object.positionAnchor != null) {
        this.sprite.positionAnchor = this.object.positionAnchor;
      }
      if (this.object.zoom != null) {
        this.sprite.zoomX = this.object.zoom.x;
        this.sprite.zoomY = this.object.zoom.y;
      }
      if (this.object.motionBlur != null) {
        return this.sprite.motionBlur = this.object.motionBlur;
      }
    };


    /**
    * Updates the sprite component by updating its visibility, image, padding and
    * properties.
    * @method update
     */

    Component_Sprite.prototype.update = function() {
      Component_Sprite.__super__.update.apply(this, arguments);
      if (!this.isSetup) {
        this.setup();
      }
      this.updateVisibility();
      this.updateImage();
      this.updateProperties();
      this.updateOptionalProperties();
      this.updatePadding();
      this.object.rIndex = this.sprite.index;
      return this.sprite.update();
    };

    return Component_Sprite;

  })(gs.Component_Visual);


  /**
  * Enumeration of appearance animations. 
  *
  * @module gs
  * @class AnimationTypes
  * @static
  * @memberof gs
   */

  AnimationTypes = (function() {
    function AnimationTypes() {}

    AnimationTypes.initialize = function() {

      /**
      * An object appears or disappears by moving into or out of the screen.
      * @property MOVEMENT
      * @type number
      * @static
      * @final
       */
      this.MOVEMENT = 0;

      /**
      * An object appears or disappears using alpha-blending.
      * @property BLENDING
      * @type number
      * @static
      * @final
       */
      this.BLENDING = 1;

      /**
      * An object appears or disappears using a mask-image.
      * @property MASKING
      * @type number
      * @static
      * @final
       */
      return this.MASKING = 2;
    };

    return AnimationTypes;

  })();

  AnimationTypes.initialize();

  gs.AnimationTypes = AnimationTypes;

  gs.Component_Sprite = Component_Sprite;

}).call(this);
