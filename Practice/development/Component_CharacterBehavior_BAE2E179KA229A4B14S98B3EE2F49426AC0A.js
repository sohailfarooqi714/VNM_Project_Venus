// Generated by CoffeeScript 1.12.7
(function() {
  var Component_CharacterBehavior,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Component_CharacterBehavior = (function(superClass) {
    extend(Component_CharacterBehavior, superClass);


    /**
    * Called if this object instance is restored from a data-bundle. It can be used
    * re-assign event-handler, anonymous functions, etc.
    *
    * @method onDataBundleRestore.
    * @param Object data - The data-bundle
    * @param gs.ObjectCodecContext context - The codec-context.
     */

    Component_CharacterBehavior.prototype.onDataBundleRestore = function(data, context) {
      return this.setupEventHandlers();
    };


    /**
    * A behavior-component which handles the character-specific behavior like
    * talking and idle.
    *
    * @module vn
    * @class Component_CharacterBehavior
    * @extends gs.Component
    * @memberof vn
    * @constructor
     */

    function Component_CharacterBehavior() {
      Component_CharacterBehavior.__super__.constructor.apply(this, arguments);

      /**
      * @property imageIndex
      * @type number
      * @private
       */
      this.imageIndex = 0;

      /**
      * @property imageDuration
      * @type number
      * @private
       */
      this.imageDuration = 30;

      /**
      * @property idleTime
      * @type number
      * @private
       */
      this.idleTime = 120 + 120 * Math.random();

      /**
      * Indicates if the character is currently talking.
      * @property talking
      * @type boolean
       */
      this.talking = false;

      /**
      * @property initialized
      * @type boolean
      * @private
       */
      this.initialized = false;

      /**
      * Temporary game settings used by this character.
      * @property imageIndex
      * @type number
       */
      this.tempSettings = GameManager.tempSettings;
    }


    /**
    * Adds event-handlers
    *
    * @method setupEventHandlers
     */

    Component_CharacterBehavior.prototype.setupEventHandlers = function() {
      gs.GlobalEventManager.on("talkingStarted", (function(_this) {
        return function(e) {
          var ref;
          if (((ref = e.character) != null ? ref.index : void 0) === _this.object.rid) {
            _this.object.talking = true;
            return _this.imageIndex = 0;
          }
        };
      })(this));
      return gs.GlobalEventManager.on("talkingEnded", (function(_this) {
        return function(e) {
          var ref;
          if (((ref = e.character) != null ? ref.index : void 0) === _this.object.rid) {
            _this.object.talking = false;
            return _this.imageIndex = 0;
          }
        };
      })(this));
    };


    /**
    * Initializes the component. Adds event-handlers.
    *
    * @method setup
     */

    Component_CharacterBehavior.prototype.setup = function() {
      this.initialized = true;
      this.setupEventHandlers();
      return this.update();
    };


    /**
    * Changes the characters expression using blending. If the duration is set
    * to 0 the expression change is executed immediately without animation.
    *
    * @method changeExpression
    * @param {vn.CharacterExpression} expression - The character expression database-record.
    * @param {number} duration - The animation-duration in frames. Pass 0 to skip animation.
    * @param {function} [callback] An optional callback-function called when the change is finished.
     */

    Component_CharacterBehavior.prototype.changeExpression = function(expression, animation, easing, duration, callback) {
      var picture, prevExpression, ref;
      prevExpression = this.object.expression;
      this.object.expression = expression;
      if ((prevExpression != null ? (ref = prevExpression.idle) != null ? ref.length : void 0 : void 0) > 0 && (this.object.expression != null) && prevExpression !== this.object.expression) {
        this.imageIndex = 0;
        picture = new gs.Object_Picture();
        picture.imageFolder = "Graphics/Characters";
        picture.image = prevExpression.idle[0].resource.name;
        picture.update();
        picture.anchor.x = this.object.anchor.x;
        picture.anchor.y = this.object.anchor.y;
        picture.dstRect.x = this.object.dstRect.x + Math.round((this.object.dstRect.width - picture.dstRect.width) / 2);
        picture.dstRect.y = this.object.dstRect.y + Math.round((this.object.dstRect.height - picture.dstRect.height) / 2);
        picture.zIndex = this.object.zIndex - 1;
        picture.zoom.x = this.object.zoom.x;
        picture.zoom.y = this.object.zoom.y;
        picture.update();
        this.object.parent.addObject(picture);
        switch (animation.fading) {
          case 0:
            this.object.animator.appear(this.object.dstRect.x, this.object.dstRect.y, animation, easing, duration, function() {
              picture.dispose();
              return typeof callback === "function" ? callback() : void 0;
            });
            return this.object.update();
          case 1:
            picture.animator.disappear(animation, easing, duration, function(object) {
              return object.dispose();
            });
            picture.update();
            this.object.animator.appear(this.object.dstRect.x, this.object.dstRect.y, animation, easing, duration, function(object) {
              return typeof callback === "function" ? callback() : void 0;
            });
            return this.object.update();
        }
      } else {
        return typeof callback === "function" ? callback() : void 0;
      }
    };


    /**
    * Lets the character start talking.
    *
    * @method startTalking
     */

    Component_CharacterBehavior.prototype.startTalking = function() {
      return this.object.talking = true;
    };


    /**
    * Lets the character stop with talking.
    *
    * @method stopTalking
     */

    Component_CharacterBehavior.prototype.stopTalking = function() {
      return this.object.talking = false;
    };


    /**
    * Updates character's talking-animation.
    *
    * @method updateTalking
    * @protected
     */

    Component_CharacterBehavior.prototype.updateTalking = function() {
      var imageIndex, ref, ref1, speed;
      if (this.tempSettings.skip && ((ref = this.object.expression.talking) != null ? ref.length : void 0) > 0) {
        this.object.talking = false;
        this.imageIndex = 0;
        return this.object.image = this.object.expression.talking[this.imageIndex].resource.name;
      } else if (this.object.expression != null) {
        if (((ref1 = this.object.expression.talking) != null ? ref1.length : void 0) > 0) {
          this.imageDuration--;
          if (this.imageDuration <= 0) {
            imageIndex = this.imageIndex;
            while (imageIndex === this.imageIndex && this.object.expression.talking.length > 1) {
              this.imageIndex = Math.round(Math.random() * (this.object.expression.talking.length - 1));
            }
            speed = this.object.expression.talkingSpeed / 100 * 5;
            this.imageDuration = speed + Math.round(speed * Math.random());
          }
          return this.object.image = this.object.expression.talking[this.imageIndex].resource.name;
        } else {
          return this.updateIdle();
        }
      }
    };


    /**
    * Updates character's idle-animation.
    *
    * @method updateIdle
    * @protected
     */

    Component_CharacterBehavior.prototype.updateIdle = function() {
      var ref;
      if ((this.object.expression != null) && ((ref = this.object.expression.idle) != null ? ref.length : void 0) > 0) {
        if (this.imageDuration <= 0) {
          this.idleTime--;
          if (this.idleTime <= 0) {
            this.idleTime = this.object.expression.idleTime.start + (this.object.expression.idleTime.end - this.object.expression.idleTime.start) * Math.random();
            this.imageDuration = this.object.expression.idleSpeed / 100 * 5;
          }
        }
        if (this.imageDuration > 0) {
          this.imageDuration--;
          if (this.imageDuration <= 0) {
            this.imageIndex++;
            if (this.imageIndex >= this.object.expression.idle.length) {
              this.imageIndex = 0;
              this.imageDuration = 0;
            } else {
              this.imageDuration = this.object.expression.idleSpeed / 100 * 5;
            }
          }
        }
        return this.object.image = this.object.expression.idle[this.imageIndex].resource.name;
      }
    };


    /**
    * Updates character logic & animation-handling.
    *
    * @method update
     */

    Component_CharacterBehavior.prototype.update = function() {
      Component_CharacterBehavior.__super__.update.apply(this, arguments);
      if (!this.initialized) {
        this.setup();
      }
      if (this.object.talking) {
        return this.updateTalking();
      } else {
        return this.updateIdle();
      }
    };

    return Component_CharacterBehavior;

  })(gs.Component);

  vn.Component_CharacterBehavior = Component_CharacterBehavior;

}).call(this);
